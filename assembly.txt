
build/zephyr/zephyr.elf:	file format elf32-littlearm

Disassembly of section rom_start:

08000000 <_vector_start>:
 8000000: f8 15 00 20  	.word	0x200015f8
 8000004: 49 2f 00 08  	.word	0x08002f49
 8000008: d1 21 00 08  	.word	0x080021d1
 800000c: 35 2f 00 08  	.word	0x08002f35
 8000010: 35 2f 00 08  	.word	0x08002f35
 8000014: 35 2f 00 08  	.word	0x08002f35
 8000018: 35 2f 00 08  	.word	0x08002f35
 800001c: 00 00 00 00  	.word	0x00000000
 8000020: 00 00 00 00  	.word	0x00000000
 8000024: 00 00 00 00  	.word	0x00000000
 8000028: 00 00 00 00  	.word	0x00000000
 800002c: b5 30 00 08  	.word	0x080030b5
 8000030: 35 2f 00 08  	.word	0x08002f35
 8000034: 00 00 00 00  	.word	0x00000000
 8000038: 45 30 00 08  	.word	0x08003045
 800003c: 51 77 00 08  	.word	0x08007751

08000040 <$d>:
 8000040: 09 33 00 08  	.word	0x08003309
 8000044: 09 33 00 08  	.word	0x08003309
 8000048: 09 33 00 08  	.word	0x08003309
 800004c: 09 33 00 08  	.word	0x08003309
 8000050: 09 33 00 08  	.word	0x08003309
 8000054: 09 33 00 08  	.word	0x08003309
 8000058: 09 33 00 08  	.word	0x08003309
 800005c: 09 33 00 08  	.word	0x08003309
 8000060: 09 33 00 08  	.word	0x08003309
 8000064: 09 33 00 08  	.word	0x08003309
 8000068: 09 33 00 08  	.word	0x08003309
 800006c: 09 33 00 08  	.word	0x08003309
 8000070: 09 33 00 08  	.word	0x08003309
 8000074: 09 33 00 08  	.word	0x08003309
 8000078: 09 33 00 08  	.word	0x08003309
 800007c: 09 33 00 08  	.word	0x08003309
 8000080: 09 33 00 08  	.word	0x08003309
 8000084: 09 33 00 08  	.word	0x08003309
 8000088: 09 33 00 08  	.word	0x08003309
 800008c: 09 33 00 08  	.word	0x08003309
 8000090: 09 33 00 08  	.word	0x08003309
 8000094: 09 33 00 08  	.word	0x08003309
 8000098: 09 33 00 08  	.word	0x08003309
 800009c: 09 33 00 08  	.word	0x08003309
 80000a0: 09 33 00 08  	.word	0x08003309
 80000a4: 09 33 00 08  	.word	0x08003309
 80000a8: 09 33 00 08  	.word	0x08003309
 80000ac: 09 33 00 08  	.word	0x08003309
 80000b0: 09 33 00 08  	.word	0x08003309
 80000b4: 09 33 00 08  	.word	0x08003309
 80000b8: 09 33 00 08  	.word	0x08003309
 80000bc: 09 33 00 08  	.word	0x08003309
 80000c0: 09 33 00 08  	.word	0x08003309
 80000c4: 09 33 00 08  	.word	0x08003309
 80000c8: 09 33 00 08  	.word	0x08003309
 80000cc: 09 33 00 08  	.word	0x08003309
 80000d0: 09 33 00 08  	.word	0x08003309
 80000d4: 09 33 00 08  	.word	0x08003309
 80000d8: 09 33 00 08  	.word	0x08003309
 80000dc: 09 33 00 08  	.word	0x08003309
 80000e0: 09 33 00 08  	.word	0x08003309
 80000e4: 09 33 00 08  	.word	0x08003309
 80000e8: 09 33 00 08  	.word	0x08003309
 80000ec: 09 33 00 08  	.word	0x08003309
 80000f0: 09 33 00 08  	.word	0x08003309
 80000f4: 09 33 00 08  	.word	0x08003309
 80000f8: 09 33 00 08  	.word	0x08003309
 80000fc: 09 33 00 08  	.word	0x08003309
 8000100: 09 33 00 08  	.word	0x08003309
 8000104: 09 33 00 08  	.word	0x08003309
 8000108: 09 33 00 08  	.word	0x08003309
 800010c: 09 33 00 08  	.word	0x08003309
 8000110: 09 33 00 08  	.word	0x08003309
 8000114: 09 33 00 08  	.word	0x08003309
 8000118: 09 33 00 08  	.word	0x08003309
 800011c: 09 33 00 08  	.word	0x08003309
 8000120: 09 33 00 08  	.word	0x08003309
 8000124: 09 33 00 08  	.word	0x08003309
 8000128: 09 33 00 08  	.word	0x08003309
 800012c: 09 33 00 08  	.word	0x08003309
 8000130: 09 33 00 08  	.word	0x08003309
 8000134: 09 33 00 08  	.word	0x08003309
 8000138: 09 33 00 08  	.word	0x08003309
 800013c: 09 33 00 08  	.word	0x08003309
 8000140: 09 33 00 08  	.word	0x08003309
 8000144: 09 33 00 08  	.word	0x08003309
 8000148: 09 33 00 08  	.word	0x08003309
 800014c: 09 33 00 08  	.word	0x08003309
 8000150: 09 33 00 08  	.word	0x08003309
 8000154: 09 33 00 08  	.word	0x08003309
 8000158: 09 33 00 08  	.word	0x08003309
 800015c: 09 33 00 08  	.word	0x08003309
 8000160: 09 33 00 08  	.word	0x08003309
 8000164: 09 33 00 08  	.word	0x08003309
 8000168: 09 33 00 08  	.word	0x08003309
 800016c: 09 33 00 08  	.word	0x08003309
 8000170: 09 33 00 08  	.word	0x08003309
 8000174: 09 33 00 08  	.word	0x08003309
 8000178: 09 33 00 08  	.word	0x08003309
 800017c: 09 33 00 08  	.word	0x08003309
 8000180: 09 33 00 08  	.word	0x08003309
 8000184: 09 33 00 08  	.word	0x08003309

Disassembly of section text:

08000188 <__text_region_start>:
 8000188: f080 4000    	eor	r0, r0, #0x80000000
 800018c: e002         	b	0x8000194 <__aeabi_fadd> @ imm = #0x4
 800018e: bf00         	nop

08000190 <__subsf3>:
 8000190: f081 4100    	eor	r1, r1, #0x80000000

08000194 <__aeabi_fadd>:
 8000194: 0042         	lsls	r2, r0, #0x1
 8000196: bf1f         	itttt	ne
 8000198: ea5f 0341    	lslsne.w	r3, r1, #0x1
 800019c: ea92 0f03    	teqne.w	r2, r3
 80001a0: ea7f 6c22    	mvnsne.w	r12, r2, asr #24
 80001a4: ea7f 6c23    	mvnsne.w	r12, r3, asr #24
 80001a8: d06a         	beq	0x8000280 <__aeabi_fadd+0xec> @ imm = #0xd4
 80001aa: ea4f 6212    	lsr.w	r2, r2, #0x18
 80001ae: ebd2 6313    	rsbs	r3, r2, r3, lsr #24
 80001b2: bfc1         	itttt	gt
 80001b4: 18d2         	addgt	r2, r2, r3
 80001b6: 4041         	eorgt	r1, r0
 80001b8: 4048         	eorgt	r0, r1
 80001ba: 4041         	eorgt	r1, r0
 80001bc: bfb8         	it	lt
 80001be: 425b         	rsblt	r3, r3, #0
 80001c0: 2b19         	cmp	r3, #0x19
 80001c2: bf88         	it	hi
 80001c4: 4770         	bxhi	lr
 80001c6: f010 4f00    	tst.w	r0, #0x80000000
 80001ca: f440 0000    	orr	r0, r0, #0x800000
 80001ce: f020 407f    	bic	r0, r0, #0xff000000
 80001d2: bf18         	it	ne
 80001d4: 4240         	rsbne	r0, r0, #0
 80001d6: f011 4f00    	tst.w	r1, #0x80000000
 80001da: f441 0100    	orr	r1, r1, #0x800000
 80001de: f021 417f    	bic	r1, r1, #0xff000000
 80001e2: bf18         	it	ne
 80001e4: 4249         	rsbne	r1, r1, #0
 80001e6: ea92 0f03    	teq.w	r2, r3
 80001ea: d03f         	beq	0x800026c <__aeabi_fadd+0xd8> @ imm = #0x7e
 80001ec: f1a2 0201    	sub.w	r2, r2, #0x1
 80001f0: fa41 fc03    	asr.w	r12, r1, r3
 80001f4: eb10 000c    	adds.w	r0, r0, r12
 80001f8: f1c3 0320    	rsb.w	r3, r3, #0x20
 80001fc: fa01 f103    	lsl.w	r1, r1, r3
 8000200: f000 4300    	and	r3, r0, #0x80000000
 8000204: d502         	bpl	0x800020c <__aeabi_fadd+0x78> @ imm = #0x4
 8000206: 4249         	rsbs	r1, r1, #0
 8000208: eb60 0040    	sbc.w	r0, r0, r0, lsl #1
 800020c: f5b0 0f00    	cmp.w	r0, #0x800000
 8000210: d313         	blo	0x800023a <__aeabi_fadd+0xa6> @ imm = #0x26
 8000212: f1b0 7f80    	cmp.w	r0, #0x1000000
 8000216: d306         	blo	0x8000226 <__aeabi_fadd+0x92> @ imm = #0xc
 8000218: 0840         	lsrs	r0, r0, #0x1
 800021a: ea4f 0131    	rrx	r1, r1
 800021e: f102 0201    	add.w	r2, r2, #0x1
 8000222: 2afe         	cmp	r2, #0xfe
 8000224: d251         	bhs	0x80002ca <__aeabi_fadd+0x136> @ imm = #0xa2
 8000226: f1b1 4f00    	cmp.w	r1, #0x80000000
 800022a: eb40 50c2    	adc.w	r0, r0, r2, lsl #23
 800022e: bf08         	it	eq
 8000230: f020 0001    	biceq	r0, r0, #0x1
 8000234: ea40 0003    	orr.w	r0, r0, r3
 8000238: 4770         	bx	lr
 800023a: 0049         	lsls	r1, r1, #0x1
 800023c: eb40 0000    	adc.w	r0, r0, r0
 8000240: 3a01         	subs	r2, #0x1
 8000242: bf28         	it	hs
 8000244: f5b0 0f00    	cmphs.w	r0, #0x800000
 8000248: d2ed         	bhs	0x8000226 <__aeabi_fadd+0x92> @ imm = #-0x26
 800024a: fab0 fc80    	clz	r12, r0
 800024e: f1ac 0c08    	sub.w	r12, r12, #0x8
 8000252: ebb2 020c    	subs.w	r2, r2, r12
 8000256: fa00 f00c    	lsl.w	r0, r0, r12
 800025a: bfaa         	itet	ge
 800025c: eb00 50c2    	addge.w	r0, r0, r2, lsl #23
 8000260: 4252         	rsblt	r2, r2, #0
 8000262: 4318         	orrge	r0, r3
 8000264: bfbc         	itt	lt
 8000266: 40d0         	lsrlt	r0, r2
 8000268: 4318         	orrlt	r0, r3
 800026a: 4770         	bx	lr
 800026c: f092 0f00    	teq.w	r2, #0x0
 8000270: f481 0100    	eor	r1, r1, #0x800000
 8000274: bf06         	itte	eq
 8000276: f480 0000    	eoreq	r0, r0, #0x800000
 800027a: 3201         	addeq	r2, #0x1
 800027c: 3b01         	subne	r3, #0x1
 800027e: e7b5         	b	0x80001ec <__aeabi_fadd+0x58> @ imm = #-0x96
 8000280: ea4f 0341    	lsl.w	r3, r1, #0x1
 8000284: ea7f 6c22    	mvns.w	r12, r2, asr #24
 8000288: bf18         	it	ne
 800028a: ea7f 6c23    	mvnsne.w	r12, r3, asr #24
 800028e: d021         	beq	0x80002d4 <__aeabi_fadd+0x140> @ imm = #0x42
 8000290: ea92 0f03    	teq.w	r2, r3
 8000294: d004         	beq	0x80002a0 <__aeabi_fadd+0x10c> @ imm = #0x8
 8000296: f092 0f00    	teq.w	r2, #0x0
 800029a: bf08         	it	eq
 800029c: 4608         	moveq	r0, r1
 800029e: 4770         	bx	lr
 80002a0: ea90 0f01    	teq.w	r0, r1
 80002a4: bf1c         	itt	ne
 80002a6: 2000         	movne	r0, #0x0
 80002a8: 4770         	bxne	lr
 80002aa: f012 4f7f    	tst.w	r2, #0xff000000
 80002ae: d104         	bne	0x80002ba <__aeabi_fadd+0x126> @ imm = #0x8
 80002b0: 0040         	lsls	r0, r0, #0x1
 80002b2: bf28         	it	hs
 80002b4: f040 4000    	orrhs	r0, r0, #0x80000000
 80002b8: 4770         	bx	lr
 80002ba: f112 7200    	adds.w	r2, r2, #0x2000000
 80002be: bf3c         	itt	lo
 80002c0: f500 0000    	addlo.w	r0, r0, #0x800000
 80002c4: 4770         	bxlo	lr
 80002c6: f000 4300    	and	r3, r0, #0x80000000
 80002ca: f043 40fe    	orr	r0, r3, #0x7f000000
 80002ce: f440 0000    	orr	r0, r0, #0x800000
 80002d2: 4770         	bx	lr
 80002d4: ea7f 6222    	mvns.w	r2, r2, asr #24
 80002d8: bf16         	itet	ne
 80002da: 4608         	movne	r0, r1
 80002dc: ea7f 6323    	mvnseq.w	r3, r3, asr #24
 80002e0: 4601         	movne	r1, r0
 80002e2: 0242         	lsls	r2, r0, #0x9
 80002e4: bf06         	itte	eq
 80002e6: ea5f 2341    	lslseq.w	r3, r1, #0x9
 80002ea: ea90 0f01    	teqeq.w	r0, r1
 80002ee: f440 0080    	orrne	r0, r0, #0x400000
 80002f2: 4770         	bx	lr

080002f4 <__floatunsisf>:
 80002f4: f04f 0300    	mov.w	r3, #0x0
 80002f8: e004         	b	0x8000304 <__floatsisf+0x8> @ imm = #0x8
 80002fa: bf00         	nop

080002fc <__floatsisf>:
 80002fc: f010 4300    	ands	r3, r0, #0x80000000
 8000300: bf48         	it	mi
 8000302: 4240         	rsbmi	r0, r0, #0
 8000304: ea5f 0c00    	movs.w	r12, r0
 8000308: bf08         	it	eq
 800030a: 4770         	bxeq	lr
 800030c: f043 4396    	orr	r3, r3, #0x4b000000
 8000310: 4601         	mov	r1, r0
 8000312: f04f 0000    	mov.w	r0, #0x0
 8000316: e01c         	b	0x8000352 <__floatdisf+0x2a> @ imm = #0x38

08000318 <__floatundisf>:
 8000318: ea50 0201    	orrs.w	r2, r0, r1
 800031c: bf08         	it	eq
 800031e: 4770         	bxeq	lr
 8000320: f04f 0300    	mov.w	r3, #0x0
 8000324: e00a         	b	0x800033c <__floatdisf+0x14> @ imm = #0x14
 8000326: bf00         	nop

08000328 <__floatdisf>:
 8000328: ea50 0201    	orrs.w	r2, r0, r1
 800032c: bf08         	it	eq
 800032e: 4770         	bxeq	lr
 8000330: f011 4300    	ands	r3, r1, #0x80000000
 8000334: d502         	bpl	0x800033c <__floatdisf+0x14> @ imm = #0x4
 8000336: 4240         	rsbs	r0, r0, #0
 8000338: eb61 0141    	sbc.w	r1, r1, r1, lsl #1
 800033c: ea5f 0c01    	movs.w	r12, r1
 8000340: bf02         	ittt	eq
 8000342: 4684         	moveq	r12, r0
 8000344: 4601         	moveq	r1, r0
 8000346: 2000         	moveq	r0, #0x0
 8000348: f043 43b6    	orr	r3, r3, #0x5b000000
 800034c: bf08         	it	eq
 800034e: f1a3 5380    	subeq.w	r3, r3, #0x10000000
 8000352: f5a3 0300    	sub.w	r3, r3, #0x800000
 8000356: fabc f28c    	clz	r2, r12
 800035a: 3a08         	subs	r2, #0x8
 800035c: eba3 53c2    	sub.w	r3, r3, r2, lsl #23
 8000360: db10         	blt	0x8000384 <__floatdisf+0x5c> @ imm = #0x20
 8000362: fa01 fc02    	lsl.w	r12, r1, r2
 8000366: 4463         	add	r3, r12
 8000368: fa00 fc02    	lsl.w	r12, r0, r2
 800036c: f1c2 0220    	rsb.w	r2, r2, #0x20
 8000370: f1bc 4f00    	cmp.w	r12, #0x80000000
 8000374: fa20 f202    	lsr.w	r2, r0, r2
 8000378: eb43 0002    	adc.w	r0, r3, r2
 800037c: bf08         	it	eq
 800037e: f020 0001    	biceq	r0, r0, #0x1
 8000382: 4770         	bx	lr
 8000384: f102 0220    	add.w	r2, r2, #0x20
 8000388: fa01 fc02    	lsl.w	r12, r1, r2
 800038c: f1c2 0220    	rsb.w	r2, r2, #0x20
 8000390: ea50 004c    	orrs.w	r0, r0, r12, lsl #1
 8000394: fa21 f202    	lsr.w	r2, r1, r2
 8000398: eb43 0002    	adc.w	r0, r3, r2
 800039c: bf08         	it	eq
 800039e: ea20 70dc    	biceq.w	r0, r0, r12, lsr #31
 80003a2: 4770         	bx	lr

080003a4 <__mulsf3>:
 80003a4: f04f 0cff    	mov.w	r12, #0xff
 80003a8: ea1c 52d0    	ands.w	r2, r12, r0, lsr #23
 80003ac: bf1e         	ittt	ne
 80003ae: ea1c 53d1    	andsne.w	r3, r12, r1, lsr #23
 80003b2: ea92 0f0c    	teqne.w	r2, r12
 80003b6: ea93 0f0c    	teqne.w	r3, r12
 80003ba: d06f         	beq	0x800049c <__mulsf3+0xf8> @ imm = #0xde
 80003bc: 441a         	add	r2, r3
 80003be: ea80 0c01    	eor.w	r12, r0, r1
 80003c2: 0240         	lsls	r0, r0, #0x9
 80003c4: bf18         	it	ne
 80003c6: ea5f 2141    	lslsne.w	r1, r1, #0x9
 80003ca: d01e         	beq	0x800040a <__mulsf3+0x66> @ imm = #0x3c
 80003cc: f04f 6300    	mov.w	r3, #0x8000000
 80003d0: ea43 1050    	orr.w	r0, r3, r0, lsr #5
 80003d4: ea43 1151    	orr.w	r1, r3, r1, lsr #5
 80003d8: fba0 3101    	umull	r3, r1, r0, r1
 80003dc: f00c 4000    	and	r0, r12, #0x80000000
 80003e0: f5b1 0f00    	cmp.w	r1, #0x800000
 80003e4: bf3e         	ittt	lo
 80003e6: 0049         	lsllo	r1, r1, #0x1
 80003e8: ea41 71d3    	orrlo.w	r1, r1, r3, lsr #31
 80003ec: 005b         	lsllo	r3, r3, #0x1
 80003ee: ea40 0001    	orr.w	r0, r0, r1
 80003f2: f162 027f    	sbc	r2, r2, #0x7f
 80003f6: 2afd         	cmp	r2, #0xfd
 80003f8: d81d         	bhi	0x8000436 <__mulsf3+0x92> @ imm = #0x3a
 80003fa: f1b3 4f00    	cmp.w	r3, #0x80000000
 80003fe: eb40 50c2    	adc.w	r0, r0, r2, lsl #23
 8000402: bf08         	it	eq
 8000404: f020 0001    	biceq	r0, r0, #0x1
 8000408: 4770         	bx	lr
 800040a: f090 0f00    	teq.w	r0, #0x0
 800040e: f00c 4c00    	and	r12, r12, #0x80000000
 8000412: bf08         	it	eq
 8000414: 0249         	lsleq	r1, r1, #0x9
 8000416: ea4c 2050    	orr.w	r0, r12, r0, lsr #9
 800041a: ea40 2051    	orr.w	r0, r0, r1, lsr #9
 800041e: 3a7f         	subs	r2, #0x7f
 8000420: bfc2         	ittt	gt
 8000422: f1d2 03ff    	rsbsgt.w	r3, r2, #0xff
 8000426: ea40 50c2    	orrgt.w	r0, r0, r2, lsl #23
 800042a: 4770         	bxgt	lr
 800042c: f440 0000    	orr	r0, r0, #0x800000
 8000430: f04f 0300    	mov.w	r3, #0x0
 8000434: 3a01         	subs	r2, #0x1
 8000436: dc5d         	bgt	0x80004f4 <__mulsf3+0x150> @ imm = #0xba
 8000438: f112 0f19    	cmn.w	r2, #0x19
 800043c: bfdc         	itt	le
 800043e: f000 4000    	andle	r0, r0, #0x80000000
 8000442: 4770         	bxle	lr
 8000444: f1c2 0200    	rsb.w	r2, r2, #0x0
 8000448: 0041         	lsls	r1, r0, #0x1
 800044a: fa21 f102    	lsr.w	r1, r1, r2
 800044e: f1c2 0220    	rsb.w	r2, r2, #0x20
 8000452: fa00 fc02    	lsl.w	r12, r0, r2
 8000456: ea5f 0031    	rrxs	r0, r1
 800045a: f140 0000    	adc	r0, r0, #0x0
 800045e: ea53 034c    	orrs.w	r3, r3, r12, lsl #1
 8000462: bf08         	it	eq
 8000464: ea20 70dc    	biceq.w	r0, r0, r12, lsr #31
 8000468: 4770         	bx	lr
 800046a: f092 0f00    	teq.w	r2, #0x0
 800046e: f000 4c00    	and	r12, r0, #0x80000000
 8000472: bf02         	ittt	eq
 8000474: 0040         	lsleq	r0, r0, #0x1
 8000476: f410 0f00    	tsteq.w	r0, #0x800000
 800047a: 3a01         	subeq	r2, #0x1
 800047c: d0f9         	beq	0x8000472 <__mulsf3+0xce> @ imm = #-0xe
 800047e: ea40 000c    	orr.w	r0, r0, r12
 8000482: f093 0f00    	teq.w	r3, #0x0
 8000486: f001 4c00    	and	r12, r1, #0x80000000
 800048a: bf02         	ittt	eq
 800048c: 0049         	lsleq	r1, r1, #0x1
 800048e: f411 0f00    	tsteq.w	r1, #0x800000
 8000492: 3b01         	subeq	r3, #0x1
 8000494: d0f9         	beq	0x800048a <__mulsf3+0xe6> @ imm = #-0xe
 8000496: ea41 010c    	orr.w	r1, r1, r12
 800049a: e78f         	b	0x80003bc <__mulsf3+0x18> @ imm = #-0xe2
 800049c: ea0c 53d1    	and.w	r3, r12, r1, lsr #23
 80004a0: ea92 0f0c    	teq.w	r2, r12
 80004a4: bf18         	it	ne
 80004a6: ea93 0f0c    	teqne.w	r3, r12
 80004aa: d00a         	beq	0x80004c2 <__mulsf3+0x11e> @ imm = #0x14
 80004ac: f030 4c00    	bics	r12, r0, #0x80000000
 80004b0: bf18         	it	ne
 80004b2: f031 4c00    	bicsne	r12, r1, #0x80000000
 80004b6: d1d8         	bne	0x800046a <__mulsf3+0xc6> @ imm = #-0x50
 80004b8: ea80 0001    	eor.w	r0, r0, r1
 80004bc: f000 4000    	and	r0, r0, #0x80000000
 80004c0: 4770         	bx	lr
 80004c2: f090 0f00    	teq.w	r0, #0x0
 80004c6: bf17         	itett	ne
 80004c8: f090 4f00    	teqne.w	r0, #0x80000000
 80004cc: 4608         	moveq	r0, r1
 80004ce: f091 0f00    	teqne.w	r1, #0x0
 80004d2: f091 4f00    	teqne.w	r1, #0x80000000
 80004d6: d014         	beq	0x8000502 <__mulsf3+0x15e> @ imm = #0x28
 80004d8: ea92 0f0c    	teq.w	r2, r12
 80004dc: d101         	bne	0x80004e2 <__mulsf3+0x13e> @ imm = #0x2
 80004de: 0242         	lsls	r2, r0, #0x9
 80004e0: d10f         	bne	0x8000502 <__mulsf3+0x15e> @ imm = #0x1e
 80004e2: ea93 0f0c    	teq.w	r3, r12
 80004e6: d103         	bne	0x80004f0 <__mulsf3+0x14c> @ imm = #0x6
 80004e8: 024b         	lsls	r3, r1, #0x9
 80004ea: bf18         	it	ne
 80004ec: 4608         	movne	r0, r1
 80004ee: d108         	bne	0x8000502 <__mulsf3+0x15e> @ imm = #0x10
 80004f0: ea80 0001    	eor.w	r0, r0, r1
 80004f4: f000 4000    	and	r0, r0, #0x80000000
 80004f8: f040 40fe    	orr	r0, r0, #0x7f000000
 80004fc: f440 0000    	orr	r0, r0, #0x800000
 8000500: 4770         	bx	lr
 8000502: f040 40fe    	orr	r0, r0, #0x7f000000
 8000506: f440 0040    	orr	r0, r0, #0xc00000
 800050a: 4770         	bx	lr

0800050c <__divsf3>:
 800050c: f04f 0cff    	mov.w	r12, #0xff
 8000510: ea1c 52d0    	ands.w	r2, r12, r0, lsr #23
 8000514: bf1e         	ittt	ne
 8000516: ea1c 53d1    	andsne.w	r3, r12, r1, lsr #23
 800051a: ea92 0f0c    	teqne.w	r2, r12
 800051e: ea93 0f0c    	teqne.w	r3, r12
 8000522: d069         	beq	0x80005f8 <__divsf3+0xec> @ imm = #0xd2
 8000524: eba2 0203    	sub.w	r2, r2, r3
 8000528: ea80 0c01    	eor.w	r12, r0, r1
 800052c: 0249         	lsls	r1, r1, #0x9
 800052e: ea4f 2040    	lsl.w	r0, r0, #0x9
 8000532: d037         	beq	0x80005a4 <__divsf3+0x98> @ imm = #0x6e
 8000534: f04f 5380    	mov.w	r3, #0x10000000
 8000538: ea43 1111    	orr.w	r1, r3, r1, lsr #4
 800053c: ea43 1310    	orr.w	r3, r3, r0, lsr #4
 8000540: f00c 4000    	and	r0, r12, #0x80000000
 8000544: 428b         	cmp	r3, r1
 8000546: bf38         	it	lo
 8000548: 005b         	lsllo	r3, r3, #0x1
 800054a: f142 027d    	adc	r2, r2, #0x7d
 800054e: f44f 0c00    	mov.w	r12, #0x800000
 8000552: 428b         	cmp	r3, r1
 8000554: bf24         	itt	hs
 8000556: 1a5b         	subhs	r3, r3, r1
 8000558: ea40 000c    	orrhs.w	r0, r0, r12
 800055c: ebb3 0f51    	cmp.w	r3, r1, lsr #1
 8000560: bf24         	itt	hs
 8000562: eba3 0351    	subhs.w	r3, r3, r1, lsr #1
 8000566: ea40 005c    	orrhs.w	r0, r0, r12, lsr #1
 800056a: ebb3 0f91    	cmp.w	r3, r1, lsr #2
 800056e: bf24         	itt	hs
 8000570: eba3 0391    	subhs.w	r3, r3, r1, lsr #2
 8000574: ea40 009c    	orrhs.w	r0, r0, r12, lsr #2
 8000578: ebb3 0fd1    	cmp.w	r3, r1, lsr #3
 800057c: bf24         	itt	hs
 800057e: eba3 03d1    	subhs.w	r3, r3, r1, lsr #3
 8000582: ea40 00dc    	orrhs.w	r0, r0, r12, lsr #3
 8000586: 011b         	lsls	r3, r3, #0x4
 8000588: bf18         	it	ne
 800058a: ea5f 1c1c    	lsrsne.w	r12, r12, #0x4
 800058e: d1e0         	bne	0x8000552 <__divsf3+0x46> @ imm = #-0x40
 8000590: 2afd         	cmp	r2, #0xfd
 8000592: f63f af50    	bhi.w	0x8000436 <__mulsf3+0x92> @ imm = #-0x160
 8000596: 428b         	cmp	r3, r1
 8000598: eb40 50c2    	adc.w	r0, r0, r2, lsl #23
 800059c: bf08         	it	eq
 800059e: f020 0001    	biceq	r0, r0, #0x1
 80005a2: 4770         	bx	lr
 80005a4: f00c 4c00    	and	r12, r12, #0x80000000
 80005a8: ea4c 2050    	orr.w	r0, r12, r0, lsr #9
 80005ac: 327f         	adds	r2, #0x7f
 80005ae: bfc2         	ittt	gt
 80005b0: f1d2 03ff    	rsbsgt.w	r3, r2, #0xff
 80005b4: ea40 50c2    	orrgt.w	r0, r0, r2, lsl #23
 80005b8: 4770         	bxgt	lr
 80005ba: f440 0000    	orr	r0, r0, #0x800000
 80005be: f04f 0300    	mov.w	r3, #0x0
 80005c2: 3a01         	subs	r2, #0x1
 80005c4: e737         	b	0x8000436 <__mulsf3+0x92> @ imm = #-0x192
 80005c6: f092 0f00    	teq.w	r2, #0x0
 80005ca: f000 4c00    	and	r12, r0, #0x80000000
 80005ce: bf02         	ittt	eq
 80005d0: 0040         	lsleq	r0, r0, #0x1
 80005d2: f410 0f00    	tsteq.w	r0, #0x800000
 80005d6: 3a01         	subeq	r2, #0x1
 80005d8: d0f9         	beq	0x80005ce <__divsf3+0xc2> @ imm = #-0xe
 80005da: ea40 000c    	orr.w	r0, r0, r12
 80005de: f093 0f00    	teq.w	r3, #0x0
 80005e2: f001 4c00    	and	r12, r1, #0x80000000
 80005e6: bf02         	ittt	eq
 80005e8: 0049         	lsleq	r1, r1, #0x1
 80005ea: f411 0f00    	tsteq.w	r1, #0x800000
 80005ee: 3b01         	subeq	r3, #0x1
 80005f0: d0f9         	beq	0x80005e6 <__divsf3+0xda> @ imm = #-0xe
 80005f2: ea41 010c    	orr.w	r1, r1, r12
 80005f6: e795         	b	0x8000524 <__divsf3+0x18> @ imm = #-0xd6
 80005f8: ea0c 53d1    	and.w	r3, r12, r1, lsr #23
 80005fc: ea92 0f0c    	teq.w	r2, r12
 8000600: d108         	bne	0x8000614 <__divsf3+0x108> @ imm = #0x10
 8000602: 0242         	lsls	r2, r0, #0x9
 8000604: f47f af7d    	bne.w	0x8000502 <__mulsf3+0x15e> @ imm = #-0x106
 8000608: ea93 0f0c    	teq.w	r3, r12
 800060c: f47f af70    	bne.w	0x80004f0 <__mulsf3+0x14c> @ imm = #-0x120
 8000610: 4608         	mov	r0, r1
 8000612: e776         	b	0x8000502 <__mulsf3+0x15e> @ imm = #-0x114
 8000614: ea93 0f0c    	teq.w	r3, r12
 8000618: d104         	bne	0x8000624 <__divsf3+0x118> @ imm = #0x8
 800061a: 024b         	lsls	r3, r1, #0x9
 800061c: f43f af4c    	beq.w	0x80004b8 <__mulsf3+0x114> @ imm = #-0x168
 8000620: 4608         	mov	r0, r1
 8000622: e76e         	b	0x8000502 <__mulsf3+0x15e> @ imm = #-0x124
 8000624: f030 4c00    	bics	r12, r0, #0x80000000
 8000628: bf18         	it	ne
 800062a: f031 4c00    	bicsne	r12, r1, #0x80000000
 800062e: d1ca         	bne	0x80005c6 <__divsf3+0xba> @ imm = #-0x6c
 8000630: f030 4200    	bics	r2, r0, #0x80000000
 8000634: f47f af5c    	bne.w	0x80004f0 <__mulsf3+0x14c> @ imm = #-0x148
 8000638: f031 4300    	bics	r3, r1, #0x80000000
 800063c: f47f af3c    	bne.w	0x80004b8 <__mulsf3+0x114> @ imm = #-0x188
 8000640: e75f         	b	0x8000502 <__mulsf3+0x15e> @ imm = #-0x142
 8000642: bf00         	nop

08000644 <__gtsf2>:
 8000644: f04f 3cff    	mov.w	r12, #0xffffffff
 8000648: e006         	b	0x8000658 <__nesf2+0x4> @ imm = #0xc
 800064a: bf00         	nop

0800064c <__ltsf2>:
 800064c: f04f 0c01    	mov.w	r12, #0x1
 8000650: e002         	b	0x8000658 <__nesf2+0x4> @ imm = #0x4
 8000652: bf00         	nop

08000654 <__nesf2>:
 8000654: f04f 0c01    	mov.w	r12, #0x1
 8000658: f84d cd04    	str	r12, [sp, #-4]!
 800065c: ea4f 0240    	lsl.w	r2, r0, #0x1
 8000660: ea4f 0341    	lsl.w	r3, r1, #0x1
 8000664: ea7f 6c22    	mvns.w	r12, r2, asr #24
 8000668: bf18         	it	ne
 800066a: ea7f 6c23    	mvnsne.w	r12, r3, asr #24
 800066e: d011         	beq	0x8000694 <__nesf2+0x40> @ imm = #0x22
 8000670: b001         	add	sp, #0x4
 8000672: ea52 0c53    	orrs.w	r12, r2, r3, lsr #1
 8000676: bf18         	it	ne
 8000678: ea90 0f01    	teqne.w	r0, r1
 800067c: bf58         	it	pl
 800067e: ebb2 0003    	subspl.w	r0, r2, r3
 8000682: bf88         	it	hi
 8000684: 17c8         	asrhi	r0, r1, #0x1f
 8000686: bf38         	it	lo
 8000688: ea6f 70e1    	mvnlo.w	r0, r1, asr #31
 800068c: bf18         	it	ne
 800068e: f040 0001    	orrne	r0, r0, #0x1
 8000692: 4770         	bx	lr
 8000694: ea7f 6c22    	mvns.w	r12, r2, asr #24
 8000698: d102         	bne	0x80006a0 <__nesf2+0x4c> @ imm = #0x4
 800069a: ea5f 2c40    	lsls.w	r12, r0, #0x9
 800069e: d105         	bne	0x80006ac <__nesf2+0x58> @ imm = #0xa
 80006a0: ea7f 6c23    	mvns.w	r12, r3, asr #24
 80006a4: d1e4         	bne	0x8000670 <__nesf2+0x1c> @ imm = #-0x38
 80006a6: ea5f 2c41    	lsls.w	r12, r1, #0x9
 80006aa: d0e1         	beq	0x8000670 <__nesf2+0x1c> @ imm = #-0x3e
 80006ac: f85d 0b04    	ldr	r0, [sp], #4
 80006b0: 4770         	bx	lr
 80006b2: bf00         	nop

080006b4 <__aeabi_cfrcmple>:
 80006b4: 4684         	mov	r12, r0
 80006b6: 4608         	mov	r0, r1
 80006b8: 4661         	mov	r1, r12
 80006ba: e7ff         	b	0x80006bc <__aeabi_cfcmple> @ imm = #-0x2

080006bc <__aeabi_cfcmple>:
 80006bc: b50f         	push	{r0, r1, r2, r3, lr}
 80006be: f7ff ffc9    	bl	0x8000654 <__nesf2>     @ imm = #-0x6e
 80006c2: 2800         	cmp	r0, #0x0
 80006c4: bf48         	it	mi
 80006c6: f110 0f00    	cmnmi.w	r0, #0x0
 80006ca: bd0f         	pop	{r0, r1, r2, r3, pc}

080006cc <__aeabi_fcmpeq>:
 80006cc: f84d ed08    	str	lr, [sp, #-8]!
 80006d0: f7ff fff4    	bl	0x80006bc <__aeabi_cfcmple> @ imm = #-0x18
 80006d4: bf0c         	ite	eq
 80006d6: 2001         	moveq	r0, #0x1
 80006d8: 2000         	movne	r0, #0x0
 80006da: f85d fb08    	ldr	pc, [sp], #8
 80006de: bf00         	nop

080006e0 <__aeabi_fcmplt>:
 80006e0: f84d ed08    	str	lr, [sp, #-8]!
 80006e4: f7ff ffea    	bl	0x80006bc <__aeabi_cfcmple> @ imm = #-0x2c
 80006e8: bf34         	ite	lo
 80006ea: 2001         	movlo	r0, #0x1
 80006ec: 2000         	movhs	r0, #0x0
 80006ee: f85d fb08    	ldr	pc, [sp], #8
 80006f2: bf00         	nop

080006f4 <__aeabi_fcmple>:
 80006f4: f84d ed08    	str	lr, [sp, #-8]!
 80006f8: f7ff ffe0    	bl	0x80006bc <__aeabi_cfcmple> @ imm = #-0x40
 80006fc: bf94         	ite	ls
 80006fe: 2001         	movls	r0, #0x1
 8000700: 2000         	movhi	r0, #0x0
 8000702: f85d fb08    	ldr	pc, [sp], #8
 8000706: bf00         	nop

08000708 <__aeabi_fcmpge>:
 8000708: f84d ed08    	str	lr, [sp, #-8]!
 800070c: f7ff ffd2    	bl	0x80006b4 <__aeabi_cfrcmple> @ imm = #-0x5c
 8000710: bf94         	ite	ls
 8000712: 2001         	movls	r0, #0x1
 8000714: 2000         	movhi	r0, #0x0
 8000716: f85d fb08    	ldr	pc, [sp], #8
 800071a: bf00         	nop

0800071c <__aeabi_fcmpgt>:
 800071c: f84d ed08    	str	lr, [sp, #-8]!
 8000720: f7ff ffc8    	bl	0x80006b4 <__aeabi_cfrcmple> @ imm = #-0x70
 8000724: bf34         	ite	lo
 8000726: 2001         	movlo	r0, #0x1
 8000728: 2000         	movhs	r0, #0x0
 800072a: f85d fb08    	ldr	pc, [sp], #8
 800072e: bf00         	nop

08000730 <__fixsfsi>:
 8000730: ea4f 0240    	lsl.w	r2, r0, #0x1
 8000734: f1b2 4ffe    	cmp.w	r2, #0x7f000000
 8000738: d30f         	blo	0x800075a <__fixsfsi+0x2a> @ imm = #0x1e
 800073a: f04f 039e    	mov.w	r3, #0x9e
 800073e: ebb3 6212    	subs.w	r2, r3, r2, lsr #24
 8000742: d90d         	bls	0x8000760 <__fixsfsi+0x30> @ imm = #0x1a
 8000744: ea4f 2300    	lsl.w	r3, r0, #0x8
 8000748: f043 4300    	orr	r3, r3, #0x80000000
 800074c: f010 4f00    	tst.w	r0, #0x80000000
 8000750: fa23 f002    	lsr.w	r0, r3, r2
 8000754: bf18         	it	ne
 8000756: 4240         	rsbne	r0, r0, #0
 8000758: 4770         	bx	lr
 800075a: f04f 0000    	mov.w	r0, #0x0
 800075e: 4770         	bx	lr
 8000760: f112 0f61    	cmn.w	r2, #0x61
 8000764: d101         	bne	0x800076a <__fixsfsi+0x3a> @ imm = #0x2
 8000766: 0242         	lsls	r2, r0, #0x9
 8000768: d105         	bne	0x8000776 <__fixsfsi+0x46> @ imm = #0xa
 800076a: f010 4000    	ands	r0, r0, #0x80000000
 800076e: bf08         	it	eq
 8000770: f06f 4000    	mvneq	r0, #0x80000000
 8000774: 4770         	bx	lr
 8000776: f04f 0000    	mov.w	r0, #0x0
 800077a: 4770         	bx	lr

0800077c <__aeabi_uldivmod>:
 800077c: b953         	cbnz	r3, 0x8000794 <__aeabi_uldivmod+0x18> @ imm = #0x14
 800077e: b94a         	cbnz	r2, 0x8000794 <__aeabi_uldivmod+0x18> @ imm = #0x12
 8000780: 2900         	cmp	r1, #0x0
 8000782: bf08         	it	eq
 8000784: 2800         	cmpeq	r0, #0x0
 8000786: bf1c         	itt	ne
 8000788: f04f 31ff    	movne.w	r1, #0xffffffff
 800078c: f04f 30ff    	movne.w	r0, #0xffffffff
 8000790: f000 b80c    	b.w	0x80007ac <__aeabi_ldiv0> @ imm = #0x18
 8000794: f1ad 0c08    	sub.w	r12, sp, #0x8
 8000798: e96d ce04    	strd	r12, lr, [sp, #-16]!
 800079c: f000 f81a    	bl	0x80007d4 <__udivmoddi4> @ imm = #0x34
 80007a0: f8dd e004    	ldr.w	lr, [sp, #0x4]
 80007a4: e9dd 2302    	ldrd	r2, r3, [sp, #8]
 80007a8: b004         	add	sp, #0x10
 80007aa: 4770         	bx	lr

080007ac <__aeabi_ldiv0>:
 80007ac: 4770         	bx	lr
 80007ae: bf00         	nop

080007b0 <strcmp>:
 80007b0: f810 2b01    	ldrb	r2, [r0], #1
 80007b4: f811 3b01    	ldrb	r3, [r1], #1
 80007b8: 2a01         	cmp	r2, #0x1
 80007ba: bf28         	it	hs
 80007bc: 429a         	cmphs	r2, r3
 80007be: d0f7         	beq	0x80007b0 <strcmp>      @ imm = #-0x12
 80007c0: 1ad0         	subs	r0, r2, r3
 80007c2: 4770         	bx	lr

080007c4 <strlen>:
 80007c4: 4603         	mov	r3, r0
 80007c6: f813 2b01    	ldrb	r2, [r3], #1
 80007ca: 2a00         	cmp	r2, #0x0
 80007cc: d1fb         	bne	0x80007c6 <strlen+0x2>  @ imm = #-0xa
 80007ce: 1a18         	subs	r0, r3, r0
 80007d0: 3801         	subs	r0, #0x1
 80007d2: 4770         	bx	lr

080007d4 <__udivmoddi4>:
 80007d4: e92d 47f0    	push.w	{r4, r5, r6, r7, r8, r9, r10, lr}
 80007d8: 4686         	mov	lr, r0
 80007da: 468c         	mov	r12, r1
 80007dc: 4608         	mov	r0, r1
 80007de: 9e08         	ldr	r6, [sp, #0x20]
 80007e0: 4615         	mov	r5, r2
 80007e2: 4674         	mov	r4, lr
 80007e4: 4619         	mov	r1, r3
 80007e6: 2b00         	cmp	r3, #0x0
 80007e8: f040 80c2    	bne.w	0x8000970 <__udivmoddi4+0x19c> @ imm = #0x184
 80007ec: 4285         	cmp	r5, r0
 80007ee: fab2 f282    	clz	r2, r2
 80007f2: d945         	bls	0x8000880 <__udivmoddi4+0xac> @ imm = #0x8a
 80007f4: b14a         	cbz	r2, 0x800080a <__udivmoddi4+0x36> @ imm = #0x12
 80007f6: f1c2 0320    	rsb.w	r3, r2, #0x20
 80007fa: fa00 fc02    	lsl.w	r12, r0, r2
 80007fe: fa2e f303    	lsr.w	r3, lr, r3
 8000802: 4095         	lsls	r5, r2
 8000804: ea43 0c0c    	orr.w	r12, r3, r12
 8000808: 4094         	lsls	r4, r2
 800080a: ea4f 4e15    	lsr.w	lr, r5, #0x10
 800080e: b2a8         	uxth	r0, r5
 8000810: fbbc f8fe    	udiv	r8, r12, lr
 8000814: 0c23         	lsrs	r3, r4, #0x10
 8000816: fb0e cc18    	mls	r12, lr, r8, r12
 800081a: fb08 f900    	mul	r9, r8, r0
 800081e: ea43 430c    	orr.w	r3, r3, r12, lsl #16
 8000822: 4599         	cmp	r9, r3
 8000824: d928         	bls	0x8000878 <__udivmoddi4+0xa4> @ imm = #0x50
 8000826: 18eb         	adds	r3, r5, r3
 8000828: f108 37ff    	add.w	r7, r8, #0xffffffff
 800082c: d204         	bhs	0x8000838 <__udivmoddi4+0x64> @ imm = #0x8
 800082e: 4599         	cmp	r9, r3
 8000830: d902         	bls	0x8000838 <__udivmoddi4+0x64> @ imm = #0x4
 8000832: f1a8 0702    	sub.w	r7, r8, #0x2
 8000836: 442b         	add	r3, r5
 8000838: eba3 0309    	sub.w	r3, r3, r9
 800083c: b2a4         	uxth	r4, r4
 800083e: fbb3 fcfe    	udiv	r12, r3, lr
 8000842: fb0e 331c    	mls	r3, lr, r12, r3
 8000846: fb0c f000    	mul	r0, r12, r0
 800084a: ea44 4403    	orr.w	r4, r4, r3, lsl #16
 800084e: 42a0         	cmp	r0, r4
 8000850: d914         	bls	0x800087c <__udivmoddi4+0xa8> @ imm = #0x28
 8000852: 192c         	adds	r4, r5, r4
 8000854: f10c 33ff    	add.w	r3, r12, #0xffffffff
 8000858: d204         	bhs	0x8000864 <__udivmoddi4+0x90> @ imm = #0x8
 800085a: 42a0         	cmp	r0, r4
 800085c: d902         	bls	0x8000864 <__udivmoddi4+0x90> @ imm = #0x4
 800085e: f1ac 0302    	sub.w	r3, r12, #0x2
 8000862: 442c         	add	r4, r5
 8000864: 1a24         	subs	r4, r4, r0
 8000866: ea43 4007    	orr.w	r0, r3, r7, lsl #16
 800086a: b11e         	cbz	r6, 0x8000874 <__udivmoddi4+0xa0> @ imm = #0x6
 800086c: 40d4         	lsrs	r4, r2
 800086e: 2300         	movs	r3, #0x0
 8000870: 6034         	str	r4, [r6]
 8000872: 6073         	str	r3, [r6, #0x4]
 8000874: e8bd 87f0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, pc}
 8000878: 4647         	mov	r7, r8
 800087a: e7dd         	b	0x8000838 <__udivmoddi4+0x64> @ imm = #-0x46
 800087c: 4663         	mov	r3, r12
 800087e: e7f1         	b	0x8000864 <__udivmoddi4+0x90> @ imm = #-0x1e
 8000880: bb92         	cbnz	r2, 0x80008e8 <__udivmoddi4+0x114> @ imm = #0x64
 8000882: 1b43         	subs	r3, r0, r5
 8000884: 2101         	movs	r1, #0x1
 8000886: ea4f 4e15    	lsr.w	lr, r5, #0x10
 800088a: b2af         	uxth	r7, r5
 800088c: fbb3 fcfe    	udiv	r12, r3, lr
 8000890: 0c20         	lsrs	r0, r4, #0x10
 8000892: fb0e 331c    	mls	r3, lr, r12, r3
 8000896: fb0c f807    	mul	r8, r12, r7
 800089a: ea40 4303    	orr.w	r3, r0, r3, lsl #16
 800089e: 4598         	cmp	r8, r3
 80008a0: d962         	bls	0x8000968 <__udivmoddi4+0x194> @ imm = #0xc4
 80008a2: 18eb         	adds	r3, r5, r3
 80008a4: f10c 30ff    	add.w	r0, r12, #0xffffffff
 80008a8: d204         	bhs	0x80008b4 <__udivmoddi4+0xe0> @ imm = #0x8
 80008aa: 4598         	cmp	r8, r3
 80008ac: d902         	bls	0x80008b4 <__udivmoddi4+0xe0> @ imm = #0x4
 80008ae: f1ac 0002    	sub.w	r0, r12, #0x2
 80008b2: 442b         	add	r3, r5
 80008b4: eba3 0308    	sub.w	r3, r3, r8
 80008b8: b2a4         	uxth	r4, r4
 80008ba: fbb3 fcfe    	udiv	r12, r3, lr
 80008be: fb0e 331c    	mls	r3, lr, r12, r3
 80008c2: fb0c f707    	mul	r7, r12, r7
 80008c6: ea44 4403    	orr.w	r4, r4, r3, lsl #16
 80008ca: 42a7         	cmp	r7, r4
 80008cc: d94e         	bls	0x800096c <__udivmoddi4+0x198> @ imm = #0x9c
 80008ce: 192c         	adds	r4, r5, r4
 80008d0: f10c 33ff    	add.w	r3, r12, #0xffffffff
 80008d4: d204         	bhs	0x80008e0 <__udivmoddi4+0x10c> @ imm = #0x8
 80008d6: 42a7         	cmp	r7, r4
 80008d8: d902         	bls	0x80008e0 <__udivmoddi4+0x10c> @ imm = #0x4
 80008da: f1ac 0302    	sub.w	r3, r12, #0x2
 80008de: 442c         	add	r4, r5
 80008e0: 1be4         	subs	r4, r4, r7
 80008e2: ea43 4000    	orr.w	r0, r3, r0, lsl #16
 80008e6: e7c0         	b	0x800086a <__udivmoddi4+0x96> @ imm = #-0x80
 80008e8: f1c2 0320    	rsb.w	r3, r2, #0x20
 80008ec: fa20 f103    	lsr.w	r1, r0, r3
 80008f0: 4095         	lsls	r5, r2
 80008f2: 4090         	lsls	r0, r2
 80008f4: fa2e f303    	lsr.w	r3, lr, r3
 80008f8: 4303         	orrs	r3, r0
 80008fa: ea4f 4e15    	lsr.w	lr, r5, #0x10
 80008fe: b2af         	uxth	r7, r5
 8000900: fbb1 fcfe    	udiv	r12, r1, lr
 8000904: fb0e 101c    	mls	r0, lr, r12, r1
 8000908: 0c19         	lsrs	r1, r3, #0x10
 800090a: fb0c f807    	mul	r8, r12, r7
 800090e: ea41 4100    	orr.w	r1, r1, r0, lsl #16
 8000912: 4588         	cmp	r8, r1
 8000914: fa04 f402    	lsl.w	r4, r4, r2
 8000918: d922         	bls	0x8000960 <__udivmoddi4+0x18c> @ imm = #0x44
 800091a: 1869         	adds	r1, r5, r1
 800091c: f10c 30ff    	add.w	r0, r12, #0xffffffff
 8000920: d204         	bhs	0x800092c <__udivmoddi4+0x158> @ imm = #0x8
 8000922: 4588         	cmp	r8, r1
 8000924: d902         	bls	0x800092c <__udivmoddi4+0x158> @ imm = #0x4
 8000926: f1ac 0002    	sub.w	r0, r12, #0x2
 800092a: 4429         	add	r1, r5
 800092c: eba1 0108    	sub.w	r1, r1, r8
 8000930: b29b         	uxth	r3, r3
 8000932: fbb1 fcfe    	udiv	r12, r1, lr
 8000936: fb0e 111c    	mls	r1, lr, r12, r1
 800093a: fb0c f707    	mul	r7, r12, r7
 800093e: ea43 4301    	orr.w	r3, r3, r1, lsl #16
 8000942: 429f         	cmp	r7, r3
 8000944: d90e         	bls	0x8000964 <__udivmoddi4+0x190> @ imm = #0x1c
 8000946: 18eb         	adds	r3, r5, r3
 8000948: f10c 31ff    	add.w	r1, r12, #0xffffffff
 800094c: d204         	bhs	0x8000958 <__udivmoddi4+0x184> @ imm = #0x8
 800094e: 429f         	cmp	r7, r3
 8000950: d902         	bls	0x8000958 <__udivmoddi4+0x184> @ imm = #0x4
 8000952: f1ac 0102    	sub.w	r1, r12, #0x2
 8000956: 442b         	add	r3, r5
 8000958: 1bdb         	subs	r3, r3, r7
 800095a: ea41 4100    	orr.w	r1, r1, r0, lsl #16
 800095e: e792         	b	0x8000886 <__udivmoddi4+0xb2> @ imm = #-0xdc
 8000960: 4660         	mov	r0, r12
 8000962: e7e3         	b	0x800092c <__udivmoddi4+0x158> @ imm = #-0x3a
 8000964: 4661         	mov	r1, r12
 8000966: e7f7         	b	0x8000958 <__udivmoddi4+0x184> @ imm = #-0x12
 8000968: 4660         	mov	r0, r12
 800096a: e7a3         	b	0x80008b4 <__udivmoddi4+0xe0> @ imm = #-0xba
 800096c: 4663         	mov	r3, r12
 800096e: e7b7         	b	0x80008e0 <__udivmoddi4+0x10c> @ imm = #-0x92
 8000970: 4283         	cmp	r3, r0
 8000972: d906         	bls	0x8000982 <__udivmoddi4+0x1ae> @ imm = #0xc
 8000974: b916         	cbnz	r6, 0x800097c <__udivmoddi4+0x1a8> @ imm = #0x4
 8000976: 2100         	movs	r1, #0x0
 8000978: 4608         	mov	r0, r1
 800097a: e77b         	b	0x8000874 <__udivmoddi4+0xa0> @ imm = #-0x10a
 800097c: e9c6 e000    	strd	lr, r0, [r6]
 8000980: e7f9         	b	0x8000976 <__udivmoddi4+0x1a2> @ imm = #-0xe
 8000982: fab3 f783    	clz	r7, r3
 8000986: b98f         	cbnz	r7, 0x80009ac <__udivmoddi4+0x1d8> @ imm = #0x22
 8000988: 4283         	cmp	r3, r0
 800098a: d301         	blo	0x8000990 <__udivmoddi4+0x1bc> @ imm = #0x2
 800098c: 4572         	cmp	r2, lr
 800098e: d808         	bhi	0x80009a2 <__udivmoddi4+0x1ce> @ imm = #0x10
 8000990: ebbe 0402    	subs.w	r4, lr, r2
 8000994: eb60 0303    	sbc.w	r3, r0, r3
 8000998: 2001         	movs	r0, #0x1
 800099a: 469c         	mov	r12, r3
 800099c: b91e         	cbnz	r6, 0x80009a6 <__udivmoddi4+0x1d2> @ imm = #0x6
 800099e: 2100         	movs	r1, #0x0
 80009a0: e768         	b	0x8000874 <__udivmoddi4+0xa0> @ imm = #-0x130
 80009a2: 4638         	mov	r0, r7
 80009a4: e7fa         	b	0x800099c <__udivmoddi4+0x1c8> @ imm = #-0xc
 80009a6: e9c6 4c00    	strd	r4, r12, [r6]
 80009aa: e7f8         	b	0x800099e <__udivmoddi4+0x1ca> @ imm = #-0x10
 80009ac: f1c7 0c20    	rsb.w	r12, r7, #0x20
 80009b0: 40bb         	lsls	r3, r7
 80009b2: fa22 f40c    	lsr.w	r4, r2, r12
 80009b6: 431c         	orrs	r4, r3
 80009b8: fa2e f10c    	lsr.w	r1, lr, r12
 80009bc: fa20 f30c    	lsr.w	r3, r0, r12
 80009c0: 40b8         	lsls	r0, r7
 80009c2: 4301         	orrs	r1, r0
 80009c4: ea4f 4914    	lsr.w	r9, r4, #0x10
 80009c8: fa0e f507    	lsl.w	r5, lr, r7
 80009cc: fbb3 f8f9    	udiv	r8, r3, r9
 80009d0: fa1f fe84    	uxth.w	lr, r4
 80009d4: fb09 3018    	mls	r0, r9, r8, r3
 80009d8: 0c0b         	lsrs	r3, r1, #0x10
 80009da: fb08 fa0e    	mul	r10, r8, lr
 80009de: ea43 4300    	orr.w	r3, r3, r0, lsl #16
 80009e2: 459a         	cmp	r10, r3
 80009e4: fa02 f207    	lsl.w	r2, r2, r7
 80009e8: d940         	bls	0x8000a6c <__udivmoddi4+0x298> @ imm = #0x80
 80009ea: 18e3         	adds	r3, r4, r3
 80009ec: f108 30ff    	add.w	r0, r8, #0xffffffff
 80009f0: d204         	bhs	0x80009fc <__udivmoddi4+0x228> @ imm = #0x8
 80009f2: 459a         	cmp	r10, r3
 80009f4: d902         	bls	0x80009fc <__udivmoddi4+0x228> @ imm = #0x4
 80009f6: f1a8 0002    	sub.w	r0, r8, #0x2
 80009fa: 4423         	add	r3, r4
 80009fc: eba3 030a    	sub.w	r3, r3, r10
 8000a00: b289         	uxth	r1, r1
 8000a02: fbb3 f8f9    	udiv	r8, r3, r9
 8000a06: fb09 3318    	mls	r3, r9, r8, r3
 8000a0a: fb08 fe0e    	mul	lr, r8, lr
 8000a0e: ea41 4103    	orr.w	r1, r1, r3, lsl #16
 8000a12: 458e         	cmp	lr, r1
 8000a14: d92c         	bls	0x8000a70 <__udivmoddi4+0x29c> @ imm = #0x58
 8000a16: 1861         	adds	r1, r4, r1
 8000a18: f108 33ff    	add.w	r3, r8, #0xffffffff
 8000a1c: d204         	bhs	0x8000a28 <__udivmoddi4+0x254> @ imm = #0x8
 8000a1e: 458e         	cmp	lr, r1
 8000a20: d902         	bls	0x8000a28 <__udivmoddi4+0x254> @ imm = #0x4
 8000a22: f1a8 0302    	sub.w	r3, r8, #0x2
 8000a26: 4421         	add	r1, r4
 8000a28: ea43 4000    	orr.w	r0, r3, r0, lsl #16
 8000a2c: fba0 9802    	umull	r9, r8, r0, r2
 8000a30: eba1 010e    	sub.w	r1, r1, lr
 8000a34: 4541         	cmp	r1, r8
 8000a36: 46ce         	mov	lr, r9
 8000a38: 4643         	mov	r3, r8
 8000a3a: d302         	blo	0x8000a42 <__udivmoddi4+0x26e> @ imm = #0x4
 8000a3c: d106         	bne	0x8000a4c <__udivmoddi4+0x278> @ imm = #0xc
 8000a3e: 454d         	cmp	r5, r9
 8000a40: d204         	bhs	0x8000a4c <__udivmoddi4+0x278> @ imm = #0x8
 8000a42: ebb9 0e02    	subs.w	lr, r9, r2
 8000a46: eb68 0304    	sbc.w	r3, r8, r4
 8000a4a: 3801         	subs	r0, #0x1
 8000a4c: 2e00         	cmp	r6, #0x0
 8000a4e: d0a6         	beq	0x800099e <__udivmoddi4+0x1ca> @ imm = #-0xb4
 8000a50: ebb5 020e    	subs.w	r2, r5, lr
 8000a54: eb61 0103    	sbc.w	r1, r1, r3
 8000a58: fa01 fc0c    	lsl.w	r12, r1, r12
 8000a5c: fa22 f307    	lsr.w	r3, r2, r7
 8000a60: ea4c 0303    	orr.w	r3, r12, r3
 8000a64: 40f9         	lsrs	r1, r7
 8000a66: e9c6 3100    	strd	r3, r1, [r6]
 8000a6a: e798         	b	0x800099e <__udivmoddi4+0x1ca> @ imm = #-0xd0
 8000a6c: 4640         	mov	r0, r8
 8000a6e: e7c5         	b	0x80009fc <__udivmoddi4+0x228> @ imm = #-0x76
 8000a70: 4643         	mov	r3, r8
 8000a72: e7d9         	b	0x8000a28 <__udivmoddi4+0x254> @ imm = #-0x4e

08000a74 <main>:
; int main(void) {
 8000a74: b590         	push	{r4, r7, lr}
 8000a76: b087         	sub	sp, #0x1c
 8000a78: af02         	add	r7, sp, #0x8
;     can_start(can_dev);
 8000a7a: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x8000ae8 <main+0x74>
 8000a7c: 681b         	ldr	r3, [r3]
 8000a7e: 4618         	mov	r0, r3
 8000a80: f00c ff20    	bl	0x800d8c4 <can_start>   @ imm = #0xce40
;     struct can_frame frame = {
 8000a84: 463b         	mov	r3, r7
 8000a86: 2200         	movs	r2, #0x0
 8000a88: 601a         	str	r2, [r3]
 8000a8a: 605a         	str	r2, [r3, #0x4]
 8000a8c: 609a         	str	r2, [r3, #0x8]
 8000a8e: 60da         	str	r2, [r3, #0xc]
 8000a90: 2318         	movs	r3, #0x18
 8000a92: 603b         	str	r3, [r7]
 8000a94: 2308         	movs	r3, #0x8
 8000a96: 713b         	strb	r3, [r7, #0x4]
 8000a98: 23ff         	movs	r3, #0xff
 8000a9a: 723b         	strb	r3, [r7, #0x8]
 8000a9c: 23ff         	movs	r3, #0xff
 8000a9e: 727b         	strb	r3, [r7, #0x9]
 8000aa0: 23ff         	movs	r3, #0xff
 8000aa2: 72bb         	strb	r3, [r7, #0xa]
 8000aa4: 23ff         	movs	r3, #0xff
 8000aa6: 72fb         	strb	r3, [r7, #0xb]
 8000aa8: 23ff         	movs	r3, #0xff
 8000aaa: 733b         	strb	r3, [r7, #0xc]
 8000aac: 23ff         	movs	r3, #0xff
 8000aae: 737b         	strb	r3, [r7, #0xd]
 8000ab0: 23ff         	movs	r3, #0xff
 8000ab2: 73bb         	strb	r3, [r7, #0xe]
 8000ab4: 23fc         	movs	r3, #0xfc
 8000ab6: 73fb         	strb	r3, [r7, #0xf]
;     can_send(can_dev, &frame, K_FOREVER, NULL, NULL);
 8000ab8: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8000ae8 <main+0x74>
 8000aba: 6818         	ldr	r0, [r3]
 8000abc: f04f 32ff    	mov.w	r2, #0xffffffff
 8000ac0: f04f 33ff    	mov.w	r3, #0xffffffff
 8000ac4: 4639         	mov	r1, r7
 8000ac6: 2400         	movs	r4, #0x0
 8000ac8: 9401         	str	r4, [sp, #0x4]
 8000aca: 2400         	movs	r4, #0x0
 8000acc: 9400         	str	r4, [sp]
 8000ace: f00c ff05    	bl	0x800d8dc <can_send>    @ imm = #0xce0a
;         k_sleep(K_FOREVER);
 8000ad2: f04f 32ff    	mov.w	r2, #0xffffffff
 8000ad6: f04f 33ff    	mov.w	r3, #0xffffffff
 8000ada: 4610         	mov	r0, r2
 8000adc: 4619         	mov	r1, r3
 8000ade: f00c fed3    	bl	0x800d888 <k_sleep>     @ imm = #0xcda6
;     while (1) {
 8000ae2: bf00         	nop
 8000ae4: e7f5         	b	0x8000ad2 <main+0x5e>   @ imm = #-0x16
 8000ae6: bf00         	nop

08000ae8 <$d>:
 8000ae8: 00 00 00 20  	.word	0x20000000

08000aec <linker_is_in_rodata>:
; {
 8000aec: b480         	push	{r7}
 8000aee: b083         	sub	sp, #0xc
 8000af0: af00         	add	r7, sp, #0x0
 8000af2: 6078         	str	r0, [r7, #0x4]
; 	return (((const char *)addr >= (const char *)RO_START) &&
 8000af4: 687b         	ldr	r3, [r7, #0x4]
 8000af6: 4a09         	ldr	r2, [pc, #0x24]         @ 0x8000b1c <linker_is_in_rodata+0x30>
 8000af8: 4293         	cmp	r3, r2
 8000afa: d305         	blo	0x8000b08 <linker_is_in_rodata+0x1c> @ imm = #0xa
 8000afc: 687b         	ldr	r3, [r7, #0x4]
 8000afe: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8000b20 <linker_is_in_rodata+0x34>
 8000b00: 4293         	cmp	r3, r2
 8000b02: d201         	bhs	0x8000b08 <linker_is_in_rodata+0x1c> @ imm = #0x2
 8000b04: 2301         	movs	r3, #0x1
 8000b06: e000         	b	0x8000b0a <linker_is_in_rodata+0x1e> @ imm = #0x0
 8000b08: 2300         	movs	r3, #0x0
 8000b0a: f003 0301    	and	r3, r3, #0x1
 8000b0e: b2db         	uxtb	r3, r3
; }
 8000b10: 4618         	mov	r0, r3
 8000b12: 370c         	adds	r7, #0xc
 8000b14: 46bd         	mov	sp, r7
 8000b16: bc80         	pop	{r7}
 8000b18: 4770         	bx	lr
 8000b1a: bf00         	nop

08000b1c <$d>:
 8000b1c: dc 44 01 08  	.word	0x080144dc
 8000b20: c4 69 01 08  	.word	0x080169c4

08000b24 <cbvprintf_package>:
; {
 8000b24: b580         	push	{r7, lr}
 8000b26: b0a4         	sub	sp, #0x90
 8000b28: af00         	add	r7, sp, #0x0
 8000b2a: 60f8         	str	r0, [r7, #0xc]
 8000b2c: 60b9         	str	r1, [r7, #0x8]
 8000b2e: 607a         	str	r2, [r7, #0x4]
 8000b30: 603b         	str	r3, [r7]
; 	uint8_t *buf0 = packaged;  /* buffer start (may be NULL) */
 8000b32: 68fb         	ldr	r3, [r7, #0xc]
 8000b34: 65fb         	str	r3, [r7, #0x5c]
; 	uintptr_t buf = (uintptr_t)buf0; /* current buffer position */
 8000b36: 6dfb         	ldr	r3, [r7, #0x5c]
 8000b38: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 	unsigned int s_idx = 0;    /* index into str_ptr_pos[] */
 8000b3c: 2300         	movs	r3, #0x0
 8000b3e: f8c7 3080    	str.w	r3, [r7, #0x80]
; 	unsigned int s_rw_cnt = 0; /* number of rw strings */
 8000b42: 2300         	movs	r3, #0x0
 8000b44: 67fb         	str	r3, [r7, #0x7c]
; 	unsigned int s_ro_cnt = 0; /* number of ro strings */
 8000b46: 2300         	movs	r3, #0x0
 8000b48: 67bb         	str	r3, [r7, #0x78]
; 	int arg_idx	      = -1; /* Argument index. Preincremented thus starting from -1.*/
 8000b4a: f04f 33ff    	mov.w	r3, #0xffffffff
 8000b4e: 677b         	str	r3, [r7, #0x74]
; 	bool parsing = false;
 8000b50: 2300         	movs	r3, #0x0
 8000b52: f887 306b    	strb.w	r3, [r7, #0x6b]
; 	bool rws_pos_en = !!(flags & CBPRINTF_PACKAGE_ADD_RW_STR_POS);
 8000b56: 687b         	ldr	r3, [r7, #0x4]
 8000b58: f003 0304    	and	r3, r3, #0x4
 8000b5c: 2b00         	cmp	r3, #0x0
 8000b5e: bf14         	ite	ne
 8000b60: 2301         	movne	r3, #0x1
 8000b62: 2300         	moveq	r3, #0x0
 8000b64: f887 305b    	strb.w	r3, [r7, #0x5b]
; 	int fros_cnt = 1 + Z_CBPRINTF_PACKAGE_FIRST_RO_STR_CNT_GET(flags);
 8000b68: 687b         	ldr	r3, [r7, #0x4]
 8000b6a: 08db         	lsrs	r3, r3, #0x3
 8000b6c: f003 0307    	and	r3, r3, #0x7
 8000b70: 3301         	adds	r3, #0x1
 8000b72: 667b         	str	r3, [r7, #0x64]
; 	bool is_str_arg = false;
 8000b74: 2300         	movs	r3, #0x0
 8000b76: f887 3063    	strb.w	r3, [r7, #0x63]
; 	union cbprintf_package_hdr *pkg_hdr = packaged;
 8000b7a: 68fb         	ldr	r3, [r7, #0xc]
 8000b7c: 657b         	str	r3, [r7, #0x54]
; 	if ((uintptr_t)packaged % sizeof(void *)) {
 8000b7e: 68fb         	ldr	r3, [r7, #0xc]
 8000b80: f003 0303    	and	r3, r3, #0x3
 8000b84: 2b00         	cmp	r3, #0x0
 8000b86: d002         	beq	0x8000b8e <cbvprintf_package+0x6a> @ imm = #0x4
; 		return -EFAULT;
 8000b88: f06f 030d    	mvn	r3, #0xd
 8000b8c: e3a2         	b	0x80012d4 <cbvprintf_package+0x7b0> @ imm = #0x744
; 	buf += sizeof(*pkg_hdr);
 8000b8e: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8000b92: 3304         	adds	r3, #0x4
 8000b94: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 	if (buf0 == NULL) {
 8000b98: 6dfb         	ldr	r3, [r7, #0x5c]
 8000b9a: 2b00         	cmp	r3, #0x0
 8000b9c: d10d         	bne	0x8000bba <cbvprintf_package+0x96> @ imm = #0x1a
; 		buf += len % CBPRINTF_PACKAGE_ALIGNMENT;
 8000b9e: 68bb         	ldr	r3, [r7, #0x8]
 8000ba0: f003 0307    	and	r3, r3, #0x7
 8000ba4: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8000ba8: 4413         	add	r3, r2
 8000baa: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 		len = CBPRINTF_PACKAGE_ALIGNMENT - (len % CBPRINTF_PACKAGE_ALIGNMENT);
 8000bae: 68bb         	ldr	r3, [r7, #0x8]
 8000bb0: f003 0307    	and	r3, r3, #0x7
 8000bb4: f1c3 0308    	rsb.w	r3, r3, #0x8
 8000bb8: 60bb         	str	r3, [r7, #0x8]
; 	if ((buf0 != NULL) && (BUF_OFFSET + sizeof(char *)) > len) {
 8000bba: 6dfb         	ldr	r3, [r7, #0x5c]
 8000bbc: 2b00         	cmp	r3, #0x0
 8000bbe: d00a         	beq	0x8000bd6 <cbvprintf_package+0xb2> @ imm = #0x14
 8000bc0: 6dfb         	ldr	r3, [r7, #0x5c]
 8000bc2: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8000bc6: 1ad3         	subs	r3, r2, r3
 8000bc8: 3304         	adds	r3, #0x4
 8000bca: 68ba         	ldr	r2, [r7, #0x8]
 8000bcc: 429a         	cmp	r2, r3
 8000bce: d202         	bhs	0x8000bd6 <cbvprintf_package+0xb2> @ imm = #0x4
; 		return -ENOSPC;
 8000bd0: f06f 031b    	mvn	r3, #0x1b
 8000bd4: e37e         	b	0x80012d4 <cbvprintf_package+0x7b0> @ imm = #0x6fc
; 	s = fmt;
 8000bd6: 683b         	ldr	r3, [r7]
 8000bd8: 66fb         	str	r3, [r7, #0x6c]
; 	--fmt;
 8000bda: 683b         	ldr	r3, [r7]
 8000bdc: 3b01         	subs	r3, #0x1
 8000bde: 603b         	str	r3, [r7]
; 	align = VA_STACK_ALIGN(char *);
 8000be0: 2304         	movs	r3, #0x4
 8000be2: f8c7 3084    	str.w	r3, [r7, #0x84]
; 	size = sizeof(char *);
 8000be6: 2304         	movs	r3, #0x4
 8000be8: f8c7 3088    	str.w	r3, [r7, #0x88]
; 	goto process_string;
 8000bec: e197         	b	0x8000f1e <cbvprintf_package+0x3fa> @ imm = #0x32e
; 			if (!parsing) {
 8000bee: f897 306b    	ldrb.w	r3, [r7, #0x6b]
 8000bf2: f083 0301    	eor	r3, r3, #0x1
 8000bf6: b2db         	uxtb	r3, r3
 8000bf8: 2b00         	cmp	r3, #0x0
 8000bfa: d011         	beq	0x8000c20 <cbvprintf_package+0xfc> @ imm = #0x22
; 				if (*fmt == '%') {
 8000bfc: 683b         	ldr	r3, [r7]
 8000bfe: 781b         	ldrb	r3, [r3]
 8000c00: 2b25         	cmp	r3, #0x25
 8000c02: f040 8278    	bne.w	0x80010f6 <cbvprintf_package+0x5d2> @ imm = #0x4f0
; 					parsing = true;
 8000c06: 2301         	movs	r3, #0x1
 8000c08: f887 306b    	strb.w	r3, [r7, #0x6b]
; 					arg_idx++;
 8000c0c: 6f7b         	ldr	r3, [r7, #0x74]
 8000c0e: 3301         	adds	r3, #0x1
 8000c10: 677b         	str	r3, [r7, #0x74]
; 					align = VA_STACK_ALIGN(int);
 8000c12: 2304         	movs	r3, #0x4
 8000c14: f8c7 3084    	str.w	r3, [r7, #0x84]
; 					size = sizeof(int);
 8000c18: 2304         	movs	r3, #0x4
 8000c1a: f8c7 3088    	str.w	r3, [r7, #0x88]
; 				continue;
 8000c1e: e26a         	b	0x80010f6 <cbvprintf_package+0x5d2> @ imm = #0x4d4
; 			switch (*fmt) {
 8000c20: 683b         	ldr	r3, [r7]
 8000c22: 781b         	ldrb	r3, [r3]
 8000c24: 2b7a         	cmp	r3, #0x7a
 8000c26: f300 8149    	bgt.w	0x8000ebc <cbvprintf_package+0x398> @ imm = #0x292
 8000c2a: 2b4c         	cmp	r3, #0x4c
 8000c2c: da11         	bge	0x8000c52 <cbvprintf_package+0x12e> @ imm = #0x22
 8000c2e: 2b47         	cmp	r3, #0x47
 8000c30: f300 8144    	bgt.w	0x8000ebc <cbvprintf_package+0x398> @ imm = #0x288
 8000c34: 2b2a         	cmp	r3, #0x2a
 8000c36: da71         	bge	0x8000d1c <cbvprintf_package+0x1f8> @ imm = #0xe2
 8000c38: 2b25         	cmp	r3, #0x25
 8000c3a: f000 8092    	beq.w	0x8000d62 <cbvprintf_package+0x23e> @ imm = #0x124
 8000c3e: 2b25         	cmp	r3, #0x25
 8000c40: f300 813c    	bgt.w	0x8000ebc <cbvprintf_package+0x398> @ imm = #0x278
 8000c44: 2b20         	cmp	r3, #0x20
 8000c46: f000 8258    	beq.w	0x80010fa <cbvprintf_package+0x5d6> @ imm = #0x4b0
 8000c4a: 2b23         	cmp	r3, #0x23
 8000c4c: f000 8255    	beq.w	0x80010fa <cbvprintf_package+0x5d6> @ imm = #0x4aa
 8000c50: e134         	b	0x8000ebc <cbvprintf_package+0x398> @ imm = #0x268
 8000c52: 3b4c         	subs	r3, #0x4c
 8000c54: 2b2e         	cmp	r3, #0x2e
 8000c56: f200 8131    	bhi.w	0x8000ebc <cbvprintf_package+0x398> @ imm = #0x262
 8000c5a: a201         	adr	r2, #4 <cbvprintf_package+0x13b>
 8000c5c: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]

08000c60 <$d>:
 8000c60: fb 10 00 08  	.word	0x080010fb
 8000c64: bd 0e 00 08  	.word	0x08000ebd
 8000c68: bd 0e 00 08  	.word	0x08000ebd
 8000c6c: bd 0e 00 08  	.word	0x08000ebd
 8000c70: bd 0e 00 08  	.word	0x08000ebd
 8000c74: bd 0e 00 08  	.word	0x08000ebd
 8000c78: bd 0e 00 08  	.word	0x08000ebd
 8000c7c: bd 0e 00 08  	.word	0x08000ebd
 8000c80: bd 0e 00 08  	.word	0x08000ebd
 8000c84: bd 0e 00 08  	.word	0x08000ebd
 8000c88: bd 0e 00 08  	.word	0x08000ebd
 8000c8c: bd 0e 00 08  	.word	0x08000ebd
 8000c90: 9b 0d 00 08  	.word	0x08000d9b
 8000c94: bd 0e 00 08  	.word	0x08000ebd
 8000c98: bd 0e 00 08  	.word	0x08000ebd
 8000c9c: bd 0e 00 08  	.word	0x08000ebd
 8000ca0: bd 0e 00 08  	.word	0x08000ebd
 8000ca4: bd 0e 00 08  	.word	0x08000ebd
 8000ca8: bd 0e 00 08  	.word	0x08000ebd
 8000cac: bd 0e 00 08  	.word	0x08000ebd
 8000cb0: bd 0e 00 08  	.word	0x08000ebd
 8000cb4: eb 0d 00 08  	.word	0x08000deb
 8000cb8: bd 0e 00 08  	.word	0x08000ebd
 8000cbc: 9b 0d 00 08  	.word	0x08000d9b
 8000cc0: 9b 0d 00 08  	.word	0x08000d9b
 8000cc4: eb 0d 00 08  	.word	0x08000deb
 8000cc8: eb 0d 00 08  	.word	0x08000deb
 8000ccc: eb 0d 00 08  	.word	0x08000deb
 8000cd0: fb 10 00 08  	.word	0x080010fb
 8000cd4: 9b 0d 00 08  	.word	0x08000d9b
 8000cd8: 71 0d 00 08  	.word	0x08000d71
 8000cdc: bd 0e 00 08  	.word	0x08000ebd
 8000ce0: fb 10 00 08  	.word	0x080010fb
 8000ce4: bd 0e 00 08  	.word	0x08000ebd
 8000ce8: d7 0d 00 08  	.word	0x08000dd7
 8000cec: 9b 0d 00 08  	.word	0x08000d9b
 8000cf0: d7 0d 00 08  	.word	0x08000dd7
 8000cf4: bd 0e 00 08  	.word	0x08000ebd
 8000cf8: bd 0e 00 08  	.word	0x08000ebd
 8000cfc: d1 0d 00 08  	.word	0x08000dd1
 8000d00: 8d 0d 00 08  	.word	0x08000d8d
 8000d04: 9b 0d 00 08  	.word	0x08000d9b
 8000d08: bd 0e 00 08  	.word	0x08000ebd
 8000d0c: bd 0e 00 08  	.word	0x08000ebd
 8000d10: 9b 0d 00 08  	.word	0x08000d9b
 8000d14: bd 0e 00 08  	.word	0x08000ebd
 8000d18: 7f 0d 00 08  	.word	0x08000d7f

08000d1c <$t>:
 8000d1c: 3b2a         	subs	r3, #0x2a
 8000d1e: 2201         	movs	r2, #0x1
 8000d20: fa02 f303    	lsl.w	r3, r2, r3
 8000d24: f64f 72da    	movw	r2, #0xffda
 8000d28: 401a         	ands	r2, r3
 8000d2a: 2a00         	cmp	r2, #0x0
 8000d2c: bf14         	ite	ne
 8000d2e: 2201         	movne	r2, #0x1
 8000d30: 2200         	moveq	r2, #0x0
 8000d32: b2d2         	uxtb	r2, r2
 8000d34: 2a00         	cmp	r2, #0x0
 8000d36: f040 81e0    	bne.w	0x80010fa <cbvprintf_package+0x5d6> @ imm = #0x3c0
 8000d3a: f003 5262    	and	r2, r3, #0x38800000
 8000d3e: 2a00         	cmp	r2, #0x0
 8000d40: bf14         	ite	ne
 8000d42: 2201         	movne	r2, #0x1
 8000d44: 2200         	moveq	r2, #0x0
 8000d46: b2d2         	uxtb	r2, r2
 8000d48: 2a00         	cmp	r2, #0x0
 8000d4a: d14e         	bne	0x8000dea <cbvprintf_package+0x2c6> @ imm = #0x9c
 8000d4c: f003 0301    	and	r3, r3, #0x1
 8000d50: 2b00         	cmp	r3, #0x0
 8000d52: bf14         	ite	ne
 8000d54: 2301         	movne	r3, #0x1
 8000d56: 2300         	moveq	r3, #0x0
 8000d58: b2db         	uxtb	r3, r3
 8000d5a: 2b00         	cmp	r3, #0x0
 8000d5c: f040 80b2    	bne.w	0x8000ec4 <cbvprintf_package+0x3a0> @ imm = #0x164
 8000d60: e0ac         	b	0x8000ebc <cbvprintf_package+0x398> @ imm = #0x158
; 				parsing = false;
 8000d62: 2300         	movs	r3, #0x0
 8000d64: f887 306b    	strb.w	r3, [r7, #0x6b]
; 				arg_idx--;
 8000d68: 6f7b         	ldr	r3, [r7, #0x74]
 8000d6a: 3b01         	subs	r3, #0x1
 8000d6c: 677b         	str	r3, [r7, #0x74]
; 				continue;
 8000d6e: e1c5         	b	0x80010fc <cbvprintf_package+0x5d8> @ imm = #0x38a
; 				align = VA_STACK_ALIGN(intmax_t);
 8000d70: 2308         	movs	r3, #0x8
 8000d72: f8c7 3084    	str.w	r3, [r7, #0x84]
; 				size = sizeof(intmax_t);
 8000d76: 2308         	movs	r3, #0x8
 8000d78: f8c7 3088    	str.w	r3, [r7, #0x88]
; 				continue;
 8000d7c: e1be         	b	0x80010fc <cbvprintf_package+0x5d8> @ imm = #0x37c
; 				align = VA_STACK_ALIGN(size_t);
 8000d7e: 2304         	movs	r3, #0x4
 8000d80: f8c7 3084    	str.w	r3, [r7, #0x84]
; 				size = sizeof(size_t);
 8000d84: 2304         	movs	r3, #0x4
 8000d86: f8c7 3088    	str.w	r3, [r7, #0x88]
; 				continue;
 8000d8a: e1b7         	b	0x80010fc <cbvprintf_package+0x5d8> @ imm = #0x36e
; 				align = VA_STACK_ALIGN(ptrdiff_t);
 8000d8c: 2304         	movs	r3, #0x4
 8000d8e: f8c7 3084    	str.w	r3, [r7, #0x84]
; 				size = sizeof(ptrdiff_t);
 8000d92: 2304         	movs	r3, #0x4
 8000d94: f8c7 3088    	str.w	r3, [r7, #0x88]
; 				continue;
 8000d98: e1b0         	b	0x80010fc <cbvprintf_package+0x5d8> @ imm = #0x360
; 				if (fmt[-1] == 'l') {
 8000d9a: 683b         	ldr	r3, [r7]
 8000d9c: 3b01         	subs	r3, #0x1
 8000d9e: 781b         	ldrb	r3, [r3]
 8000da0: 2b6c         	cmp	r3, #0x6c
 8000da2: d111         	bne	0x8000dc8 <cbvprintf_package+0x2a4> @ imm = #0x22
; 					if (fmt[-2] == 'l') {
 8000da4: 683b         	ldr	r3, [r7]
 8000da6: 3b02         	subs	r3, #0x2
 8000da8: 781b         	ldrb	r3, [r3]
 8000daa: 2b6c         	cmp	r3, #0x6c
 8000dac: d106         	bne	0x8000dbc <cbvprintf_package+0x298> @ imm = #0xc
; 						align = VA_STACK_ALIGN(long long);
 8000dae: 2308         	movs	r3, #0x8
 8000db0: f8c7 3084    	str.w	r3, [r7, #0x84]
; 						size = sizeof(long long);
 8000db4: 2308         	movs	r3, #0x8
 8000db6: f8c7 3088    	str.w	r3, [r7, #0x88]
 8000dba: e005         	b	0x8000dc8 <cbvprintf_package+0x2a4> @ imm = #0xa
; 						align = VA_STACK_ALIGN(long);
 8000dbc: 2304         	movs	r3, #0x4
 8000dbe: f8c7 3084    	str.w	r3, [r7, #0x84]
; 						size = sizeof(long);
 8000dc2: 2304         	movs	r3, #0x4
 8000dc4: f8c7 3088    	str.w	r3, [r7, #0x88]
; 				parsing = false;
 8000dc8: 2300         	movs	r3, #0x0
 8000dca: f887 306b    	strb.w	r3, [r7, #0x6b]
; 				break;
 8000dce: e07a         	b	0x8000ec6 <cbvprintf_package+0x3a2> @ imm = #0xf4
; 				is_str_arg = true;
 8000dd0: 2301         	movs	r3, #0x1
 8000dd2: f887 3063    	strb.w	r3, [r7, #0x63]
; 				align = VA_STACK_ALIGN(void *);
 8000dd6: 2304         	movs	r3, #0x4
 8000dd8: f8c7 3084    	str.w	r3, [r7, #0x84]
; 				size = sizeof(void *);
 8000ddc: 2304         	movs	r3, #0x4
 8000dde: f8c7 3088    	str.w	r3, [r7, #0x88]
; 				parsing = false;
 8000de2: 2300         	movs	r3, #0x0
 8000de4: f887 306b    	strb.w	r3, [r7, #0x6b]
; 				break;
 8000de8: e06d         	b	0x8000ec6 <cbvprintf_package+0x3a2> @ imm = #0xda
; 				if (fmt[-1] == 'L') {
 8000dea: 683b         	ldr	r3, [r7]
 8000dec: 3b01         	subs	r3, #0x1
 8000dee: 781b         	ldrb	r3, [r3]
 8000df0: 2b4c         	cmp	r3, #0x4c
 8000df2: d113         	bne	0x8000e1c <cbvprintf_package+0x2f8> @ imm = #0x26
; 					v.ld = va_arg(ap, long double);
 8000df4: f8d7 3098    	ldr.w	r3, [r7, #0x98]
 8000df8: 3307         	adds	r3, #0x7
 8000dfa: f023 0307    	bic	r3, r3, #0x7
 8000dfe: f103 0208    	add.w	r2, r3, #0x8
 8000e02: f8c7 2098    	str.w	r2, [r7, #0x98]
 8000e06: e9d3 2300    	ldrd	r2, r3, [r3]
 8000e0a: e9c7 2306    	strd	r2, r3, [r7, #24]
; 					align = VA_STACK_ALIGN(long double);
 8000e0e: 2308         	movs	r3, #0x8
 8000e10: f8c7 3084    	str.w	r3, [r7, #0x84]
; 					size = sizeof(long double);
 8000e14: 2308         	movs	r3, #0x8
 8000e16: f8c7 3088    	str.w	r3, [r7, #0x88]
 8000e1a: e012         	b	0x8000e42 <cbvprintf_package+0x31e> @ imm = #0x24
; 					v.d = va_arg(ap, double);
 8000e1c: f8d7 3098    	ldr.w	r3, [r7, #0x98]
 8000e20: 3307         	adds	r3, #0x7
 8000e22: f023 0307    	bic	r3, r3, #0x7
 8000e26: f103 0208    	add.w	r2, r3, #0x8
 8000e2a: f8c7 2098    	str.w	r2, [r7, #0x98]
 8000e2e: e9d3 2300    	ldrd	r2, r3, [r3]
 8000e32: e9c7 2306    	strd	r2, r3, [r7, #24]
; 					align = VA_STACK_ALIGN(double);
 8000e36: 2308         	movs	r3, #0x8
 8000e38: f8c7 3084    	str.w	r3, [r7, #0x84]
; 					size = sizeof(double);
 8000e3c: 2308         	movs	r3, #0x8
 8000e3e: f8c7 3088    	str.w	r3, [r7, #0x88]
; 				buf = ROUND_UP(buf, align);
 8000e42: f8d7 2084    	ldr.w	r2, [r7, #0x84]
 8000e46: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8000e4a: 4413         	add	r3, r2
 8000e4c: 1e5a         	subs	r2, r3, #0x1
 8000e4e: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8000e52: fbb2 f2f3    	udiv	r2, r2, r3
 8000e56: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8000e5a: fb02 f303    	mul	r3, r2, r3
 8000e5e: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 				if (buf0 != NULL) {
 8000e62: 6dfb         	ldr	r3, [r7, #0x5c]
 8000e64: 2b00         	cmp	r3, #0x0
 8000e66: d01e         	beq	0x8000ea6 <cbvprintf_package+0x382> @ imm = #0x3c
; 					if (BUF_OFFSET + size > len) {
 8000e68: 6dfb         	ldr	r3, [r7, #0x5c]
 8000e6a: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8000e6e: 1ad2         	subs	r2, r2, r3
 8000e70: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 8000e74: 4413         	add	r3, r2
 8000e76: 68ba         	ldr	r2, [r7, #0x8]
 8000e78: 429a         	cmp	r2, r3
 8000e7a: d202         	bhs	0x8000e82 <cbvprintf_package+0x35e> @ imm = #0x4
; 						return -ENOSPC;
 8000e7c: f06f 031b    	mvn	r3, #0x1b
 8000e80: e228         	b	0x80012d4 <cbvprintf_package+0x7b0> @ imm = #0x450
; 					} else if (fmt[-1] == 'L') {
 8000e82: 683b         	ldr	r3, [r7]
 8000e84: 3b01         	subs	r3, #0x1
 8000e86: 781b         	ldrb	r3, [r3]
 8000e88: 2b4c         	cmp	r3, #0x4c
 8000e8a: d106         	bne	0x8000e9a <cbvprintf_package+0x376> @ imm = #0xc
; 						*(long double *)buf = v.ld;
 8000e8c: f8d7 108c    	ldr.w	r1, [r7, #0x8c]
 8000e90: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 8000e94: e9c1 2300    	strd	r2, r3, [r1]
 8000e98: e005         	b	0x8000ea6 <cbvprintf_package+0x382> @ imm = #0xa
; 						*(double *)buf = v.d;
 8000e9a: f8d7 108c    	ldr.w	r1, [r7, #0x8c]
 8000e9e: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 8000ea2: e9c1 2300    	strd	r2, r3, [r1]
; 				buf += size;
 8000ea6: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8000eaa: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 8000eae: 4413         	add	r3, r2
 8000eb0: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 				parsing = false;
 8000eb4: 2300         	movs	r3, #0x0
 8000eb6: f887 306b    	strb.w	r3, [r7, #0x6b]
 8000eba: e11f         	b	0x80010fc <cbvprintf_package+0x5d8> @ imm = #0x23e
; 				parsing = false;
 8000ebc: 2300         	movs	r3, #0x0
 8000ebe: f887 306b    	strb.w	r3, [r7, #0x6b]
; 				continue;
 8000ec2: e11b         	b	0x80010fc <cbvprintf_package+0x5d8> @ imm = #0x236
; 				break;
 8000ec4: bf00         	nop
; 		buf = ROUND_UP(buf, align);
 8000ec6: f8d7 2084    	ldr.w	r2, [r7, #0x84]
 8000eca: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8000ece: 4413         	add	r3, r2
 8000ed0: 1e5a         	subs	r2, r3, #0x1
 8000ed2: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8000ed6: fbb2 f2f3    	udiv	r2, r2, r3
 8000eda: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8000ede: fb02 f303    	mul	r3, r2, r3
 8000ee2: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 		if ((buf0 != NULL) && (BUF_OFFSET + size) > len) {
 8000ee6: 6dfb         	ldr	r3, [r7, #0x5c]
 8000ee8: 2b00         	cmp	r3, #0x0
 8000eea: d00c         	beq	0x8000f06 <cbvprintf_package+0x3e2> @ imm = #0x18
 8000eec: 6dfb         	ldr	r3, [r7, #0x5c]
 8000eee: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8000ef2: 1ad2         	subs	r2, r2, r3
 8000ef4: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 8000ef8: 4413         	add	r3, r2
 8000efa: 68ba         	ldr	r2, [r7, #0x8]
 8000efc: 429a         	cmp	r2, r3
 8000efe: d202         	bhs	0x8000f06 <cbvprintf_package+0x3e2> @ imm = #0x4
; 			return -ENOSPC;
 8000f00: f06f 031b    	mvn	r3, #0x1b
 8000f04: e1e6         	b	0x80012d4 <cbvprintf_package+0x7b0> @ imm = #0x3cc
; 		if (is_str_arg) {
 8000f06: f897 3063    	ldrb.w	r3, [r7, #0x63]
 8000f0a: 2b00         	cmp	r3, #0x0
 8000f0c: f000 80a0    	beq.w	0x8001050 <cbvprintf_package+0x52c> @ imm = #0x140
; 			s = va_arg(ap, char *);
 8000f10: f8d7 3098    	ldr.w	r3, [r7, #0x98]
 8000f14: 1d1a         	adds	r2, r3, #0x4
 8000f16: f8c7 2098    	str.w	r2, [r7, #0x98]
 8000f1a: 681b         	ldr	r3, [r3]
 8000f1c: 66fb         	str	r3, [r7, #0x6c]
; 			if (buf0 != NULL) {
 8000f1e: 6dfb         	ldr	r3, [r7, #0x5c]
 8000f20: 2b00         	cmp	r3, #0x0
 8000f22: d003         	beq	0x8000f2c <cbvprintf_package+0x408> @ imm = #0x6
; 				*(const char **)buf = s;
 8000f24: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8000f28: 6efa         	ldr	r2, [r7, #0x6c]
 8000f2a: 601a         	str	r2, [r3]
; 			bool is_ro = (fros_cnt-- > 0) ? true : ptr_in_rodata(s);
 8000f2c: 6e7b         	ldr	r3, [r7, #0x64]
 8000f2e: 1e5a         	subs	r2, r3, #0x1
 8000f30: 667a         	str	r2, [r7, #0x64]
 8000f32: 2b00         	cmp	r3, #0x0
 8000f34: dc05         	bgt	0x8000f42 <cbvprintf_package+0x41e> @ imm = #0xa
 8000f36: 6ef8         	ldr	r0, [r7, #0x6c]
 8000f38: f00c ff6e    	bl	0x800de18 <ptr_in_rodata> @ imm = #0xcedc
 8000f3c: 4603         	mov	r3, r0
 8000f3e: 2b00         	cmp	r3, #0x0
 8000f40: d001         	beq	0x8000f46 <cbvprintf_package+0x422> @ imm = #0x2
 8000f42: 2301         	movs	r3, #0x1
 8000f44: e000         	b	0x8000f48 <cbvprintf_package+0x424> @ imm = #0x0
 8000f46: 2300         	movs	r3, #0x0
 8000f48: f887 3053    	strb.w	r3, [r7, #0x53]
; 			bool do_ro = !!(flags & CBPRINTF_PACKAGE_ADD_RO_STR_POS);
 8000f4c: 687b         	ldr	r3, [r7, #0x4]
 8000f4e: f003 0302    	and	r3, r3, #0x2
 8000f52: 2b00         	cmp	r3, #0x0
 8000f54: bf14         	ite	ne
 8000f56: 2301         	movne	r3, #0x1
 8000f58: 2300         	moveq	r3, #0x0
 8000f5a: f887 3052    	strb.w	r3, [r7, #0x52]
; 			if (is_ro && !do_ro) {
 8000f5e: f897 3053    	ldrb.w	r3, [r7, #0x53]
 8000f62: 2b00         	cmp	r3, #0x0
 8000f64: d006         	beq	0x8000f74 <cbvprintf_package+0x450> @ imm = #0xc
 8000f66: f897 3052    	ldrb.w	r3, [r7, #0x52]
 8000f6a: f083 0301    	eor	r3, r3, #0x1
 8000f6e: b2db         	uxtb	r3, r3
 8000f70: 2b00         	cmp	r3, #0x0
 8000f72: d164         	bne	0x800103e <cbvprintf_package+0x51a> @ imm = #0xc8
; 				uint32_t s_ptr_idx = BUF_OFFSET / sizeof(int);
 8000f74: 6dfb         	ldr	r3, [r7, #0x5c]
 8000f76: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8000f7a: 1ad3         	subs	r3, r2, r3
 8000f7c: 089b         	lsrs	r3, r3, #0x2
 8000f7e: 64fb         	str	r3, [r7, #0x4c]
; 				if (do_ro && s_ptr_idx > STR_POS_MASK) {
 8000f80: f897 3052    	ldrb.w	r3, [r7, #0x52]
 8000f84: 2b00         	cmp	r3, #0x0
 8000f86: d005         	beq	0x8000f94 <cbvprintf_package+0x470> @ imm = #0xa
 8000f88: 6cfb         	ldr	r3, [r7, #0x4c]
 8000f8a: 2b7f         	cmp	r3, #0x7f
 8000f8c: d902         	bls	0x8000f94 <cbvprintf_package+0x470> @ imm = #0x4
; 					return -EINVAL;
 8000f8e: f06f 0315    	mvn	r3, #0x15
 8000f92: e19f         	b	0x80012d4 <cbvprintf_package+0x7b0> @ imm = #0x33e
; 				if (s_idx >= ARRAY_SIZE(str_ptr_pos)) {
 8000f94: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8000f98: 2b0f         	cmp	r3, #0xf
 8000f9a: d902         	bls	0x8000fa2 <cbvprintf_package+0x47e> @ imm = #0x4
; 					return -EINVAL;
 8000f9c: f06f 0315    	mvn	r3, #0x15
 8000fa0: e198         	b	0x80012d4 <cbvprintf_package+0x7b0> @ imm = #0x330
; 				if (buf0 != NULL) {
 8000fa2: 6dfb         	ldr	r3, [r7, #0x5c]
 8000fa4: 2b00         	cmp	r3, #0x0
 8000fa6: d02d         	beq	0x8001004 <cbvprintf_package+0x4e0> @ imm = #0x5a
; 					str_ptr_pos[s_idx] = s_ptr_idx;
 8000fa8: 6cfb         	ldr	r3, [r7, #0x4c]
 8000faa: b2d9         	uxtb	r1, r3
 8000fac: f107 0230    	add.w	r2, r7, #0x30
 8000fb0: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8000fb4: 4413         	add	r3, r2
 8000fb6: 460a         	mov	r2, r1
 8000fb8: 701a         	strb	r2, [r3]
; 					str_ptr_arg[s_idx] = arg_idx;
 8000fba: 6f7b         	ldr	r3, [r7, #0x74]
 8000fbc: b2d9         	uxtb	r1, r3
 8000fbe: f107 0220    	add.w	r2, r7, #0x20
 8000fc2: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8000fc6: 4413         	add	r3, r2
 8000fc8: 460a         	mov	r2, r1
 8000fca: 701a         	strb	r2, [r3]
; 					if (is_ro) {
 8000fcc: f897 3053    	ldrb.w	r3, [r7, #0x53]
 8000fd0: 2b00         	cmp	r3, #0x0
 8000fd2: d013         	beq	0x8000ffc <cbvprintf_package+0x4d8> @ imm = #0x26
; 						str_ptr_pos[s_idx] |= STR_POS_RO_FLAG;
 8000fd4: f107 0230    	add.w	r2, r7, #0x30
 8000fd8: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8000fdc: 4413         	add	r3, r2
 8000fde: 781b         	ldrb	r3, [r3]
 8000fe0: f063 037f    	orn	r3, r3, #0x7f
 8000fe4: b2d9         	uxtb	r1, r3
 8000fe6: f107 0230    	add.w	r2, r7, #0x30
 8000fea: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8000fee: 4413         	add	r3, r2
 8000ff0: 460a         	mov	r2, r1
 8000ff2: 701a         	strb	r2, [r3]
; 						s_ro_cnt++;
 8000ff4: 6fbb         	ldr	r3, [r7, #0x78]
 8000ff6: 3301         	adds	r3, #0x1
 8000ff8: 67bb         	str	r3, [r7, #0x78]
 8000ffa: e01b         	b	0x8001034 <cbvprintf_package+0x510> @ imm = #0x36
; 						s_rw_cnt++;
 8000ffc: 6ffb         	ldr	r3, [r7, #0x7c]
 8000ffe: 3301         	adds	r3, #0x1
 8001000: 67fb         	str	r3, [r7, #0x7c]
 8001002: e017         	b	0x8001034 <cbvprintf_package+0x510> @ imm = #0x2e
; 				} else if (is_ro) {
 8001004: f897 3053    	ldrb.w	r3, [r7, #0x53]
 8001008: 2b00         	cmp	r3, #0x0
 800100a: d003         	beq	0x8001014 <cbvprintf_package+0x4f0> @ imm = #0x6
; 					len += 1;
 800100c: 68bb         	ldr	r3, [r7, #0x8]
 800100e: 3301         	adds	r3, #0x1
 8001010: 60bb         	str	r3, [r7, #0x8]
 8001012: e00f         	b	0x8001034 <cbvprintf_package+0x510> @ imm = #0x1e
; 				} else if (rws_pos_en) {
 8001014: f897 305b    	ldrb.w	r3, [r7, #0x5b]
 8001018: 2b00         	cmp	r3, #0x0
 800101a: d003         	beq	0x8001024 <cbvprintf_package+0x500> @ imm = #0x6
; 					len += 2;
 800101c: 68bb         	ldr	r3, [r7, #0x8]
 800101e: 3302         	adds	r3, #0x2
 8001020: 60bb         	str	r3, [r7, #0x8]
 8001022: e007         	b	0x8001034 <cbvprintf_package+0x510> @ imm = #0xe
; 					len += strlen(s) + 1 + 1;
 8001024: 6ef8         	ldr	r0, [r7, #0x6c]
 8001026: f7ff fbcd    	bl	0x80007c4 <strlen>      @ imm = #-0x866
 800102a: 4602         	mov	r2, r0
 800102c: 68bb         	ldr	r3, [r7, #0x8]
 800102e: 4413         	add	r3, r2
 8001030: 3302         	adds	r3, #0x2
 8001032: 60bb         	str	r3, [r7, #0x8]
; 				s_idx++;
 8001034: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8001038: 3301         	adds	r3, #0x1
 800103a: f8c7 3080    	str.w	r3, [r7, #0x80]
; 			buf += sizeof(char *);
 800103e: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8001042: 3304         	adds	r3, #0x4
 8001044: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 			is_str_arg = false;
 8001048: 2300         	movs	r3, #0x0
 800104a: f887 3063    	strb.w	r3, [r7, #0x63]
 800104e: e055         	b	0x80010fc <cbvprintf_package+0x5d8> @ imm = #0xaa
; 		} else if (size == sizeof(int)) {
 8001050: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 8001054: 2b04         	cmp	r3, #0x4
 8001056: d113         	bne	0x8001080 <cbvprintf_package+0x55c> @ imm = #0x26
; 			int v = va_arg(ap, int);
 8001058: f8d7 3098    	ldr.w	r3, [r7, #0x98]
 800105c: 1d1a         	adds	r2, r3, #0x4
 800105e: f8c7 2098    	str.w	r2, [r7, #0x98]
 8001062: 681b         	ldr	r3, [r3]
 8001064: 647b         	str	r3, [r7, #0x44]
; 			if (buf0 != NULL) {
 8001066: 6dfb         	ldr	r3, [r7, #0x5c]
 8001068: 2b00         	cmp	r3, #0x0
 800106a: d003         	beq	0x8001074 <cbvprintf_package+0x550> @ imm = #0x6
; 				*(int *)buf = v;
 800106c: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8001070: 6c7a         	ldr	r2, [r7, #0x44]
 8001072: 601a         	str	r2, [r3]
; 			buf += sizeof(int);
 8001074: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8001078: 3304         	adds	r3, #0x4
 800107a: f8c7 308c    	str.w	r3, [r7, #0x8c]
 800107e: e03d         	b	0x80010fc <cbvprintf_package+0x5d8> @ imm = #0x7a
; 		} else if (size == sizeof(long)) {
 8001080: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 8001084: 2b04         	cmp	r3, #0x4
 8001086: d113         	bne	0x80010b0 <cbvprintf_package+0x58c> @ imm = #0x26
; 			long v = va_arg(ap, long);
 8001088: f8d7 3098    	ldr.w	r3, [r7, #0x98]
 800108c: 1d1a         	adds	r2, r3, #0x4
 800108e: f8c7 2098    	str.w	r2, [r7, #0x98]
 8001092: 681b         	ldr	r3, [r3]
 8001094: 64bb         	str	r3, [r7, #0x48]
; 			if (buf0 != NULL) {
 8001096: 6dfb         	ldr	r3, [r7, #0x5c]
 8001098: 2b00         	cmp	r3, #0x0
 800109a: d003         	beq	0x80010a4 <cbvprintf_package+0x580> @ imm = #0x6
; 				*(long *)buf = v;
 800109c: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 80010a0: 6cba         	ldr	r2, [r7, #0x48]
 80010a2: 601a         	str	r2, [r3]
; 			buf += sizeof(long);
 80010a4: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 80010a8: 3304         	adds	r3, #0x4
 80010aa: f8c7 308c    	str.w	r3, [r7, #0x8c]
 80010ae: e025         	b	0x80010fc <cbvprintf_package+0x5d8> @ imm = #0x4a
; 		} else if (size == sizeof(long long)) {
 80010b0: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 80010b4: 2b08         	cmp	r3, #0x8
 80010b6: d11b         	bne	0x80010f0 <cbvprintf_package+0x5cc> @ imm = #0x36
; 			long long v = va_arg(ap, long long);
 80010b8: f8d7 3098    	ldr.w	r3, [r7, #0x98]
 80010bc: 3307         	adds	r3, #0x7
 80010be: f023 0307    	bic	r3, r3, #0x7
 80010c2: f103 0208    	add.w	r2, r3, #0x8
 80010c6: f8c7 2098    	str.w	r2, [r7, #0x98]
 80010ca: e9d3 2300    	ldrd	r2, r3, [r3]
 80010ce: e9c7 2304    	strd	r2, r3, [r7, #16]
; 			if (buf0 != NULL) {
 80010d2: 6dfb         	ldr	r3, [r7, #0x5c]
 80010d4: 2b00         	cmp	r3, #0x0
 80010d6: d005         	beq	0x80010e4 <cbvprintf_package+0x5c0> @ imm = #0xa
; 					*(long long *)buf = v;
 80010d8: f8d7 108c    	ldr.w	r1, [r7, #0x8c]
 80010dc: e9d7 2304    	ldrd	r2, r3, [r7, #16]
 80010e0: e9c1 2300    	strd	r2, r3, [r1]
; 			buf += sizeof(long long);
 80010e4: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 80010e8: 3308         	adds	r3, #0x8
 80010ea: f8c7 308c    	str.w	r3, [r7, #0x8c]
 80010ee: e005         	b	0x80010fc <cbvprintf_package+0x5d8> @ imm = #0xa
; 			return -EINVAL;
 80010f0: f06f 0315    	mvn	r3, #0x15
 80010f4: e0ee         	b	0x80012d4 <cbvprintf_package+0x7b0> @ imm = #0x1dc
; 				continue;
 80010f6: bf00         	nop
 80010f8: e000         	b	0x80010fc <cbvprintf_package+0x5d8> @ imm = #0x0
; 				continue;
 80010fa: bf00         	nop
; 			if (*++fmt == '\0') {
 80010fc: 683b         	ldr	r3, [r7]
 80010fe: 3301         	adds	r3, #0x1
 8001100: 603b         	str	r3, [r7]
 8001102: 683b         	ldr	r3, [r7]
 8001104: 781b         	ldrb	r3, [r3]
 8001106: 2b00         	cmp	r3, #0x0
 8001108: f47f ad71    	bne.w	0x8000bee <cbvprintf_package+0xca> @ imm = #-0x51e
; 				break;
 800110c: bf00         	nop
; 	if ((BUF_OFFSET / sizeof(int)) > 255) {
 800110e: 6dfb         	ldr	r3, [r7, #0x5c]
 8001110: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8001114: 1ad3         	subs	r3, r2, r3
 8001116: f5b3 6f80    	cmp.w	r3, #0x400
 800111a: d302         	blo	0x8001122 <cbvprintf_package+0x5fe> @ imm = #0x4
; 		return -EINVAL;
 800111c: f06f 0315    	mvn	r3, #0x15
 8001120: e0d8         	b	0x80012d4 <cbvprintf_package+0x7b0> @ imm = #0x1b0
; 	if (buf0 == NULL) {
 8001122: 6dfb         	ldr	r3, [r7, #0x5c]
 8001124: 2b00         	cmp	r3, #0x0
 8001126: d107         	bne	0x8001138 <cbvprintf_package+0x614> @ imm = #0xe
; 		return BUF_OFFSET + len - CBPRINTF_PACKAGE_ALIGNMENT;
 8001128: 6dfb         	ldr	r3, [r7, #0x5c]
 800112a: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 800112e: 1ad2         	subs	r2, r2, r3
 8001130: 68bb         	ldr	r3, [r7, #0x8]
 8001132: 4413         	add	r3, r2
 8001134: 3b08         	subs	r3, #0x8
 8001136: e0cd         	b	0x80012d4 <cbvprintf_package+0x7b0> @ imm = #0x19a
; 	*(char **)buf0 = NULL;
 8001138: 6dfb         	ldr	r3, [r7, #0x5c]
 800113a: 2200         	movs	r2, #0x0
 800113c: 601a         	str	r2, [r3]
; 	pkg_hdr->desc.len = BUF_OFFSET / sizeof(int);
 800113e: 6dfb         	ldr	r3, [r7, #0x5c]
 8001140: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 8001144: 1ad3         	subs	r3, r2, r3
 8001146: 089b         	lsrs	r3, r3, #0x2
 8001148: b2da         	uxtb	r2, r3
 800114a: 6d7b         	ldr	r3, [r7, #0x54]
 800114c: 701a         	strb	r2, [r3]
; 	if (rws_pos_en) {
 800114e: f897 305b    	ldrb.w	r3, [r7, #0x5b]
 8001152: 2b00         	cmp	r3, #0x0
 8001154: d007         	beq	0x8001166 <cbvprintf_package+0x642> @ imm = #0xe
; 		pkg_hdr->desc.str_cnt = 0;
 8001156: 6d7b         	ldr	r3, [r7, #0x54]
 8001158: 2200         	movs	r2, #0x0
 800115a: 705a         	strb	r2, [r3, #0x1]
; 		pkg_hdr->desc.rw_str_cnt = s_rw_cnt;
 800115c: 6ffb         	ldr	r3, [r7, #0x7c]
 800115e: b2da         	uxtb	r2, r3
 8001160: 6d7b         	ldr	r3, [r7, #0x54]
 8001162: 70da         	strb	r2, [r3, #0x3]
 8001164: e006         	b	0x8001174 <cbvprintf_package+0x650> @ imm = #0xc
; 		pkg_hdr->desc.str_cnt = s_rw_cnt;
 8001166: 6ffb         	ldr	r3, [r7, #0x7c]
 8001168: b2da         	uxtb	r2, r3
 800116a: 6d7b         	ldr	r3, [r7, #0x54]
 800116c: 705a         	strb	r2, [r3, #0x1]
; 		pkg_hdr->desc.rw_str_cnt = 0;
 800116e: 6d7b         	ldr	r3, [r7, #0x54]
 8001170: 2200         	movs	r2, #0x0
 8001172: 70da         	strb	r2, [r3, #0x3]
; 	pkg_hdr->desc.ro_str_cnt = s_ro_cnt;
 8001174: 6fbb         	ldr	r3, [r7, #0x78]
 8001176: b2da         	uxtb	r2, r3
 8001178: 6d7b         	ldr	r3, [r7, #0x54]
 800117a: 709a         	strb	r2, [r3, #0x2]
; 	if (s_ro_cnt != 0U) {
 800117c: 6fbb         	ldr	r3, [r7, #0x78]
 800117e: 2b00         	cmp	r3, #0x0
 8001180: d032         	beq	0x80011e8 <cbvprintf_package+0x6c4> @ imm = #0x64
; 		for (i = 0; i < s_idx; i++) {
 8001182: 2300         	movs	r3, #0x0
 8001184: 673b         	str	r3, [r7, #0x70]
 8001186: e02a         	b	0x80011de <cbvprintf_package+0x6ba> @ imm = #0x54
; 			if (!(str_ptr_pos[i] & STR_POS_RO_FLAG)) {
 8001188: f107 0230    	add.w	r2, r7, #0x30
 800118c: 6f3b         	ldr	r3, [r7, #0x70]
 800118e: 4413         	add	r3, r2
 8001190: 781b         	ldrb	r3, [r3]
 8001192: b25b         	sxtb	r3, r3
 8001194: 2b00         	cmp	r3, #0x0
 8001196: da1e         	bge	0x80011d6 <cbvprintf_package+0x6b2> @ imm = #0x3c
; 			uint8_t pos = str_ptr_pos[i] & STR_POS_MASK;
 8001198: f107 0230    	add.w	r2, r7, #0x30
 800119c: 6f3b         	ldr	r3, [r7, #0x70]
 800119e: 4413         	add	r3, r2
 80011a0: 781b         	ldrb	r3, [r3]
 80011a2: f003 037f    	and	r3, r3, #0x7f
 80011a6: f887 3043    	strb.w	r3, [r7, #0x43]
; 			if ((BUF_OFFSET + 1) > len) {
 80011aa: 6dfb         	ldr	r3, [r7, #0x5c]
 80011ac: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 80011b0: 1ad3         	subs	r3, r2, r3
 80011b2: 3301         	adds	r3, #0x1
 80011b4: 68ba         	ldr	r2, [r7, #0x8]
 80011b6: 429a         	cmp	r2, r3
 80011b8: d202         	bhs	0x80011c0 <cbvprintf_package+0x69c> @ imm = #0x4
; 				return -ENOSPC;
 80011ba: f06f 031b    	mvn	r3, #0x1b
 80011be: e089         	b	0x80012d4 <cbvprintf_package+0x7b0> @ imm = #0x112
; 			*(uint8_t *)buf = pos;
 80011c0: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 80011c4: f897 2043    	ldrb.w	r2, [r7, #0x43]
 80011c8: 701a         	strb	r2, [r3]
; 			++buf;
 80011ca: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 80011ce: 3301         	adds	r3, #0x1
 80011d0: f8c7 308c    	str.w	r3, [r7, #0x8c]
 80011d4: e000         	b	0x80011d8 <cbvprintf_package+0x6b4> @ imm = #0x0
; 				continue;
 80011d6: bf00         	nop
; 		for (i = 0; i < s_idx; i++) {
 80011d8: 6f3b         	ldr	r3, [r7, #0x70]
 80011da: 3301         	adds	r3, #0x1
 80011dc: 673b         	str	r3, [r7, #0x70]
 80011de: 6f3a         	ldr	r2, [r7, #0x70]
 80011e0: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 80011e4: 429a         	cmp	r2, r3
 80011e6: d3cf         	blo	0x8001188 <cbvprintf_package+0x664> @ imm = #-0x62
; 	for (i = 0; i < s_idx; i++) {
 80011e8: 2300         	movs	r3, #0x0
 80011ea: 673b         	str	r3, [r7, #0x70]
 80011ec: e069         	b	0x80012c2 <cbvprintf_package+0x79e> @ imm = #0xd2
; 		if (s_ro_cnt && str_ptr_pos[i] & STR_POS_RO_FLAG) {
 80011ee: 6fbb         	ldr	r3, [r7, #0x78]
 80011f0: 2b00         	cmp	r3, #0x0
 80011f2: d007         	beq	0x8001204 <cbvprintf_package+0x6e0> @ imm = #0xe
 80011f4: f107 0230    	add.w	r2, r7, #0x30
 80011f8: 6f3b         	ldr	r3, [r7, #0x70]
 80011fa: 4413         	add	r3, r2
 80011fc: 781b         	ldrb	r3, [r3]
 80011fe: b25b         	sxtb	r3, r3
 8001200: 2b00         	cmp	r3, #0x0
 8001202: db5a         	blt	0x80012ba <cbvprintf_package+0x796> @ imm = #0xb4
; 		if (rws_pos_en) {
 8001204: f897 305b    	ldrb.w	r3, [r7, #0x5b]
 8001208: 2b00         	cmp	r3, #0x0
 800120a: d010         	beq	0x800122e <cbvprintf_package+0x70a> @ imm = #0x20
; 			size = 0;
 800120c: 2300         	movs	r3, #0x0
 800120e: f8c7 3088    	str.w	r3, [r7, #0x88]
; 			*(uint8_t *)buf = str_ptr_arg[i];
 8001212: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8001216: f107 0120    	add.w	r1, r7, #0x20
 800121a: 6f3a         	ldr	r2, [r7, #0x70]
 800121c: 440a         	add	r2, r1
 800121e: 7812         	ldrb	r2, [r2]
 8001220: 701a         	strb	r2, [r3]
; 			++buf;
 8001222: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8001226: 3301         	adds	r3, #0x1
 8001228: f8c7 308c    	str.w	r3, [r7, #0x8c]
 800122c: e01a         	b	0x8001264 <cbvprintf_package+0x740> @ imm = #0x34
; 			s = *(char **)(buf0 + str_ptr_pos[i] * sizeof(int));
 800122e: f107 0230    	add.w	r2, r7, #0x30
 8001232: 6f3b         	ldr	r3, [r7, #0x70]
 8001234: 4413         	add	r3, r2
 8001236: 781b         	ldrb	r3, [r3]
 8001238: 009b         	lsls	r3, r3, #0x2
 800123a: 6dfa         	ldr	r2, [r7, #0x5c]
 800123c: 4413         	add	r3, r2
 800123e: 681b         	ldr	r3, [r3]
 8001240: 66fb         	str	r3, [r7, #0x6c]
; 			*(char **)(buf0 + str_ptr_pos[i] * sizeof(int)) = NULL;
 8001242: f107 0230    	add.w	r2, r7, #0x30
 8001246: 6f3b         	ldr	r3, [r7, #0x70]
 8001248: 4413         	add	r3, r2
 800124a: 781b         	ldrb	r3, [r3]
 800124c: 009b         	lsls	r3, r3, #0x2
 800124e: 6dfa         	ldr	r2, [r7, #0x5c]
 8001250: 4413         	add	r3, r2
 8001252: 2200         	movs	r2, #0x0
 8001254: 601a         	str	r2, [r3]
; 			size = strlen(s) + 1;
 8001256: 6ef8         	ldr	r0, [r7, #0x6c]
 8001258: f7ff fab4    	bl	0x80007c4 <strlen>      @ imm = #-0xa98
 800125c: 4603         	mov	r3, r0
 800125e: 3301         	adds	r3, #0x1
 8001260: f8c7 3088    	str.w	r3, [r7, #0x88]
; 		if ((BUF_OFFSET + 1 + size) > len) {
 8001264: 6dfb         	ldr	r3, [r7, #0x5c]
 8001266: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 800126a: 1ad2         	subs	r2, r2, r3
 800126c: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 8001270: 4413         	add	r3, r2
 8001272: 3301         	adds	r3, #0x1
 8001274: 68ba         	ldr	r2, [r7, #0x8]
 8001276: 429a         	cmp	r2, r3
 8001278: d202         	bhs	0x8001280 <cbvprintf_package+0x75c> @ imm = #0x4
; 			return -ENOSPC;
 800127a: f06f 031b    	mvn	r3, #0x1b
 800127e: e029         	b	0x80012d4 <cbvprintf_package+0x7b0> @ imm = #0x52
; 		*(uint8_t *)buf = str_ptr_pos[i];
 8001280: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8001284: f107 0130    	add.w	r1, r7, #0x30
 8001288: 6f3a         	ldr	r2, [r7, #0x70]
 800128a: 440a         	add	r2, r1
 800128c: 7812         	ldrb	r2, [r2]
 800128e: 701a         	strb	r2, [r3]
; 		++buf;
 8001290: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8001294: 3301         	adds	r3, #0x1
 8001296: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 		memcpy((void *)buf, (uint8_t *)s, size);
 800129a: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 800129e: f8d7 2088    	ldr.w	r2, [r7, #0x88]
 80012a2: 6ef9         	ldr	r1, [r7, #0x6c]
 80012a4: 4618         	mov	r0, r3
 80012a6: f012 ff2b    	bl	0x8014100 <memcpy>      @ imm = #0x12e56
; 		buf += size;
 80012aa: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 80012ae: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 80012b2: 4413         	add	r3, r2
 80012b4: f8c7 308c    	str.w	r3, [r7, #0x8c]
 80012b8: e000         	b	0x80012bc <cbvprintf_package+0x798> @ imm = #0x0
; 			continue;
 80012ba: bf00         	nop
; 	for (i = 0; i < s_idx; i++) {
 80012bc: 6f3b         	ldr	r3, [r7, #0x70]
 80012be: 3301         	adds	r3, #0x1
 80012c0: 673b         	str	r3, [r7, #0x70]
 80012c2: 6f3a         	ldr	r2, [r7, #0x70]
 80012c4: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 80012c8: 429a         	cmp	r2, r3
 80012ca: d390         	blo	0x80011ee <cbvprintf_package+0x6ca> @ imm = #-0xe0
; 	return BUF_OFFSET;
 80012cc: 6dfb         	ldr	r3, [r7, #0x5c]
 80012ce: f8d7 208c    	ldr.w	r2, [r7, #0x8c]
 80012d2: 1ad3         	subs	r3, r2, r3
; }
 80012d4: 4618         	mov	r0, r3
 80012d6: 3790         	adds	r7, #0x90
 80012d8: 46bd         	mov	sp, r7
 80012da: bd80         	pop	{r7, pc}

080012dc <__printk_hook_install>:
; {
 80012dc: b480         	push	{r7}
 80012de: b083         	sub	sp, #0xc
 80012e0: af00         	add	r7, sp, #0x0
 80012e2: 6078         	str	r0, [r7, #0x4]
; 	_char_out = fn;
 80012e4: 4a03         	ldr	r2, [pc, #0xc]          @ 0x80012f4 <__printk_hook_install+0x18>
 80012e6: 687b         	ldr	r3, [r7, #0x4]
 80012e8: 6013         	str	r3, [r2]
; }
 80012ea: bf00         	nop
 80012ec: 370c         	adds	r7, #0xc
 80012ee: 46bd         	mov	sp, r7
 80012f0: bc80         	pop	{r7}
 80012f2: 4770         	bx	lr

080012f4 <$d>:
 80012f4: 04 00 00 20  	.word	0x20000004

080012f8 <k_current_get>:
; {
 80012f8: b580         	push	{r7, lr}
 80012fa: af00         	add	r7, sp, #0x0
; 	return z_tls_current;
 80012fc: f013 f8e4    	bl	0x80144c8 <__aeabi_read_tp> @ imm = #0x131c8
 8001300: 4603         	mov	r3, r0
 8001302: 4a02         	ldr	r2, [pc, #0x8]          @ 0x800130c <k_current_get+0x14>
 8001304: 589b         	ldr	r3, [r3, r2]
; }
 8001306: 4618         	mov	r0, r3
 8001308: bd80         	pop	{r7, pc}
 800130a: bf00         	nop

0800130c <$d>:
 800130c: 08 00 00 00  	.word	0x00000008

08001310 <z_thread_entry>:
; {
 8001310: b580         	push	{r7, lr}
 8001312: b084         	sub	sp, #0x10
 8001314: af00         	add	r7, sp, #0x0
 8001316: 60f8         	str	r0, [r7, #0xc]
 8001318: 60b9         	str	r1, [r7, #0x8]
 800131a: 607a         	str	r2, [r7, #0x4]
 800131c: 603b         	str	r3, [r7]
; 	z_tls_current = k_sched_current_thread_query();
 800131e: f00c fe1d    	bl	0x800df5c <k_sched_current_thread_query> @ imm = #0xcc3a
 8001322: 4602         	mov	r2, r0
 8001324: f013 f8d0    	bl	0x80144c8 <__aeabi_read_tp> @ imm = #0x131a0
 8001328: 4603         	mov	r3, r0
 800132a: 4906         	ldr	r1, [pc, #0x18]         @ 0x8001344 <z_thread_entry+0x34>
 800132c: 505a         	str	r2, [r3, r1]
; 	entry(p1, p2, p3);
 800132e: 68fb         	ldr	r3, [r7, #0xc]
 8001330: 683a         	ldr	r2, [r7]
 8001332: 6879         	ldr	r1, [r7, #0x4]
 8001334: 68b8         	ldr	r0, [r7, #0x8]
 8001336: 4798         	blx	r3
; 	k_thread_abort(k_current_get());
 8001338: f7ff ffde    	bl	0x80012f8 <k_current_get> @ imm = #-0x44
 800133c: 4603         	mov	r3, r0
 800133e: 4618         	mov	r0, r3
 8001340: f00c fe13    	bl	0x800df6a <k_thread_abort> @ imm = #0xcc26

08001344 <$d>:
 8001344: 08 00 00 00  	.word	0x00000008

08001348 <LL_DBGMCU_DisableDBGStopMode>:
; {
 8001348: b480         	push	{r7}
 800134a: af00         	add	r7, sp, #0x0
;   CLEAR_BIT(DBGMCU->CR, DBGMCU_CR_DBG_STOP);
 800134c: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8001360 <LL_DBGMCU_DisableDBGStopMode+0x18>
 800134e: 685b         	ldr	r3, [r3, #0x4]
 8001350: 4a03         	ldr	r2, [pc, #0xc]          @ 0x8001360 <LL_DBGMCU_DisableDBGStopMode+0x18>
 8001352: f023 0302    	bic	r3, r3, #0x2
 8001356: 6053         	str	r3, [r2, #0x4]
; }
 8001358: bf00         	nop
 800135a: 46bd         	mov	sp, r7
 800135c: bc80         	pop	{r7}
 800135e: 4770         	bx	lr

08001360 <$d>:
 8001360: 00 20 04 e0  	.word	0xe0042000

08001364 <LL_FLASH_EnablePrefetch>:
; {
 8001364: b480         	push	{r7}
 8001366: af00         	add	r7, sp, #0x0
;   SET_BIT(FLASH->ACR, FLASH_ACR_PRFTEN);
 8001368: 4b04         	ldr	r3, [pc, #0x10]         @ 0x800137c <LL_FLASH_EnablePrefetch+0x18>
 800136a: 681b         	ldr	r3, [r3]
 800136c: 4a03         	ldr	r2, [pc, #0xc]          @ 0x800137c <LL_FLASH_EnablePrefetch+0x18>
 800136e: f443 7380    	orr	r3, r3, #0x100
 8001372: 6013         	str	r3, [r2]
; }
 8001374: bf00         	nop
 8001376: 46bd         	mov	sp, r7
 8001378: bc80         	pop	{r7}
 800137a: 4770         	bx	lr

0800137c <$d>:
 800137c: 00 3c 02 40  	.word	0x40023c00

08001380 <LL_FLASH_EnableInstCache>:
; {
 8001380: b480         	push	{r7}
 8001382: af00         	add	r7, sp, #0x0
;   SET_BIT(FLASH->ACR, FLASH_ACR_ICEN);
 8001384: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8001398 <LL_FLASH_EnableInstCache+0x18>
 8001386: 681b         	ldr	r3, [r3]
 8001388: 4a03         	ldr	r2, [pc, #0xc]          @ 0x8001398 <LL_FLASH_EnableInstCache+0x18>
 800138a: f443 7300    	orr	r3, r3, #0x200
 800138e: 6013         	str	r3, [r2]
; }
 8001390: bf00         	nop
 8001392: 46bd         	mov	sp, r7
 8001394: bc80         	pop	{r7}
 8001396: 4770         	bx	lr

08001398 <$d>:
 8001398: 00 3c 02 40  	.word	0x40023c00

0800139c <LL_FLASH_EnableDataCache>:
; {
 800139c: b480         	push	{r7}
 800139e: af00         	add	r7, sp, #0x0
;   SET_BIT(FLASH->ACR, FLASH_ACR_DCEN);
 80013a0: 4b04         	ldr	r3, [pc, #0x10]         @ 0x80013b4 <LL_FLASH_EnableDataCache+0x18>
 80013a2: 681b         	ldr	r3, [r3]
 80013a4: 4a03         	ldr	r2, [pc, #0xc]          @ 0x80013b4 <LL_FLASH_EnableDataCache+0x18>
 80013a6: f443 6380    	orr	r3, r3, #0x400
 80013aa: 6013         	str	r3, [r2]
; }
 80013ac: bf00         	nop
 80013ae: 46bd         	mov	sp, r7
 80013b0: bc80         	pop	{r7}
 80013b2: 4770         	bx	lr

080013b4 <$d>:
 80013b4: 00 3c 02 40  	.word	0x40023c00

080013b8 <soc_early_init_hook>:
; {
 80013b8: b580         	push	{r7, lr}
 80013ba: af00         	add	r7, sp, #0x0
; 	LL_FLASH_EnablePrefetch();
 80013bc: f7ff ffd2    	bl	0x8001364 <LL_FLASH_EnablePrefetch> @ imm = #-0x5c
; 	LL_FLASH_EnableInstCache();
 80013c0: f7ff ffde    	bl	0x8001380 <LL_FLASH_EnableInstCache> @ imm = #-0x44
; 	LL_FLASH_EnableDataCache();
 80013c4: f7ff ffea    	bl	0x800139c <LL_FLASH_EnableDataCache> @ imm = #-0x2c
; 	SystemCoreClock = 16000000;
 80013c8: 4b02         	ldr	r3, [pc, #0x8]          @ 0x80013d4 <soc_early_init_hook+0x1c>
 80013ca: 4a03         	ldr	r2, [pc, #0xc]          @ 0x80013d8 <soc_early_init_hook+0x20>
 80013cc: 601a         	str	r2, [r3]
; }
 80013ce: bf00         	nop
 80013d0: bd80         	pop	{r7, pc}
 80013d2: bf00         	nop

080013d4 <$d>:
 80013d4: f4 00 00 20  	.word	0x200000f4
 80013d8: 00 24 f4 00  	.word	0x00f42400

080013dc <log_backend_get>:
; {
 80013dc: b480         	push	{r7}
 80013de: b085         	sub	sp, #0x14
 80013e0: af00         	add	r7, sp, #0x0
 80013e2: 6078         	str	r0, [r7, #0x4]
; 	STRUCT_SECTION_GET(log_backend, idx, &backend);
 80013e4: 687b         	ldr	r3, [r7, #0x4]
 80013e6: 011b         	lsls	r3, r3, #0x4
 80013e8: 4a04         	ldr	r2, [pc, #0x10]         @ 0x80013fc <log_backend_get+0x20>
 80013ea: 4413         	add	r3, r2
 80013ec: 60fb         	str	r3, [r7, #0xc]
; 	return backend;
 80013ee: 68fb         	ldr	r3, [r7, #0xc]
; }
 80013f0: 4618         	mov	r0, r3
 80013f2: 3714         	adds	r7, #0x14
 80013f4: 46bd         	mov	sp, r7
 80013f6: bc80         	pop	{r7}
 80013f8: 4770         	bx	lr
 80013fa: bf00         	nop

080013fc <$d>:
 80013fc: 74 4a 01 08  	.word	0x08014a74

08001400 <log_format_func_t_get>:
; {
 8001400: b480         	push	{r7}
 8001402: b083         	sub	sp, #0xc
 8001404: af00         	add	r7, sp, #0x0
 8001406: 6078         	str	r0, [r7, #0x4]
; 	return format_table[log_type];
 8001408: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800141c <log_format_func_t_get+0x1c>
 800140a: 687b         	ldr	r3, [r7, #0x4]
 800140c: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
; }
 8001410: 4618         	mov	r0, r3
 8001412: 370c         	adds	r7, #0xc
 8001414: 46bd         	mov	sp, r7
 8001416: bc80         	pop	{r7}
 8001418: 4770         	bx	lr
 800141a: bf00         	nop

0800141c <$d>:
 800141c: 30 62 01 08  	.word	0x08016230

08001420 <log_core_init>:
; {
 8001420: b580         	push	{r7, lr}
 8001422: af00         	add	r7, sp, #0x0
; 	panic_mode = false;
 8001424: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8001444 <log_core_init+0x24>
 8001426: 2200         	movs	r2, #0x0
 8001428: 701a         	strb	r2, [r3]
; 	dropped_cnt = 0;
 800142a: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8001448 <log_core_init+0x28>
 800142c: 2200         	movs	r2, #0x0
 800142e: 601a         	str	r2, [r3]
; 	buffered_cnt = 0;
 8001430: 4b06         	ldr	r3, [pc, #0x18]         @ 0x800144c <log_core_init+0x2c>
 8001432: 2200         	movs	r2, #0x0
 8001434: 601a         	str	r2, [r3]
; 		log_set_timestamp_func(default_lf_get_timestamp, 1000U);
 8001436: f44f 717a    	mov.w	r1, #0x3e8
 800143a: 4805         	ldr	r0, [pc, #0x14]         @ 0x8001450 <log_core_init+0x30>
 800143c: f000 f86a    	bl	0x8001514 <log_set_timestamp_func> @ imm = #0xd4
; }
 8001440: bd80         	pop	{r7, pc}
 8001442: bf00         	nop

08001444 <$d>:
 8001444: f4 09 00 20  	.word	0x200009f4
 8001448: 98 05 00 20  	.word	0x20000598
 800144c: 94 05 00 20  	.word	0x20000594
 8001450: ef e1 00 08  	.word	0x0800e1ef

08001454 <z_log_init>:
; {
 8001454: b580         	push	{r7, lr}
 8001456: b086         	sub	sp, #0x18
 8001458: af00         	add	r7, sp, #0x0
 800145a: 4603         	mov	r3, r0
 800145c: 460a         	mov	r2, r1
 800145e: 71fb         	strb	r3, [r7, #0x7]
 8001460: 4613         	mov	r3, r2
 8001462: 71bb         	strb	r3, [r7, #0x6]
; 	uint32_t mask = 0;
 8001464: 2300         	movs	r3, #0x0
 8001466: 617b         	str	r3, [r7, #0x14]
; 	if (atomic_inc(&initialized) != 0) {
 8001468: 4827         	ldr	r0, [pc, #0x9c]         @ 0x8001508 <z_log_init+0xb4>
 800146a: f00c fdc8    	bl	0x800dffe <atomic_inc>  @ imm = #0xcb90
 800146e: 4603         	mov	r3, r0
 8001470: 2b00         	cmp	r3, #0x0
 8001472: d001         	beq	0x8001478 <z_log_init+0x24> @ imm = #0x2
; 		return 0;
 8001474: 2300         	movs	r3, #0x0
 8001476: e042         	b	0x80014fe <z_log_init+0xaa> @ imm = #0x84
; 	int backend_index = 0;
 8001478: 2300         	movs	r3, #0x0
 800147a: 613b         	str	r3, [r7, #0x10]
; 	STRUCT_SECTION_FOREACH(log_backend, backend) {
 800147c: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x800150c <z_log_init+0xb8>
 800147e: 60fb         	str	r3, [r7, #0xc]
 8001480: e022         	b	0x80014c8 <z_log_init+0x74> @ imm = #0x44
; 		if (backend->autostart) {
 8001482: 68fb         	ldr	r3, [r7, #0xc]
 8001484: 7b1b         	ldrb	r3, [r3, #0xc]
 8001486: 2b00         	cmp	r3, #0x0
 8001488: d018         	beq	0x80014bc <z_log_init+0x68> @ imm = #0x30
; 			log_backend_init(backend);
 800148a: 68f8         	ldr	r0, [r7, #0xc]
 800148c: f00c fe43    	bl	0x800e116 <log_backend_init> @ imm = #0xcc86
; 			if (log_backend_is_ready(backend) == 0) {
 8001490: 68f8         	ldr	r0, [r7, #0xc]
 8001492: f00c fe52    	bl	0x800e13a <log_backend_is_ready> @ imm = #0xcca4
 8001496: 4603         	mov	r3, r0
 8001498: 2b00         	cmp	r3, #0x0
 800149a: d108         	bne	0x80014ae <z_log_init+0x5a> @ imm = #0x10
; 						   backend->cb->ctx,
 800149c: 68fb         	ldr	r3, [r7, #0xc]
 800149e: 685b         	ldr	r3, [r3, #0x4]
; 				log_backend_enable(backend,
 80014a0: 681b         	ldr	r3, [r3]
 80014a2: 2204         	movs	r2, #0x4
 80014a4: 4619         	mov	r1, r3
 80014a6: 68f8         	ldr	r0, [r7, #0xc]
 80014a8: f00c ffa3    	bl	0x800e3f2 <log_backend_enable> @ imm = #0xcf46
 80014ac: e006         	b	0x80014bc <z_log_init+0x68> @ imm = #0xc
; 				mask |= BIT(backend_index);
 80014ae: 2201         	movs	r2, #0x1
 80014b0: 693b         	ldr	r3, [r7, #0x10]
 80014b2: fa02 f303    	lsl.w	r3, r2, r3
 80014b6: 697a         	ldr	r2, [r7, #0x14]
 80014b8: 4313         	orrs	r3, r2
 80014ba: 617b         	str	r3, [r7, #0x14]
; 		++backend_index;
 80014bc: 693b         	ldr	r3, [r7, #0x10]
 80014be: 3301         	adds	r3, #0x1
 80014c0: 613b         	str	r3, [r7, #0x10]
; 	STRUCT_SECTION_FOREACH(log_backend, backend) {
 80014c2: 68fb         	ldr	r3, [r7, #0xc]
 80014c4: 3310         	adds	r3, #0x10
 80014c6: 60fb         	str	r3, [r7, #0xc]
 80014c8: 68fb         	ldr	r3, [r7, #0xc]
 80014ca: 4a11         	ldr	r2, [pc, #0x44]         @ 0x8001510 <z_log_init+0xbc>
 80014cc: 4293         	cmp	r3, r2
 80014ce: bf34         	ite	lo
 80014d0: 2301         	movlo	r3, #0x1
 80014d2: 2300         	movhs	r3, #0x0
 80014d4: b2db         	uxtb	r3, r3
 80014d6: 2b00         	cmp	r3, #0x0
 80014d8: d1d3         	bne	0x8001482 <z_log_init+0x2e> @ imm = #-0x5a
; 	if (blocking) {
 80014da: 79fb         	ldrb	r3, [r7, #0x7]
 80014dc: 2b00         	cmp	r3, #0x0
 80014de: d00d         	beq	0x80014fc <z_log_init+0xa8> @ imm = #0x1a
; 		while (mask) {
 80014e0: e009         	b	0x80014f6 <z_log_init+0xa2> @ imm = #0x12
; 			mask = activate_foreach_backend(mask);
 80014e2: 6978         	ldr	r0, [r7, #0x14]
 80014e4: f00c fe8a    	bl	0x800e1fc <activate_foreach_backend> @ imm = #0xcd14
 80014e8: 6178         	str	r0, [r7, #0x14]
; 			if (IS_ENABLED(CONFIG_MULTITHREADING) && can_sleep) {
 80014ea: 79bb         	ldrb	r3, [r7, #0x6]
 80014ec: 2b00         	cmp	r3, #0x0
 80014ee: d002         	beq	0x80014f6 <z_log_init+0xa2> @ imm = #0x4
; 				k_msleep(10);
 80014f0: 200a         	movs	r0, #0xa
 80014f2: f00c fdb1    	bl	0x800e058 <k_msleep>    @ imm = #0xcb62
; 		while (mask) {
 80014f6: 697b         	ldr	r3, [r7, #0x14]
 80014f8: 2b00         	cmp	r3, #0x0
 80014fa: d1f2         	bne	0x80014e2 <z_log_init+0x8e> @ imm = #-0x1c
; 	return mask;
 80014fc: 697b         	ldr	r3, [r7, #0x14]
; }
 80014fe: 4618         	mov	r0, r3
 8001500: 3718         	adds	r7, #0x18
 8001502: 46bd         	mov	sp, r7
 8001504: bd80         	pop	{r7, pc}
 8001506: bf00         	nop

08001508 <$d>:
 8001508: 90 05 00 20  	.word	0x20000590
 800150c: 74 4a 01 08  	.word	0x08014a74
 8001510: 84 4a 01 08  	.word	0x08014a84

08001514 <log_set_timestamp_func>:
; {
 8001514: b580         	push	{r7, lr}
 8001516: b082         	sub	sp, #0x8
 8001518: af00         	add	r7, sp, #0x0
 800151a: 6078         	str	r0, [r7, #0x4]
 800151c: 6039         	str	r1, [r7]
; 	if (timestamp_getter == NULL) {
 800151e: 687b         	ldr	r3, [r7, #0x4]
 8001520: 2b00         	cmp	r3, #0x0
 8001522: d102         	bne	0x800152a <log_set_timestamp_func+0x16> @ imm = #0x4
; 		return -EINVAL;
 8001524: f06f 0315    	mvn	r3, #0x15
 8001528: e009         	b	0x800153e <log_set_timestamp_func+0x2a> @ imm = #0x12
; 	timestamp_func = timestamp_getter;
 800152a: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8001548 <log_set_timestamp_func+0x34>
 800152c: 687b         	ldr	r3, [r7, #0x4]
 800152e: 6013         	str	r3, [r2]
; 	timestamp_freq = freq;
 8001530: 4a06         	ldr	r2, [pc, #0x18]         @ 0x800154c <log_set_timestamp_func+0x38>
 8001532: 683b         	ldr	r3, [r7]
 8001534: 6013         	str	r3, [r2]
; 		log_output_timestamp_freq_set(freq);
 8001536: 6838         	ldr	r0, [r7]
 8001538: f000 fcea    	bl	0x8001f10 <log_output_timestamp_freq_set> @ imm = #0x9d4
; 	return 0;
 800153c: 2300         	movs	r3, #0x0
; }
 800153e: 4618         	mov	r0, r3
 8001540: 3708         	adds	r7, #0x8
 8001542: 46bd         	mov	sp, r7
 8001544: bd80         	pop	{r7, pc}
 8001546: bf00         	nop

08001548 <$d>:
 8001548: 08 00 00 20  	.word	0x20000008
 800154c: 9c 05 00 20  	.word	0x2000059c

08001550 <z_impl_log_panic>:
; {
 8001550: b580         	push	{r7, lr}
 8001552: b082         	sub	sp, #0x8
 8001554: af00         	add	r7, sp, #0x0
; 	if (panic_mode) {
 8001556: 4b14         	ldr	r3, [pc, #0x50]         @ 0x80015a8 <z_impl_log_panic+0x58>
 8001558: 781b         	ldrb	r3, [r3]
 800155a: 2b00         	cmp	r3, #0x0
 800155c: d120         	bne	0x80015a0 <z_impl_log_panic+0x50> @ imm = #0x40
; 	(void)z_log_init(true, false);
 800155e: 2100         	movs	r1, #0x0
 8001560: 2001         	movs	r0, #0x1
 8001562: f7ff ff77    	bl	0x8001454 <z_log_init>  @ imm = #-0x112
; 	STRUCT_SECTION_FOREACH(log_backend, backend) {
 8001566: 4b11         	ldr	r3, [pc, #0x44]         @ 0x80015ac <z_impl_log_panic+0x5c>
 8001568: 607b         	str	r3, [r7, #0x4]
 800156a: e00b         	b	0x8001584 <z_impl_log_panic+0x34> @ imm = #0x16
; 		if (log_backend_is_active(backend)) {
 800156c: 6878         	ldr	r0, [r7, #0x4]
 800156e: f00c fe15    	bl	0x800e19c <log_backend_is_active> @ imm = #0xcc2a
 8001572: 4603         	mov	r3, r0
 8001574: 2b00         	cmp	r3, #0x0
 8001576: d002         	beq	0x800157e <z_impl_log_panic+0x2e> @ imm = #0x4
; 			log_backend_panic(backend);
 8001578: 6878         	ldr	r0, [r7, #0x4]
 800157a: f00c fe02    	bl	0x800e182 <log_backend_panic> @ imm = #0xcc04
; 	STRUCT_SECTION_FOREACH(log_backend, backend) {
 800157e: 687b         	ldr	r3, [r7, #0x4]
 8001580: 3310         	adds	r3, #0x10
 8001582: 607b         	str	r3, [r7, #0x4]
 8001584: 687b         	ldr	r3, [r7, #0x4]
 8001586: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x80015b0 <z_impl_log_panic+0x60>
 8001588: 4293         	cmp	r3, r2
 800158a: bf34         	ite	lo
 800158c: 2301         	movlo	r3, #0x1
 800158e: 2300         	movhs	r3, #0x0
 8001590: b2db         	uxtb	r3, r3
 8001592: 2b00         	cmp	r3, #0x0
 8001594: d1ea         	bne	0x800156c <z_impl_log_panic+0x1c> @ imm = #-0x2c
; out:
 8001596: bf00         	nop
; 	panic_mode = true;
 8001598: 4b03         	ldr	r3, [pc, #0xc]          @ 0x80015a8 <z_impl_log_panic+0x58>
 800159a: 2201         	movs	r2, #0x1
 800159c: 701a         	strb	r2, [r3]
 800159e: e000         	b	0x80015a2 <z_impl_log_panic+0x52> @ imm = #0x0
; 		return;
 80015a0: bf00         	nop
; }
 80015a2: 3708         	adds	r7, #0x8
 80015a4: 46bd         	mov	sp, r7
 80015a6: bd80         	pop	{r7, pc}

080015a8 <$d>:
 80015a8: f4 09 00 20  	.word	0x200009f4
 80015ac: 74 4a 01 08  	.word	0x08014a74
 80015b0: 84 4a 01 08  	.word	0x08014a84

080015b4 <msg_process>:
; {
 80015b4: b580         	push	{r7, lr}
 80015b6: b084         	sub	sp, #0x10
 80015b8: af00         	add	r7, sp, #0x0
 80015ba: 6078         	str	r0, [r7, #0x4]
; 	STRUCT_SECTION_FOREACH(log_backend, backend) {
 80015bc: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8001608 <msg_process+0x54>
 80015be: 60fb         	str	r3, [r7, #0xc]
 80015c0: e013         	b	0x80015ea <msg_process+0x36> @ imm = #0x26
; 		if (log_backend_is_active(backend) &&
 80015c2: 68f8         	ldr	r0, [r7, #0xc]
 80015c4: f00c fdea    	bl	0x800e19c <log_backend_is_active> @ imm = #0xcbd4
 80015c8: 4603         	mov	r3, r0
 80015ca: 2b00         	cmp	r3, #0x0
 80015cc: d00a         	beq	0x80015e4 <msg_process+0x30> @ imm = #0x14
; 		    msg_filter_check(backend, msg)) {
 80015ce: 6879         	ldr	r1, [r7, #0x4]
 80015d0: 68f8         	ldr	r0, [r7, #0xc]
 80015d2: f00c fe4e    	bl	0x800e272 <msg_filter_check> @ imm = #0xcc9c
 80015d6: 4603         	mov	r3, r0
; 		if (log_backend_is_active(backend) &&
 80015d8: 2b00         	cmp	r3, #0x0
 80015da: d003         	beq	0x80015e4 <msg_process+0x30> @ imm = #0x6
; 			log_backend_msg_process(backend, msg);
 80015dc: 6879         	ldr	r1, [r7, #0x4]
 80015de: 68f8         	ldr	r0, [r7, #0xc]
 80015e0: f00c fdc0    	bl	0x800e164 <log_backend_msg_process> @ imm = #0xcb80
; 	STRUCT_SECTION_FOREACH(log_backend, backend) {
 80015e4: 68fb         	ldr	r3, [r7, #0xc]
 80015e6: 3310         	adds	r3, #0x10
 80015e8: 60fb         	str	r3, [r7, #0xc]
 80015ea: 68fb         	ldr	r3, [r7, #0xc]
 80015ec: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x800160c <msg_process+0x58>
 80015ee: 4293         	cmp	r3, r2
 80015f0: bf34         	ite	lo
 80015f2: 2301         	movlo	r3, #0x1
 80015f4: 2300         	movhs	r3, #0x0
 80015f6: b2db         	uxtb	r3, r3
 80015f8: 2b00         	cmp	r3, #0x0
 80015fa: d1e2         	bne	0x80015c2 <msg_process+0xe> @ imm = #-0x3c
; }
 80015fc: bf00         	nop
 80015fe: bf00         	nop
 8001600: 3710         	adds	r7, #0x10
 8001602: 46bd         	mov	sp, r7
 8001604: bd80         	pop	{r7, pc}
 8001606: bf00         	nop

08001608 <$d>:
 8001608: 74 4a 01 08  	.word	0x08014a74
 800160c: 84 4a 01 08  	.word	0x08014a84

08001610 <z_log_notify_backend_enabled>:
; {
 8001610: b480         	push	{r7}
 8001612: af00         	add	r7, sp, #0x0
; 	backend_attached = true;
 8001614: 4b03         	ldr	r3, [pc, #0xc]          @ 0x8001624 <z_log_notify_backend_enabled+0x14>
 8001616: 2201         	movs	r2, #0x1
 8001618: 701a         	strb	r2, [r3]
; }
 800161a: bf00         	nop
 800161c: 46bd         	mov	sp, r7
 800161e: bc80         	pop	{r7}
 8001620: 4770         	bx	lr
 8001622: bf00         	nop

08001624 <$d>:
 8001624: f5 09 00 20  	.word	0x200009f5

08001628 <z_log_dropped>:
; {
 8001628: b580         	push	{r7, lr}
 800162a: b082         	sub	sp, #0x8
 800162c: af00         	add	r7, sp, #0x0
 800162e: 4603         	mov	r3, r0
 8001630: 71fb         	strb	r3, [r7, #0x7]
; 	atomic_inc(&dropped_cnt);
 8001632: 4806         	ldr	r0, [pc, #0x18]         @ 0x800164c <z_log_dropped+0x24>
 8001634: f00c fce3    	bl	0x800dffe <atomic_inc>  @ imm = #0xc9c6
; 	if (buffered) {
 8001638: 79fb         	ldrb	r3, [r7, #0x7]
 800163a: 2b00         	cmp	r3, #0x0
 800163c: d002         	beq	0x8001644 <z_log_dropped+0x1c> @ imm = #0x4
; 		atomic_dec(&buffered_cnt);
 800163e: 4804         	ldr	r0, [pc, #0x10]         @ 0x8001650 <z_log_dropped+0x28>
 8001640: f00c fcea    	bl	0x800e018 <atomic_dec>  @ imm = #0xc9d4
; }
 8001644: bf00         	nop
 8001646: 3708         	adds	r7, #0x8
 8001648: 46bd         	mov	sp, r7
 800164a: bd80         	pop	{r7, pc}

0800164c <$d>:
 800164c: 98 05 00 20  	.word	0x20000598
 8001650: 94 05 00 20  	.word	0x20000594

08001654 <z_log_msg_commit>:
; {
 8001654: b580         	push	{r7, lr}
 8001656: b082         	sub	sp, #0x8
 8001658: af00         	add	r7, sp, #0x0
 800165a: 6078         	str	r0, [r7, #0x4]
; 	msg->hdr.timestamp = timestamp_func();
 800165c: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8001678 <z_log_msg_commit+0x24>
 800165e: 681b         	ldr	r3, [r3]
 8001660: 4798         	blx	r3
 8001662: 4602         	mov	r2, r0
 8001664: 687b         	ldr	r3, [r7, #0x4]
 8001666: 609a         	str	r2, [r3, #0x8]
; 	msg_commit(&log_buffer, msg);
 8001668: 6879         	ldr	r1, [r7, #0x4]
 800166a: 4804         	ldr	r0, [pc, #0x10]         @ 0x800167c <z_log_msg_commit+0x28>
 800166c: f00c fe16    	bl	0x800e29c <msg_commit>  @ imm = #0xcc2c
; }
 8001670: bf00         	nop
 8001672: 3708         	adds	r7, #0x8
 8001674: 46bd         	mov	sp, r7
 8001676: bd80         	pop	{r7, pc}

08001678 <$d>:
 8001678: 08 00 00 20  	.word	0x20000008
 800167c: 50 01 00 20  	.word	0x20000150

08001680 <log_const_source_id>:
; {
 8001680: b480         	push	{r7}
 8001682: b083         	sub	sp, #0xc
 8001684: af00         	add	r7, sp, #0x0
 8001686: 6078         	str	r0, [r7, #0x4]
; 	return ((const uint8_t *)data - (uint8_t *)TYPE_SECTION_START(log_const))/
 8001688: 687b         	ldr	r3, [r7, #0x4]
 800168a: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800169c <log_const_source_id+0x1c>
 800168c: 1a9b         	subs	r3, r3, r2
 800168e: 08db         	lsrs	r3, r3, #0x3
; }
 8001690: 4618         	mov	r0, r3
 8001692: 370c         	adds	r7, #0xc
 8001694: 46bd         	mov	sp, r7
 8001696: bc80         	pop	{r7}
 8001698: 4770         	bx	lr
 800169a: bf00         	nop

0800169c <$d>:
 800169c: fc 49 01 08  	.word	0x080149fc

080016a0 <z_log_sources_count>:
; {
 80016a0: b580         	push	{r7, lr}
 80016a2: af00         	add	r7, sp, #0x0
; 	return log_const_source_id(TYPE_SECTION_END(log_const));
 80016a4: 4802         	ldr	r0, [pc, #0x8]          @ 0x80016b0 <z_log_sources_count+0x10>
 80016a6: f7ff ffeb    	bl	0x8001680 <log_const_source_id> @ imm = #-0x2a
 80016aa: 4603         	mov	r3, r0
; }
 80016ac: 4618         	mov	r0, r3
 80016ae: bd80         	pop	{r7, pc}

080016b0 <$d>:
 80016b0: 74 4a 01 08  	.word	0x08014a74

080016b4 <log_backend_get>:
; {
 80016b4: b480         	push	{r7}
 80016b6: b085         	sub	sp, #0x14
 80016b8: af00         	add	r7, sp, #0x0
 80016ba: 6078         	str	r0, [r7, #0x4]
; 	STRUCT_SECTION_GET(log_backend, idx, &backend);
 80016bc: 687b         	ldr	r3, [r7, #0x4]
 80016be: 011b         	lsls	r3, r3, #0x4
 80016c0: 4a04         	ldr	r2, [pc, #0x10]         @ 0x80016d4 <log_backend_get+0x20>
 80016c2: 4413         	add	r3, r2
 80016c4: 60fb         	str	r3, [r7, #0xc]
; 	return backend;
 80016c6: 68fb         	ldr	r3, [r7, #0xc]
; }
 80016c8: 4618         	mov	r0, r3
 80016ca: 3714         	adds	r7, #0x14
 80016cc: 46bd         	mov	sp, r7
 80016ce: bc80         	pop	{r7}
 80016d0: 4770         	bx	lr
 80016d2: bf00         	nop

080016d4 <$d>:
 80016d4: 74 4a 01 08  	.word	0x08014a74

080016d8 <get_link_domain>:
; {
 80016d8: b480         	push	{r7}
 80016da: b085         	sub	sp, #0x14
 80016dc: af00         	add	r7, sp, #0x0
 80016de: 4603         	mov	r3, r0
 80016e0: 6039         	str	r1, [r7]
 80016e2: 71fb         	strb	r3, [r7, #0x7]
; 	STRUCT_SECTION_FOREACH(log_link, link) {
 80016e4: 4b18         	ldr	r3, [pc, #0x60]         @ 0x8001748 <get_link_domain+0x70>
 80016e6: 60fb         	str	r3, [r7, #0xc]
 80016e8: e01b         	b	0x8001722 <get_link_domain+0x4a> @ imm = #0x36
; 		domain_max = link->ctrl_blk->domain_offset +
 80016ea: 68fb         	ldr	r3, [r7, #0xc]
 80016ec: 689b         	ldr	r3, [r3, #0x8]
 80016ee: 689b         	ldr	r3, [r3, #0x8]
 80016f0: b2da         	uxtb	r2, r3
; 				link->ctrl_blk->domain_cnt;
 80016f2: 68fb         	ldr	r3, [r7, #0xc]
 80016f4: 689b         	ldr	r3, [r3, #0x8]
 80016f6: 681b         	ldr	r3, [r3]
; 		domain_max = link->ctrl_blk->domain_offset +
 80016f8: b2db         	uxtb	r3, r3
 80016fa: 4413         	add	r3, r2
 80016fc: 72fb         	strb	r3, [r7, #0xb]
; 		if (domain_id < domain_max) {
 80016fe: 79fa         	ldrb	r2, [r7, #0x7]
 8001700: 7afb         	ldrb	r3, [r7, #0xb]
 8001702: 429a         	cmp	r2, r3
 8001704: d20a         	bhs	0x800171c <get_link_domain+0x44> @ imm = #0x14
; 			*rel_domain_id = domain_id - link->ctrl_blk->domain_offset;
 8001706: 68fb         	ldr	r3, [r7, #0xc]
 8001708: 689b         	ldr	r3, [r3, #0x8]
 800170a: 689b         	ldr	r3, [r3, #0x8]
 800170c: b2db         	uxtb	r3, r3
 800170e: 79fa         	ldrb	r2, [r7, #0x7]
 8001710: 1ad3         	subs	r3, r2, r3
 8001712: b2da         	uxtb	r2, r3
 8001714: 683b         	ldr	r3, [r7]
 8001716: 701a         	strb	r2, [r3]
; 			return link;
 8001718: 68fb         	ldr	r3, [r7, #0xc]
 800171a: e00f         	b	0x800173c <get_link_domain+0x64> @ imm = #0x1e
; 	STRUCT_SECTION_FOREACH(log_link, link) {
 800171c: 68fb         	ldr	r3, [r7, #0xc]
 800171e: 3318         	adds	r3, #0x18
 8001720: 60fb         	str	r3, [r7, #0xc]
 8001722: 68fb         	ldr	r3, [r7, #0xc]
 8001724: 4a09         	ldr	r2, [pc, #0x24]         @ 0x800174c <get_link_domain+0x74>
 8001726: 4293         	cmp	r3, r2
 8001728: bf34         	ite	lo
 800172a: 2301         	movlo	r3, #0x1
 800172c: 2300         	movhs	r3, #0x0
 800172e: b2db         	uxtb	r3, r3
 8001730: 2b00         	cmp	r3, #0x0
 8001732: d1da         	bne	0x80016ea <get_link_domain+0x12> @ imm = #-0x4c
; 	*rel_domain_id = 0;
 8001734: 683b         	ldr	r3, [r7]
 8001736: 2200         	movs	r2, #0x0
 8001738: 701a         	strb	r2, [r3]
; 	return NULL;
 800173a: 2300         	movs	r3, #0x0
; }
 800173c: 4618         	mov	r0, r3
 800173e: 3714         	adds	r7, #0x14
 8001740: 46bd         	mov	sp, r7
 8001742: bc80         	pop	{r7}
 8001744: 4770         	bx	lr
 8001746: bf00         	nop

08001748 <$d>:
 8001748: 84 4a 01 08  	.word	0x08014a84
 800174c: 84 4a 01 08  	.word	0x08014a84

08001750 <link_source_name_get>:
; {
 8001750: b580         	push	{r7, lr}
 8001752: b08a         	sub	sp, #0x28
 8001754: af02         	add	r7, sp, #0x8
 8001756: 4603         	mov	r3, r0
 8001758: 6039         	str	r1, [r7]
 800175a: 71fb         	strb	r3, [r7, #0x7]
; 	size_t cache_size = sname_cache.item_size;
 800175c: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x80017d0 <link_source_name_get+0x80>
 800175e: 69db         	ldr	r3, [r3, #0x1c]
 8001760: 613b         	str	r3, [r7, #0x10]
; 	union log_source_ids id = {
 8001762: 79fb         	ldrb	r3, [r7, #0x7]
 8001764: 733b         	strb	r3, [r7, #0xc]
 8001766: 683b         	ldr	r3, [r7]
 8001768: b29b         	uxth	r3, r3
 800176a: 81fb         	strh	r3, [r7, #0xe]
; 	if (!log_cache_get(&sname_cache, id.raw, &cached)) {
 800176c: 68fb         	ldr	r3, [r7, #0xc]
 800176e: f107 0214    	add.w	r2, r7, #0x14
 8001772: 4619         	mov	r1, r3
 8001774: 4816         	ldr	r0, [pc, #0x58]         @ 0x80017d0 <link_source_name_get+0x80>
 8001776: f00c ff73    	bl	0x800e660 <log_cache_get> @ imm = #0xcee6
 800177a: 4603         	mov	r3, r0
 800177c: f083 0301    	eor	r3, r3, #0x1
 8001780: b2db         	uxtb	r3, r3
 8001782: 2b00         	cmp	r3, #0x0
 8001784: d01f         	beq	0x80017c6 <link_source_name_get+0x76> @ imm = #0x3e
; 		const struct log_link *link = get_link_domain(domain_id, &rel_domain_id);
 8001786: f107 020b    	add.w	r2, r7, #0xb
 800178a: 79fb         	ldrb	r3, [r7, #0x7]
 800178c: 4611         	mov	r1, r2
 800178e: 4618         	mov	r0, r3
 8001790: f7ff ffa2    	bl	0x80016d8 <get_link_domain> @ imm = #-0xbc
 8001794: 61f8         	str	r0, [r7, #0x1c]
; 		err = log_link_get_source_name(link, rel_domain_id, source_id,
 8001796: 7afb         	ldrb	r3, [r7, #0xb]
 8001798: 4618         	mov	r0, r3
 800179a: 683b         	ldr	r3, [r7]
 800179c: b29a         	uxth	r2, r3
 800179e: 6979         	ldr	r1, [r7, #0x14]
 80017a0: f107 0310    	add.w	r3, r7, #0x10
 80017a4: 9300         	str	r3, [sp]
 80017a6: 460b         	mov	r3, r1
 80017a8: 4601         	mov	r1, r0
 80017aa: 69f8         	ldr	r0, [r7, #0x1c]
 80017ac: f00c fdcf    	bl	0x800e34e <log_link_get_source_name> @ imm = #0xcb9e
 80017b0: 61b8         	str	r0, [r7, #0x18]
; 		if (err < 0) {
 80017b2: 69bb         	ldr	r3, [r7, #0x18]
 80017b4: 2b00         	cmp	r3, #0x0
 80017b6: da01         	bge	0x80017bc <link_source_name_get+0x6c> @ imm = #0x2
; 			return NULL;
 80017b8: 2300         	movs	r3, #0x0
 80017ba: e005         	b	0x80017c8 <link_source_name_get+0x78> @ imm = #0xa
; 		log_cache_put(&sname_cache, cached);
 80017bc: 697b         	ldr	r3, [r7, #0x14]
 80017be: 4619         	mov	r1, r3
 80017c0: 4803         	ldr	r0, [pc, #0xc]          @ 0x80017d0 <link_source_name_get+0x80>
 80017c2: f00c ffd0    	bl	0x800e766 <log_cache_put> @ imm = #0xcfa0
; 	return (const char *)cached;
 80017c6: 697b         	ldr	r3, [r7, #0x14]
; }
 80017c8: 4618         	mov	r0, r3
 80017ca: 3720         	adds	r7, #0x20
 80017cc: 46bd         	mov	sp, r7
 80017ce: bd80         	pop	{r7, pc}

080017d0 <$d>:
 80017d0: a0 05 00 20  	.word	0x200005a0

080017d4 <log_source_name_get>:
; {
 80017d4: b580         	push	{r7, lr}
 80017d6: b082         	sub	sp, #0x8
 80017d8: af00         	add	r7, sp, #0x0
 80017da: 6078         	str	r0, [r7, #0x4]
 80017dc: 6039         	str	r1, [r7]
; 	if (z_log_is_local_domain(domain_id)) {
 80017de: 687b         	ldr	r3, [r7, #0x4]
 80017e0: b2db         	uxtb	r3, r3
 80017e2: 4618         	mov	r0, r3
 80017e4: f00c fd77    	bl	0x800e2d6 <z_log_is_local_domain> @ imm = #0xcaee
 80017e8: 4603         	mov	r3, r0
 80017ea: 2b00         	cmp	r3, #0x0
 80017ec: d00d         	beq	0x800180a <log_source_name_get+0x36> @ imm = #0x1a
; 		if (source_id < log_src_cnt_get(domain_id)) {
 80017ee: 6878         	ldr	r0, [r7, #0x4]
 80017f0: f00c fddb    	bl	0x800e3aa <log_src_cnt_get> @ imm = #0xcbb6
 80017f4: 4602         	mov	r2, r0
 80017f6: 683b         	ldr	r3, [r7]
 80017f8: 4293         	cmp	r3, r2
 80017fa: d204         	bhs	0x8001806 <log_source_name_get+0x32> @ imm = #0x8
; 			return TYPE_SECTION_START(log_const)[source_id].name;
 80017fc: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8001820 <log_source_name_get+0x4c>
 80017fe: 683b         	ldr	r3, [r7]
 8001800: f852 3033    	ldr.w	r3, [r2, r3, lsl #3]
 8001804: e008         	b	0x8001818 <log_source_name_get+0x44> @ imm = #0x10
; 			return NULL;
 8001806: 2300         	movs	r3, #0x0
 8001808: e006         	b	0x8001818 <log_source_name_get+0x44> @ imm = #0xc
; 	return link_source_name_get(domain_id, source_id);
 800180a: 687b         	ldr	r3, [r7, #0x4]
 800180c: b2db         	uxtb	r3, r3
 800180e: 6839         	ldr	r1, [r7]
 8001810: 4618         	mov	r0, r3
 8001812: f7ff ff9d    	bl	0x8001750 <link_source_name_get> @ imm = #-0xc6
 8001816: 4603         	mov	r3, r0
; }
 8001818: 4618         	mov	r0, r3
 800181a: 3708         	adds	r7, #0x8
 800181c: 46bd         	mov	sp, r7
 800181e: bd80         	pop	{r7, pc}

08001820 <$d>:
 8001820: fc 49 01 08  	.word	0x080149fc

08001824 <log_const_source_id>:
; {
 8001824: b480         	push	{r7}
 8001826: b083         	sub	sp, #0xc
 8001828: af00         	add	r7, sp, #0x0
 800182a: 6078         	str	r0, [r7, #0x4]
; 	return ((const uint8_t *)data - (uint8_t *)TYPE_SECTION_START(log_const))/
 800182c: 687b         	ldr	r3, [r7, #0x4]
 800182e: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8001840 <log_const_source_id+0x1c>
 8001830: 1a9b         	subs	r3, r3, r2
 8001832: 08db         	lsrs	r3, r3, #0x3
; }
 8001834: 4618         	mov	r0, r3
 8001836: 370c         	adds	r7, #0xc
 8001838: 46bd         	mov	sp, r7
 800183a: bc80         	pop	{r7}
 800183c: 4770         	bx	lr
 800183e: bf00         	nop

08001840 <$d>:
 8001840: fc 49 01 08  	.word	0x080149fc

08001844 <z_log_msg_runtime_vcreate>:
; {
 8001844: b580         	push	{r7, lr}
 8001846: b090         	sub	sp, #0x40
 8001848: af04         	add	r7, sp, #0x10
 800184a: 60b9         	str	r1, [r7, #0x8]
 800184c: 607b         	str	r3, [r7, #0x4]
 800184e: 4603         	mov	r3, r0
 8001850: 73fb         	strb	r3, [r7, #0xf]
 8001852: 4613         	mov	r3, r2
 8001854: 73bb         	strb	r3, [r7, #0xe]
; 	if (fmt) {
 8001856: 6c3b         	ldr	r3, [r7, #0x40]
 8001858: 2b00         	cmp	r3, #0x0
 800185a: d00b         	beq	0x8001874 <z_log_msg_runtime_vcreate+0x30> @ imm = #0x16
; 		va_copy(ap2, ap);
 800185c: 6c7b         	ldr	r3, [r7, #0x44]
 800185e: 613b         	str	r3, [r7, #0x10]
; 		plen = cbvprintf_package(NULL, Z_LOG_MSG_ALIGN_OFFSET,
 8001860: 693b         	ldr	r3, [r7, #0x10]
 8001862: 9300         	str	r3, [sp]
 8001864: 6c3b         	ldr	r3, [r7, #0x40]
 8001866: 6bfa         	ldr	r2, [r7, #0x3c]
 8001868: 2110         	movs	r1, #0x10
 800186a: 2000         	movs	r0, #0x0
 800186c: f7ff f95a    	bl	0x8000b24 <cbvprintf_package> @ imm = #-0xd4c
 8001870: 62f8         	str	r0, [r7, #0x2c]
 8001872: e001         	b	0x8001878 <z_log_msg_runtime_vcreate+0x34> @ imm = #0x2
; 		plen = 0;
 8001874: 2300         	movs	r3, #0x0
 8001876: 62fb         	str	r3, [r7, #0x2c]
; 	if (plen > Z_LOG_MSG_MAX_PACKAGE) {
 8001878: 6afb         	ldr	r3, [r7, #0x2c]
 800187a: f5b3 6f00    	cmp.w	r3, #0x800
 800187e: d31d         	blo	0x80018bc <z_log_msg_runtime_vcreate+0x78> @ imm = #0x3a
; 		LOG_WRN("Message dropped because it exceeds size limitation (%u)",
 8001880: 2303         	movs	r3, #0x3
 8001882: 2b01         	cmp	r3, #0x1
 8001884: d973         	bls	0x800196e <z_log_msg_runtime_vcreate+0x12a> @ imm = #0xe6
 8001886: 2301         	movs	r3, #0x1
 8001888: 77fb         	strb	r3, [r7, #0x1f]
 800188a: 7ffb         	ldrb	r3, [r7, #0x1f]
 800188c: f083 0301    	eor	r3, r3, #0x1
 8001890: b2db         	uxtb	r3, r3
 8001892: 2b00         	cmp	r3, #0x0
 8001894: d16b         	bne	0x800196e <z_log_msg_runtime_vcreate+0x12a> @ imm = #0xd6
 8001896: 4b37         	ldr	r3, [pc, #0xdc]         @ 0x8001974 <z_log_msg_runtime_vcreate+0x130>
 8001898: 6819         	ldr	r1, [r3]
 800189a: f240 73ff    	movw	r3, #0x7ff
 800189e: 9303         	str	r3, [sp, #0xc]
 80018a0: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x8001978 <z_log_msg_runtime_vcreate+0x134>
 80018a2: 9302         	str	r3, [sp, #0x8]
 80018a4: 2300         	movs	r3, #0x0
 80018a6: 9301         	str	r3, [sp, #0x4]
 80018a8: 2300         	movs	r3, #0x0
 80018aa: 9300         	str	r3, [sp]
 80018ac: 2300         	movs	r3, #0x0
 80018ae: 2202         	movs	r2, #0x2
 80018b0: 2000         	movs	r0, #0x0
 80018b2: f00c ff6a    	bl	0x800e78a <z_log_msg_runtime_create> @ imm = #0xced4
 80018b6: 2300         	movs	r3, #0x0
 80018b8: 61bb         	str	r3, [r7, #0x18]
; 		return;
 80018ba: e058         	b	0x800196e <z_log_msg_runtime_vcreate+0x12a> @ imm = #0xb0
; 	size_t msg_wlen = Z_LOG_MSG_ALIGNED_WLEN(plen, dlen);
 80018bc: 6afa         	ldr	r2, [r7, #0x2c]
 80018be: 6bbb         	ldr	r3, [r7, #0x38]
 80018c0: 4413         	add	r3, r2
 80018c2: 3317         	adds	r3, #0x17
 80018c4: f023 0307    	bic	r3, r3, #0x7
 80018c8: 3303         	adds	r3, #0x3
 80018ca: 089b         	lsrs	r3, r3, #0x2
 80018cc: 62bb         	str	r3, [r7, #0x28]
; 	struct log_msg_desc desc =
 80018ce: 7d3b         	ldrb	r3, [r7, #0x14]
 80018d0: f36f 0300    	bfc	r3, #0, #1
 80018d4: 753b         	strb	r3, [r7, #0x14]
 80018d6: 7d3b         	ldrb	r3, [r7, #0x14]
 80018d8: f36f 0341    	bfc	r3, #1, #1
 80018dc: 753b         	strb	r3, [r7, #0x14]
 80018de: 7d3b         	ldrb	r3, [r7, #0x14]
 80018e0: f36f 0382    	bfc	r3, #2, #1
 80018e4: 753b         	strb	r3, [r7, #0x14]
 80018e6: 7bfb         	ldrb	r3, [r7, #0xf]
 80018e8: f003 0307    	and	r3, r3, #0x7
 80018ec: b2da         	uxtb	r2, r3
 80018ee: 7d3b         	ldrb	r3, [r7, #0x14]
 80018f0: f362 03c5    	bfi	r3, r2, #3, #3
 80018f4: 753b         	strb	r3, [r7, #0x14]
 80018f6: 7bbb         	ldrb	r3, [r7, #0xe]
 80018f8: f003 0307    	and	r3, r3, #0x7
 80018fc: b2da         	uxtb	r2, r3
 80018fe: 8abb         	ldrh	r3, [r7, #0x14]
 8001900: f362 1388    	bfi	r3, r2, #6, #3
 8001904: 82bb         	strh	r3, [r7, #0x14]
 8001906: 6afb         	ldr	r3, [r7, #0x2c]
 8001908: f3c3 030a    	ubfx	r3, r3, #0x0, #0xb
 800190c: b29a         	uxth	r2, r3
 800190e: 697b         	ldr	r3, [r7, #0x14]
 8001910: f362 2353    	bfi	r3, r2, #9, #11
 8001914: 617b         	str	r3, [r7, #0x14]
 8001916: 6bbb         	ldr	r3, [r7, #0x38]
 8001918: f3c3 030b    	ubfx	r3, r3, #0x0, #0xc
 800191c: b29a         	uxth	r2, r3
 800191e: 8afb         	ldrh	r3, [r7, #0x16]
 8001920: f362 130f    	bfi	r3, r2, #4, #12
 8001924: 82fb         	strh	r3, [r7, #0x16]
; 		msg = alloca(msg_wlen * sizeof(int));
 8001926: 6abb         	ldr	r3, [r7, #0x28]
 8001928: 009b         	lsls	r3, r3, #0x2
 800192a: 3307         	adds	r3, #0x7
 800192c: 08db         	lsrs	r3, r3, #0x3
 800192e: 00db         	lsls	r3, r3, #0x3
 8001930: ebad 0d03    	sub.w	sp, sp, r3
 8001934: ab04         	add	r3, sp, #0x10
 8001936: 3307         	adds	r3, #0x7
 8001938: 08db         	lsrs	r3, r3, #0x3
 800193a: 00db         	lsls	r3, r3, #0x3
 800193c: 627b         	str	r3, [r7, #0x24]
; 		pkg = msg->data;
 800193e: 6a7b         	ldr	r3, [r7, #0x24]
 8001940: 3310         	adds	r3, #0x10
 8001942: 623b         	str	r3, [r7, #0x20]
; 	if (pkg && fmt) {
 8001944: 6a3b         	ldr	r3, [r7, #0x20]
 8001946: 2b00         	cmp	r3, #0x0
 8001948: d00b         	beq	0x8001962 <z_log_msg_runtime_vcreate+0x11e> @ imm = #0x16
 800194a: 6c3b         	ldr	r3, [r7, #0x40]
 800194c: 2b00         	cmp	r3, #0x0
 800194e: d008         	beq	0x8001962 <z_log_msg_runtime_vcreate+0x11e> @ imm = #0x10
; 		plen = cbvprintf_package(pkg, (size_t)plen, package_flags, fmt, ap);
 8001950: 6af9         	ldr	r1, [r7, #0x2c]
 8001952: 6c7b         	ldr	r3, [r7, #0x44]
 8001954: 9300         	str	r3, [sp]
 8001956: 6c3b         	ldr	r3, [r7, #0x40]
 8001958: 6bfa         	ldr	r2, [r7, #0x3c]
 800195a: 6a38         	ldr	r0, [r7, #0x20]
 800195c: f7ff f8e2    	bl	0x8000b24 <cbvprintf_package> @ imm = #-0xe3c
 8001960: 62f8         	str	r0, [r7, #0x2c]
; 		z_log_msg_finalize(msg, source, desc, data);
 8001962: 687b         	ldr	r3, [r7, #0x4]
 8001964: 697a         	ldr	r2, [r7, #0x14]
 8001966: 68b9         	ldr	r1, [r7, #0x8]
 8001968: 6a78         	ldr	r0, [r7, #0x24]
 800196a: f00c ff5c    	bl	0x800e826 <z_log_msg_finalize> @ imm = #0xceb8
; }
 800196e: 3730         	adds	r7, #0x30
 8001970: 46bd         	mov	sp, r7
 8001972: bd80         	pop	{r7, pc}

08001974 <$d>:
 8001974: 0c 00 00 20  	.word	0x2000000c
 8001978: bc 4c 01 08  	.word	0x08014cbc

0800197c <cbpprintf>:
; {
 800197c: b580         	push	{r7, lr}
 800197e: b084         	sub	sp, #0x10
 8001980: af00         	add	r7, sp, #0x0
 8001982: 60f8         	str	r0, [r7, #0xc]
 8001984: 60b9         	str	r1, [r7, #0x8]
 8001986: 607a         	str	r2, [r7, #0x4]
; 	return cbpprintf_external(out, cbvprintf, ctx, packaged);
 8001988: 687b         	ldr	r3, [r7, #0x4]
 800198a: 68ba         	ldr	r2, [r7, #0x8]
 800198c: 4904         	ldr	r1, [pc, #0x10]         @ 0x80019a0 <cbpprintf+0x24>
 800198e: 68f8         	ldr	r0, [r7, #0xc]
 8001990: f00c fa62    	bl	0x800de58 <cbpprintf_external> @ imm = #0xc4c4
 8001994: 4603         	mov	r3, r0
; }
 8001996: 4618         	mov	r0, r3
 8001998: 3710         	adds	r7, #0x10
 800199a: 46bd         	mov	sp, r7
 800199c: bd80         	pop	{r7, pc}
 800199e: bf00         	nop

080019a0 <$d>:
 80019a0: 45 33 00 08  	.word	0x08003345

080019a4 <__ctype_lookup>:
; static __inline char __ctype_lookup(int c) { return (__CTYPE_PTR + 1)[c]; }
 80019a4: b480         	push	{r7}
 80019a6: b083         	sub	sp, #0xc
 80019a8: af00         	add	r7, sp, #0x0
 80019aa: 6078         	str	r0, [r7, #0x4]
 80019ac: 687b         	ldr	r3, [r7, #0x4]
 80019ae: 3301         	adds	r3, #0x1
 80019b0: 4a03         	ldr	r2, [pc, #0xc]          @ 0x80019c0 <__ctype_lookup+0x1c>
 80019b2: 4413         	add	r3, r2
 80019b4: 781b         	ldrb	r3, [r3]
 80019b6: 4618         	mov	r0, r3
 80019b8: 370c         	adds	r7, #0xc
 80019ba: 46bd         	mov	sp, r7
 80019bc: bc80         	pop	{r7}
 80019be: 4770         	bx	lr

080019c0 <$d>:
 80019c0: b4 68 01 08  	.word	0x080168b4

080019c4 <print_formatted>:
; {
 80019c4: b40e         	push	{r1, r2, r3}
 80019c6: b580         	push	{r7, lr}
 80019c8: b085         	sub	sp, #0x14
 80019ca: af00         	add	r7, sp, #0x0
 80019cc: 6078         	str	r0, [r7, #0x4]
; 	int length = 0;
 80019ce: 2300         	movs	r3, #0x0
 80019d0: 60fb         	str	r3, [r7, #0xc]
; 	va_start(args, fmt);
 80019d2: f107 0320    	add.w	r3, r7, #0x20
 80019d6: 60bb         	str	r3, [r7, #0x8]
; 	length = cbvprintf(out_func, (void *)output, fmt, args);
 80019d8: 68bb         	ldr	r3, [r7, #0x8]
 80019da: 69fa         	ldr	r2, [r7, #0x1c]
 80019dc: 6879         	ldr	r1, [r7, #0x4]
 80019de: 4806         	ldr	r0, [pc, #0x18]         @ 0x80019f8 <print_formatted+0x34>
 80019e0: f001 fcb0    	bl	0x8003344 <cbvprintf>   @ imm = #0x1960
 80019e4: 60f8         	str	r0, [r7, #0xc]
; 	return length;
 80019e6: 68fb         	ldr	r3, [r7, #0xc]
; }
 80019e8: 4618         	mov	r0, r3
 80019ea: 3714         	adds	r7, #0x14
 80019ec: 46bd         	mov	sp, r7
 80019ee: e8bd 4080    	pop.w	{r7, lr}
 80019f2: b003         	add	sp, #0xc
 80019f4: 4770         	bx	lr
 80019f6: bf00         	nop

080019f8 <$d>:
 80019f8: 03 ea 00 08  	.word	0x0800ea03

080019fc <timestamp_print>:
; {
 80019fc: b580         	push	{r7, lr}
 80019fe: b09a         	sub	sp, #0x68
 8001a00: af04         	add	r7, sp, #0x10
 8001a02: 60f8         	str	r0, [r7, #0xc]
 8001a04: 60b9         	str	r1, [r7, #0x8]
 8001a06: 607a         	str	r2, [r7, #0x4]
; 		IS_ENABLED(CONFIG_LOG_OUTPUT_FORMAT_LINUX_TIMESTAMP) |
 8001a08: 68bb         	ldr	r3, [r7, #0x8]
 8001a0a: f003 0344    	and	r3, r3, #0x44
; 	bool format =
 8001a0e: 2b00         	cmp	r3, #0x0
 8001a10: bf14         	ite	ne
 8001a12: 2301         	movne	r3, #0x1
 8001a14: 2300         	moveq	r3, #0x0
 8001a16: f887 3037    	strb.w	r3, [r7, #0x37]
; 	if (!format) {
 8001a1a: f897 3037    	ldrb.w	r3, [r7, #0x37]
 8001a1e: f083 0301    	eor	r3, r3, #0x1
 8001a22: b2db         	uxtb	r3, r3
 8001a24: 2b00         	cmp	r3, #0x0
 8001a26: d006         	beq	0x8001a36 <timestamp_print+0x3a> @ imm = #0xc
; 		length = print_formatted(output, "[%08lu] ", timestamp);
 8001a28: 687a         	ldr	r2, [r7, #0x4]
 8001a2a: 4938         	ldr	r1, [pc, #0xe0]         @ 0x8001b0c <timestamp_print+0x110>
 8001a2c: 68f8         	ldr	r0, [r7, #0xc]
 8001a2e: f7ff ffc9    	bl	0x80019c4 <print_formatted> @ imm = #-0x6e
 8001a32: 63b8         	str	r0, [r7, #0x38]
 8001a34: e065         	b	0x8001b02 <timestamp_print+0x106> @ imm = #0xca
; 	} else if (freq != 0U) {
 8001a36: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x8001b10 <timestamp_print+0x114>
 8001a38: 681b         	ldr	r3, [r3]
 8001a3a: 2b00         	cmp	r3, #0x0
 8001a3c: d05f         	beq	0x8001afe <timestamp_print+0x102> @ imm = #0xbe
; 		timestamp /= timestamp_div;
 8001a3e: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x8001b14 <timestamp_print+0x118>
 8001a40: 681b         	ldr	r3, [r3]
 8001a42: 687a         	ldr	r2, [r7, #0x4]
 8001a44: fbb2 f3f3    	udiv	r3, r2, r3
 8001a48: 607b         	str	r3, [r7, #0x4]
; 		total_seconds = timestamp / freq;
 8001a4a: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x8001b10 <timestamp_print+0x114>
 8001a4c: 681b         	ldr	r3, [r3]
 8001a4e: 687a         	ldr	r2, [r7, #0x4]
 8001a50: fbb2 f3f3    	udiv	r3, r2, r3
 8001a54: 63fb         	str	r3, [r7, #0x3c]
; 		seconds = total_seconds;
 8001a56: 6bfb         	ldr	r3, [r7, #0x3c]
 8001a58: 653b         	str	r3, [r7, #0x50]
; 		hours = seconds / 3600U;
 8001a5a: 6d3b         	ldr	r3, [r7, #0x50]
 8001a5c: 4a2e         	ldr	r2, [pc, #0xb8]         @ 0x8001b18 <timestamp_print+0x11c>
 8001a5e: fba2 2303    	umull	r2, r3, r2, r3
 8001a62: 0adb         	lsrs	r3, r3, #0xb
 8001a64: 643b         	str	r3, [r7, #0x40]
; 		seconds -= hours * 3600U;
 8001a66: 6c3b         	ldr	r3, [r7, #0x40]
 8001a68: f44f 6261    	mov.w	r2, #0xe10
 8001a6c: fb02 f303    	mul	r3, r2, r3
 8001a70: 6d3a         	ldr	r2, [r7, #0x50]
 8001a72: 1ad3         	subs	r3, r2, r3
 8001a74: 653b         	str	r3, [r7, #0x50]
; 		mins = seconds / 60U;
 8001a76: 6d3b         	ldr	r3, [r7, #0x50]
 8001a78: 4a28         	ldr	r2, [pc, #0xa0]         @ 0x8001b1c <timestamp_print+0x120>
 8001a7a: fba2 2303    	umull	r2, r3, r2, r3
 8001a7e: 095b         	lsrs	r3, r3, #0x5
 8001a80: 657b         	str	r3, [r7, #0x54]
; 		seconds -= mins * 60U;
 8001a82: 6d7a         	ldr	r2, [r7, #0x54]
 8001a84: 4613         	mov	r3, r2
 8001a86: 011b         	lsls	r3, r3, #0x4
 8001a88: 1a9b         	subs	r3, r3, r2
 8001a8a: 009b         	lsls	r3, r3, #0x2
 8001a8c: 461a         	mov	r2, r3
 8001a8e: 6d3b         	ldr	r3, [r7, #0x50]
 8001a90: 1a9b         	subs	r3, r3, r2
 8001a92: 653b         	str	r3, [r7, #0x50]
; 		remainder = timestamp % freq;
 8001a94: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x8001b10 <timestamp_print+0x114>
 8001a96: 681a         	ldr	r2, [r3]
 8001a98: 687b         	ldr	r3, [r7, #0x4]
 8001a9a: fbb3 f1f2    	udiv	r1, r3, r2
 8001a9e: fb01 f202    	mul	r2, r1, r2
 8001aa2: 1a9b         	subs	r3, r3, r2
 8001aa4: 64fb         	str	r3, [r7, #0x4c]
; 		ms = (remainder * 1000U) / freq;
 8001aa6: 6cfb         	ldr	r3, [r7, #0x4c]
 8001aa8: f44f 727a    	mov.w	r2, #0x3e8
 8001aac: fb03 f202    	mul	r2, r3, r2
 8001ab0: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x8001b10 <timestamp_print+0x114>
 8001ab2: 681b         	ldr	r3, [r3]
 8001ab4: fbb2 f3f3    	udiv	r3, r2, r3
 8001ab8: 64bb         	str	r3, [r7, #0x48]
; 		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
 8001aba: 6cfb         	ldr	r3, [r7, #0x4c]
 8001abc: f44f 727a    	mov.w	r2, #0x3e8
 8001ac0: fb03 f202    	mul	r2, r3, r2
 8001ac4: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8001b10 <timestamp_print+0x114>
 8001ac6: 681b         	ldr	r3, [r3]
 8001ac8: 6cb9         	ldr	r1, [r7, #0x48]
 8001aca: fb01 f303    	mul	r3, r1, r3
 8001ace: 1ad3         	subs	r3, r2, r3
 8001ad0: f44f 727a    	mov.w	r2, #0x3e8
 8001ad4: fb03 f202    	mul	r2, r3, r2
 8001ad8: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8001b10 <timestamp_print+0x114>
 8001ada: 681b         	ldr	r3, [r3]
 8001adc: fbb2 f3f3    	udiv	r3, r2, r3
 8001ae0: 647b         	str	r3, [r7, #0x44]
; 				length = print_formatted(output,
 8001ae2: 6c7b         	ldr	r3, [r7, #0x44]
 8001ae4: 9302         	str	r3, [sp, #0x8]
 8001ae6: 6cbb         	ldr	r3, [r7, #0x48]
 8001ae8: 9301         	str	r3, [sp, #0x4]
 8001aea: 6d3b         	ldr	r3, [r7, #0x50]
 8001aec: 9300         	str	r3, [sp]
 8001aee: 6d7b         	ldr	r3, [r7, #0x54]
 8001af0: 6c3a         	ldr	r2, [r7, #0x40]
 8001af2: 490b         	ldr	r1, [pc, #0x2c]         @ 0x8001b20 <timestamp_print+0x124>
 8001af4: 68f8         	ldr	r0, [r7, #0xc]
 8001af6: f7ff ff65    	bl	0x80019c4 <print_formatted> @ imm = #-0x136
 8001afa: 63b8         	str	r0, [r7, #0x38]
 8001afc: e001         	b	0x8001b02 <timestamp_print+0x106> @ imm = #0x2
; 		length = 0;
 8001afe: 2300         	movs	r3, #0x0
 8001b00: 63bb         	str	r3, [r7, #0x38]
; 	return length;
 8001b02: 6bbb         	ldr	r3, [r7, #0x38]
; }
 8001b04: 4618         	mov	r0, r3
 8001b06: 3758         	adds	r7, #0x58
 8001b08: 46bd         	mov	sp, r7
 8001b0a: bd80         	pop	{r7, pc}

08001b0c <$d>:
 8001b0c: 14 4d 01 08  	.word	0x08014d14
 8001b10: c0 05 00 20  	.word	0x200005c0
 8001b14: c4 05 00 20  	.word	0x200005c4
 8001b18: c5 b3 a2 91  	.word	0x91a2b3c5
 8001b1c: 89 88 88 88  	.word	0x88888889
 8001b20: 20 4d 01 08  	.word	0x08014d20

08001b24 <color_print>:
; {
 8001b24: b580         	push	{r7, lr}
 8001b26: b086         	sub	sp, #0x18
 8001b28: af00         	add	r7, sp, #0x0
 8001b2a: 60f8         	str	r0, [r7, #0xc]
 8001b2c: 607b         	str	r3, [r7, #0x4]
 8001b2e: 460b         	mov	r3, r1
 8001b30: 72fb         	strb	r3, [r7, #0xb]
 8001b32: 4613         	mov	r3, r2
 8001b34: 72bb         	strb	r3, [r7, #0xa]
; 	if (color) {
 8001b36: 7afb         	ldrb	r3, [r7, #0xb]
 8001b38: 2b00         	cmp	r3, #0x0
 8001b3a: d014         	beq	0x8001b66 <color_print+0x42> @ imm = #0x28
; 				colors[level] : LOG_COLOR_CODE_DEFAULT;
 8001b3c: 7abb         	ldrb	r3, [r7, #0xa]
 8001b3e: 2b00         	cmp	r3, #0x0
 8001b40: d00a         	beq	0x8001b58 <color_print+0x34> @ imm = #0x14
; 		const char *log_color = start && (colors[level] != NULL) ?
 8001b42: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x8001b70 <color_print+0x4c>
 8001b44: 687b         	ldr	r3, [r7, #0x4]
 8001b46: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 8001b4a: 2b00         	cmp	r3, #0x0
 8001b4c: d004         	beq	0x8001b58 <color_print+0x34> @ imm = #0x8
; 				colors[level] : LOG_COLOR_CODE_DEFAULT;
 8001b4e: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8001b70 <color_print+0x4c>
 8001b50: 687b         	ldr	r3, [r7, #0x4]
 8001b52: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 8001b56: e000         	b	0x8001b5a <color_print+0x36> @ imm = #0x0
 8001b58: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8001b74 <color_print+0x50>
; 		const char *log_color = start && (colors[level] != NULL) ?
 8001b5a: 617b         	str	r3, [r7, #0x14]
; 		print_formatted(output, "%s", log_color);
 8001b5c: 697a         	ldr	r2, [r7, #0x14]
 8001b5e: 4906         	ldr	r1, [pc, #0x18]         @ 0x8001b78 <color_print+0x54>
 8001b60: 68f8         	ldr	r0, [r7, #0xc]
 8001b62: f7ff ff2f    	bl	0x80019c4 <print_formatted> @ imm = #-0x1a2
; }
 8001b66: bf00         	nop
 8001b68: 3718         	adds	r7, #0x18
 8001b6a: 46bd         	mov	sp, r7
 8001b6c: bd80         	pop	{r7, pc}
 8001b6e: bf00         	nop

08001b70 <$d>:
 8001b70: 54 62 01 08  	.word	0x08016254
 8001b74: 3c 4d 01 08  	.word	0x08014d3c
 8001b78: 44 4d 01 08  	.word	0x08014d44

08001b7c <ids_print>:
; {
 8001b7c: b580         	push	{r7, lr}
 8001b7e: b084         	sub	sp, #0x10
 8001b80: af00         	add	r7, sp, #0x0
 8001b82: 6078         	str	r0, [r7, #0x4]
 8001b84: 4608         	mov	r0, r1
 8001b86: 4611         	mov	r1, r2
 8001b88: 461a         	mov	r2, r3
 8001b8a: 4603         	mov	r3, r0
 8001b8c: 70fb         	strb	r3, [r7, #0x3]
 8001b8e: 460b         	mov	r3, r1
 8001b90: 70bb         	strb	r3, [r7, #0x2]
 8001b92: 4613         	mov	r3, r2
 8001b94: 707b         	strb	r3, [r7, #0x1]
; 	int total = 0;
 8001b96: 2300         	movs	r3, #0x0
 8001b98: 60fb         	str	r3, [r7, #0xc]
; 	if (level_on) {
 8001b9a: 78fb         	ldrb	r3, [r7, #0x3]
 8001b9c: 2b00         	cmp	r3, #0x0
 8001b9e: d00c         	beq	0x8001bba <ids_print+0x3e> @ imm = #0x18
; 		total += print_formatted(output, "<%s> ", severity[level]);
 8001ba0: 4a19         	ldr	r2, [pc, #0x64]         @ 0x8001c08 <ids_print+0x8c>
 8001ba2: 6a7b         	ldr	r3, [r7, #0x24]
 8001ba4: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 8001ba8: 461a         	mov	r2, r3
 8001baa: 4918         	ldr	r1, [pc, #0x60]         @ 0x8001c0c <ids_print+0x90>
 8001bac: 6878         	ldr	r0, [r7, #0x4]
 8001bae: f7ff ff09    	bl	0x80019c4 <print_formatted> @ imm = #-0x1ee
 8001bb2: 4602         	mov	r2, r0
 8001bb4: 68fb         	ldr	r3, [r7, #0xc]
 8001bb6: 4413         	add	r3, r2
 8001bb8: 60fb         	str	r3, [r7, #0xc]
; 	if (domain) {
 8001bba: 69bb         	ldr	r3, [r7, #0x18]
 8001bbc: 2b00         	cmp	r3, #0x0
 8001bbe: d008         	beq	0x8001bd2 <ids_print+0x56> @ imm = #0x10
; 		total += print_formatted(output, "%s/", domain);
 8001bc0: 69ba         	ldr	r2, [r7, #0x18]
 8001bc2: 4913         	ldr	r1, [pc, #0x4c]         @ 0x8001c10 <ids_print+0x94>
 8001bc4: 6878         	ldr	r0, [r7, #0x4]
 8001bc6: f7ff fefd    	bl	0x80019c4 <print_formatted> @ imm = #-0x206
 8001bca: 4602         	mov	r2, r0
 8001bcc: 68fb         	ldr	r3, [r7, #0xc]
 8001bce: 4413         	add	r3, r2
 8001bd0: 60fb         	str	r3, [r7, #0xc]
; 	if (source) {
 8001bd2: 69fb         	ldr	r3, [r7, #0x1c]
 8001bd4: 2b00         	cmp	r3, #0x0
 8001bd6: d011         	beq	0x8001bfc <ids_print+0x80> @ imm = #0x22
; 		total += print_formatted(output,
 8001bd8: 78bb         	ldrb	r3, [r7, #0x2]
 8001bda: 2b00         	cmp	r3, #0x0
 8001bdc: d004         	beq	0x8001be8 <ids_print+0x6c> @ imm = #0x8
; 				(func_on &&
 8001bde: 6a7b         	ldr	r3, [r7, #0x24]
 8001be0: 2b04         	cmp	r3, #0x4
 8001be2: d101         	bne	0x8001be8 <ids_print+0x6c> @ imm = #0x2
; 		total += print_formatted(output,
 8001be4: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8001c14 <ids_print+0x98>
 8001be6: e000         	b	0x8001bea <ids_print+0x6e> @ imm = #0x0
 8001be8: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8001c18 <ids_print+0x9c>
 8001bea: 69fa         	ldr	r2, [r7, #0x1c]
 8001bec: 4619         	mov	r1, r3
 8001bee: 6878         	ldr	r0, [r7, #0x4]
 8001bf0: f7ff fee8    	bl	0x80019c4 <print_formatted> @ imm = #-0x230
 8001bf4: 4602         	mov	r2, r0
 8001bf6: 68fb         	ldr	r3, [r7, #0xc]
 8001bf8: 4413         	add	r3, r2
 8001bfa: 60fb         	str	r3, [r7, #0xc]
; 	return total;
 8001bfc: 68fb         	ldr	r3, [r7, #0xc]
; }
 8001bfe: 4618         	mov	r0, r3
 8001c00: 3710         	adds	r7, #0x10
 8001c02: 46bd         	mov	sp, r7
 8001c04: bd80         	pop	{r7, pc}
 8001c06: bf00         	nop

08001c08 <$d>:
 8001c08: 40 62 01 08  	.word	0x08016240
 8001c0c: 48 4d 01 08  	.word	0x08014d48
 8001c10: 50 4d 01 08  	.word	0x08014d50
 8001c14: 54 4d 01 08  	.word	0x08014d54
 8001c18: 58 4d 01 08  	.word	0x08014d58

08001c1c <newline_print>:
; {
 8001c1c: b580         	push	{r7, lr}
 8001c1e: b082         	sub	sp, #0x8
 8001c20: af00         	add	r7, sp, #0x0
 8001c22: 6078         	str	r0, [r7, #0x4]
 8001c24: 6039         	str	r1, [r7]
; 	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
 8001c26: 683b         	ldr	r3, [r7]
 8001c28: f003 0310    	and	r3, r3, #0x10
 8001c2c: 2b00         	cmp	r3, #0x0
 8001c2e: d10e         	bne	0x8001c4e <newline_print+0x32> @ imm = #0x1c
; 	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
 8001c30: 683b         	ldr	r3, [r7]
 8001c32: f003 0320    	and	r3, r3, #0x20
 8001c36: 2b00         	cmp	r3, #0x0
 8001c38: d004         	beq	0x8001c44 <newline_print+0x28> @ imm = #0x8
; 		print_formatted(ctx, "\n");
 8001c3a: 4907         	ldr	r1, [pc, #0x1c]         @ 0x8001c58 <newline_print+0x3c>
 8001c3c: 6878         	ldr	r0, [r7, #0x4]
 8001c3e: f7ff fec1    	bl	0x80019c4 <print_formatted> @ imm = #-0x27e
 8001c42: e005         	b	0x8001c50 <newline_print+0x34> @ imm = #0xa
; 		print_formatted(ctx, "\r\n");
 8001c44: 4905         	ldr	r1, [pc, #0x14]         @ 0x8001c5c <newline_print+0x40>
 8001c46: 6878         	ldr	r0, [r7, #0x4]
 8001c48: f7ff febc    	bl	0x80019c4 <print_formatted> @ imm = #-0x288
 8001c4c: e000         	b	0x8001c50 <newline_print+0x34> @ imm = #0x0
; 		return;
 8001c4e: bf00         	nop
; }
 8001c50: 3708         	adds	r7, #0x8
 8001c52: 46bd         	mov	sp, r7
 8001c54: bd80         	pop	{r7, pc}
 8001c56: bf00         	nop

08001c58 <$d>:
 8001c58: 60 4d 01 08  	.word	0x08014d60
 8001c5c: 64 4d 01 08  	.word	0x08014d64

08001c60 <hexdump_line_print>:
; {
 8001c60: b580         	push	{r7, lr}
 8001c62: b088         	sub	sp, #0x20
 8001c64: af00         	add	r7, sp, #0x0
 8001c66: 60f8         	str	r0, [r7, #0xc]
 8001c68: 60b9         	str	r1, [r7, #0x8]
 8001c6a: 607a         	str	r2, [r7, #0x4]
 8001c6c: 603b         	str	r3, [r7]
; 	newline_print(output, flags);
 8001c6e: 6ab9         	ldr	r1, [r7, #0x28]
 8001c70: 68f8         	ldr	r0, [r7, #0xc]
 8001c72: f7ff ffd3    	bl	0x8001c1c <newline_print> @ imm = #-0x5a
; 	for (int i = 0; i < prefix_offset; i++) {
 8001c76: 2300         	movs	r3, #0x0
 8001c78: 61fb         	str	r3, [r7, #0x1c]
 8001c7a: e006         	b	0x8001c8a <hexdump_line_print+0x2a> @ imm = #0xc
; 		print_formatted(output, " ");
 8001c7c: 4937         	ldr	r1, [pc, #0xdc]         @ 0x8001d5c <hexdump_line_print+0xfc>
 8001c7e: 68f8         	ldr	r0, [r7, #0xc]
 8001c80: f7ff fea0    	bl	0x80019c4 <print_formatted> @ imm = #-0x2c0
; 	for (int i = 0; i < prefix_offset; i++) {
 8001c84: 69fb         	ldr	r3, [r7, #0x1c]
 8001c86: 3301         	adds	r3, #0x1
 8001c88: 61fb         	str	r3, [r7, #0x1c]
 8001c8a: 69fa         	ldr	r2, [r7, #0x1c]
 8001c8c: 683b         	ldr	r3, [r7]
 8001c8e: 429a         	cmp	r2, r3
 8001c90: dbf4         	blt	0x8001c7c <hexdump_line_print+0x1c> @ imm = #-0x18
; 	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
 8001c92: 2300         	movs	r3, #0x0
 8001c94: 61bb         	str	r3, [r7, #0x18]
 8001c96: e020         	b	0x8001cda <hexdump_line_print+0x7a> @ imm = #0x40
; 		if (i > 0 && !(i % 8)) {
 8001c98: 69bb         	ldr	r3, [r7, #0x18]
 8001c9a: 2b00         	cmp	r3, #0x0
 8001c9c: dd08         	ble	0x8001cb0 <hexdump_line_print+0x50> @ imm = #0x10
 8001c9e: 69bb         	ldr	r3, [r7, #0x18]
 8001ca0: f003 0307    	and	r3, r3, #0x7
 8001ca4: 2b00         	cmp	r3, #0x0
 8001ca6: d103         	bne	0x8001cb0 <hexdump_line_print+0x50> @ imm = #0x6
; 			print_formatted(output, " ");
 8001ca8: 492c         	ldr	r1, [pc, #0xb0]         @ 0x8001d5c <hexdump_line_print+0xfc>
 8001caa: 68f8         	ldr	r0, [r7, #0xc]
 8001cac: f7ff fe8a    	bl	0x80019c4 <print_formatted> @ imm = #-0x2ec
; 		if (i < length) {
 8001cb0: 69bb         	ldr	r3, [r7, #0x18]
 8001cb2: 687a         	ldr	r2, [r7, #0x4]
 8001cb4: 429a         	cmp	r2, r3
 8001cb6: d909         	bls	0x8001ccc <hexdump_line_print+0x6c> @ imm = #0x12
; 			print_formatted(output, "%02x ", data[i]);
 8001cb8: 69bb         	ldr	r3, [r7, #0x18]
 8001cba: 68ba         	ldr	r2, [r7, #0x8]
 8001cbc: 4413         	add	r3, r2
 8001cbe: 781b         	ldrb	r3, [r3]
 8001cc0: 461a         	mov	r2, r3
 8001cc2: 4927         	ldr	r1, [pc, #0x9c]         @ 0x8001d60 <hexdump_line_print+0x100>
 8001cc4: 68f8         	ldr	r0, [r7, #0xc]
 8001cc6: f7ff fe7d    	bl	0x80019c4 <print_formatted> @ imm = #-0x306
 8001cca: e003         	b	0x8001cd4 <hexdump_line_print+0x74> @ imm = #0x6
; 			print_formatted(output, "   ");
 8001ccc: 4925         	ldr	r1, [pc, #0x94]         @ 0x8001d64 <hexdump_line_print+0x104>
 8001cce: 68f8         	ldr	r0, [r7, #0xc]
 8001cd0: f7ff fe78    	bl	0x80019c4 <print_formatted> @ imm = #-0x310
; 	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
 8001cd4: 69bb         	ldr	r3, [r7, #0x18]
 8001cd6: 3301         	adds	r3, #0x1
 8001cd8: 61bb         	str	r3, [r7, #0x18]
 8001cda: 69bb         	ldr	r3, [r7, #0x18]
 8001cdc: 2b0f         	cmp	r3, #0xf
 8001cde: dddb         	ble	0x8001c98 <hexdump_line_print+0x38> @ imm = #-0x4a
; 	print_formatted(output, "|");
 8001ce0: 4921         	ldr	r1, [pc, #0x84]         @ 0x8001d68 <hexdump_line_print+0x108>
 8001ce2: 68f8         	ldr	r0, [r7, #0xc]
 8001ce4: f7ff fe6e    	bl	0x80019c4 <print_formatted> @ imm = #-0x324
; 	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
 8001ce8: 2300         	movs	r3, #0x0
 8001cea: 617b         	str	r3, [r7, #0x14]
 8001cec: e02d         	b	0x8001d4a <hexdump_line_print+0xea> @ imm = #0x5a
; 		if (i > 0 && !(i % 8)) {
 8001cee: 697b         	ldr	r3, [r7, #0x14]
 8001cf0: 2b00         	cmp	r3, #0x0
 8001cf2: dd08         	ble	0x8001d06 <hexdump_line_print+0xa6> @ imm = #0x10
 8001cf4: 697b         	ldr	r3, [r7, #0x14]
 8001cf6: f003 0307    	and	r3, r3, #0x7
 8001cfa: 2b00         	cmp	r3, #0x0
 8001cfc: d103         	bne	0x8001d06 <hexdump_line_print+0xa6> @ imm = #0x6
; 			print_formatted(output, " ");
 8001cfe: 4917         	ldr	r1, [pc, #0x5c]         @ 0x8001d5c <hexdump_line_print+0xfc>
 8001d00: 68f8         	ldr	r0, [r7, #0xc]
 8001d02: f7ff fe5f    	bl	0x80019c4 <print_formatted> @ imm = #-0x342
; 		if (i < length) {
 8001d06: 697b         	ldr	r3, [r7, #0x14]
 8001d08: 687a         	ldr	r2, [r7, #0x4]
 8001d0a: 429a         	cmp	r2, r3
 8001d0c: d916         	bls	0x8001d3c <hexdump_line_print+0xdc> @ imm = #0x2c
; 			unsigned char c = (unsigned char)data[i];
 8001d0e: 697b         	ldr	r3, [r7, #0x14]
 8001d10: 68ba         	ldr	r2, [r7, #0x8]
 8001d12: 4413         	add	r3, r2
 8001d14: 781b         	ldrb	r3, [r3]
 8001d16: 74fb         	strb	r3, [r7, #0x13]
; 			      isprint((int)c) != 0 ? c : '.');
 8001d18: 7cfb         	ldrb	r3, [r7, #0x13]
 8001d1a: 4618         	mov	r0, r3
 8001d1c: f7ff fe42    	bl	0x80019a4 <__ctype_lookup> @ imm = #-0x37c
 8001d20: 4603         	mov	r3, r0
 8001d22: f003 0397    	and	r3, r3, #0x97
; 			print_formatted(output, "%c",
 8001d26: 2b00         	cmp	r3, #0x0
 8001d28: d001         	beq	0x8001d2e <hexdump_line_print+0xce> @ imm = #0x2
 8001d2a: 7cfb         	ldrb	r3, [r7, #0x13]
 8001d2c: e000         	b	0x8001d30 <hexdump_line_print+0xd0> @ imm = #0x0
 8001d2e: 232e         	movs	r3, #0x2e
 8001d30: 461a         	mov	r2, r3
 8001d32: 490e         	ldr	r1, [pc, #0x38]         @ 0x8001d6c <hexdump_line_print+0x10c>
 8001d34: 68f8         	ldr	r0, [r7, #0xc]
 8001d36: f7ff fe45    	bl	0x80019c4 <print_formatted> @ imm = #-0x376
 8001d3a: e003         	b	0x8001d44 <hexdump_line_print+0xe4> @ imm = #0x6
; 			print_formatted(output, " ");
 8001d3c: 4907         	ldr	r1, [pc, #0x1c]         @ 0x8001d5c <hexdump_line_print+0xfc>
 8001d3e: 68f8         	ldr	r0, [r7, #0xc]
 8001d40: f7ff fe40    	bl	0x80019c4 <print_formatted> @ imm = #-0x380
; 	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
 8001d44: 697b         	ldr	r3, [r7, #0x14]
 8001d46: 3301         	adds	r3, #0x1
 8001d48: 617b         	str	r3, [r7, #0x14]
 8001d4a: 697b         	ldr	r3, [r7, #0x14]
 8001d4c: 2b0f         	cmp	r3, #0xf
 8001d4e: ddce         	ble	0x8001cee <hexdump_line_print+0x8e> @ imm = #-0x64
; }
 8001d50: bf00         	nop
 8001d52: bf00         	nop
 8001d54: 3720         	adds	r7, #0x20
 8001d56: 46bd         	mov	sp, r7
 8001d58: bd80         	pop	{r7, pc}
 8001d5a: bf00         	nop

08001d5c <$d>:
 8001d5c: 68 4d 01 08  	.word	0x08014d68
 8001d60: 6c 4d 01 08  	.word	0x08014d6c
 8001d64: 74 4d 01 08  	.word	0x08014d74
 8001d68: 78 4d 01 08  	.word	0x08014d78
 8001d6c: 7c 4d 01 08  	.word	0x08014d7c

08001d70 <prefix_print>:
; {
 8001d70: b590         	push	{r4, r7, lr}
 8001d72: b08d         	sub	sp, #0x34
 8001d74: af04         	add	r7, sp, #0x10
 8001d76: 60f8         	str	r0, [r7, #0xc]
 8001d78: 60b9         	str	r1, [r7, #0x8]
 8001d7a: 603b         	str	r3, [r7]
 8001d7c: 4613         	mov	r3, r2
 8001d7e: 71fb         	strb	r3, [r7, #0x7]
; 	uint32_t length = 0U;
 8001d80: 2300         	movs	r3, #0x0
 8001d82: 61fb         	str	r3, [r7, #0x1c]
; 	bool stamp = flags & LOG_OUTPUT_FLAG_TIMESTAMP;
 8001d84: 68bb         	ldr	r3, [r7, #0x8]
 8001d86: f003 0302    	and	r3, r3, #0x2
 8001d8a: 2b00         	cmp	r3, #0x0
 8001d8c: bf14         	ite	ne
 8001d8e: 2301         	movne	r3, #0x1
 8001d90: 2300         	moveq	r3, #0x0
 8001d92: 76fb         	strb	r3, [r7, #0x1b]
; 	bool colors_on = flags & LOG_OUTPUT_FLAG_COLORS;
 8001d94: 68bb         	ldr	r3, [r7, #0x8]
 8001d96: f003 0301    	and	r3, r3, #0x1
 8001d9a: 2b00         	cmp	r3, #0x0
 8001d9c: bf14         	ite	ne
 8001d9e: 2301         	movne	r3, #0x1
 8001da0: 2300         	moveq	r3, #0x0
 8001da2: 76bb         	strb	r3, [r7, #0x1a]
; 	bool level_on = flags & LOG_OUTPUT_FLAG_LEVEL;
 8001da4: 68bb         	ldr	r3, [r7, #0x8]
 8001da6: f003 0308    	and	r3, r3, #0x8
 8001daa: 2b00         	cmp	r3, #0x0
 8001dac: bf14         	ite	ne
 8001dae: 2301         	movne	r3, #0x1
 8001db0: 2300         	moveq	r3, #0x0
 8001db2: 767b         	strb	r3, [r7, #0x19]
; 	bool thread_on = IS_ENABLED(CONFIG_LOG_THREAD_ID_PREFIX) &&
 8001db4: 2300         	movs	r3, #0x0
 8001db6: 74fb         	strb	r3, [r7, #0x13]
; 	bool source_off = flags & LOG_OUTPUT_FLAG_SKIP_SOURCE;
 8001db8: 68bb         	ldr	r3, [r7, #0x8]
 8001dba: f403 7380    	and	r3, r3, #0x100
 8001dbe: 2b00         	cmp	r3, #0x0
 8001dc0: bf14         	ite	ne
 8001dc2: 2301         	movne	r3, #0x1
 8001dc4: 2300         	moveq	r3, #0x0
 8001dc6: 763b         	strb	r3, [r7, #0x18]
; 	const char *tag = IS_ENABLED(CONFIG_LOG) ? z_log_get_tag() : NULL;
 8001dc8: f00c fa75    	bl	0x800e2b6 <z_log_get_tag> @ imm = #0xc4ea
 8001dcc: 6178         	str	r0, [r7, #0x14]
; 	if (tag) {
 8001dce: 697b         	ldr	r3, [r7, #0x14]
 8001dd0: 2b00         	cmp	r3, #0x0
 8001dd2: d009         	beq	0x8001de8 <prefix_print+0x78> @ imm = #0x12
; 		length += print_formatted(output, "%s ", tag);
 8001dd4: 697a         	ldr	r2, [r7, #0x14]
 8001dd6: 491e         	ldr	r1, [pc, #0x78]         @ 0x8001e50 <prefix_print+0xe0>
 8001dd8: 68f8         	ldr	r0, [r7, #0xc]
 8001dda: f7ff fdf3    	bl	0x80019c4 <print_formatted> @ imm = #-0x41a
 8001dde: 4603         	mov	r3, r0
 8001de0: 461a         	mov	r2, r3
 8001de2: 69fb         	ldr	r3, [r7, #0x1c]
 8001de4: 4413         	add	r3, r2
 8001de6: 61fb         	str	r3, [r7, #0x1c]
; 	if (stamp) {
 8001de8: 7efb         	ldrb	r3, [r7, #0x1b]
 8001dea: 2b00         	cmp	r3, #0x0
 8001dec: d009         	beq	0x8001e02 <prefix_print+0x92> @ imm = #0x12
; 		length += timestamp_print(output, flags, timestamp);
 8001dee: 683a         	ldr	r2, [r7]
 8001df0: 68b9         	ldr	r1, [r7, #0x8]
 8001df2: 68f8         	ldr	r0, [r7, #0xc]
 8001df4: f7ff fe02    	bl	0x80019fc <timestamp_print> @ imm = #-0x3fc
 8001df8: 4603         	mov	r3, r0
 8001dfa: 461a         	mov	r2, r3
 8001dfc: 69fb         	ldr	r3, [r7, #0x1c]
 8001dfe: 4413         	add	r3, r2
 8001e00: 61fb         	str	r3, [r7, #0x1c]
; 		color_prefix(output, colors_on, level);
 8001e02: f897 203c    	ldrb.w	r2, [r7, #0x3c]
 8001e06: 7ebb         	ldrb	r3, [r7, #0x1a]
 8001e08: 4619         	mov	r1, r3
 8001e0a: 68f8         	ldr	r0, [r7, #0xc]
 8001e0c: f00c fe26    	bl	0x800ea5c <color_prefix> @ imm = #0xcc4c
; 	length += ids_print(output, level_on, func_on, thread_on, domain,
 8001e10: 7cfc         	ldrb	r4, [r7, #0x13]
 8001e12: 7e3b         	ldrb	r3, [r7, #0x18]
 8001e14: 2b00         	cmp	r3, #0x0
 8001e16: d001         	beq	0x8001e1c <prefix_print+0xac> @ imm = #0x2
 8001e18: 2300         	movs	r3, #0x0
 8001e1a: e000         	b	0x8001e1e <prefix_print+0xae> @ imm = #0x0
 8001e1c: 6b7b         	ldr	r3, [r7, #0x34]
 8001e1e: f897 203c    	ldrb.w	r2, [r7, #0x3c]
 8001e22: 79f8         	ldrb	r0, [r7, #0x7]
 8001e24: 7e79         	ldrb	r1, [r7, #0x19]
 8001e26: 9203         	str	r2, [sp, #0xc]
 8001e28: 6bba         	ldr	r2, [r7, #0x38]
 8001e2a: 9202         	str	r2, [sp, #0x8]
 8001e2c: 9301         	str	r3, [sp, #0x4]
 8001e2e: 6b3b         	ldr	r3, [r7, #0x30]
 8001e30: 9300         	str	r3, [sp]
 8001e32: 4623         	mov	r3, r4
 8001e34: 4602         	mov	r2, r0
 8001e36: 68f8         	ldr	r0, [r7, #0xc]
 8001e38: f7ff fea0    	bl	0x8001b7c <ids_print>   @ imm = #-0x2c0
 8001e3c: 4603         	mov	r3, r0
 8001e3e: 461a         	mov	r2, r3
 8001e40: 69fb         	ldr	r3, [r7, #0x1c]
 8001e42: 4413         	add	r3, r2
 8001e44: 61fb         	str	r3, [r7, #0x1c]
; 	return length;
 8001e46: 69fb         	ldr	r3, [r7, #0x1c]
; }
 8001e48: 4618         	mov	r0, r3
 8001e4a: 3724         	adds	r7, #0x24
 8001e4c: 46bd         	mov	sp, r7
 8001e4e: bd90         	pop	{r4, r7, pc}

08001e50 <$d>:
 8001e50: 88 4d 01 08  	.word	0x08014d88

08001e54 <log_output_process>:
; {
 8001e54: b580         	push	{r7, lr}
 8001e56: b08c         	sub	sp, #0x30
 8001e58: af04         	add	r7, sp, #0x10
 8001e5a: 60f8         	str	r0, [r7, #0xc]
 8001e5c: 60b9         	str	r1, [r7, #0x8]
 8001e5e: 607a         	str	r2, [r7, #0x4]
 8001e60: 603b         	str	r3, [r7]
; 	bool raw_string = (level == LOG_LEVEL_INTERNAL_RAW_STRING);
 8001e62: f897 302c    	ldrb.w	r3, [r7, #0x2c]
 8001e66: 2b00         	cmp	r3, #0x0
 8001e68: bf0c         	ite	eq
 8001e6a: 2301         	moveq	r3, #0x1
 8001e6c: 2300         	movne	r3, #0x0
 8001e6e: 75fb         	strb	r3, [r7, #0x17]
; 	if (!raw_string) {
 8001e70: 7dfb         	ldrb	r3, [r7, #0x17]
 8001e72: f083 0301    	eor	r3, r3, #0x1
 8001e76: b2db         	uxtb	r3, r3
 8001e78: 2b00         	cmp	r3, #0x0
 8001e7a: d012         	beq	0x8001ea2 <log_output_process+0x4e> @ imm = #0x24
; 		prefix_offset = prefix_print(output, flags, 0, timestamp,
 8001e7c: f897 302c    	ldrb.w	r3, [r7, #0x2c]
 8001e80: 9303         	str	r3, [sp, #0xc]
 8001e82: 6abb         	ldr	r3, [r7, #0x28]
 8001e84: 9302         	str	r3, [sp, #0x8]
 8001e86: 683b         	ldr	r3, [r7]
 8001e88: 9301         	str	r3, [sp, #0x4]
 8001e8a: 687b         	ldr	r3, [r7, #0x4]
 8001e8c: 9300         	str	r3, [sp]
 8001e8e: 68bb         	ldr	r3, [r7, #0x8]
 8001e90: 2200         	movs	r2, #0x0
 8001e92: 6bf9         	ldr	r1, [r7, #0x3c]
 8001e94: 68f8         	ldr	r0, [r7, #0xc]
 8001e96: f7ff ff6b    	bl	0x8001d70 <prefix_print> @ imm = #-0x12a
 8001e9a: 61f8         	str	r0, [r7, #0x1c]
; 		cb = out_func;
 8001e9c: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x8001f08 <log_output_process+0xb4>
 8001e9e: 61bb         	str	r3, [r7, #0x18]
 8001ea0: e008         	b	0x8001eb4 <log_output_process+0x60> @ imm = #0x10
; 		prefix_offset = 0;
 8001ea2: 2300         	movs	r3, #0x0
 8001ea4: 61fb         	str	r3, [r7, #0x1c]
; 		cb = ((uintptr_t)source == 1) ? out_func : cr_out_func;
 8001ea6: 683b         	ldr	r3, [r7]
 8001ea8: 2b01         	cmp	r3, #0x1
 8001eaa: d101         	bne	0x8001eb0 <log_output_process+0x5c> @ imm = #0x2
 8001eac: 4b16         	ldr	r3, [pc, #0x58]         @ 0x8001f08 <log_output_process+0xb4>
 8001eae: e000         	b	0x8001eb2 <log_output_process+0x5e> @ imm = #0x0
 8001eb0: 4b16         	ldr	r3, [pc, #0x58]         @ 0x8001f0c <log_output_process+0xb8>
 8001eb2: 61bb         	str	r3, [r7, #0x18]
; 	if (package) {
 8001eb4: 6b3b         	ldr	r3, [r7, #0x30]
 8001eb6: 2b00         	cmp	r3, #0x0
 8001eb8: d005         	beq	0x8001ec6 <log_output_process+0x72> @ imm = #0xa
; 		int err = cbpprintf(cb, (void *)output, (void *)package);
 8001eba: 6b3a         	ldr	r2, [r7, #0x30]
 8001ebc: 68f9         	ldr	r1, [r7, #0xc]
 8001ebe: 69b8         	ldr	r0, [r7, #0x18]
 8001ec0: f7ff fd5c    	bl	0x800197c <cbpprintf>   @ imm = #-0x548
 8001ec4: 6138         	str	r0, [r7, #0x10]
; 	if (data_len) {
 8001ec6: 6bbb         	ldr	r3, [r7, #0x38]
 8001ec8: 2b00         	cmp	r3, #0x0
 8001eca: d008         	beq	0x8001ede <log_output_process+0x8a> @ imm = #0x10
; 		log_msg_hexdump(output, (uint8_t *)data, data_len, prefix_offset, flags);
 8001ecc: 69fa         	ldr	r2, [r7, #0x1c]
 8001ece: 6bfb         	ldr	r3, [r7, #0x3c]
 8001ed0: 9300         	str	r3, [sp]
 8001ed2: 4613         	mov	r3, r2
 8001ed4: 6bba         	ldr	r2, [r7, #0x38]
 8001ed6: 6b79         	ldr	r1, [r7, #0x34]
 8001ed8: 68f8         	ldr	r0, [r7, #0xc]
 8001eda: f00c fde1    	bl	0x800eaa0 <log_msg_hexdump> @ imm = #0xcbc2
; 	if (!raw_string) {
 8001ede: 7dfb         	ldrb	r3, [r7, #0x17]
 8001ee0: f083 0301    	eor	r3, r3, #0x1
 8001ee4: b2db         	uxtb	r3, r3
 8001ee6: 2b00         	cmp	r3, #0x0
 8001ee8: d006         	beq	0x8001ef8 <log_output_process+0xa4> @ imm = #0xc
; 		postfix_print(output, flags, level);
 8001eea: f897 302c    	ldrb.w	r3, [r7, #0x2c]
 8001eee: 461a         	mov	r2, r3
 8001ef0: 6bf9         	ldr	r1, [r7, #0x3c]
 8001ef2: 68f8         	ldr	r0, [r7, #0xc]
 8001ef4: f00c fdf8    	bl	0x800eae8 <postfix_print> @ imm = #0xcbf0
; 	log_output_flush(output);
 8001ef8: 68f8         	ldr	r0, [r7, #0xc]
 8001efa: f00c fd69    	bl	0x800e9d0 <log_output_flush> @ imm = #0xcad2
; }
 8001efe: bf00         	nop
 8001f00: 3720         	adds	r7, #0x20
 8001f02: 46bd         	mov	sp, r7
 8001f04: bd80         	pop	{r7, pc}
 8001f06: bf00         	nop

08001f08 <$d>:
 8001f08: 03 ea 00 08  	.word	0x0800ea03
 8001f0c: 33 ea 00 08  	.word	0x0800ea33

08001f10 <log_output_timestamp_freq_set>:
; {
 8001f10: b480         	push	{r7}
 8001f12: b083         	sub	sp, #0xc
 8001f14: af00         	add	r7, sp, #0x0
 8001f16: 6078         	str	r0, [r7, #0x4]
; 	timestamp_div = 1U;
 8001f18: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8001f48 <log_output_timestamp_freq_set+0x38>
 8001f1a: 2201         	movs	r2, #0x1
 8001f1c: 601a         	str	r2, [r3]
; 	while (frequency > 1000000) {
 8001f1e: e007         	b	0x8001f30 <log_output_timestamp_freq_set+0x20> @ imm = #0xe
; 		frequency /= 2U;
 8001f20: 687b         	ldr	r3, [r7, #0x4]
 8001f22: 085b         	lsrs	r3, r3, #0x1
 8001f24: 607b         	str	r3, [r7, #0x4]
; 		timestamp_div *= 2U;
 8001f26: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8001f48 <log_output_timestamp_freq_set+0x38>
 8001f28: 681b         	ldr	r3, [r3]
 8001f2a: 005b         	lsls	r3, r3, #0x1
 8001f2c: 4a06         	ldr	r2, [pc, #0x18]         @ 0x8001f48 <log_output_timestamp_freq_set+0x38>
 8001f2e: 6013         	str	r3, [r2]
; 	while (frequency > 1000000) {
 8001f30: 687b         	ldr	r3, [r7, #0x4]
 8001f32: 4a06         	ldr	r2, [pc, #0x18]         @ 0x8001f4c <log_output_timestamp_freq_set+0x3c>
 8001f34: 4293         	cmp	r3, r2
 8001f36: d8f3         	bhi	0x8001f20 <log_output_timestamp_freq_set+0x10> @ imm = #-0x1a
; 	freq = frequency;
 8001f38: 4a05         	ldr	r2, [pc, #0x14]         @ 0x8001f50 <log_output_timestamp_freq_set+0x40>
 8001f3a: 687b         	ldr	r3, [r7, #0x4]
 8001f3c: 6013         	str	r3, [r2]
; }
 8001f3e: bf00         	nop
 8001f40: 370c         	adds	r7, #0xc
 8001f42: 46bd         	mov	sp, r7
 8001f44: bc80         	pop	{r7}
 8001f46: 4770         	bx	lr

08001f48 <$d>:
 8001f48: c4 05 00 20  	.word	0x200005c4
 8001f4c: 40 42 0f 00  	.word	0x000f4240
 8001f50: c0 05 00 20  	.word	0x200005c0

08001f54 <char_out>:
; {
 8001f54: b580         	push	{r7, lr}
 8001f56: b088         	sub	sp, #0x20
 8001f58: af00         	add	r7, sp, #0x0
 8001f5a: 60f8         	str	r0, [r7, #0xc]
 8001f5c: 60b9         	str	r1, [r7, #0x8]
 8001f5e: 607a         	str	r2, [r7, #0x4]
; 	const struct lbu_cb_ctx *cb_ctx = ctx;
 8001f60: 687b         	ldr	r3, [r7, #0x4]
 8001f62: 61bb         	str	r3, [r7, #0x18]
; 	struct lbu_data *lb_data = cb_ctx->data;
 8001f64: 69bb         	ldr	r3, [r7, #0x18]
 8001f66: 685b         	ldr	r3, [r3, #0x4]
 8001f68: 617b         	str	r3, [r7, #0x14]
; 	const struct device *uart_dev = LBU_UART_DEV(cb_ctx);
 8001f6a: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8001fc0 <char_out+0x6c>
 8001f6c: 613b         	str	r3, [r7, #0x10]
; 	if (pm_device_runtime_get(uart_dev) < 0) {
 8001f6e: 6938         	ldr	r0, [r7, #0x10]
 8001f70: f00c feb2    	bl	0x800ecd8 <pm_device_runtime_get> @ imm = #0xcd64
 8001f74: 4603         	mov	r3, r0
 8001f76: 2b00         	cmp	r3, #0x0
 8001f78: da01         	bge	0x8001f7e <char_out+0x2a> @ imm = #0x2
; 		return length;
 8001f7a: 68b9         	ldr	r1, [r7, #0x8]
 8001f7c: e01a         	b	0x8001fb4 <char_out+0x60> @ imm = #0x34
; 		for (size_t i = 0; i < length; i++) {
 8001f7e: 2300         	movs	r3, #0x0
 8001f80: 61fb         	str	r3, [r7, #0x1c]
 8001f82: e00a         	b	0x8001f9a <char_out+0x46> @ imm = #0x14
; 			uart_poll_out(uart_dev, data[i]);
 8001f84: 68fa         	ldr	r2, [r7, #0xc]
 8001f86: 69fb         	ldr	r3, [r7, #0x1c]
 8001f88: 4413         	add	r3, r2
 8001f8a: 781b         	ldrb	r3, [r3]
 8001f8c: 4619         	mov	r1, r3
 8001f8e: 6938         	ldr	r0, [r7, #0x10]
 8001f90: f00c fe93    	bl	0x800ecba <uart_poll_out> @ imm = #0xcd26
; 		for (size_t i = 0; i < length; i++) {
 8001f94: 69fb         	ldr	r3, [r7, #0x1c]
 8001f96: 3301         	adds	r3, #0x1
 8001f98: 61fb         	str	r3, [r7, #0x1c]
 8001f9a: 69fa         	ldr	r2, [r7, #0x1c]
 8001f9c: 68bb         	ldr	r3, [r7, #0x8]
 8001f9e: 429a         	cmp	r2, r3
 8001fa0: d3f0         	blo	0x8001f84 <char_out+0x30> @ imm = #-0x20
; 		goto cleanup;
 8001fa2: bf00         	nop
; 	(void)pm_device_runtime_put_async(uart_dev, K_MSEC(1));
 8001fa4: f04f 020a    	mov.w	r2, #0xa
 8001fa8: f04f 0300    	mov.w	r3, #0x0
 8001fac: 6938         	ldr	r0, [r7, #0x10]
 8001fae: f00c fe9d    	bl	0x800ecec <pm_device_runtime_put_async> @ imm = #0xcd3a
; 	return length;
 8001fb2: 68b9         	ldr	r1, [r7, #0x8]
; }
 8001fb4: 460b         	mov	r3, r1
 8001fb6: 4618         	mov	r0, r3
 8001fb8: 3720         	adds	r7, #0x20
 8001fba: 46bd         	mov	sp, r7
 8001fbc: bd80         	pop	{r7, pc}
 8001fbe: bf00         	nop

08001fc0 <$d>:
 8001fc0: 94 46 01 08  	.word	0x08014694

08001fc4 <log_backend_uart_init>:
; {
 8001fc4: b580         	push	{r7, lr}
 8001fc6: b086         	sub	sp, #0x18
 8001fc8: af00         	add	r7, sp, #0x0
 8001fca: 6078         	str	r0, [r7, #0x4]
; 	const struct lbu_cb_ctx *ctx = backend->cb->ctx;
 8001fcc: 687b         	ldr	r3, [r7, #0x4]
 8001fce: 685b         	ldr	r3, [r3, #0x4]
 8001fd0: 681b         	ldr	r3, [r3]
 8001fd2: 613b         	str	r3, [r7, #0x10]
; 	const struct device *uart_dev = LBU_UART_DEV(ctx);
 8001fd4: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8001ff0 <log_backend_uart_init+0x2c>
 8001fd6: 60fb         	str	r3, [r7, #0xc]
; 	struct lbu_data *data = ctx->data;
 8001fd8: 693b         	ldr	r3, [r7, #0x10]
 8001fda: 685b         	ldr	r3, [r3, #0x4]
 8001fdc: 617b         	str	r3, [r7, #0x14]
; 	log_output_ctx_set(ctx->output, (void *)ctx);
 8001fde: 693b         	ldr	r3, [r7, #0x10]
 8001fe0: 681b         	ldr	r3, [r3]
 8001fe2: 6939         	ldr	r1, [r7, #0x10]
 8001fe4: 4618         	mov	r0, r3
 8001fe6: f00c fe29    	bl	0x800ec3c <log_output_ctx_set> @ imm = #0xcc52
; }
 8001fea: 3718         	adds	r7, #0x18
 8001fec: 46bd         	mov	sp, r7
 8001fee: bd80         	pop	{r7, pc}

08001ff0 <$d>:
 8001ff0: 94 46 01 08  	.word	0x08014694

08001ff4 <panic>:
; {
 8001ff4: b580         	push	{r7, lr}
 8001ff6: b086         	sub	sp, #0x18
 8001ff8: af00         	add	r7, sp, #0x0
 8001ffa: 6078         	str	r0, [r7, #0x4]
; 	const struct lbu_cb_ctx *ctx = backend->cb->ctx;
 8001ffc: 687b         	ldr	r3, [r7, #0x4]
 8001ffe: 685b         	ldr	r3, [r3, #0x4]
 8002000: 681b         	ldr	r3, [r3]
 8002002: 617b         	str	r3, [r7, #0x14]
; 	struct lbu_data *data = ctx->data;
 8002004: 697b         	ldr	r3, [r7, #0x14]
 8002006: 685b         	ldr	r3, [r3, #0x4]
 8002008: 613b         	str	r3, [r7, #0x10]
; 	const struct device *uart_dev = LBU_UART_DEV(ctx);
 800200a: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8002028 <panic+0x34>
 800200c: 60fb         	str	r3, [r7, #0xc]
; 	data->in_panic = true;
 800200e: 693b         	ldr	r3, [r7, #0x10]
 8002010: 2201         	movs	r2, #0x1
 8002012: 751a         	strb	r2, [r3, #0x14]
; 	log_backend_std_panic(ctx->output);
 8002014: 697b         	ldr	r3, [r7, #0x14]
 8002016: 681b         	ldr	r3, [r3]
 8002018: 4618         	mov	r0, r3
 800201a: f00c fe30    	bl	0x800ec7e <log_backend_std_panic> @ imm = #0xcc60
; }
 800201e: bf00         	nop
 8002020: 3718         	adds	r7, #0x18
 8002022: 46bd         	mov	sp, r7
 8002024: bd80         	pop	{r7, pc}
 8002026: bf00         	nop

08002028 <$d>:
 8002028: 94 46 01 08  	.word	0x08014694

0800202c <esf_dump>:
; {
 800202c: b580         	push	{r7, lr}
 800202e: b090         	sub	sp, #0x40
 8002030: af06         	add	r7, sp, #0x18
 8002032: 6078         	str	r0, [r7, #0x4]
; 	LOG_ERR("r0/a1:  0x%08x  r1/a2:  0x%08x  r2/a3:  0x%08x",
 8002034: 2303         	movs	r3, #0x3
 8002036: 2b00         	cmp	r3, #0x0
 8002038: d020         	beq	0x800207c <esf_dump+0x50> @ imm = #0x40
 800203a: 2301         	movs	r3, #0x1
 800203c: 73bb         	strb	r3, [r7, #0xe]
 800203e: 7bbb         	ldrb	r3, [r7, #0xe]
 8002040: f083 0301    	eor	r3, r3, #0x1
 8002044: b2db         	uxtb	r3, r3
 8002046: 2b00         	cmp	r3, #0x0
 8002048: d118         	bne	0x800207c <esf_dump+0x50> @ imm = #0x30
 800204a: 4b3e         	ldr	r3, [pc, #0xf8]         @ 0x8002144 <esf_dump+0x118>
 800204c: 6818         	ldr	r0, [r3]
 800204e: 687b         	ldr	r3, [r7, #0x4]
 8002050: 681b         	ldr	r3, [r3]
 8002052: 687a         	ldr	r2, [r7, #0x4]
 8002054: 6852         	ldr	r2, [r2, #0x4]
 8002056: 6879         	ldr	r1, [r7, #0x4]
 8002058: 6889         	ldr	r1, [r1, #0x8]
 800205a: 9105         	str	r1, [sp, #0x14]
 800205c: 9204         	str	r2, [sp, #0x10]
 800205e: 9303         	str	r3, [sp, #0xc]
 8002060: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x8002148 <esf_dump+0x11c>
 8002062: 9302         	str	r3, [sp, #0x8]
 8002064: 2300         	movs	r3, #0x0
 8002066: 9301         	str	r3, [sp, #0x4]
 8002068: 2300         	movs	r3, #0x0
 800206a: 9300         	str	r3, [sp]
 800206c: 2300         	movs	r3, #0x0
 800206e: 2201         	movs	r2, #0x1
 8002070: 4601         	mov	r1, r0
 8002072: 2000         	movs	r0, #0x0
 8002074: f00c fe7a    	bl	0x800ed6c <z_log_msg_runtime_create> @ imm = #0xccf4
 8002078: 2300         	movs	r3, #0x0
 800207a: 613b         	str	r3, [r7, #0x10]
; 	LOG_ERR("r3/a4:  0x%08x r12/ip:  0x%08x r14/lr:  0x%08x",
 800207c: 2303         	movs	r3, #0x3
 800207e: 2b00         	cmp	r3, #0x0
 8002080: d020         	beq	0x80020c4 <esf_dump+0x98> @ imm = #0x40
 8002082: 2301         	movs	r3, #0x1
 8002084: 73fb         	strb	r3, [r7, #0xf]
 8002086: 7bfb         	ldrb	r3, [r7, #0xf]
 8002088: f083 0301    	eor	r3, r3, #0x1
 800208c: b2db         	uxtb	r3, r3
 800208e: 2b00         	cmp	r3, #0x0
 8002090: d118         	bne	0x80020c4 <esf_dump+0x98> @ imm = #0x30
 8002092: 4b2c         	ldr	r3, [pc, #0xb0]         @ 0x8002144 <esf_dump+0x118>
 8002094: 6818         	ldr	r0, [r3]
 8002096: 687b         	ldr	r3, [r7, #0x4]
 8002098: 68db         	ldr	r3, [r3, #0xc]
 800209a: 687a         	ldr	r2, [r7, #0x4]
 800209c: 6912         	ldr	r2, [r2, #0x10]
 800209e: 6879         	ldr	r1, [r7, #0x4]
 80020a0: 6949         	ldr	r1, [r1, #0x14]
 80020a2: 9105         	str	r1, [sp, #0x14]
 80020a4: 9204         	str	r2, [sp, #0x10]
 80020a6: 9303         	str	r3, [sp, #0xc]
 80020a8: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x800214c <esf_dump+0x120>
 80020aa: 9302         	str	r3, [sp, #0x8]
 80020ac: 2300         	movs	r3, #0x0
 80020ae: 9301         	str	r3, [sp, #0x4]
 80020b0: 2300         	movs	r3, #0x0
 80020b2: 9300         	str	r3, [sp]
 80020b4: 2300         	movs	r3, #0x0
 80020b6: 2201         	movs	r2, #0x1
 80020b8: 4601         	mov	r1, r0
 80020ba: 2000         	movs	r0, #0x0
 80020bc: f00c fe56    	bl	0x800ed6c <z_log_msg_runtime_create> @ imm = #0xccac
 80020c0: 2300         	movs	r3, #0x0
 80020c2: 623b         	str	r3, [r7, #0x20]
; 	LOG_ERR(" xpsr:  0x%08x", esf->basic.xpsr);
 80020c4: 2303         	movs	r3, #0x3
 80020c6: 2b00         	cmp	r3, #0x0
 80020c8: d019         	beq	0x80020fe <esf_dump+0xd2> @ imm = #0x32
 80020ca: 2301         	movs	r3, #0x1
 80020cc: 77fb         	strb	r3, [r7, #0x1f]
 80020ce: 7ffb         	ldrb	r3, [r7, #0x1f]
 80020d0: f083 0301    	eor	r3, r3, #0x1
 80020d4: b2db         	uxtb	r3, r3
 80020d6: 2b00         	cmp	r3, #0x0
 80020d8: d111         	bne	0x80020fe <esf_dump+0xd2> @ imm = #0x22
 80020da: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x8002144 <esf_dump+0x118>
 80020dc: 6819         	ldr	r1, [r3]
 80020de: 687b         	ldr	r3, [r7, #0x4]
 80020e0: 69db         	ldr	r3, [r3, #0x1c]
 80020e2: 9303         	str	r3, [sp, #0xc]
 80020e4: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x8002150 <esf_dump+0x124>
 80020e6: 9302         	str	r3, [sp, #0x8]
 80020e8: 2300         	movs	r3, #0x0
 80020ea: 9301         	str	r3, [sp, #0x4]
 80020ec: 2300         	movs	r3, #0x0
 80020ee: 9300         	str	r3, [sp]
 80020f0: 2300         	movs	r3, #0x0
 80020f2: 2201         	movs	r2, #0x1
 80020f4: 2000         	movs	r0, #0x0
 80020f6: f00c fe39    	bl	0x800ed6c <z_log_msg_runtime_create> @ imm = #0xcc72
 80020fa: 2300         	movs	r3, #0x0
 80020fc: 61bb         	str	r3, [r7, #0x18]
; 	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
 80020fe: 2303         	movs	r3, #0x3
 8002100: 2b00         	cmp	r3, #0x0
 8002102: d01a         	beq	0x800213a <esf_dump+0x10e> @ imm = #0x34
 8002104: 2301         	movs	r3, #0x1
 8002106: 75fb         	strb	r3, [r7, #0x17]
 8002108: 7dfb         	ldrb	r3, [r7, #0x17]
 800210a: f083 0301    	eor	r3, r3, #0x1
 800210e: b2db         	uxtb	r3, r3
 8002110: 2b00         	cmp	r3, #0x0
 8002112: d112         	bne	0x800213a <esf_dump+0x10e> @ imm = #0x24
 8002114: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8002144 <esf_dump+0x118>
 8002116: 6819         	ldr	r1, [r3]
 8002118: 687b         	ldr	r3, [r7, #0x4]
 800211a: 699b         	ldr	r3, [r3, #0x18]
 800211c: 9303         	str	r3, [sp, #0xc]
 800211e: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8002154 <esf_dump+0x128>
 8002120: 9302         	str	r3, [sp, #0x8]
 8002122: 2300         	movs	r3, #0x0
 8002124: 9301         	str	r3, [sp, #0x4]
 8002126: 2300         	movs	r3, #0x0
 8002128: 9300         	str	r3, [sp]
 800212a: 2300         	movs	r3, #0x0
 800212c: 2201         	movs	r2, #0x1
 800212e: 2000         	movs	r0, #0x0
 8002130: f00c fe1c    	bl	0x800ed6c <z_log_msg_runtime_create> @ imm = #0xcc38
 8002134: 2300         	movs	r3, #0x0
 8002136: 627b         	str	r3, [r7, #0x24]
; }
 8002138: bf00         	nop
 800213a: bf00         	nop
 800213c: 3728         	adds	r7, #0x28
 800213e: 46bd         	mov	sp, r7
 8002140: bd80         	pop	{r7, pc}
 8002142: bf00         	nop

08002144 <$d>:
 8002144: 18 00 00 20  	.word	0x20000018
 8002148: c4 4d 01 08  	.word	0x08014dc4
 800214c: f4 4d 01 08  	.word	0x08014df4
 8002150: 24 4e 01 08  	.word	0x08014e24
 8002154: 34 4e 01 08  	.word	0x08014e34

08002158 <z_arm_fatal_error>:
; {
 8002158: b580         	push	{r7, lr}
 800215a: b08a         	sub	sp, #0x28
 800215c: af04         	add	r7, sp, #0x10
 800215e: 6078         	str	r0, [r7, #0x4]
 8002160: 6039         	str	r1, [r7]
; 	if (esf != NULL) {
 8002162: 683b         	ldr	r3, [r7]
 8002164: 2b00         	cmp	r3, #0x0
 8002166: d002         	beq	0x800216e <z_arm_fatal_error+0x16> @ imm = #0x4
; 		esf_dump(esf);
 8002168: 6838         	ldr	r0, [r7]
 800216a: f7ff ff5f    	bl	0x800202c <esf_dump>    @ imm = #-0x142
; 	if (reason == K_ERR_SPURIOUS_IRQ) {
 800216e: 687b         	ldr	r3, [r7, #0x4]
 8002170: 2b01         	cmp	r3, #0x1
 8002172: d121         	bne	0x80021b8 <z_arm_fatal_error+0x60> @ imm = #0x42
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8002174: f3ef 8305    	mrs	r3, ipsr
 8002178: 60bb         	str	r3, [r7, #0x8]
;   return(result);
 800217a: 68bb         	ldr	r3, [r7, #0x8]
; 		uint32_t irqn = __get_IPSR() - 16;
 800217c: 3b10         	subs	r3, #0x10
 800217e: 617b         	str	r3, [r7, #0x14]
; 		LOG_ERR("Unhandled IRQn: %d", irqn);
 8002180: 2303         	movs	r3, #0x3
 8002182: 2b00         	cmp	r3, #0x0
 8002184: d018         	beq	0x80021b8 <z_arm_fatal_error+0x60> @ imm = #0x30
 8002186: 2301         	movs	r3, #0x1
 8002188: 74fb         	strb	r3, [r7, #0x13]
 800218a: 7cfb         	ldrb	r3, [r7, #0x13]
 800218c: f083 0301    	eor	r3, r3, #0x1
 8002190: b2db         	uxtb	r3, r3
 8002192: 2b00         	cmp	r3, #0x0
 8002194: d110         	bne	0x80021b8 <z_arm_fatal_error+0x60> @ imm = #0x20
 8002196: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x80021c8 <z_arm_fatal_error+0x70>
 8002198: 6819         	ldr	r1, [r3]
 800219a: 697b         	ldr	r3, [r7, #0x14]
 800219c: 9303         	str	r3, [sp, #0xc]
 800219e: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x80021cc <z_arm_fatal_error+0x74>
 80021a0: 9302         	str	r3, [sp, #0x8]
 80021a2: 2300         	movs	r3, #0x0
 80021a4: 9301         	str	r3, [sp, #0x4]
 80021a6: 2300         	movs	r3, #0x0
 80021a8: 9300         	str	r3, [sp]
 80021aa: 2300         	movs	r3, #0x0
 80021ac: 2201         	movs	r2, #0x1
 80021ae: 2000         	movs	r0, #0x0
 80021b0: f00c fddc    	bl	0x800ed6c <z_log_msg_runtime_create> @ imm = #0xcbb8
 80021b4: 2300         	movs	r3, #0x0
 80021b6: 60fb         	str	r3, [r7, #0xc]
; 	z_fatal_error(reason, esf);
 80021b8: 6839         	ldr	r1, [r7]
 80021ba: 6878         	ldr	r0, [r7, #0x4]
 80021bc: f006 feb2    	bl	0x8008f24 <z_fatal_error> @ imm = #0x6d64
; }
 80021c0: bf00         	nop
 80021c2: 3718         	adds	r7, #0x18
 80021c4: 46bd         	mov	sp, r7
 80021c6: bd80         	pop	{r7, pc}

080021c8 <$d>:
 80021c8: 18 00 00 20  	.word	0x20000018
 80021cc: 64 4e 01 08  	.word	0x08014e64

080021d0 <z_arm_nmi>:
; {
 80021d0: b580         	push	{r7, lr}
 80021d2: af00         	add	r7, sp, #0x0
; 	handler();
 80021d4: 4b03         	ldr	r3, [pc, #0xc]          @ 0x80021e4 <z_arm_nmi+0x14>
 80021d6: 681b         	ldr	r3, [r3]
 80021d8: 4798         	blx	r3
; 	z_arm_int_exit();
 80021da: f000 f835    	bl	0x8002248 <z_arm_int_exit> @ imm = #0x6a
; }
 80021de: bf00         	nop
 80021e0: bd80         	pop	{r7, pc}
 80021e2: bf00         	nop

080021e4 <$d>:
 80021e4: 1c 00 00 20  	.word	0x2000001c

080021e8 <z_SysNmiOnReset>:
;     wfi
 80021e8: bf30         	wfi
;     b z_SysNmiOnReset
 80021ea: f7ff bffd    	b.w	0x80021e8 <z_SysNmiOnReset> @ imm = #-0x6
 80021ee: bf00         	nop

080021f0 <z_tls_data_size>:
; {
 80021f0: b480         	push	{r7}
 80021f2: af00         	add	r7, sp, #0x0
; 	return (size_t)(uintptr_t)__tdata_size +
 80021f4: 4a03         	ldr	r2, [pc, #0xc]          @ 0x8002204 <z_tls_data_size+0x14>
; 	       (size_t)(uintptr_t)__tbss_size;
 80021f6: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8002208 <z_tls_data_size+0x18>
; 	return (size_t)(uintptr_t)__tdata_size +
 80021f8: 4413         	add	r3, r2
; }
 80021fa: 4618         	mov	r0, r3
 80021fc: 46bd         	mov	sp, r7
 80021fe: bc80         	pop	{r7}
 8002200: 4770         	bx	lr
 8002202: bf00         	nop

08002204 <$d>:
 8002204: 00 00 00 00  	.word	0x00000000
 8002208: 04 00 00 00  	.word	0x00000004

0800220c <z_tls_copy>:
; {
 800220c: b580         	push	{r7, lr}
 800220e: b082         	sub	sp, #0x8
 8002210: af00         	add	r7, sp, #0x0
 8002212: 6078         	str	r0, [r7, #0x4]
; 	memcpy(dest, __tdata_start, (size_t)(uintptr_t)__tdata_size);
 8002214: 4b09         	ldr	r3, [pc, #0x24]         @ 0x800223c <z_tls_copy+0x30>
 8002216: 461a         	mov	r2, r3
 8002218: 4909         	ldr	r1, [pc, #0x24]         @ 0x8002240 <z_tls_copy+0x34>
 800221a: 6878         	ldr	r0, [r7, #0x4]
 800221c: f011 ff70    	bl	0x8014100 <memcpy>      @ imm = #0x11ee0
; 	dest += (size_t)(uintptr_t)__tdata_size;
 8002220: 4a06         	ldr	r2, [pc, #0x18]         @ 0x800223c <z_tls_copy+0x30>
 8002222: 687b         	ldr	r3, [r7, #0x4]
 8002224: 4413         	add	r3, r2
 8002226: 607b         	str	r3, [r7, #0x4]
; 	memset(dest, 0, (size_t)(uintptr_t)__tbss_size);
 8002228: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8002244 <z_tls_copy+0x38>
 800222a: 461a         	mov	r2, r3
 800222c: 2100         	movs	r1, #0x0
 800222e: 6878         	ldr	r0, [r7, #0x4]
 8002230: f011 ff74    	bl	0x801411c <memset>      @ imm = #0x11ee8
; }
 8002234: bf00         	nop
 8002236: 3708         	adds	r7, #0x8
 8002238: 46bd         	mov	sp, r7
 800223a: bd80         	pop	{r7, pc}

0800223c <$d>:
 800223c: 00 00 00 00  	.word	0x00000000
 8002240: 84 4a 01 08  	.word	0x08014a84
 8002244: 04 00 00 00  	.word	0x00000004

08002248 <z_arm_int_exit>:
; {
 8002248: b480         	push	{r7}
 800224a: af00         	add	r7, sp, #0x0
; 	if (_kernel.cpus->current->base.prio >= 0) {
 800224c: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8002278 <z_arm_int_exit+0x30>
 800224e: 689b         	ldr	r3, [r3, #0x8]
 8002250: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 8002254: 2b00         	cmp	r3, #0x0
 8002256: db0b         	blt	0x8002270 <z_arm_int_exit+0x28> @ imm = #0x16
; 		if (_kernel.ready_q.cache != _kernel.cpus->current) {
 8002258: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8002278 <z_arm_int_exit+0x30>
 800225a: 69da         	ldr	r2, [r3, #0x1c]
 800225c: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8002278 <z_arm_int_exit+0x30>
 800225e: 689b         	ldr	r3, [r3, #0x8]
 8002260: 429a         	cmp	r2, r3
 8002262: d005         	beq	0x8002270 <z_arm_int_exit+0x28> @ imm = #0xa
; 			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
 8002264: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800227c <z_arm_int_exit+0x34>
 8002266: 685b         	ldr	r3, [r3, #0x4]
 8002268: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800227c <z_arm_int_exit+0x34>
 800226a: f043 5380    	orr	r3, r3, #0x10000000
 800226e: 6053         	str	r3, [r2, #0x4]
; }
 8002270: bf00         	nop
 8002272: 46bd         	mov	sp, r7
 8002274: bc80         	pop	{r7}
 8002276: 4770         	bx	lr

08002278 <$d>:
 8002278: c0 02 00 20  	.word	0x200002c0
 800227c: 00 ed 00 e0  	.word	0xe000ed00

08002280 <mem_manage_fault>:
; {
 8002280: b580         	push	{r7, lr}
 8002282: b09a         	sub	sp, #0x68
 8002284: af04         	add	r7, sp, #0x10
 8002286: 60f8         	str	r0, [r7, #0xc]
 8002288: 60b9         	str	r1, [r7, #0x8]
 800228a: 607a         	str	r2, [r7, #0x4]
; 	uint32_t reason = K_ERR_ARM_MEM_GENERIC;
 800228c: 2310         	movs	r3, #0x10
 800228e: 657b         	str	r3, [r7, #0x54]
; 	uint32_t mmfar = -EINVAL;
 8002290: f06f 0315    	mvn	r3, #0x15
 8002294: 653b         	str	r3, [r7, #0x50]
; 	PR_FAULT_INFO("***** MPU FAULT *****");
 8002296: 2303         	movs	r3, #0x3
 8002298: 2b00         	cmp	r3, #0x0
 800229a: d018         	beq	0x80022ce <mem_manage_fault+0x4e> @ imm = #0x30
 800229c: 2301         	movs	r3, #0x1
 800229e: f887 304f    	strb.w	r3, [r7, #0x4f]
 80022a2: f897 304f    	ldrb.w	r3, [r7, #0x4f]
 80022a6: f083 0301    	eor	r3, r3, #0x1
 80022aa: b2db         	uxtb	r3, r3
 80022ac: 2b00         	cmp	r3, #0x0
 80022ae: d10e         	bne	0x80022ce <mem_manage_fault+0x4e> @ imm = #0x1c
 80022b0: 4b8c         	ldr	r3, [pc, #0x230]        @ 0x80024e4 <mem_manage_fault+0x264>
 80022b2: 6819         	ldr	r1, [r3]
 80022b4: 4b8c         	ldr	r3, [pc, #0x230]        @ 0x80024e8 <mem_manage_fault+0x268>
 80022b6: 9302         	str	r3, [sp, #0x8]
 80022b8: 2300         	movs	r3, #0x0
 80022ba: 9301         	str	r3, [sp, #0x4]
 80022bc: 2300         	movs	r3, #0x0
 80022be: 9300         	str	r3, [sp]
 80022c0: 2300         	movs	r3, #0x0
 80022c2: 2201         	movs	r2, #0x1
 80022c4: 2000         	movs	r0, #0x0
 80022c6: f00c fda3    	bl	0x800ee10 <z_log_msg_runtime_create> @ imm = #0xcb46
 80022ca: 2300         	movs	r3, #0x0
 80022cc: 64bb         	str	r3, [r7, #0x48]
; 	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
 80022ce: 4b87         	ldr	r3, [pc, #0x21c]        @ 0x80024ec <mem_manage_fault+0x26c>
 80022d0: 6a9b         	ldr	r3, [r3, #0x28]
 80022d2: f003 0310    	and	r3, r3, #0x10
 80022d6: 2b00         	cmp	r3, #0x0
 80022d8: d01d         	beq	0x8002316 <mem_manage_fault+0x96> @ imm = #0x3a
; 		reason = K_ERR_ARM_MEM_STACKING;
 80022da: 2311         	movs	r3, #0x11
 80022dc: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Stacking error (context area might be"
 80022de: 2303         	movs	r3, #0x3
 80022e0: 2b00         	cmp	r3, #0x0
 80022e2: d018         	beq	0x8002316 <mem_manage_fault+0x96> @ imm = #0x30
 80022e4: 2301         	movs	r3, #0x1
 80022e6: f887 3047    	strb.w	r3, [r7, #0x47]
 80022ea: f897 3047    	ldrb.w	r3, [r7, #0x47]
 80022ee: f083 0301    	eor	r3, r3, #0x1
 80022f2: b2db         	uxtb	r3, r3
 80022f4: 2b00         	cmp	r3, #0x0
 80022f6: d10e         	bne	0x8002316 <mem_manage_fault+0x96> @ imm = #0x1c
 80022f8: 4b7a         	ldr	r3, [pc, #0x1e8]        @ 0x80024e4 <mem_manage_fault+0x264>
 80022fa: 6819         	ldr	r1, [r3]
 80022fc: 4b7c         	ldr	r3, [pc, #0x1f0]        @ 0x80024f0 <mem_manage_fault+0x270>
 80022fe: 9302         	str	r3, [sp, #0x8]
 8002300: 2300         	movs	r3, #0x0
 8002302: 9301         	str	r3, [sp, #0x4]
 8002304: 2300         	movs	r3, #0x0
 8002306: 9300         	str	r3, [sp]
 8002308: 2300         	movs	r3, #0x0
 800230a: 2201         	movs	r2, #0x1
 800230c: 2000         	movs	r0, #0x0
 800230e: f00c fd7f    	bl	0x800ee10 <z_log_msg_runtime_create> @ imm = #0xcafe
 8002312: 2300         	movs	r3, #0x0
 8002314: 643b         	str	r3, [r7, #0x40]
; 	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
 8002316: 4b75         	ldr	r3, [pc, #0x1d4]        @ 0x80024ec <mem_manage_fault+0x26c>
 8002318: 6a9b         	ldr	r3, [r3, #0x28]
 800231a: f003 0308    	and	r3, r3, #0x8
 800231e: 2b00         	cmp	r3, #0x0
 8002320: d01d         	beq	0x800235e <mem_manage_fault+0xde> @ imm = #0x3a
; 		reason = K_ERR_ARM_MEM_UNSTACKING;
 8002322: 2312         	movs	r3, #0x12
 8002324: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Unstacking error");
 8002326: 2303         	movs	r3, #0x3
 8002328: 2b00         	cmp	r3, #0x0
 800232a: d018         	beq	0x800235e <mem_manage_fault+0xde> @ imm = #0x30
 800232c: 2301         	movs	r3, #0x1
 800232e: f887 303f    	strb.w	r3, [r7, #0x3f]
 8002332: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 8002336: f083 0301    	eor	r3, r3, #0x1
 800233a: b2db         	uxtb	r3, r3
 800233c: 2b00         	cmp	r3, #0x0
 800233e: d10e         	bne	0x800235e <mem_manage_fault+0xde> @ imm = #0x1c
 8002340: 4b68         	ldr	r3, [pc, #0x1a0]        @ 0x80024e4 <mem_manage_fault+0x264>
 8002342: 6819         	ldr	r1, [r3]
 8002344: 4b6b         	ldr	r3, [pc, #0x1ac]        @ 0x80024f4 <mem_manage_fault+0x274>
 8002346: 9302         	str	r3, [sp, #0x8]
 8002348: 2300         	movs	r3, #0x0
 800234a: 9301         	str	r3, [sp, #0x4]
 800234c: 2300         	movs	r3, #0x0
 800234e: 9300         	str	r3, [sp]
 8002350: 2300         	movs	r3, #0x0
 8002352: 2201         	movs	r2, #0x1
 8002354: 2000         	movs	r0, #0x0
 8002356: f00c fd5b    	bl	0x800ee10 <z_log_msg_runtime_create> @ imm = #0xcab6
 800235a: 2300         	movs	r3, #0x0
 800235c: 63bb         	str	r3, [r7, #0x38]
; 	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
 800235e: 4b63         	ldr	r3, [pc, #0x18c]        @ 0x80024ec <mem_manage_fault+0x26c>
 8002360: 6a9b         	ldr	r3, [r3, #0x28]
 8002362: f003 0302    	and	r3, r3, #0x2
 8002366: 2b00         	cmp	r3, #0x0
 8002368: d04f         	beq	0x800240a <mem_manage_fault+0x18a> @ imm = #0x9e
; 		reason = K_ERR_ARM_MEM_DATA_ACCESS;
 800236a: 2313         	movs	r3, #0x13
 800236c: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Data Access Violation");
 800236e: 2303         	movs	r3, #0x3
 8002370: 2b00         	cmp	r3, #0x0
 8002372: d018         	beq	0x80023a6 <mem_manage_fault+0x126> @ imm = #0x30
 8002374: 2301         	movs	r3, #0x1
 8002376: f887 3037    	strb.w	r3, [r7, #0x37]
 800237a: f897 3037    	ldrb.w	r3, [r7, #0x37]
 800237e: f083 0301    	eor	r3, r3, #0x1
 8002382: b2db         	uxtb	r3, r3
 8002384: 2b00         	cmp	r3, #0x0
 8002386: d10e         	bne	0x80023a6 <mem_manage_fault+0x126> @ imm = #0x1c
 8002388: 4b56         	ldr	r3, [pc, #0x158]        @ 0x80024e4 <mem_manage_fault+0x264>
 800238a: 6819         	ldr	r1, [r3]
 800238c: 4b5a         	ldr	r3, [pc, #0x168]        @ 0x80024f8 <mem_manage_fault+0x278>
 800238e: 9302         	str	r3, [sp, #0x8]
 8002390: 2300         	movs	r3, #0x0
 8002392: 9301         	str	r3, [sp, #0x4]
 8002394: 2300         	movs	r3, #0x0
 8002396: 9300         	str	r3, [sp]
 8002398: 2300         	movs	r3, #0x0
 800239a: 2201         	movs	r2, #0x1
 800239c: 2000         	movs	r0, #0x0
 800239e: f00c fd37    	bl	0x800ee10 <z_log_msg_runtime_create> @ imm = #0xca6e
 80023a2: 2300         	movs	r3, #0x0
 80023a4: 633b         	str	r3, [r7, #0x30]
; 		uint32_t temp = SCB->MMFAR;
 80023a6: 4b51         	ldr	r3, [pc, #0x144]        @ 0x80024ec <mem_manage_fault+0x26c>
 80023a8: 6b5b         	ldr	r3, [r3, #0x34]
 80023aa: 62fb         	str	r3, [r7, #0x2c]
; 		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
 80023ac: 4b4f         	ldr	r3, [pc, #0x13c]        @ 0x80024ec <mem_manage_fault+0x26c>
 80023ae: 6a9b         	ldr	r3, [r3, #0x28]
 80023b0: f003 0380    	and	r3, r3, #0x80
 80023b4: 2b00         	cmp	r3, #0x0
 80023b6: d028         	beq	0x800240a <mem_manage_fault+0x18a> @ imm = #0x50
; 			mmfar = temp;
 80023b8: 6afb         	ldr	r3, [r7, #0x2c]
 80023ba: 653b         	str	r3, [r7, #0x50]
; 			PR_EXC("  MMFAR Address: 0x%x", mmfar);
 80023bc: 2303         	movs	r3, #0x3
 80023be: 2b00         	cmp	r3, #0x0
 80023c0: d01a         	beq	0x80023f8 <mem_manage_fault+0x178> @ imm = #0x34
 80023c2: 2301         	movs	r3, #0x1
 80023c4: f887 302b    	strb.w	r3, [r7, #0x2b]
 80023c8: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 80023cc: f083 0301    	eor	r3, r3, #0x1
 80023d0: b2db         	uxtb	r3, r3
 80023d2: 2b00         	cmp	r3, #0x0
 80023d4: d110         	bne	0x80023f8 <mem_manage_fault+0x178> @ imm = #0x20
 80023d6: 4b43         	ldr	r3, [pc, #0x10c]        @ 0x80024e4 <mem_manage_fault+0x264>
 80023d8: 6819         	ldr	r1, [r3]
 80023da: 6d3b         	ldr	r3, [r7, #0x50]
 80023dc: 9303         	str	r3, [sp, #0xc]
 80023de: 4b47         	ldr	r3, [pc, #0x11c]        @ 0x80024fc <mem_manage_fault+0x27c>
 80023e0: 9302         	str	r3, [sp, #0x8]
 80023e2: 2300         	movs	r3, #0x0
 80023e4: 9301         	str	r3, [sp, #0x4]
 80023e6: 2300         	movs	r3, #0x0
 80023e8: 9300         	str	r3, [sp]
 80023ea: 2300         	movs	r3, #0x0
 80023ec: 2201         	movs	r2, #0x1
 80023ee: 2000         	movs	r0, #0x0
 80023f0: f00c fd0e    	bl	0x800ee10 <z_log_msg_runtime_create> @ imm = #0xca1c
 80023f4: 2300         	movs	r3, #0x0
 80023f6: 627b         	str	r3, [r7, #0x24]
; 			if (from_hard_fault != 0) {
 80023f8: 68bb         	ldr	r3, [r7, #0x8]
 80023fa: 2b00         	cmp	r3, #0x0
 80023fc: d005         	beq	0x800240a <mem_manage_fault+0x18a> @ imm = #0xa
; 				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
 80023fe: 4b3b         	ldr	r3, [pc, #0xec]         @ 0x80024ec <mem_manage_fault+0x26c>
 8002400: 6a9b         	ldr	r3, [r3, #0x28]
 8002402: 4a3a         	ldr	r2, [pc, #0xe8]         @ 0x80024ec <mem_manage_fault+0x26c>
 8002404: f023 0380    	bic	r3, r3, #0x80
 8002408: 6293         	str	r3, [r2, #0x28]
; 	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
 800240a: 4b38         	ldr	r3, [pc, #0xe0]         @ 0x80024ec <mem_manage_fault+0x26c>
 800240c: 6a9b         	ldr	r3, [r3, #0x28]
 800240e: f003 0301    	and	r3, r3, #0x1
 8002412: 2b00         	cmp	r3, #0x0
 8002414: d01d         	beq	0x8002452 <mem_manage_fault+0x1d2> @ imm = #0x3a
; 		reason = K_ERR_ARM_MEM_INSTRUCTION_ACCESS;
 8002416: 2314         	movs	r3, #0x14
 8002418: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Instruction Access Violation");
 800241a: 2303         	movs	r3, #0x3
 800241c: 2b00         	cmp	r3, #0x0
 800241e: d018         	beq	0x8002452 <mem_manage_fault+0x1d2> @ imm = #0x30
 8002420: 2301         	movs	r3, #0x1
 8002422: f887 3023    	strb.w	r3, [r7, #0x23]
 8002426: f897 3023    	ldrb.w	r3, [r7, #0x23]
 800242a: f083 0301    	eor	r3, r3, #0x1
 800242e: b2db         	uxtb	r3, r3
 8002430: 2b00         	cmp	r3, #0x0
 8002432: d10e         	bne	0x8002452 <mem_manage_fault+0x1d2> @ imm = #0x1c
 8002434: 4b2b         	ldr	r3, [pc, #0xac]         @ 0x80024e4 <mem_manage_fault+0x264>
 8002436: 6819         	ldr	r1, [r3]
 8002438: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x8002500 <mem_manage_fault+0x280>
 800243a: 9302         	str	r3, [sp, #0x8]
 800243c: 2300         	movs	r3, #0x0
 800243e: 9301         	str	r3, [sp, #0x4]
 8002440: 2300         	movs	r3, #0x0
 8002442: 9300         	str	r3, [sp]
 8002444: 2300         	movs	r3, #0x0
 8002446: 2201         	movs	r2, #0x1
 8002448: 2000         	movs	r0, #0x0
 800244a: f00c fce1    	bl	0x800ee10 <z_log_msg_runtime_create> @ imm = #0xc9c2
 800244e: 2300         	movs	r3, #0x0
 8002450: 61fb         	str	r3, [r7, #0x1c]
; 	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
 8002452: 4b26         	ldr	r3, [pc, #0x98]         @ 0x80024ec <mem_manage_fault+0x26c>
 8002454: 6a9b         	ldr	r3, [r3, #0x28]
 8002456: f003 0320    	and	r3, r3, #0x20
 800245a: 2b00         	cmp	r3, #0x0
 800245c: d01b         	beq	0x8002496 <mem_manage_fault+0x216> @ imm = #0x36
; 		reason = K_ERR_ARM_MEM_FP_LAZY_STATE_PRESERVATION;
 800245e: 2315         	movs	r3, #0x15
 8002460: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO(
 8002462: 2303         	movs	r3, #0x3
 8002464: 2b00         	cmp	r3, #0x0
 8002466: d016         	beq	0x8002496 <mem_manage_fault+0x216> @ imm = #0x2c
 8002468: 2301         	movs	r3, #0x1
 800246a: 76fb         	strb	r3, [r7, #0x1b]
 800246c: 7efb         	ldrb	r3, [r7, #0x1b]
 800246e: f083 0301    	eor	r3, r3, #0x1
 8002472: b2db         	uxtb	r3, r3
 8002474: 2b00         	cmp	r3, #0x0
 8002476: d10e         	bne	0x8002496 <mem_manage_fault+0x216> @ imm = #0x1c
 8002478: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x80024e4 <mem_manage_fault+0x264>
 800247a: 6819         	ldr	r1, [r3]
 800247c: 4b21         	ldr	r3, [pc, #0x84]         @ 0x8002504 <mem_manage_fault+0x284>
 800247e: 9302         	str	r3, [sp, #0x8]
 8002480: 2300         	movs	r3, #0x0
 8002482: 9301         	str	r3, [sp, #0x4]
 8002484: 2300         	movs	r3, #0x0
 8002486: 9300         	str	r3, [sp]
 8002488: 2300         	movs	r3, #0x0
 800248a: 2201         	movs	r2, #0x1
 800248c: 2000         	movs	r0, #0x0
 800248e: f00c fcbf    	bl	0x800ee10 <z_log_msg_runtime_create> @ imm = #0xc97e
 8002492: 2300         	movs	r3, #0x0
 8002494: 617b         	str	r3, [r7, #0x14]
; 	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
 8002496: 4b15         	ldr	r3, [pc, #0x54]         @ 0x80024ec <mem_manage_fault+0x26c>
 8002498: 6a9b         	ldr	r3, [r3, #0x28]
 800249a: f003 0310    	and	r3, r3, #0x10
 800249e: 2b00         	cmp	r3, #0x0
 80024a0: d101         	bne	0x80024a6 <mem_manage_fault+0x226> @ imm = #0x2
; 		(SCB->CFSR & SCB_CFSR_DACCVIOL_Msk)) {
 80024a2: 4b12         	ldr	r3, [pc, #0x48]         @ 0x80024ec <mem_manage_fault+0x26c>
 80024a4: 6a9b         	ldr	r3, [r3, #0x28]
; 	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
 80024a6: 4b11         	ldr	r3, [pc, #0x44]         @ 0x80024ec <mem_manage_fault+0x26c>
 80024a8: 6a9b         	ldr	r3, [r3, #0x28]
 80024aa: f003 0320    	and	r3, r3, #0x20
 80024ae: 2b00         	cmp	r3, #0x0
 80024b0: d005         	beq	0x80024be <mem_manage_fault+0x23e> @ imm = #0xa
; 		SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTPENDED_Msk;
 80024b2: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x80024ec <mem_manage_fault+0x26c>
 80024b4: 6a5b         	ldr	r3, [r3, #0x24]
 80024b6: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x80024ec <mem_manage_fault+0x26c>
 80024b8: f423 5300    	bic	r3, r3, #0x2000
 80024bc: 6253         	str	r3, [r2, #0x24]
; 	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
 80024be: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x80024ec <mem_manage_fault+0x26c>
 80024c0: 6a9b         	ldr	r3, [r3, #0x28]
 80024c2: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x80024ec <mem_manage_fault+0x26c>
 80024c4: f043 03ff    	orr	r3, r3, #0xff
 80024c8: 6293         	str	r3, [r2, #0x28]
; 	*recoverable = memory_fault_recoverable(esf, true);
 80024ca: 2101         	movs	r1, #0x1
 80024cc: 68f8         	ldr	r0, [r7, #0xc]
 80024ce: f00c fcc7    	bl	0x800ee60 <memory_fault_recoverable> @ imm = #0xc98e
 80024d2: 4603         	mov	r3, r0
 80024d4: 461a         	mov	r2, r3
 80024d6: 687b         	ldr	r3, [r7, #0x4]
 80024d8: 701a         	strb	r2, [r3]
; 	return reason;
 80024da: 6d7b         	ldr	r3, [r7, #0x54]
; }
 80024dc: 4618         	mov	r0, r3
 80024de: 3758         	adds	r7, #0x58
 80024e0: 46bd         	mov	sp, r7
 80024e2: bd80         	pop	{r7, pc}

080024e4 <$d>:
 80024e4: 20 00 00 20  	.word	0x20000020
 80024e8: 78 4e 01 08  	.word	0x08014e78
 80024ec: 00 ed 00 e0  	.word	0xe000ed00
 80024f0: 90 4e 01 08  	.word	0x08014e90
 80024f4: c4 4e 01 08  	.word	0x08014ec4
 80024f8: d8 4e 01 08  	.word	0x08014ed8
 80024fc: f0 4e 01 08  	.word	0x08014ef0
 8002500: 08 4f 01 08  	.word	0x08014f08
 8002504: 28 4f 01 08  	.word	0x08014f28

08002508 <bus_fault>:
; {
 8002508: b580         	push	{r7, lr}
 800250a: b09a         	sub	sp, #0x68
 800250c: af04         	add	r7, sp, #0x10
 800250e: 60f8         	str	r0, [r7, #0xc]
 8002510: 60b9         	str	r1, [r7, #0x8]
 8002512: 607a         	str	r2, [r7, #0x4]
; 	uint32_t reason = K_ERR_ARM_BUS_GENERIC;
 8002514: 2316         	movs	r3, #0x16
 8002516: 657b         	str	r3, [r7, #0x54]
; 	PR_FAULT_INFO("***** BUS FAULT *****");
 8002518: 2303         	movs	r3, #0x3
 800251a: 2b00         	cmp	r3, #0x0
 800251c: d018         	beq	0x8002550 <bus_fault+0x48> @ imm = #0x30
 800251e: 2301         	movs	r3, #0x1
 8002520: f887 3053    	strb.w	r3, [r7, #0x53]
 8002524: f897 3053    	ldrb.w	r3, [r7, #0x53]
 8002528: f083 0301    	eor	r3, r3, #0x1
 800252c: b2db         	uxtb	r3, r3
 800252e: 2b00         	cmp	r3, #0x0
 8002530: d10e         	bne	0x8002550 <bus_fault+0x48> @ imm = #0x1c
 8002532: 4b93         	ldr	r3, [pc, #0x24c]        @ 0x8002780 <bus_fault+0x278>
 8002534: 6819         	ldr	r1, [r3]
 8002536: 4b93         	ldr	r3, [pc, #0x24c]        @ 0x8002784 <bus_fault+0x27c>
 8002538: 9302         	str	r3, [sp, #0x8]
 800253a: 2300         	movs	r3, #0x0
 800253c: 9301         	str	r3, [sp, #0x4]
 800253e: 2300         	movs	r3, #0x0
 8002540: 9300         	str	r3, [sp]
 8002542: 2300         	movs	r3, #0x0
 8002544: 2201         	movs	r2, #0x1
 8002546: 2000         	movs	r0, #0x0
 8002548: f00c fc62    	bl	0x800ee10 <z_log_msg_runtime_create> @ imm = #0xc8c4
 800254c: 2300         	movs	r3, #0x0
 800254e: 64fb         	str	r3, [r7, #0x4c]
; 	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
 8002550: 4b8d         	ldr	r3, [pc, #0x234]        @ 0x8002788 <bus_fault+0x280>
 8002552: 6a9b         	ldr	r3, [r3, #0x28]
 8002554: f403 5380    	and	r3, r3, #0x1000
 8002558: 2b00         	cmp	r3, #0x0
 800255a: d01d         	beq	0x8002598 <bus_fault+0x90> @ imm = #0x3a
; 		reason = K_ERR_ARM_BUS_STACKING;
 800255c: 2317         	movs	r3, #0x17
 800255e: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Stacking error");
 8002560: 2303         	movs	r3, #0x3
 8002562: 2b00         	cmp	r3, #0x0
 8002564: d018         	beq	0x8002598 <bus_fault+0x90> @ imm = #0x30
 8002566: 2301         	movs	r3, #0x1
 8002568: f887 304b    	strb.w	r3, [r7, #0x4b]
 800256c: f897 304b    	ldrb.w	r3, [r7, #0x4b]
 8002570: f083 0301    	eor	r3, r3, #0x1
 8002574: b2db         	uxtb	r3, r3
 8002576: 2b00         	cmp	r3, #0x0
 8002578: d10e         	bne	0x8002598 <bus_fault+0x90> @ imm = #0x1c
 800257a: 4b81         	ldr	r3, [pc, #0x204]        @ 0x8002780 <bus_fault+0x278>
 800257c: 6819         	ldr	r1, [r3]
 800257e: 4b83         	ldr	r3, [pc, #0x20c]        @ 0x800278c <bus_fault+0x284>
 8002580: 9302         	str	r3, [sp, #0x8]
 8002582: 2300         	movs	r3, #0x0
 8002584: 9301         	str	r3, [sp, #0x4]
 8002586: 2300         	movs	r3, #0x0
 8002588: 9300         	str	r3, [sp]
 800258a: 2300         	movs	r3, #0x0
 800258c: 2201         	movs	r2, #0x1
 800258e: 2000         	movs	r0, #0x0
 8002590: f00c fc3e    	bl	0x800ee10 <z_log_msg_runtime_create> @ imm = #0xc87c
 8002594: 2300         	movs	r3, #0x0
 8002596: 647b         	str	r3, [r7, #0x44]
; 	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
 8002598: 4b7b         	ldr	r3, [pc, #0x1ec]        @ 0x8002788 <bus_fault+0x280>
 800259a: 6a9b         	ldr	r3, [r3, #0x28]
 800259c: f403 6300    	and	r3, r3, #0x800
 80025a0: 2b00         	cmp	r3, #0x0
 80025a2: d01d         	beq	0x80025e0 <bus_fault+0xd8> @ imm = #0x3a
; 		reason = K_ERR_ARM_BUS_UNSTACKING;
 80025a4: 2318         	movs	r3, #0x18
 80025a6: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Unstacking error");
 80025a8: 2303         	movs	r3, #0x3
 80025aa: 2b00         	cmp	r3, #0x0
 80025ac: d018         	beq	0x80025e0 <bus_fault+0xd8> @ imm = #0x30
 80025ae: 2301         	movs	r3, #0x1
 80025b0: f887 3043    	strb.w	r3, [r7, #0x43]
 80025b4: f897 3043    	ldrb.w	r3, [r7, #0x43]
 80025b8: f083 0301    	eor	r3, r3, #0x1
 80025bc: b2db         	uxtb	r3, r3
 80025be: 2b00         	cmp	r3, #0x0
 80025c0: d10e         	bne	0x80025e0 <bus_fault+0xd8> @ imm = #0x1c
 80025c2: 4b6f         	ldr	r3, [pc, #0x1bc]        @ 0x8002780 <bus_fault+0x278>
 80025c4: 6819         	ldr	r1, [r3]
 80025c6: 4b72         	ldr	r3, [pc, #0x1c8]        @ 0x8002790 <bus_fault+0x288>
 80025c8: 9302         	str	r3, [sp, #0x8]
 80025ca: 2300         	movs	r3, #0x0
 80025cc: 9301         	str	r3, [sp, #0x4]
 80025ce: 2300         	movs	r3, #0x0
 80025d0: 9300         	str	r3, [sp]
 80025d2: 2300         	movs	r3, #0x0
 80025d4: 2201         	movs	r2, #0x1
 80025d6: 2000         	movs	r0, #0x0
 80025d8: f00c fc1a    	bl	0x800ee10 <z_log_msg_runtime_create> @ imm = #0xc834
 80025dc: 2300         	movs	r3, #0x0
 80025de: 63fb         	str	r3, [r7, #0x3c]
; 	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
 80025e0: 4b69         	ldr	r3, [pc, #0x1a4]        @ 0x8002788 <bus_fault+0x280>
 80025e2: 6a9b         	ldr	r3, [r3, #0x28]
 80025e4: f403 7300    	and	r3, r3, #0x200
 80025e8: 2b00         	cmp	r3, #0x0
 80025ea: d04d         	beq	0x8002688 <bus_fault+0x180> @ imm = #0x9a
; 		reason = K_ERR_ARM_BUS_PRECISE_DATA_BUS;
 80025ec: 2319         	movs	r3, #0x19
 80025ee: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Precise data bus error");
 80025f0: 2303         	movs	r3, #0x3
 80025f2: 2b00         	cmp	r3, #0x0
 80025f4: d018         	beq	0x8002628 <bus_fault+0x120> @ imm = #0x30
 80025f6: 2301         	movs	r3, #0x1
 80025f8: f887 303b    	strb.w	r3, [r7, #0x3b]
 80025fc: f897 303b    	ldrb.w	r3, [r7, #0x3b]
 8002600: f083 0301    	eor	r3, r3, #0x1
 8002604: b2db         	uxtb	r3, r3
 8002606: 2b00         	cmp	r3, #0x0
 8002608: d10e         	bne	0x8002628 <bus_fault+0x120> @ imm = #0x1c
 800260a: 4b5d         	ldr	r3, [pc, #0x174]        @ 0x8002780 <bus_fault+0x278>
 800260c: 6819         	ldr	r1, [r3]
 800260e: 4b61         	ldr	r3, [pc, #0x184]        @ 0x8002794 <bus_fault+0x28c>
 8002610: 9302         	str	r3, [sp, #0x8]
 8002612: 2300         	movs	r3, #0x0
 8002614: 9301         	str	r3, [sp, #0x4]
 8002616: 2300         	movs	r3, #0x0
 8002618: 9300         	str	r3, [sp]
 800261a: 2300         	movs	r3, #0x0
 800261c: 2201         	movs	r2, #0x1
 800261e: 2000         	movs	r0, #0x0
 8002620: f00c fbf6    	bl	0x800ee10 <z_log_msg_runtime_create> @ imm = #0xc7ec
 8002624: 2300         	movs	r3, #0x0
 8002626: 637b         	str	r3, [r7, #0x34]
; 		STORE_xFAR(bfar, SCB->BFAR);
 8002628: 4b57         	ldr	r3, [pc, #0x15c]        @ 0x8002788 <bus_fault+0x280>
 800262a: 6b9b         	ldr	r3, [r3, #0x38]
 800262c: 633b         	str	r3, [r7, #0x30]
; 		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
 800262e: 4b56         	ldr	r3, [pc, #0x158]        @ 0x8002788 <bus_fault+0x280>
 8002630: 6a9b         	ldr	r3, [r3, #0x28]
 8002632: f403 4300    	and	r3, r3, #0x8000
 8002636: 2b00         	cmp	r3, #0x0
 8002638: d026         	beq	0x8002688 <bus_fault+0x180> @ imm = #0x4c
; 			PR_EXC("  BFAR Address: 0x%x", bfar);
 800263a: 2303         	movs	r3, #0x3
 800263c: 2b00         	cmp	r3, #0x0
 800263e: d01a         	beq	0x8002676 <bus_fault+0x16e> @ imm = #0x34
 8002640: 2301         	movs	r3, #0x1
 8002642: f887 302f    	strb.w	r3, [r7, #0x2f]
 8002646: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 800264a: f083 0301    	eor	r3, r3, #0x1
 800264e: b2db         	uxtb	r3, r3
 8002650: 2b00         	cmp	r3, #0x0
 8002652: d110         	bne	0x8002676 <bus_fault+0x16e> @ imm = #0x20
 8002654: 4b4a         	ldr	r3, [pc, #0x128]        @ 0x8002780 <bus_fault+0x278>
 8002656: 6819         	ldr	r1, [r3]
 8002658: 6b3b         	ldr	r3, [r7, #0x30]
 800265a: 9303         	str	r3, [sp, #0xc]
 800265c: 4b4e         	ldr	r3, [pc, #0x138]        @ 0x8002798 <bus_fault+0x290>
 800265e: 9302         	str	r3, [sp, #0x8]
 8002660: 2300         	movs	r3, #0x0
 8002662: 9301         	str	r3, [sp, #0x4]
 8002664: 2300         	movs	r3, #0x0
 8002666: 9300         	str	r3, [sp]
 8002668: 2300         	movs	r3, #0x0
 800266a: 2201         	movs	r2, #0x1
 800266c: 2000         	movs	r0, #0x0
 800266e: f00c fbcf    	bl	0x800ee10 <z_log_msg_runtime_create> @ imm = #0xc79e
 8002672: 2300         	movs	r3, #0x0
 8002674: 62bb         	str	r3, [r7, #0x28]
; 			if (from_hard_fault != 0) {
 8002676: 68bb         	ldr	r3, [r7, #0x8]
 8002678: 2b00         	cmp	r3, #0x0
 800267a: d005         	beq	0x8002688 <bus_fault+0x180> @ imm = #0xa
; 				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
 800267c: 4b42         	ldr	r3, [pc, #0x108]        @ 0x8002788 <bus_fault+0x280>
 800267e: 6a9b         	ldr	r3, [r3, #0x28]
 8002680: 4a41         	ldr	r2, [pc, #0x104]        @ 0x8002788 <bus_fault+0x280>
 8002682: f423 4300    	bic	r3, r3, #0x8000
 8002686: 6293         	str	r3, [r2, #0x28]
; 	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
 8002688: 4b3f         	ldr	r3, [pc, #0xfc]         @ 0x8002788 <bus_fault+0x280>
 800268a: 6a9b         	ldr	r3, [r3, #0x28]
 800268c: f403 6380    	and	r3, r3, #0x400
 8002690: 2b00         	cmp	r3, #0x0
 8002692: d01d         	beq	0x80026d0 <bus_fault+0x1c8> @ imm = #0x3a
; 		reason = K_ERR_ARM_BUS_IMPRECISE_DATA_BUS;
 8002694: 231a         	movs	r3, #0x1a
 8002696: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Imprecise data bus error");
 8002698: 2303         	movs	r3, #0x3
 800269a: 2b00         	cmp	r3, #0x0
 800269c: d018         	beq	0x80026d0 <bus_fault+0x1c8> @ imm = #0x30
 800269e: 2301         	movs	r3, #0x1
 80026a0: f887 3027    	strb.w	r3, [r7, #0x27]
 80026a4: f897 3027    	ldrb.w	r3, [r7, #0x27]
 80026a8: f083 0301    	eor	r3, r3, #0x1
 80026ac: b2db         	uxtb	r3, r3
 80026ae: 2b00         	cmp	r3, #0x0
 80026b0: d10e         	bne	0x80026d0 <bus_fault+0x1c8> @ imm = #0x1c
 80026b2: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x8002780 <bus_fault+0x278>
 80026b4: 6819         	ldr	r1, [r3]
 80026b6: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x800279c <bus_fault+0x294>
 80026b8: 9302         	str	r3, [sp, #0x8]
 80026ba: 2300         	movs	r3, #0x0
 80026bc: 9301         	str	r3, [sp, #0x4]
 80026be: 2300         	movs	r3, #0x0
 80026c0: 9300         	str	r3, [sp]
 80026c2: 2300         	movs	r3, #0x0
 80026c4: 2201         	movs	r2, #0x1
 80026c6: 2000         	movs	r0, #0x0
 80026c8: f00c fba2    	bl	0x800ee10 <z_log_msg_runtime_create> @ imm = #0xc744
 80026cc: 2300         	movs	r3, #0x0
 80026ce: 623b         	str	r3, [r7, #0x20]
; 	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
 80026d0: 4b2d         	ldr	r3, [pc, #0xb4]         @ 0x8002788 <bus_fault+0x280>
 80026d2: 6a9b         	ldr	r3, [r3, #0x28]
 80026d4: f403 7380    	and	r3, r3, #0x100
 80026d8: 2b00         	cmp	r3, #0x0
 80026da: d01c         	beq	0x8002716 <bus_fault+0x20e> @ imm = #0x38
; 		reason = K_ERR_ARM_BUS_INSTRUCTION_BUS;
 80026dc: 231b         	movs	r3, #0x1b
 80026de: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Instruction bus error");
 80026e0: 2303         	movs	r3, #0x3
 80026e2: 2b00         	cmp	r3, #0x0
 80026e4: d039         	beq	0x800275a <bus_fault+0x252> @ imm = #0x72
 80026e6: 2301         	movs	r3, #0x1
 80026e8: 75fb         	strb	r3, [r7, #0x17]
 80026ea: 7dfb         	ldrb	r3, [r7, #0x17]
 80026ec: f083 0301    	eor	r3, r3, #0x1
 80026f0: b2db         	uxtb	r3, r3
 80026f2: 2b00         	cmp	r3, #0x0
 80026f4: d131         	bne	0x800275a <bus_fault+0x252> @ imm = #0x62
 80026f6: 4b22         	ldr	r3, [pc, #0x88]         @ 0x8002780 <bus_fault+0x278>
 80026f8: 6819         	ldr	r1, [r3]
 80026fa: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x80027a0 <bus_fault+0x298>
 80026fc: 9302         	str	r3, [sp, #0x8]
 80026fe: 2300         	movs	r3, #0x0
 8002700: 9301         	str	r3, [sp, #0x4]
 8002702: 2300         	movs	r3, #0x0
 8002704: 9300         	str	r3, [sp]
 8002706: 2300         	movs	r3, #0x0
 8002708: 2201         	movs	r2, #0x1
 800270a: 2000         	movs	r0, #0x0
 800270c: f00c fb80    	bl	0x800ee10 <z_log_msg_runtime_create> @ imm = #0xc700
 8002710: 2300         	movs	r3, #0x0
 8002712: 613b         	str	r3, [r7, #0x10]
 8002714: e021         	b	0x800275a <bus_fault+0x252> @ imm = #0x42
; 	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
 8002716: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x8002788 <bus_fault+0x280>
 8002718: 6a9b         	ldr	r3, [r3, #0x28]
 800271a: f403 5300    	and	r3, r3, #0x2000
 800271e: 2b00         	cmp	r3, #0x0
 8002720: d01b         	beq	0x800275a <bus_fault+0x252> @ imm = #0x36
; 		reason = K_ERR_ARM_BUS_FP_LAZY_STATE_PRESERVATION;
 8002722: 231c         	movs	r3, #0x1c
 8002724: 657b         	str	r3, [r7, #0x54]
; 		PR_FAULT_INFO("  Floating-point lazy state preservation error");
 8002726: 2303         	movs	r3, #0x3
 8002728: 2b00         	cmp	r3, #0x0
 800272a: d016         	beq	0x800275a <bus_fault+0x252> @ imm = #0x2c
 800272c: 2301         	movs	r3, #0x1
 800272e: 77fb         	strb	r3, [r7, #0x1f]
 8002730: 7ffb         	ldrb	r3, [r7, #0x1f]
 8002732: f083 0301    	eor	r3, r3, #0x1
 8002736: b2db         	uxtb	r3, r3
 8002738: 2b00         	cmp	r3, #0x0
 800273a: d10e         	bne	0x800275a <bus_fault+0x252> @ imm = #0x1c
 800273c: 4b10         	ldr	r3, [pc, #0x40]         @ 0x8002780 <bus_fault+0x278>
 800273e: 6819         	ldr	r1, [r3]
 8002740: 4b18         	ldr	r3, [pc, #0x60]         @ 0x80027a4 <bus_fault+0x29c>
 8002742: 9302         	str	r3, [sp, #0x8]
 8002744: 2300         	movs	r3, #0x0
 8002746: 9301         	str	r3, [sp, #0x4]
 8002748: 2300         	movs	r3, #0x0
 800274a: 9300         	str	r3, [sp]
 800274c: 2300         	movs	r3, #0x0
 800274e: 2201         	movs	r2, #0x1
 8002750: 2000         	movs	r0, #0x0
 8002752: f00c fb5d    	bl	0x800ee10 <z_log_msg_runtime_create> @ imm = #0xc6ba
 8002756: 2300         	movs	r3, #0x0
 8002758: 61bb         	str	r3, [r7, #0x18]
; 	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
 800275a: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8002788 <bus_fault+0x280>
 800275c: 6a9b         	ldr	r3, [r3, #0x28]
 800275e: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x8002788 <bus_fault+0x280>
 8002760: f443 437f    	orr	r3, r3, #0xff00
 8002764: 6293         	str	r3, [r2, #0x28]
; 	*recoverable = memory_fault_recoverable(esf, true);
 8002766: 2101         	movs	r1, #0x1
 8002768: 68f8         	ldr	r0, [r7, #0xc]
 800276a: f00c fb79    	bl	0x800ee60 <memory_fault_recoverable> @ imm = #0xc6f2
 800276e: 4603         	mov	r3, r0
 8002770: 461a         	mov	r2, r3
 8002772: 687b         	ldr	r3, [r7, #0x4]
 8002774: 701a         	strb	r2, [r3]
; 	return reason;
 8002776: 6d7b         	ldr	r3, [r7, #0x54]
; }
 8002778: 4618         	mov	r0, r3
 800277a: 3758         	adds	r7, #0x58
 800277c: 46bd         	mov	sp, r7
 800277e: bd80         	pop	{r7, pc}

08002780 <$d>:
 8002780: 20 00 00 20  	.word	0x20000020
 8002784: 58 4f 01 08  	.word	0x08014f58
 8002788: 00 ed 00 e0  	.word	0xe000ed00
 800278c: 70 4f 01 08  	.word	0x08014f70
 8002790: c4 4e 01 08  	.word	0x08014ec4
 8002794: 84 4f 01 08  	.word	0x08014f84
 8002798: a0 4f 01 08  	.word	0x08014fa0
 800279c: b8 4f 01 08  	.word	0x08014fb8
 80027a0: d4 4f 01 08  	.word	0x08014fd4
 80027a4: 28 4f 01 08  	.word	0x08014f28

080027a8 <usage_fault>:
; {
 80027a8: b580         	push	{r7, lr}
 80027aa: b096         	sub	sp, #0x58
 80027ac: af04         	add	r7, sp, #0x10
 80027ae: 6078         	str	r0, [r7, #0x4]
; 	uint32_t reason = K_ERR_ARM_USAGE_GENERIC;
 80027b0: 231d         	movs	r3, #0x1d
 80027b2: 647b         	str	r3, [r7, #0x44]
; 	PR_FAULT_INFO("***** USAGE FAULT *****");
 80027b4: 2303         	movs	r3, #0x3
 80027b6: 2b00         	cmp	r3, #0x0
 80027b8: d018         	beq	0x80027ec <usage_fault+0x44> @ imm = #0x30
 80027ba: 2301         	movs	r3, #0x1
 80027bc: f887 3043    	strb.w	r3, [r7, #0x43]
 80027c0: f897 3043    	ldrb.w	r3, [r7, #0x43]
 80027c4: f083 0301    	eor	r3, r3, #0x1
 80027c8: b2db         	uxtb	r3, r3
 80027ca: 2b00         	cmp	r3, #0x0
 80027cc: d10e         	bne	0x80027ec <usage_fault+0x44> @ imm = #0x1c
 80027ce: 4b78         	ldr	r3, [pc, #0x1e0]        @ 0x80029b0 <usage_fault+0x208>
 80027d0: 6819         	ldr	r1, [r3]
 80027d2: 4b78         	ldr	r3, [pc, #0x1e0]        @ 0x80029b4 <usage_fault+0x20c>
 80027d4: 9302         	str	r3, [sp, #0x8]
 80027d6: 2300         	movs	r3, #0x0
 80027d8: 9301         	str	r3, [sp, #0x4]
 80027da: 2300         	movs	r3, #0x0
 80027dc: 9300         	str	r3, [sp]
 80027de: 2300         	movs	r3, #0x0
 80027e0: 2201         	movs	r2, #0x1
 80027e2: 2000         	movs	r0, #0x0
 80027e4: f00c fb14    	bl	0x800ee10 <z_log_msg_runtime_create> @ imm = #0xc628
 80027e8: 2300         	movs	r3, #0x0
 80027ea: 63fb         	str	r3, [r7, #0x3c]
; 	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
 80027ec: 4b72         	ldr	r3, [pc, #0x1c8]        @ 0x80029b8 <usage_fault+0x210>
 80027ee: 6a9b         	ldr	r3, [r3, #0x28]
 80027f0: f003 7300    	and	r3, r3, #0x2000000
 80027f4: 2b00         	cmp	r3, #0x0
 80027f6: d01d         	beq	0x8002834 <usage_fault+0x8c> @ imm = #0x3a
; 		reason = K_ERR_ARM_USAGE_DIV_0;
 80027f8: 231e         	movs	r3, #0x1e
 80027fa: 647b         	str	r3, [r7, #0x44]
; 		PR_FAULT_INFO("  Division by zero");
 80027fc: 2303         	movs	r3, #0x3
 80027fe: 2b00         	cmp	r3, #0x0
 8002800: d018         	beq	0x8002834 <usage_fault+0x8c> @ imm = #0x30
 8002802: 2301         	movs	r3, #0x1
 8002804: f887 303b    	strb.w	r3, [r7, #0x3b]
 8002808: f897 303b    	ldrb.w	r3, [r7, #0x3b]
 800280c: f083 0301    	eor	r3, r3, #0x1
 8002810: b2db         	uxtb	r3, r3
 8002812: 2b00         	cmp	r3, #0x0
 8002814: d10e         	bne	0x8002834 <usage_fault+0x8c> @ imm = #0x1c
 8002816: 4b66         	ldr	r3, [pc, #0x198]        @ 0x80029b0 <usage_fault+0x208>
 8002818: 6819         	ldr	r1, [r3]
 800281a: 4b68         	ldr	r3, [pc, #0x1a0]        @ 0x80029bc <usage_fault+0x214>
 800281c: 9302         	str	r3, [sp, #0x8]
 800281e: 2300         	movs	r3, #0x0
 8002820: 9301         	str	r3, [sp, #0x4]
 8002822: 2300         	movs	r3, #0x0
 8002824: 9300         	str	r3, [sp]
 8002826: 2300         	movs	r3, #0x0
 8002828: 2201         	movs	r2, #0x1
 800282a: 2000         	movs	r0, #0x0
 800282c: f00c faf0    	bl	0x800ee10 <z_log_msg_runtime_create> @ imm = #0xc5e0
 8002830: 2300         	movs	r3, #0x0
 8002832: 637b         	str	r3, [r7, #0x34]
; 	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
 8002834: 4b60         	ldr	r3, [pc, #0x180]        @ 0x80029b8 <usage_fault+0x210>
 8002836: 6a9b         	ldr	r3, [r3, #0x28]
 8002838: f003 7380    	and	r3, r3, #0x1000000
 800283c: 2b00         	cmp	r3, #0x0
 800283e: d01d         	beq	0x800287c <usage_fault+0xd4> @ imm = #0x3a
; 		reason = K_ERR_ARM_USAGE_UNALIGNED_ACCESS;
 8002840: 231f         	movs	r3, #0x1f
 8002842: 647b         	str	r3, [r7, #0x44]
; 		PR_FAULT_INFO("  Unaligned memory access");
 8002844: 2303         	movs	r3, #0x3
 8002846: 2b00         	cmp	r3, #0x0
 8002848: d018         	beq	0x800287c <usage_fault+0xd4> @ imm = #0x30
 800284a: 2301         	movs	r3, #0x1
 800284c: f887 3033    	strb.w	r3, [r7, #0x33]
 8002850: f897 3033    	ldrb.w	r3, [r7, #0x33]
 8002854: f083 0301    	eor	r3, r3, #0x1
 8002858: b2db         	uxtb	r3, r3
 800285a: 2b00         	cmp	r3, #0x0
 800285c: d10e         	bne	0x800287c <usage_fault+0xd4> @ imm = #0x1c
 800285e: 4b54         	ldr	r3, [pc, #0x150]        @ 0x80029b0 <usage_fault+0x208>
 8002860: 6819         	ldr	r1, [r3]
 8002862: 4b57         	ldr	r3, [pc, #0x15c]        @ 0x80029c0 <usage_fault+0x218>
 8002864: 9302         	str	r3, [sp, #0x8]
 8002866: 2300         	movs	r3, #0x0
 8002868: 9301         	str	r3, [sp, #0x4]
 800286a: 2300         	movs	r3, #0x0
 800286c: 9300         	str	r3, [sp]
 800286e: 2300         	movs	r3, #0x0
 8002870: 2201         	movs	r2, #0x1
 8002872: 2000         	movs	r0, #0x0
 8002874: f00c facc    	bl	0x800ee10 <z_log_msg_runtime_create> @ imm = #0xc598
 8002878: 2300         	movs	r3, #0x0
 800287a: 62fb         	str	r3, [r7, #0x2c]
; 	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
 800287c: 4b4e         	ldr	r3, [pc, #0x138]        @ 0x80029b8 <usage_fault+0x210>
 800287e: 6a9b         	ldr	r3, [r3, #0x28]
 8002880: f403 2300    	and	r3, r3, #0x80000
 8002884: 2b00         	cmp	r3, #0x0
 8002886: d01d         	beq	0x80028c4 <usage_fault+0x11c> @ imm = #0x3a
; 		reason = K_ERR_ARM_USAGE_NO_COPROCESSOR;
 8002888: 2321         	movs	r3, #0x21
 800288a: 647b         	str	r3, [r7, #0x44]
; 		PR_FAULT_INFO("  No coprocessor instructions");
 800288c: 2303         	movs	r3, #0x3
 800288e: 2b00         	cmp	r3, #0x0
 8002890: d018         	beq	0x80028c4 <usage_fault+0x11c> @ imm = #0x30
 8002892: 2301         	movs	r3, #0x1
 8002894: f887 302b    	strb.w	r3, [r7, #0x2b]
 8002898: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 800289c: f083 0301    	eor	r3, r3, #0x1
 80028a0: b2db         	uxtb	r3, r3
 80028a2: 2b00         	cmp	r3, #0x0
 80028a4: d10e         	bne	0x80028c4 <usage_fault+0x11c> @ imm = #0x1c
 80028a6: 4b42         	ldr	r3, [pc, #0x108]        @ 0x80029b0 <usage_fault+0x208>
 80028a8: 6819         	ldr	r1, [r3]
 80028aa: 4b46         	ldr	r3, [pc, #0x118]        @ 0x80029c4 <usage_fault+0x21c>
 80028ac: 9302         	str	r3, [sp, #0x8]
 80028ae: 2300         	movs	r3, #0x0
 80028b0: 9301         	str	r3, [sp, #0x4]
 80028b2: 2300         	movs	r3, #0x0
 80028b4: 9300         	str	r3, [sp]
 80028b6: 2300         	movs	r3, #0x0
 80028b8: 2201         	movs	r2, #0x1
 80028ba: 2000         	movs	r0, #0x0
 80028bc: f00c faa8    	bl	0x800ee10 <z_log_msg_runtime_create> @ imm = #0xc550
 80028c0: 2300         	movs	r3, #0x0
 80028c2: 627b         	str	r3, [r7, #0x24]
; 	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
 80028c4: 4b3c         	ldr	r3, [pc, #0xf0]         @ 0x80029b8 <usage_fault+0x210>
 80028c6: 6a9b         	ldr	r3, [r3, #0x28]
 80028c8: f403 2380    	and	r3, r3, #0x40000
 80028cc: 2b00         	cmp	r3, #0x0
 80028ce: d01d         	beq	0x800290c <usage_fault+0x164> @ imm = #0x3a
; 		reason = K_ERR_ARM_USAGE_ILLEGAL_EXC_RETURN;
 80028d0: 2322         	movs	r3, #0x22
 80028d2: 647b         	str	r3, [r7, #0x44]
; 		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC");
 80028d4: 2303         	movs	r3, #0x3
 80028d6: 2b00         	cmp	r3, #0x0
 80028d8: d018         	beq	0x800290c <usage_fault+0x164> @ imm = #0x30
 80028da: 2301         	movs	r3, #0x1
 80028dc: f887 3023    	strb.w	r3, [r7, #0x23]
 80028e0: f897 3023    	ldrb.w	r3, [r7, #0x23]
 80028e4: f083 0301    	eor	r3, r3, #0x1
 80028e8: b2db         	uxtb	r3, r3
 80028ea: 2b00         	cmp	r3, #0x0
 80028ec: d10e         	bne	0x800290c <usage_fault+0x164> @ imm = #0x1c
 80028ee: 4b30         	ldr	r3, [pc, #0xc0]         @ 0x80029b0 <usage_fault+0x208>
 80028f0: 6819         	ldr	r1, [r3]
 80028f2: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x80029c8 <usage_fault+0x220>
 80028f4: 9302         	str	r3, [sp, #0x8]
 80028f6: 2300         	movs	r3, #0x0
 80028f8: 9301         	str	r3, [sp, #0x4]
 80028fa: 2300         	movs	r3, #0x0
 80028fc: 9300         	str	r3, [sp]
 80028fe: 2300         	movs	r3, #0x0
 8002900: 2201         	movs	r2, #0x1
 8002902: 2000         	movs	r0, #0x0
 8002904: f00c fa84    	bl	0x800ee10 <z_log_msg_runtime_create> @ imm = #0xc508
 8002908: 2300         	movs	r3, #0x0
 800290a: 61fb         	str	r3, [r7, #0x1c]
; 	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
 800290c: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x80029b8 <usage_fault+0x210>
 800290e: 6a9b         	ldr	r3, [r3, #0x28]
 8002910: f403 3300    	and	r3, r3, #0x20000
 8002914: 2b00         	cmp	r3, #0x0
 8002916: d01b         	beq	0x8002950 <usage_fault+0x1a8> @ imm = #0x36
; 		reason = K_ERR_ARM_USAGE_ILLEGAL_EPSR;
 8002918: 2323         	movs	r3, #0x23
 800291a: 647b         	str	r3, [r7, #0x44]
; 		PR_FAULT_INFO("  Illegal use of the EPSR");
 800291c: 2303         	movs	r3, #0x3
 800291e: 2b00         	cmp	r3, #0x0
 8002920: d016         	beq	0x8002950 <usage_fault+0x1a8> @ imm = #0x2c
 8002922: 2301         	movs	r3, #0x1
 8002924: 76fb         	strb	r3, [r7, #0x1b]
 8002926: 7efb         	ldrb	r3, [r7, #0x1b]
 8002928: f083 0301    	eor	r3, r3, #0x1
 800292c: b2db         	uxtb	r3, r3
 800292e: 2b00         	cmp	r3, #0x0
 8002930: d10e         	bne	0x8002950 <usage_fault+0x1a8> @ imm = #0x1c
 8002932: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x80029b0 <usage_fault+0x208>
 8002934: 6819         	ldr	r1, [r3]
 8002936: 4b25         	ldr	r3, [pc, #0x94]         @ 0x80029cc <usage_fault+0x224>
 8002938: 9302         	str	r3, [sp, #0x8]
 800293a: 2300         	movs	r3, #0x0
 800293c: 9301         	str	r3, [sp, #0x4]
 800293e: 2300         	movs	r3, #0x0
 8002940: 9300         	str	r3, [sp]
 8002942: 2300         	movs	r3, #0x0
 8002944: 2201         	movs	r2, #0x1
 8002946: 2000         	movs	r0, #0x0
 8002948: f00c fa62    	bl	0x800ee10 <z_log_msg_runtime_create> @ imm = #0xc4c4
 800294c: 2300         	movs	r3, #0x0
 800294e: 617b         	str	r3, [r7, #0x14]
; 	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
 8002950: 4b19         	ldr	r3, [pc, #0x64]         @ 0x80029b8 <usage_fault+0x210>
 8002952: 6a9b         	ldr	r3, [r3, #0x28]
 8002954: f403 3380    	and	r3, r3, #0x10000
 8002958: 2b00         	cmp	r3, #0x0
 800295a: d01b         	beq	0x8002994 <usage_fault+0x1ec> @ imm = #0x36
; 		reason = K_ERR_ARM_USAGE_UNDEFINED_INSTRUCTION;
 800295c: 2324         	movs	r3, #0x24
 800295e: 647b         	str	r3, [r7, #0x44]
; 		PR_FAULT_INFO("  Attempt to execute undefined instruction");
 8002960: 2303         	movs	r3, #0x3
 8002962: 2b00         	cmp	r3, #0x0
 8002964: d016         	beq	0x8002994 <usage_fault+0x1ec> @ imm = #0x2c
 8002966: 2301         	movs	r3, #0x1
 8002968: 74fb         	strb	r3, [r7, #0x13]
 800296a: 7cfb         	ldrb	r3, [r7, #0x13]
 800296c: f083 0301    	eor	r3, r3, #0x1
 8002970: b2db         	uxtb	r3, r3
 8002972: 2b00         	cmp	r3, #0x0
 8002974: d10e         	bne	0x8002994 <usage_fault+0x1ec> @ imm = #0x1c
 8002976: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x80029b0 <usage_fault+0x208>
 8002978: 6819         	ldr	r1, [r3]
 800297a: 4b15         	ldr	r3, [pc, #0x54]         @ 0x80029d0 <usage_fault+0x228>
 800297c: 9302         	str	r3, [sp, #0x8]
 800297e: 2300         	movs	r3, #0x0
 8002980: 9301         	str	r3, [sp, #0x4]
 8002982: 2300         	movs	r3, #0x0
 8002984: 9300         	str	r3, [sp]
 8002986: 2300         	movs	r3, #0x0
 8002988: 2201         	movs	r2, #0x1
 800298a: 2000         	movs	r0, #0x0
 800298c: f00c fa40    	bl	0x800ee10 <z_log_msg_runtime_create> @ imm = #0xc480
 8002990: 2300         	movs	r3, #0x0
 8002992: 60fb         	str	r3, [r7, #0xc]
; 	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
 8002994: 4b08         	ldr	r3, [pc, #0x20]         @ 0x80029b8 <usage_fault+0x210>
 8002996: 6a9b         	ldr	r3, [r3, #0x28]
 8002998: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x80029b8 <usage_fault+0x210>
 800299a: ea6f 4303    	mvn.w	r3, r3, lsl #16
 800299e: ea6f 4313    	mvn.w	r3, r3, lsr #16
 80029a2: 6293         	str	r3, [r2, #0x28]
; 	return reason;
 80029a4: 6c7b         	ldr	r3, [r7, #0x44]
; }
 80029a6: 4618         	mov	r0, r3
 80029a8: 3748         	adds	r7, #0x48
 80029aa: 46bd         	mov	sp, r7
 80029ac: bd80         	pop	{r7, pc}
 80029ae: bf00         	nop

080029b0 <$d>:
 80029b0: 20 00 00 20  	.word	0x20000020
 80029b4: ec 4f 01 08  	.word	0x08014fec
 80029b8: 00 ed 00 e0  	.word	0xe000ed00
 80029bc: 04 50 01 08  	.word	0x08015004
 80029c0: 18 50 01 08  	.word	0x08015018
 80029c4: 34 50 01 08  	.word	0x08015034
 80029c8: 54 50 01 08  	.word	0x08015054
 80029cc: 7c 50 01 08  	.word	0x0801507c
 80029d0: 98 50 01 08  	.word	0x08015098

080029d4 <debug_monitor>:
; {
 80029d4: b580         	push	{r7, lr}
 80029d6: b088         	sub	sp, #0x20
 80029d8: af04         	add	r7, sp, #0x10
 80029da: 6078         	str	r0, [r7, #0x4]
 80029dc: 6039         	str	r1, [r7]
; 	*recoverable = false;
 80029de: 683b         	ldr	r3, [r7]
 80029e0: 2200         	movs	r2, #0x0
 80029e2: 701a         	strb	r2, [r3]
; 	PR_FAULT_INFO(
 80029e4: 2303         	movs	r3, #0x3
 80029e6: 2b00         	cmp	r3, #0x0
 80029e8: d017         	beq	0x8002a1a <debug_monitor+0x46> @ imm = #0x2e
 80029ea: 2301         	movs	r3, #0x1
 80029ec: 73fb         	strb	r3, [r7, #0xf]
 80029ee: 7bfb         	ldrb	r3, [r7, #0xf]
 80029f0: f083 0301    	eor	r3, r3, #0x1
 80029f4: b2db         	uxtb	r3, r3
 80029f6: 2b00         	cmp	r3, #0x0
 80029f8: d10f         	bne	0x8002a1a <debug_monitor+0x46> @ imm = #0x1e
 80029fa: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8002a24 <debug_monitor+0x50>
 80029fc: 6819         	ldr	r1, [r3]
 80029fe: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8002a28 <debug_monitor+0x54>
 8002a00: 9302         	str	r3, [sp, #0x8]
 8002a02: 2300         	movs	r3, #0x0
 8002a04: 9301         	str	r3, [sp, #0x4]
 8002a06: 2300         	movs	r3, #0x0
 8002a08: 9300         	str	r3, [sp]
 8002a0a: 2300         	movs	r3, #0x0
 8002a0c: 2201         	movs	r2, #0x1
 8002a0e: 2000         	movs	r0, #0x0
 8002a10: f00c f9fe    	bl	0x800ee10 <z_log_msg_runtime_create> @ imm = #0xc3fc
 8002a14: 2300         	movs	r3, #0x0
 8002a16: 60bb         	str	r3, [r7, #0x8]
; }
 8002a18: bf00         	nop
 8002a1a: bf00         	nop
 8002a1c: 3710         	adds	r7, #0x10
 8002a1e: 46bd         	mov	sp, r7
 8002a20: bd80         	pop	{r7, pc}
 8002a22: bf00         	nop

08002a24 <$d>:
 8002a24: 20 00 00 20  	.word	0x20000020
 8002a28: c4 50 01 08  	.word	0x080150c4

08002a2c <z_arm_is_synchronous_svc>:
; {
 8002a2c: b480         	push	{r7}
 8002a2e: b085         	sub	sp, #0x14
 8002a30: af00         	add	r7, sp, #0x0
 8002a32: 6078         	str	r0, [r7, #0x4]
; 	uint16_t *ret_addr = (uint16_t *)esf->basic.pc;
 8002a34: 687b         	ldr	r3, [r7, #0x4]
 8002a36: 699b         	ldr	r3, [r3, #0x18]
 8002a38: 60fb         	str	r3, [r7, #0xc]
; 	SCB->CCR |= SCB_CCR_BFHFNMIGN_Msk;
 8002a3a: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x8002aa8 <z_arm_is_synchronous_svc+0x7c>
 8002a3c: 695b         	ldr	r3, [r3, #0x14]
 8002a3e: 4a1a         	ldr	r2, [pc, #0x68]         @ 0x8002aa8 <z_arm_is_synchronous_svc+0x7c>
 8002a40: f443 7380    	orr	r3, r3, #0x100
 8002a44: 6153         	str	r3, [r2, #0x14]
;   __ASM volatile ("dsb 0xF":::"memory");
 8002a46: f3bf 8f4f    	dsb	sy
; }
 8002a4a: bf00         	nop
; }
 8002a4c: bf00         	nop
; }
 8002a4e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8002a50: f3bf 8f6f    	isb	sy
; }
 8002a54: bf00         	nop
; }
 8002a56: bf00         	nop
; }
 8002a58: bf00         	nop
; 	uint16_t fault_insn = *(ret_addr - 1);
 8002a5a: 68fb         	ldr	r3, [r7, #0xc]
 8002a5c: f833 3c02    	ldrh	r3, [r3, #-2]
 8002a60: 817b         	strh	r3, [r7, #0xa]
; 	SCB->CCR &= ~SCB_CCR_BFHFNMIGN_Msk;
 8002a62: 4b11         	ldr	r3, [pc, #0x44]         @ 0x8002aa8 <z_arm_is_synchronous_svc+0x7c>
 8002a64: 695b         	ldr	r3, [r3, #0x14]
 8002a66: 4a10         	ldr	r2, [pc, #0x40]         @ 0x8002aa8 <z_arm_is_synchronous_svc+0x7c>
 8002a68: f423 7380    	bic	r3, r3, #0x100
 8002a6c: 6153         	str	r3, [r2, #0x14]
;   __ASM volatile ("dsb 0xF":::"memory");
 8002a6e: f3bf 8f4f    	dsb	sy
; }
 8002a72: bf00         	nop
; }
 8002a74: bf00         	nop
; }
 8002a76: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8002a78: f3bf 8f6f    	isb	sy
; }
 8002a7c: bf00         	nop
; }
 8002a7e: bf00         	nop
; }
 8002a80: bf00         	nop
; 	if (((fault_insn & 0xff00) == _SVC_OPCODE) &&
 8002a82: 897b         	ldrh	r3, [r7, #0xa]
 8002a84: f403 437f    	and	r3, r3, #0xff00
 8002a88: f5b3 4f5f    	cmp.w	r3, #0xdf00
 8002a8c: d105         	bne	0x8002a9a <z_arm_is_synchronous_svc+0x6e> @ imm = #0xa
; 		((fault_insn & 0x00ff) == _SVC_CALL_RUNTIME_EXCEPT)) {
 8002a8e: 897b         	ldrh	r3, [r7, #0xa]
 8002a90: b2db         	uxtb	r3, r3
; 	if (((fault_insn & 0xff00) == _SVC_OPCODE) &&
 8002a92: 2b02         	cmp	r3, #0x2
 8002a94: d101         	bne	0x8002a9a <z_arm_is_synchronous_svc+0x6e> @ imm = #0x2
; 		return true;
 8002a96: 2301         	movs	r3, #0x1
 8002a98: e000         	b	0x8002a9c <z_arm_is_synchronous_svc+0x70> @ imm = #0x0
; 	return false;
 8002a9a: 2300         	movs	r3, #0x0
; }
 8002a9c: 4618         	mov	r0, r3
 8002a9e: 3714         	adds	r7, #0x14
 8002aa0: 46bd         	mov	sp, r7
 8002aa2: bc80         	pop	{r7}
 8002aa4: 4770         	bx	lr
 8002aa6: bf00         	nop

08002aa8 <$d>:
 8002aa8: 00 ed 00 e0  	.word	0xe000ed00

08002aac <hard_fault>:
; {
 8002aac: b580         	push	{r7, lr}
 8002aae: b092         	sub	sp, #0x48
 8002ab0: af04         	add	r7, sp, #0x10
 8002ab2: 6078         	str	r0, [r7, #0x4]
 8002ab4: 6039         	str	r1, [r7]
; 	uint32_t reason = K_ERR_CPU_EXCEPTION;
 8002ab6: 2300         	movs	r3, #0x0
 8002ab8: 62fb         	str	r3, [r7, #0x2c]
; 	PR_FAULT_INFO("***** HARD FAULT *****");
 8002aba: 2303         	movs	r3, #0x3
 8002abc: 2b00         	cmp	r3, #0x0
 8002abe: d018         	beq	0x8002af2 <hard_fault+0x46> @ imm = #0x30
 8002ac0: 2301         	movs	r3, #0x1
 8002ac2: f887 3033    	strb.w	r3, [r7, #0x33]
 8002ac6: f897 3033    	ldrb.w	r3, [r7, #0x33]
 8002aca: f083 0301    	eor	r3, r3, #0x1
 8002ace: b2db         	uxtb	r3, r3
 8002ad0: 2b00         	cmp	r3, #0x0
 8002ad2: d10e         	bne	0x8002af2 <hard_fault+0x46> @ imm = #0x1c
 8002ad4: 4b63         	ldr	r3, [pc, #0x18c]        @ 0x8002c64 <hard_fault+0x1b8>
 8002ad6: 6819         	ldr	r1, [r3]
 8002ad8: 4b63         	ldr	r3, [pc, #0x18c]        @ 0x8002c68 <hard_fault+0x1bc>
 8002ada: 9302         	str	r3, [sp, #0x8]
 8002adc: 2300         	movs	r3, #0x0
 8002ade: 9301         	str	r3, [sp, #0x4]
 8002ae0: 2300         	movs	r3, #0x0
 8002ae2: 9300         	str	r3, [sp]
 8002ae4: 2300         	movs	r3, #0x0
 8002ae6: 2201         	movs	r2, #0x1
 8002ae8: 2000         	movs	r0, #0x0
 8002aea: f00c f991    	bl	0x800ee10 <z_log_msg_runtime_create> @ imm = #0xc322
 8002aee: 2300         	movs	r3, #0x0
 8002af0: 637b         	str	r3, [r7, #0x34]
; 	*recoverable = false;
 8002af2: 683b         	ldr	r3, [r7]
 8002af4: 2200         	movs	r2, #0x0
 8002af6: 701a         	strb	r2, [r3]
; 	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
 8002af8: 4b5c         	ldr	r3, [pc, #0x170]        @ 0x8002c6c <hard_fault+0x1c0>
 8002afa: 6adb         	ldr	r3, [r3, #0x2c]
 8002afc: f003 0302    	and	r3, r3, #0x2
 8002b00: 2b00         	cmp	r3, #0x0
 8002b02: d01c         	beq	0x8002b3e <hard_fault+0x92> @ imm = #0x38
; 		PR_EXC("  Bus fault on vector table read");
 8002b04: 2303         	movs	r3, #0x3
 8002b06: 2b00         	cmp	r3, #0x0
 8002b08: f000 80a7    	beq.w	0x8002c5a <hard_fault+0x1ae> @ imm = #0x14e
 8002b0c: 2301         	movs	r3, #0x1
 8002b0e: 74fb         	strb	r3, [r7, #0x13]
 8002b10: 7cfb         	ldrb	r3, [r7, #0x13]
 8002b12: f083 0301    	eor	r3, r3, #0x1
 8002b16: b2db         	uxtb	r3, r3
 8002b18: 2b00         	cmp	r3, #0x0
 8002b1a: f040 809e    	bne.w	0x8002c5a <hard_fault+0x1ae> @ imm = #0x13c
 8002b1e: 4b51         	ldr	r3, [pc, #0x144]        @ 0x8002c64 <hard_fault+0x1b8>
 8002b20: 6819         	ldr	r1, [r3]
 8002b22: 4b53         	ldr	r3, [pc, #0x14c]        @ 0x8002c70 <hard_fault+0x1c4>
 8002b24: 9302         	str	r3, [sp, #0x8]
 8002b26: 2300         	movs	r3, #0x0
 8002b28: 9301         	str	r3, [sp, #0x4]
 8002b2a: 2300         	movs	r3, #0x0
 8002b2c: 9300         	str	r3, [sp]
 8002b2e: 2300         	movs	r3, #0x0
 8002b30: 2201         	movs	r2, #0x1
 8002b32: 2000         	movs	r0, #0x0
 8002b34: f00c f96c    	bl	0x800ee10 <z_log_msg_runtime_create> @ imm = #0xc2d8
 8002b38: 2300         	movs	r3, #0x0
 8002b3a: 60fb         	str	r3, [r7, #0xc]
 8002b3c: e08d         	b	0x8002c5a <hard_fault+0x1ae> @ imm = #0x11a
; 	} else if ((SCB->HFSR & SCB_HFSR_DEBUGEVT_Msk) != 0) {
 8002b3e: 4b4b         	ldr	r3, [pc, #0x12c]        @ 0x8002c6c <hard_fault+0x1c0>
 8002b40: 6adb         	ldr	r3, [r3, #0x2c]
 8002b42: 2b00         	cmp	r3, #0x0
 8002b44: da1b         	bge	0x8002b7e <hard_fault+0xd2> @ imm = #0x36
; 		PR_EXC("  Debug event");
 8002b46: 2303         	movs	r3, #0x3
 8002b48: 2b00         	cmp	r3, #0x0
 8002b4a: f000 8086    	beq.w	0x8002c5a <hard_fault+0x1ae> @ imm = #0x10c
 8002b4e: 2301         	movs	r3, #0x1
 8002b50: 76fb         	strb	r3, [r7, #0x1b]
 8002b52: 7efb         	ldrb	r3, [r7, #0x1b]
 8002b54: f083 0301    	eor	r3, r3, #0x1
 8002b58: b2db         	uxtb	r3, r3
 8002b5a: 2b00         	cmp	r3, #0x0
 8002b5c: d17d         	bne	0x8002c5a <hard_fault+0x1ae> @ imm = #0xfa
 8002b5e: 4b41         	ldr	r3, [pc, #0x104]        @ 0x8002c64 <hard_fault+0x1b8>
 8002b60: 6819         	ldr	r1, [r3]
 8002b62: 4b44         	ldr	r3, [pc, #0x110]        @ 0x8002c74 <hard_fault+0x1c8>
 8002b64: 9302         	str	r3, [sp, #0x8]
 8002b66: 2300         	movs	r3, #0x0
 8002b68: 9301         	str	r3, [sp, #0x4]
 8002b6a: 2300         	movs	r3, #0x0
 8002b6c: 9300         	str	r3, [sp]
 8002b6e: 2300         	movs	r3, #0x0
 8002b70: 2201         	movs	r2, #0x1
 8002b72: 2000         	movs	r0, #0x0
 8002b74: f00c f94c    	bl	0x800ee10 <z_log_msg_runtime_create> @ imm = #0xc298
 8002b78: 2300         	movs	r3, #0x0
 8002b7a: 617b         	str	r3, [r7, #0x14]
 8002b7c: e06d         	b	0x8002c5a <hard_fault+0x1ae> @ imm = #0xda
; 	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
 8002b7e: 4b3b         	ldr	r3, [pc, #0xec]         @ 0x8002c6c <hard_fault+0x1c0>
 8002b80: 6adb         	ldr	r3, [r3, #0x2c]
 8002b82: f003 4380    	and	r3, r3, #0x40000000
 8002b86: 2b00         	cmp	r3, #0x0
 8002b88: d067         	beq	0x8002c5a <hard_fault+0x1ae> @ imm = #0xce
; 		PR_EXC("  Fault escalation (see below)");
 8002b8a: 2303         	movs	r3, #0x3
 8002b8c: 2b00         	cmp	r3, #0x0
 8002b8e: d018         	beq	0x8002bc2 <hard_fault+0x116> @ imm = #0x30
 8002b90: 2301         	movs	r3, #0x1
 8002b92: f887 302b    	strb.w	r3, [r7, #0x2b]
 8002b96: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 8002b9a: f083 0301    	eor	r3, r3, #0x1
 8002b9e: b2db         	uxtb	r3, r3
 8002ba0: 2b00         	cmp	r3, #0x0
 8002ba2: d10e         	bne	0x8002bc2 <hard_fault+0x116> @ imm = #0x1c
 8002ba4: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x8002c64 <hard_fault+0x1b8>
 8002ba6: 6819         	ldr	r1, [r3]
 8002ba8: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x8002c78 <hard_fault+0x1cc>
 8002baa: 9302         	str	r3, [sp, #0x8]
 8002bac: 2300         	movs	r3, #0x0
 8002bae: 9301         	str	r3, [sp, #0x4]
 8002bb0: 2300         	movs	r3, #0x0
 8002bb2: 9300         	str	r3, [sp]
 8002bb4: 2300         	movs	r3, #0x0
 8002bb6: 2201         	movs	r2, #0x1
 8002bb8: 2000         	movs	r0, #0x0
 8002bba: f00c f929    	bl	0x800ee10 <z_log_msg_runtime_create> @ imm = #0xc252
 8002bbe: 2300         	movs	r3, #0x0
 8002bc0: 627b         	str	r3, [r7, #0x24]
; 		if (z_arm_is_synchronous_svc(esf)) {
 8002bc2: 6878         	ldr	r0, [r7, #0x4]
 8002bc4: f7ff ff32    	bl	0x8002a2c <z_arm_is_synchronous_svc> @ imm = #-0x19c
 8002bc8: 4603         	mov	r3, r0
 8002bca: 2b00         	cmp	r3, #0x0
 8002bcc: d022         	beq	0x8002c14 <hard_fault+0x168> @ imm = #0x44
; 			PR_EXC("ARCH_EXCEPT with reason %x\n", esf->basic.r0);
 8002bce: 2303         	movs	r3, #0x3
 8002bd0: 2b00         	cmp	r3, #0x0
 8002bd2: d01b         	beq	0x8002c0c <hard_fault+0x160> @ imm = #0x36
 8002bd4: 2301         	movs	r3, #0x1
 8002bd6: f887 3023    	strb.w	r3, [r7, #0x23]
 8002bda: f897 3023    	ldrb.w	r3, [r7, #0x23]
 8002bde: f083 0301    	eor	r3, r3, #0x1
 8002be2: b2db         	uxtb	r3, r3
 8002be4: 2b00         	cmp	r3, #0x0
 8002be6: d111         	bne	0x8002c0c <hard_fault+0x160> @ imm = #0x22
 8002be8: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x8002c64 <hard_fault+0x1b8>
 8002bea: 6819         	ldr	r1, [r3]
 8002bec: 687b         	ldr	r3, [r7, #0x4]
 8002bee: 681b         	ldr	r3, [r3]
 8002bf0: 9303         	str	r3, [sp, #0xc]
 8002bf2: 4b22         	ldr	r3, [pc, #0x88]         @ 0x8002c7c <hard_fault+0x1d0>
 8002bf4: 9302         	str	r3, [sp, #0x8]
 8002bf6: 2300         	movs	r3, #0x0
 8002bf8: 9301         	str	r3, [sp, #0x4]
 8002bfa: 2300         	movs	r3, #0x0
 8002bfc: 9300         	str	r3, [sp]
 8002bfe: 2300         	movs	r3, #0x0
 8002c00: 2201         	movs	r2, #0x1
 8002c02: 2000         	movs	r0, #0x0
 8002c04: f00c f904    	bl	0x800ee10 <z_log_msg_runtime_create> @ imm = #0xc208
 8002c08: 2300         	movs	r3, #0x0
 8002c0a: 61fb         	str	r3, [r7, #0x1c]
; 			reason = esf->basic.r0;
 8002c0c: 687b         	ldr	r3, [r7, #0x4]
 8002c0e: 681b         	ldr	r3, [r3]
 8002c10: 62fb         	str	r3, [r7, #0x2c]
 8002c12: e022         	b	0x8002c5a <hard_fault+0x1ae> @ imm = #0x44
; 		} else if ((SCB->CFSR & SCB_CFSR_MEMFAULTSR_Msk) != 0) {
 8002c14: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8002c6c <hard_fault+0x1c0>
 8002c16: 6a9b         	ldr	r3, [r3, #0x28]
 8002c18: b2db         	uxtb	r3, r3
 8002c1a: 2b00         	cmp	r3, #0x0
 8002c1c: d006         	beq	0x8002c2c <hard_fault+0x180> @ imm = #0xc
; 			reason = mem_manage_fault(esf, 1, recoverable);
 8002c1e: 683a         	ldr	r2, [r7]
 8002c20: 2101         	movs	r1, #0x1
 8002c22: 6878         	ldr	r0, [r7, #0x4]
 8002c24: f7ff fb2c    	bl	0x8002280 <mem_manage_fault> @ imm = #-0x9a8
 8002c28: 62f8         	str	r0, [r7, #0x2c]
 8002c2a: e016         	b	0x8002c5a <hard_fault+0x1ae> @ imm = #0x2c
; 		} else if ((SCB->CFSR & SCB_CFSR_BUSFAULTSR_Msk) != 0) {
 8002c2c: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x8002c6c <hard_fault+0x1c0>
 8002c2e: 6a9b         	ldr	r3, [r3, #0x28]
 8002c30: f403 437f    	and	r3, r3, #0xff00
 8002c34: 2b00         	cmp	r3, #0x0
 8002c36: d007         	beq	0x8002c48 <hard_fault+0x19c> @ imm = #0xe
; 			reason = bus_fault(esf, 1, recoverable);
 8002c38: 683a         	ldr	r2, [r7]
 8002c3a: 2101         	movs	r1, #0x1
 8002c3c: 6878         	ldr	r0, [r7, #0x4]
 8002c3e: f7ff fc63    	bl	0x8002508 <bus_fault>   @ imm = #-0x73a
 8002c42: 4603         	mov	r3, r0
 8002c44: 62fb         	str	r3, [r7, #0x2c]
 8002c46: e008         	b	0x8002c5a <hard_fault+0x1ae> @ imm = #0x10
; 		} else if ((SCB->CFSR & SCB_CFSR_USGFAULTSR_Msk) != 0) {
 8002c48: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8002c6c <hard_fault+0x1c0>
 8002c4a: 6a9b         	ldr	r3, [r3, #0x28]
 8002c4c: f5b3 3f80    	cmp.w	r3, #0x10000
 8002c50: d303         	blo	0x8002c5a <hard_fault+0x1ae> @ imm = #0x6
; 			reason = usage_fault(esf);
 8002c52: 6878         	ldr	r0, [r7, #0x4]
 8002c54: f7ff fda8    	bl	0x80027a8 <usage_fault> @ imm = #-0x4b0
 8002c58: 62f8         	str	r0, [r7, #0x2c]
; 	return reason;
 8002c5a: 6afb         	ldr	r3, [r7, #0x2c]
; }
 8002c5c: 4618         	mov	r0, r3
 8002c5e: 3738         	adds	r7, #0x38
 8002c60: 46bd         	mov	sp, r7
 8002c62: bd80         	pop	{r7, pc}

08002c64 <$d>:
 8002c64: 20 00 00 20  	.word	0x20000020
 8002c68: e8 50 01 08  	.word	0x080150e8
 8002c6c: 00 ed 00 e0  	.word	0xe000ed00
 8002c70: 00 51 01 08  	.word	0x08015100
 8002c74: 24 51 01 08  	.word	0x08015124
 8002c78: 34 51 01 08  	.word	0x08015134
 8002c7c: 54 51 01 08  	.word	0x08015154

08002c80 <reserved_exception>:
; {
 8002c80: b580         	push	{r7, lr}
 8002c82: b08a         	sub	sp, #0x28
 8002c84: af06         	add	r7, sp, #0x18
 8002c86: 6078         	str	r0, [r7, #0x4]
 8002c88: 6039         	str	r1, [r7]
; 	PR_FAULT_INFO("***** %s %d) *****",
 8002c8a: 2303         	movs	r3, #0x3
 8002c8c: 2b00         	cmp	r3, #0x0
 8002c8e: d021         	beq	0x8002cd4 <reserved_exception+0x54> @ imm = #0x42
 8002c90: 2301         	movs	r3, #0x1
 8002c92: 73fb         	strb	r3, [r7, #0xf]
 8002c94: 7bfb         	ldrb	r3, [r7, #0xf]
 8002c96: f083 0301    	eor	r3, r3, #0x1
 8002c9a: b2db         	uxtb	r3, r3
 8002c9c: 2b00         	cmp	r3, #0x0
 8002c9e: d119         	bne	0x8002cd4 <reserved_exception+0x54> @ imm = #0x32
 8002ca0: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8002cdc <reserved_exception+0x5c>
 8002ca2: 6819         	ldr	r1, [r3]
 8002ca4: 683b         	ldr	r3, [r7]
 8002ca6: 2b0f         	cmp	r3, #0xf
 8002ca8: dc01         	bgt	0x8002cae <reserved_exception+0x2e> @ imm = #0x2
 8002caa: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8002ce0 <reserved_exception+0x60>
 8002cac: e000         	b	0x8002cb0 <reserved_exception+0x30> @ imm = #0x0
 8002cae: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8002ce4 <reserved_exception+0x64>
 8002cb0: 683a         	ldr	r2, [r7]
 8002cb2: 3a10         	subs	r2, #0x10
 8002cb4: 9204         	str	r2, [sp, #0x10]
 8002cb6: 9303         	str	r3, [sp, #0xc]
 8002cb8: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8002ce8 <reserved_exception+0x68>
 8002cba: 9302         	str	r3, [sp, #0x8]
 8002cbc: 2300         	movs	r3, #0x0
 8002cbe: 9301         	str	r3, [sp, #0x4]
 8002cc0: 2300         	movs	r3, #0x0
 8002cc2: 9300         	str	r3, [sp]
 8002cc4: 2300         	movs	r3, #0x0
 8002cc6: 2201         	movs	r2, #0x1
 8002cc8: 2000         	movs	r0, #0x0
 8002cca: f00c f8a1    	bl	0x800ee10 <z_log_msg_runtime_create> @ imm = #0xc142
 8002cce: 2300         	movs	r3, #0x0
 8002cd0: 60bb         	str	r3, [r7, #0x8]
; }
 8002cd2: bf00         	nop
 8002cd4: bf00         	nop
 8002cd6: 3710         	adds	r7, #0x10
 8002cd8: 46bd         	mov	sp, r7
 8002cda: bd80         	pop	{r7, pc}

08002cdc <$d>:
 8002cdc: 20 00 00 20  	.word	0x20000020
 8002ce0: 70 51 01 08  	.word	0x08015170
 8002ce4: 88 51 01 08  	.word	0x08015188
 8002ce8: a4 51 01 08  	.word	0x080151a4

08002cec <fault_handle>:
; {
 8002cec: b580         	push	{r7, lr}
 8002cee: b086         	sub	sp, #0x18
 8002cf0: af00         	add	r7, sp, #0x0
 8002cf2: 60f8         	str	r0, [r7, #0xc]
 8002cf4: 60b9         	str	r1, [r7, #0x8]
 8002cf6: 607a         	str	r2, [r7, #0x4]
; 	uint32_t reason = K_ERR_CPU_EXCEPTION;
 8002cf8: 2300         	movs	r3, #0x0
 8002cfa: 617b         	str	r3, [r7, #0x14]
; 	*recoverable = false;
 8002cfc: 687b         	ldr	r3, [r7, #0x4]
 8002cfe: 2200         	movs	r2, #0x0
 8002d00: 701a         	strb	r2, [r3]
; 	switch (fault) {
 8002d02: 68bb         	ldr	r3, [r7, #0x8]
 8002d04: 3b03         	subs	r3, #0x3
 8002d06: 2b09         	cmp	r3, #0x9
 8002d08: d835         	bhi	0x8002d76 <fault_handle+0x8a> @ imm = #0x6a
 8002d0a: a201         	adr	r2, #4 <fault_handle+0x23>
 8002d0c: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]

08002d10 <$d>:
 8002d10: 39 2d 00 08  	.word	0x08002d39
 8002d14: 45 2d 00 08  	.word	0x08002d45
 8002d18: 53 2d 00 08  	.word	0x08002d53
 8002d1c: 63 2d 00 08  	.word	0x08002d63
 8002d20: 77 2d 00 08  	.word	0x08002d77
 8002d24: 77 2d 00 08  	.word	0x08002d77
 8002d28: 77 2d 00 08  	.word	0x08002d77
 8002d2c: 77 2d 00 08  	.word	0x08002d77
 8002d30: 77 2d 00 08  	.word	0x08002d77
 8002d34: 6d 2d 00 08  	.word	0x08002d6d

08002d38 <$t>:
; 		reason = hard_fault(esf, recoverable);
 8002d38: 6879         	ldr	r1, [r7, #0x4]
 8002d3a: 68f8         	ldr	r0, [r7, #0xc]
 8002d3c: f7ff feb6    	bl	0x8002aac <hard_fault>  @ imm = #-0x294
 8002d40: 6178         	str	r0, [r7, #0x14]
; 		break;
 8002d42: e01d         	b	0x8002d80 <fault_handle+0x94> @ imm = #0x3a
; 		reason = mem_manage_fault(esf, 0, recoverable);
 8002d44: 687a         	ldr	r2, [r7, #0x4]
 8002d46: 2100         	movs	r1, #0x0
 8002d48: 68f8         	ldr	r0, [r7, #0xc]
 8002d4a: f7ff fa99    	bl	0x8002280 <mem_manage_fault> @ imm = #-0xace
 8002d4e: 6178         	str	r0, [r7, #0x14]
; 		break;
 8002d50: e016         	b	0x8002d80 <fault_handle+0x94> @ imm = #0x2c
; 		reason = bus_fault(esf, 0, recoverable);
 8002d52: 687a         	ldr	r2, [r7, #0x4]
 8002d54: 2100         	movs	r1, #0x0
 8002d56: 68f8         	ldr	r0, [r7, #0xc]
 8002d58: f7ff fbd6    	bl	0x8002508 <bus_fault>   @ imm = #-0x854
 8002d5c: 4603         	mov	r3, r0
 8002d5e: 617b         	str	r3, [r7, #0x14]
; 		break;
 8002d60: e00e         	b	0x8002d80 <fault_handle+0x94> @ imm = #0x1c
; 		reason = usage_fault(esf);
 8002d62: 68f8         	ldr	r0, [r7, #0xc]
 8002d64: f7ff fd20    	bl	0x80027a8 <usage_fault> @ imm = #-0x5c0
 8002d68: 6178         	str	r0, [r7, #0x14]
; 		break;
 8002d6a: e009         	b	0x8002d80 <fault_handle+0x94> @ imm = #0x12
; 		debug_monitor(esf, recoverable);
 8002d6c: 6879         	ldr	r1, [r7, #0x4]
 8002d6e: 68f8         	ldr	r0, [r7, #0xc]
 8002d70: f7ff fe30    	bl	0x80029d4 <debug_monitor> @ imm = #-0x3a0
; 		break;
 8002d74: e004         	b	0x8002d80 <fault_handle+0x94> @ imm = #0x8
; 		reserved_exception(esf, fault);
 8002d76: 68b9         	ldr	r1, [r7, #0x8]
 8002d78: 68f8         	ldr	r0, [r7, #0xc]
 8002d7a: f7ff ff81    	bl	0x8002c80 <reserved_exception> @ imm = #-0xfe
; 		break;
 8002d7e: bf00         	nop
; 	if ((*recoverable) == false) {
 8002d80: 687b         	ldr	r3, [r7, #0x4]
 8002d82: 781b         	ldrb	r3, [r3]
 8002d84: f083 0301    	eor	r3, r3, #0x1
 8002d88: b2db         	uxtb	r3, r3
 8002d8a: 2b00         	cmp	r3, #0x0
 8002d8c: d003         	beq	0x8002d96 <fault_handle+0xaa> @ imm = #0x6
; 		fault_show(esf, fault);
 8002d8e: 68b9         	ldr	r1, [r7, #0x8]
 8002d90: 68f8         	ldr	r0, [r7, #0xc]
 8002d92: f00c f85b    	bl	0x800ee4c <fault_show>  @ imm = #0xc0b6
; 	return reason;
 8002d96: 697b         	ldr	r3, [r7, #0x14]
; }
 8002d98: 4618         	mov	r0, r3
 8002d9a: 3718         	adds	r7, #0x18
 8002d9c: 46bd         	mov	sp, r7
 8002d9e: bd80         	pop	{r7, pc}

08002da0 <get_esf>:
; {
 8002da0: b580         	push	{r7, lr}
 8002da2: b08c         	sub	sp, #0x30
 8002da4: af04         	add	r7, sp, #0x10
 8002da6: 60f8         	str	r0, [r7, #0xc]
 8002da8: 60b9         	str	r1, [r7, #0x8]
 8002daa: 607a         	str	r2, [r7, #0x4]
 8002dac: 603b         	str	r3, [r7]
; 	bool alternative_state_exc = false;
 8002dae: 2300         	movs	r3, #0x0
 8002db0: 76fb         	strb	r3, [r7, #0x1b]
; 	struct arch_esf *ptr_esf = NULL;
 8002db2: 2300         	movs	r3, #0x0
 8002db4: 61fb         	str	r3, [r7, #0x1c]
; 	*nested_exc = false;
 8002db6: 683b         	ldr	r3, [r7]
 8002db8: 2200         	movs	r2, #0x0
 8002dba: 701a         	strb	r2, [r3]
; 	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
 8002dbc: 687b         	ldr	r3, [r7, #0x4]
 8002dbe: f003 437f    	and	r3, r3, #0xff000000
 8002dc2: f1b3 4f7f    	cmp.w	r3, #0xff000000
 8002dc6: d001         	beq	0x8002dcc <get_esf+0x2c> @ imm = #0x2
; 		return NULL;
 8002dc8: 2300         	movs	r3, #0x0
 8002dca: e039         	b	0x8002e40 <get_esf+0xa0> @ imm = #0x72
; 	if ((exc_return & EXC_RETURN_MODE_THREAD) &&
 8002dcc: 687b         	ldr	r3, [r7, #0x4]
 8002dce: f003 0308    	and	r3, r3, #0x8
 8002dd2: 2b00         	cmp	r3, #0x0
 8002dd4: d020         	beq	0x8002e18 <get_esf+0x78> @ imm = #0x40
; 		(!(exc_return & EXC_RETURN_SPSEL_PROCESS))) {
 8002dd6: 687b         	ldr	r3, [r7, #0x4]
 8002dd8: f003 0304    	and	r3, r3, #0x4
; 	if ((exc_return & EXC_RETURN_MODE_THREAD) &&
 8002ddc: 2b00         	cmp	r3, #0x0
 8002dde: d11b         	bne	0x8002e18 <get_esf+0x78> @ imm = #0x36
; 		PR_EXC("SPSEL in thread mode does not indicate PSP");
 8002de0: 2303         	movs	r3, #0x3
 8002de2: 2b00         	cmp	r3, #0x0
 8002de4: d016         	beq	0x8002e14 <get_esf+0x74> @ imm = #0x2c
 8002de6: 2301         	movs	r3, #0x1
 8002de8: 76bb         	strb	r3, [r7, #0x1a]
 8002dea: 7ebb         	ldrb	r3, [r7, #0x1a]
 8002dec: f083 0301    	eor	r3, r3, #0x1
 8002df0: b2db         	uxtb	r3, r3
 8002df2: 2b00         	cmp	r3, #0x0
 8002df4: d10e         	bne	0x8002e14 <get_esf+0x74> @ imm = #0x1c
 8002df6: 4b14         	ldr	r3, [pc, #0x50]         @ 0x8002e48 <get_esf+0xa8>
 8002df8: 6819         	ldr	r1, [r3]
 8002dfa: 4b14         	ldr	r3, [pc, #0x50]         @ 0x8002e4c <get_esf+0xac>
 8002dfc: 9302         	str	r3, [sp, #0x8]
 8002dfe: 2300         	movs	r3, #0x0
 8002e00: 9301         	str	r3, [sp, #0x4]
 8002e02: 2300         	movs	r3, #0x0
 8002e04: 9300         	str	r3, [sp]
 8002e06: 2300         	movs	r3, #0x0
 8002e08: 2201         	movs	r2, #0x1
 8002e0a: 2000         	movs	r0, #0x0
 8002e0c: f00c f800    	bl	0x800ee10 <z_log_msg_runtime_create> @ imm = #0xc000
 8002e10: 2300         	movs	r3, #0x0
 8002e12: 617b         	str	r3, [r7, #0x14]
; 		return NULL;
 8002e14: 2300         	movs	r3, #0x0
 8002e16: e013         	b	0x8002e40 <get_esf+0xa0> @ imm = #0x26
; 	if (!alternative_state_exc) {
 8002e18: 7efb         	ldrb	r3, [r7, #0x1b]
 8002e1a: f083 0301    	eor	r3, r3, #0x1
 8002e1e: b2db         	uxtb	r3, r3
 8002e20: 2b00         	cmp	r3, #0x0
 8002e22: d00c         	beq	0x8002e3e <get_esf+0x9e> @ imm = #0x18
; 		if (exc_return & EXC_RETURN_MODE_THREAD) {
 8002e24: 687b         	ldr	r3, [r7, #0x4]
 8002e26: f003 0308    	and	r3, r3, #0x8
 8002e2a: 2b00         	cmp	r3, #0x0
 8002e2c: d002         	beq	0x8002e34 <get_esf+0x94> @ imm = #0x4
; 			ptr_esf =  (struct arch_esf *)psp;
 8002e2e: 68bb         	ldr	r3, [r7, #0x8]
 8002e30: 61fb         	str	r3, [r7, #0x1c]
 8002e32: e004         	b	0x8002e3e <get_esf+0x9e> @ imm = #0x8
; 			ptr_esf = (struct arch_esf *)msp;
 8002e34: 68fb         	ldr	r3, [r7, #0xc]
 8002e36: 61fb         	str	r3, [r7, #0x1c]
; 			*nested_exc = true;
 8002e38: 683b         	ldr	r3, [r7]
 8002e3a: 2201         	movs	r2, #0x1
 8002e3c: 701a         	strb	r2, [r3]
; 	return ptr_esf;
 8002e3e: 69fb         	ldr	r3, [r7, #0x1c]
; }
 8002e40: 4618         	mov	r0, r3
 8002e42: 3720         	adds	r7, #0x20
 8002e44: 46bd         	mov	sp, r7
 8002e46: bd80         	pop	{r7, pc}

08002e48 <$d>:
 8002e48: 20 00 00 20  	.word	0x20000020
 8002e4c: b8 51 01 08  	.word	0x080151b8

08002e50 <z_arm_fault>:
; {
 8002e50: b580         	push	{r7, lr}
 8002e52: b094         	sub	sp, #0x50
 8002e54: af00         	add	r7, sp, #0x0
 8002e56: 60f8         	str	r0, [r7, #0xc]
 8002e58: 60b9         	str	r1, [r7, #0x8]
 8002e5a: 607a         	str	r2, [r7, #0x4]
 8002e5c: 603b         	str	r3, [r7]
; 	uint32_t reason = K_ERR_CPU_EXCEPTION;
 8002e5e: 2300         	movs	r3, #0x0
 8002e60: 64fb         	str	r3, [r7, #0x4c]
; 	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
 8002e62: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x8002f08 <z_arm_fault+0xb8>
 8002e64: 685b         	ldr	r3, [r3, #0x4]
 8002e66: f3c3 0308    	ubfx	r3, r3, #0x0, #0x9
 8002e6a: 64bb         	str	r3, [r7, #0x48]
 8002e6c: 2300         	movs	r3, #0x0
 8002e6e: 63bb         	str	r3, [r7, #0x38]
 8002e70: 6bbb         	ldr	r3, [r7, #0x38]
 8002e72: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002e74: 6b7b         	ldr	r3, [r7, #0x34]
 8002e76: f383 8811    	msr	basepri, r3
; }
 8002e7a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8002e7c: f3bf 8f6f    	isb	sy
; }
 8002e80: bf00         	nop
; }
 8002e82: bf00         	nop
; 	 esf = get_esf(msp, psp, exc_return, &nested_exc);
 8002e84: f107 0332    	add.w	r3, r7, #0x32
 8002e88: 687a         	ldr	r2, [r7, #0x4]
 8002e8a: 68b9         	ldr	r1, [r7, #0x8]
 8002e8c: 68f8         	ldr	r0, [r7, #0xc]
 8002e8e: f7ff ff87    	bl	0x8002da0 <get_esf>     @ imm = #-0xf2
 8002e92: 6478         	str	r0, [r7, #0x44]
 8002e94: 6c7b         	ldr	r3, [r7, #0x44]
 8002e96: 643b         	str	r3, [r7, #0x40]
 8002e98: 687b         	ldr	r3, [r7, #0x4]
 8002e9a: 63fb         	str	r3, [r7, #0x3c]
; }
 8002e9c: bf00         	nop
; 	reason = fault_handle(esf, fault, &recoverable);
 8002e9e: f107 0333    	add.w	r3, r7, #0x33
 8002ea2: 461a         	mov	r2, r3
 8002ea4: 6cb9         	ldr	r1, [r7, #0x48]
 8002ea6: 6c78         	ldr	r0, [r7, #0x44]
 8002ea8: f7ff ff20    	bl	0x8002cec <fault_handle> @ imm = #-0x1c0
 8002eac: 64f8         	str	r0, [r7, #0x4c]
; 	if (recoverable) {
 8002eae: f897 3033    	ldrb.w	r3, [r7, #0x33]
 8002eb2: 2b00         	cmp	r3, #0x0
 8002eb4: d123         	bne	0x8002efe <z_arm_fault+0xae> @ imm = #0x46
; 	memcpy(&esf_copy, esf, sizeof(struct arch_esf));
 8002eb6: f107 0310    	add.w	r3, r7, #0x10
 8002eba: 2220         	movs	r2, #0x20
 8002ebc: 6c79         	ldr	r1, [r7, #0x44]
 8002ebe: 4618         	mov	r0, r3
 8002ec0: f011 f91e    	bl	0x8014100 <memcpy>      @ imm = #0x1123c
; 	if (nested_exc) {
 8002ec4: f897 3032    	ldrb.w	r3, [r7, #0x32]
 8002ec8: 2b00         	cmp	r3, #0x0
 8002eca: d00b         	beq	0x8002ee4 <z_arm_fault+0x94> @ imm = #0x16
; 		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
 8002ecc: 6afb         	ldr	r3, [r7, #0x2c]
 8002ece: f3c3 0308    	ubfx	r3, r3, #0x0, #0x9
 8002ed2: 2b00         	cmp	r3, #0x0
 8002ed4: d10c         	bne	0x8002ef0 <z_arm_fault+0xa0> @ imm = #0x18
; 			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
 8002ed6: 6afb         	ldr	r3, [r7, #0x2c]
 8002ed8: ea6f 2353    	mvn.w	r3, r3, lsr #9
 8002edc: ea6f 2343    	mvn.w	r3, r3, lsl #9
 8002ee0: 62fb         	str	r3, [r7, #0x2c]
 8002ee2: e005         	b	0x8002ef0 <z_arm_fault+0xa0> @ imm = #0xa
; 		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
 8002ee4: 6afb         	ldr	r3, [r7, #0x2c]
 8002ee6: f423 73ff    	bic	r3, r3, #0x1fe
 8002eea: f023 0301    	bic	r3, r3, #0x1
 8002eee: 62fb         	str	r3, [r7, #0x2c]
; 	z_arm_fatal_error(reason, &esf_copy);
 8002ef0: f107 0310    	add.w	r3, r7, #0x10
 8002ef4: 4619         	mov	r1, r3
 8002ef6: 6cf8         	ldr	r0, [r7, #0x4c]
 8002ef8: f7ff f92e    	bl	0x8002158 <z_arm_fatal_error> @ imm = #-0xda4
 8002efc: e000         	b	0x8002f00 <z_arm_fault+0xb0> @ imm = #0x0
; 		return;
 8002efe: bf00         	nop
; }
 8002f00: 3750         	adds	r7, #0x50
 8002f02: 46bd         	mov	sp, r7
 8002f04: bd80         	pop	{r7, pc}
 8002f06: bf00         	nop

08002f08 <$d>:
 8002f08: 00 ed 00 e0  	.word	0xe000ed00

08002f0c <z_arm_fault_init>:
; {
 8002f0c: b480         	push	{r7}
 8002f0e: af00         	add	r7, sp, #0x0
; 	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
 8002f10: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8002f30 <z_arm_fault_init+0x24>
 8002f12: 695b         	ldr	r3, [r3, #0x14]
 8002f14: 4a06         	ldr	r2, [pc, #0x18]         @ 0x8002f30 <z_arm_fault_init+0x24>
 8002f16: f043 0310    	orr	r3, r3, #0x10
 8002f1a: 6153         	str	r3, [r2, #0x14]
; 	SCB->CCR &= ~SCB_CCR_UNALIGN_TRP_Msk;
 8002f1c: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8002f30 <z_arm_fault_init+0x24>
 8002f1e: 695b         	ldr	r3, [r3, #0x14]
 8002f20: 4a03         	ldr	r2, [pc, #0xc]          @ 0x8002f30 <z_arm_fault_init+0x24>
 8002f22: f023 0308    	bic	r3, r3, #0x8
 8002f26: 6153         	str	r3, [r2, #0x14]
; }
 8002f28: bf00         	nop
 8002f2a: 46bd         	mov	sp, r7
 8002f2c: bc80         	pop	{r7}
 8002f2e: 4770         	bx	lr

08002f30 <$d>:
 8002f30: 00 ed 00 e0  	.word	0xe000ed00

08002f34 <z_arm_usage_fault>:
; 	mrs r0, MSP
 8002f34: f3ef 8008    	mrs	r0, msp
; 	mrs r1, PSP
 8002f38: f3ef 8109    	mrs	r1, psp
; 	push {r0, lr}
 8002f3c: b501         	push	{r0, lr}
; 	mov r2, lr /* EXC_RETURN */
 8002f3e: 4672         	mov	r2, lr
; 	bl z_arm_fault
 8002f40: f7ff ff86    	bl	0x8002e50 <z_arm_fault> @ imm = #-0xf4
; 	pop {r0, pc}
 8002f44: bd01         	pop	{r0, pc}
 8002f46: bf00         	nop

08002f48 <z_arm_reset>:
;     movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
 8002f48: 2010         	movs	r0, #0x10
;     msr BASEPRI, r0
 8002f4a: f380 8811    	msr	basepri, r0
;     ldr r0, =z_interrupt_stacks
 8002f4e: 480b         	ldr	r0, [pc, #0x2c]         @ 0x8002f7c <z_arm_reset+0x34>
;     ldr r1, =0xaa
 8002f50: f04f 01aa    	mov.w	r1, #0xaa
;     ldr r2, =CONFIG_ISR_STACK_SIZE + MPU_GUARD_ALIGN_AND_SIZE
 8002f54: f44f 6200    	mov.w	r2, #0x800
;     bl z_early_memset
 8002f58: f00f feb7    	bl	0x8012cca <z_early_memset> @ imm = #0xfd6e
;     ldr r0, =z_interrupt_stacks
 8002f5c: 4807         	ldr	r0, [pc, #0x1c]         @ 0x8002f7c <z_arm_reset+0x34>
;     ldr r1, =CONFIG_ISR_STACK_SIZE + MPU_GUARD_ALIGN_AND_SIZE
 8002f5e: f44f 6100    	mov.w	r1, #0x800
;     adds r0, r0, r1
 8002f62: 1840         	adds	r0, r0, r1
;     msr PSP, r0
 8002f64: f380 8809    	msr	psp, r0
;     mrs r0, CONTROL
 8002f68: f3ef 8014    	mrs	r0, control
;     movs r1, #2
 8002f6c: 2102         	movs	r1, #0x2
;     orrs r0, r1 /* CONTROL_SPSEL_Msk */
 8002f6e: 4308         	orrs	r0, r1
;     msr CONTROL, r0
 8002f70: f380 8814    	msr	control, r0
;     isb
 8002f74: f3bf 8f6f    	isb	sy
;     bl z_prep_c
 8002f78: f00b ffaa    	bl	0x800eed0 <z_prep_c>    @ imm = #0xbf54

08002f7c <$d>:
 8002f7c: 38 17 00 20  	.word	0x20001738

08002f80 <z_impl_k_thread_abort>:
; {
 8002f80: b580         	push	{r7, lr}
 8002f82: b084         	sub	sp, #0x10
 8002f84: af00         	add	r7, sp, #0x0
 8002f86: 6078         	str	r0, [r7, #0x4]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8002f88: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8002fd4 <z_impl_k_thread_abort+0x54>
 8002f8a: 689b         	ldr	r3, [r3, #0x8]
 8002f8c: 60fb         	str	r3, [r7, #0xc]
; 	return ret;
 8002f8e: 68fb         	ldr	r3, [r7, #0xc]
; 	if (arch_current_thread() == thread) {
 8002f90: 687a         	ldr	r2, [r7, #0x4]
 8002f92: 429a         	cmp	r2, r3
 8002f94: d116         	bne	0x8002fc4 <z_impl_k_thread_abort+0x44> @ imm = #0x2c
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8002f96: f3ef 8305    	mrs	r3, ipsr
 8002f9a: 60bb         	str	r3, [r7, #0x8]
;   return(result);
 8002f9c: 68bb         	ldr	r3, [r7, #0x8]
; 	return (__get_IPSR()) ? (true) : (false);
 8002f9e: 2b00         	cmp	r3, #0x0
 8002fa0: bf14         	ite	ne
 8002fa2: 2301         	movne	r3, #0x1
 8002fa4: 2300         	moveq	r3, #0x0
 8002fa6: b2db         	uxtb	r3, r3
; 		if (arch_is_in_isr()) {
 8002fa8: 2b00         	cmp	r3, #0x0
 8002faa: d00b         	beq	0x8002fc4 <z_impl_k_thread_abort+0x44> @ imm = #0x16
; 			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
 8002fac: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8002fd8 <z_impl_k_thread_abort+0x58>
 8002fae: 685b         	ldr	r3, [r3, #0x4]
 8002fb0: 4a09         	ldr	r2, [pc, #0x24]         @ 0x8002fd8 <z_impl_k_thread_abort+0x58>
 8002fb2: f043 5380    	orr	r3, r3, #0x10000000
 8002fb6: 6053         	str	r3, [r2, #0x4]
; 			SCB->SHCSR &= ~SCB_SHCSR_SVCALLPENDED_Msk;
 8002fb8: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8002fd8 <z_impl_k_thread_abort+0x58>
 8002fba: 6a5b         	ldr	r3, [r3, #0x24]
 8002fbc: 4a06         	ldr	r2, [pc, #0x18]         @ 0x8002fd8 <z_impl_k_thread_abort+0x58>
 8002fbe: f423 4300    	bic	r3, r3, #0x8000
 8002fc2: 6253         	str	r3, [r2, #0x24]
; 	z_thread_abort(thread);
 8002fc4: 6878         	ldr	r0, [r7, #0x4]
 8002fc6: f008 fde9    	bl	0x800bb9c <z_thread_abort> @ imm = #0x8bd2
; }
 8002fca: bf00         	nop
 8002fcc: 3710         	adds	r7, #0x10
 8002fce: 46bd         	mov	sp, r7
 8002fd0: bd80         	pop	{r7, pc}
 8002fd2: bf00         	nop

08002fd4 <$d>:
 8002fd4: c0 02 00 20  	.word	0x200002c0
 8002fd8: 00 ed 00 e0  	.word	0xe000ed00

08002fdc <arch_swap>:
; {
 8002fdc: b480         	push	{r7}
 8002fde: b089         	sub	sp, #0x24
 8002fe0: af00         	add	r7, sp, #0x0
 8002fe2: 6078         	str	r0, [r7, #0x4]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8002fe4: 4b15         	ldr	r3, [pc, #0x54]         @ 0x800303c <arch_swap+0x60>
 8002fe6: 689b         	ldr	r3, [r3, #0x8]
 8002fe8: 60fb         	str	r3, [r7, #0xc]
; 	return ret;
 8002fea: 68fb         	ldr	r3, [r7, #0xc]
; 	arch_current_thread()->arch.basepri = key;
 8002fec: 687a         	ldr	r2, [r7, #0x4]
 8002fee: f8c3 20c8    	str.w	r2, [r3, #0xc8]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8002ff2: 4b12         	ldr	r3, [pc, #0x48]         @ 0x800303c <arch_swap+0x60>
 8002ff4: 689b         	ldr	r3, [r3, #0x8]
 8002ff6: 613b         	str	r3, [r7, #0x10]
; 	return ret;
 8002ff8: 693b         	ldr	r3, [r7, #0x10]
; 	arch_current_thread()->arch.swap_return_value = -EAGAIN;
 8002ffa: f06f 020a    	mvn	r2, #0xa
 8002ffe: f8c3 20cc    	str.w	r2, [r3, #0xcc]
; 	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
 8003002: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x8003040 <arch_swap+0x64>
 8003004: 685b         	ldr	r3, [r3, #0x4]
 8003006: 4a0e         	ldr	r2, [pc, #0x38]         @ 0x8003040 <arch_swap+0x64>
 8003008: f043 5380    	orr	r3, r3, #0x10000000
 800300c: 6053         	str	r3, [r2, #0x4]
 800300e: 2300         	movs	r3, #0x0
 8003010: 61bb         	str	r3, [r7, #0x18]
 8003012: 69bb         	ldr	r3, [r7, #0x18]
 8003014: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8003016: 697b         	ldr	r3, [r7, #0x14]
 8003018: f383 8811    	msr	basepri, r3
; }
 800301c: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800301e: f3bf 8f6f    	isb	sy
; }
 8003022: bf00         	nop
; }
 8003024: bf00         	nop
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8003026: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800303c <arch_swap+0x60>
 8003028: 689b         	ldr	r3, [r3, #0x8]
 800302a: 61fb         	str	r3, [r7, #0x1c]
; 	return ret;
 800302c: 69fb         	ldr	r3, [r7, #0x1c]
; 	return arch_current_thread()->arch.swap_return_value;
 800302e: f8d3 30cc    	ldr.w	r3, [r3, #0xcc]
; }
 8003032: 4618         	mov	r0, r3
 8003034: 3724         	adds	r7, #0x24
 8003036: 46bd         	mov	sp, r7
 8003038: bc80         	pop	{r7}
 800303a: 4770         	bx	lr

0800303c <$d>:
 800303c: c0 02 00 20  	.word	0x200002c0
 8003040: 00 ed 00 e0  	.word	0xe000ed00

08003044 <z_arm_pendsv>:
;     push {r0, lr}
 8003044: b501         	push	{r0, lr}
;     bl z_thread_mark_switched_out
 8003046: f010 fa5d    	bl	0x8013504 <z_thread_mark_switched_out> @ imm = #0x104ba
;     pop {r0, lr}
 800304a: e8bd 4001    	pop.w	{r0, lr}
;     ldr r1, =_kernel
 800304e: 4916         	ldr	r1, [pc, #0x58]         @ 0x80030a8 <z_arm_pendsv+0x64>
;     ldr r2, [r1, #_kernel_offset_to_current]
 8003050: 688a         	ldr	r2, [r1, #0x8]
;     ldr r0, =_thread_offset_to_callee_saved
 8003052: f04f 0040    	mov.w	r0, #0x40
;     add r0, r2
 8003056: 4410         	add	r0, r2
;     mrs ip, PSP
 8003058: f3ef 8c09    	mrs	r12, psp
;     stmia r0, {r4-r11, ip}
 800305c: e880 1ff0    	stm.w	r0, {r4, r5, r6, r7, r8, r9, r10, r11, r12}
;     movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
 8003060: 2010         	movs	r0, #0x10
;     msr BASEPRI_MAX, r0
 8003062: f380 8812    	msr	basepri_max, r0
;     isb /* Make the effect of disabling interrupts be realized immediately */
 8003066: f3bf 8f6f    	isb	sy
;     ldr r7, =_SCS_ICSR
 800306a: 4f10         	ldr	r7, [pc, #0x40]         @ 0x80030ac <z_arm_pendsv+0x68>
;     ldr r6, =_SCS_ICSR_UNPENDSV
 800306c: f04f 6600    	mov.w	r6, #0x8000000
;     ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
 8003070: 69ca         	ldr	r2, [r1, #0x1c]
;     str r2, [r1, #_kernel_offset_to_current]
 8003072: 608a         	str	r2, [r1, #0x8]
;     str r6, [r7, #0]
 8003074: 603e         	str	r6, [r7]
;     ldr r4, =_thread_offset_to_tls
 8003076: f04f 04c4    	mov.w	r4, #0xc4
;     adds r4, r2, r4
 800307a: 1914         	adds	r4, r2, r4
;     ldr r0, [r4]
 800307c: 6820         	ldr	r0, [r4]
;     ldr r4, =z_arm_tls_ptr
 800307e: 4c0c         	ldr	r4, [pc, #0x30]         @ 0x80030b0 <z_arm_pendsv+0x6c>
;     str r0, [r4]
 8003080: 6020         	str	r0, [r4]
;     ldr r0, [r2, #_thread_offset_to_basepri]
 8003082: f8d2 00c8    	ldr.w	r0, [r2, #0xc8]
;     movs r3, #0
 8003086: 2300         	movs	r3, #0x0
;     str r3, [r2, #_thread_offset_to_basepri]
 8003088: f8c2 30c8    	str.w	r3, [r2, #0xc8]
;     msr BASEPRI, r0
 800308c: f380 8811    	msr	basepri, r0
;     add r0, r2, #_thread_offset_to_callee_saved
 8003090: f102 0040    	add.w	r0, r2, #0x40
;     ldmia r0, {r4-r11, ip}
 8003094: e890 1ff0    	ldm.w	r0, {r4, r5, r6, r7, r8, r9, r10, r11, r12}
;     msr PSP, ip
 8003098: f38c 8809    	msr	psp, r12
;     push {r0, lr}
 800309c: b501         	push	{r0, lr}
;     bl z_thread_mark_switched_in
 800309e: f007 f9d3    	bl	0x800a448 <z_thread_mark_switched_in> @ imm = #0x73a6
;     pop {r0, lr}
 80030a2: e8bd 4001    	pop.w	{r0, lr}
;     bx lr
 80030a6: 4770         	bx	lr

080030a8 <$d>:
 80030a8: c0 02 00 20  	.word	0x200002c0
 80030ac: 04 ed 00 e0  	.word	0xe000ed04
 80030b0: f0 05 00 20  	.word	0x200005f0

080030b4 <z_arm_svc>:
;     tst lr, #_EXC_RETURN_SPSEL_Msk /* did we come from thread mode ? */
 80030b4: f01e 0f04    	tst.w	lr, #0x4
;     ite eq  /* if zero (equal), came from handler mode */
 80030b8: bf0c         	ite	eq
;         mrseq r0, MSP   /* handler mode, stack frame is on MSP */
 80030ba: f3ef 8008    	mrseq	r0, msp
;         mrsne r0, PSP   /* thread mode, stack frame is on PSP */
 80030be: f3ef 8009    	mrsne	r0, psp
;     ldr r1, [r0, #24]   /* grab address of PC from stack frame */
 80030c2: 6981         	ldr	r1, [r0, #0x18]
;     ldrb r1, [r1, #-2]
 80030c4: f811 1c02    	ldrb	r1, [r1, #-2]
;     cmp r1, #2
 80030c8: 2902         	cmp	r1, #0x2
;     beq _oops
 80030ca: d0ff         	beq	0x80030cc <_oops>       @ imm = #-0x2

080030cc <_oops>:
;     push {r0, lr}
 80030cc: b501         	push	{r0, lr}
;     mov r2, lr /* EXC_RETURN */
 80030ce: 4672         	mov	r2, lr
;     bl z_do_kernel_oops
 80030d0: f00b fe6a    	bl	0x800eda8 <z_do_kernel_oops> @ imm = #0xbcd4
;     pop {r0, pc}
 80030d4: bd01         	pop	{r0, pc}
 80030d6: bf00         	nop

080030d8 <__NVIC_EnableIRQ>:
; {
 80030d8: b480         	push	{r7}
 80030da: b083         	sub	sp, #0xc
 80030dc: af00         	add	r7, sp, #0x0
 80030de: 4603         	mov	r3, r0
 80030e0: 71fb         	strb	r3, [r7, #0x7]
;   if ((int32_t)(IRQn) >= 0)
 80030e2: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 80030e6: 2b00         	cmp	r3, #0x0
 80030e8: db0b         	blt	0x8003102 <__NVIC_EnableIRQ+0x2a> @ imm = #0x16
;     NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 80030ea: 79fb         	ldrb	r3, [r7, #0x7]
 80030ec: f003 021f    	and	r2, r3, #0x1f
 80030f0: 4906         	ldr	r1, [pc, #0x18]         @ 0x800310c <__NVIC_EnableIRQ+0x34>
 80030f2: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 80030f6: 095b         	lsrs	r3, r3, #0x5
 80030f8: 2001         	movs	r0, #0x1
 80030fa: fa00 f202    	lsl.w	r2, r0, r2
 80030fe: f841 2023    	str.w	r2, [r1, r3, lsl #2]
; }
 8003102: bf00         	nop
 8003104: 370c         	adds	r7, #0xc
 8003106: 46bd         	mov	sp, r7
 8003108: bc80         	pop	{r7}
 800310a: 4770         	bx	lr

0800310c <$d>:
 800310c: 00 e1 00 e0  	.word	0xe000e100

08003110 <__NVIC_SetPriority>:
; {
 8003110: b480         	push	{r7}
 8003112: b083         	sub	sp, #0xc
 8003114: af00         	add	r7, sp, #0x0
 8003116: 4603         	mov	r3, r0
 8003118: 6039         	str	r1, [r7]
 800311a: 71fb         	strb	r3, [r7, #0x7]
;   if ((int32_t)(IRQn) >= 0)
 800311c: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 8003120: 2b00         	cmp	r3, #0x0
 8003122: db0a         	blt	0x800313a <__NVIC_SetPriority+0x2a> @ imm = #0x14
;     NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8003124: 683b         	ldr	r3, [r7]
 8003126: b2da         	uxtb	r2, r3
 8003128: 490c         	ldr	r1, [pc, #0x30]         @ 0x800315c <__NVIC_SetPriority+0x4c>
 800312a: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 800312e: 0112         	lsls	r2, r2, #0x4
 8003130: b2d2         	uxtb	r2, r2
 8003132: 440b         	add	r3, r1
 8003134: f883 2300    	strb.w	r2, [r3, #0x300]
; }
 8003138: e00a         	b	0x8003150 <__NVIC_SetPriority+0x40> @ imm = #0x14
;     SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800313a: 683b         	ldr	r3, [r7]
 800313c: b2da         	uxtb	r2, r3
 800313e: 4908         	ldr	r1, [pc, #0x20]         @ 0x8003160 <__NVIC_SetPriority+0x50>
 8003140: 79fb         	ldrb	r3, [r7, #0x7]
 8003142: f003 030f    	and	r3, r3, #0xf
 8003146: 3b04         	subs	r3, #0x4
 8003148: 0112         	lsls	r2, r2, #0x4
 800314a: b2d2         	uxtb	r2, r2
 800314c: 440b         	add	r3, r1
 800314e: 761a         	strb	r2, [r3, #0x18]
; }
 8003150: bf00         	nop
 8003152: 370c         	adds	r7, #0xc
 8003154: 46bd         	mov	sp, r7
 8003156: bc80         	pop	{r7}
 8003158: 4770         	bx	lr
 800315a: bf00         	nop

0800315c <$d>:
 800315c: 00 e1 00 e0  	.word	0xe000e100
 8003160: 00 ed 00 e0  	.word	0xe000ed00

08003164 <relocate_vector_table>:
; {
 8003164: b480         	push	{r7}
 8003166: af00         	add	r7, sp, #0x0
; 	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
 8003168: 4b09         	ldr	r3, [pc, #0x24]         @ 0x8003190 <relocate_vector_table+0x2c>
 800316a: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x8003194 <relocate_vector_table+0x30>
 800316c: f023 037f    	bic	r3, r3, #0x7f
 8003170: 6093         	str	r3, [r2, #0x8]
;   __ASM volatile ("dsb 0xF":::"memory");
 8003172: f3bf 8f4f    	dsb	sy
; }
 8003176: bf00         	nop
; }
 8003178: bf00         	nop
; }
 800317a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800317c: f3bf 8f6f    	isb	sy
; }
 8003180: bf00         	nop
; }
 8003182: bf00         	nop
; }
 8003184: bf00         	nop
; }
 8003186: bf00         	nop
 8003188: 46bd         	mov	sp, r7
 800318a: bc80         	pop	{r7}
 800318c: 4770         	bx	lr
 800318e: bf00         	nop

08003190 <$d>:
 8003190: 00 00 00 08  	.word	0x08000000
 8003194: 00 ed 00 e0  	.word	0xe000ed00

08003198 <z_arm_floating_point_init>:
; {
 8003198: b480         	push	{r7}
 800319a: b083         	sub	sp, #0xc
 800319c: af00         	add	r7, sp, #0x0
; 	SCB->CPACR &= (~(CPACR_CP10_Msk | CPACR_CP11_Msk));
 800319e: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x80031d4 <z_arm_floating_point_init+0x3c>
 80031a0: f8d3 3088    	ldr.w	r3, [r3, #0x88]
 80031a4: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x80031d4 <z_arm_floating_point_init+0x3c>
 80031a6: f423 0370    	bic	r3, r3, #0xf00000
 80031aa: f8c2 3088    	str.w	r3, [r2, #0x88]
;   __ASM volatile ("MRS %0, control" : "=r" (result) );
 80031ae: f3ef 8314    	mrs	r3, control
 80031b2: 603b         	str	r3, [r7]
;   return(result);
 80031b4: 683b         	ldr	r3, [r7]
; 	__set_CONTROL(__get_CONTROL() & (~(CONTROL_FPCA_Msk)));
 80031b6: f023 0304    	bic	r3, r3, #0x4
 80031ba: 607b         	str	r3, [r7, #0x4]
;   __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
 80031bc: 687b         	ldr	r3, [r7, #0x4]
 80031be: f383 8814    	msr	control, r3
;   __ASM volatile ("isb 0xF":::"memory");
 80031c2: f3bf 8f6f    	isb	sy
; }
 80031c6: bf00         	nop
; }
 80031c8: bf00         	nop
; }
 80031ca: bf00         	nop
 80031cc: 370c         	adds	r7, #0xc
 80031ce: 46bd         	mov	sp, r7
 80031d0: bc80         	pop	{r7}
 80031d2: 4770         	bx	lr

080031d4 <$d>:
 80031d4: 00 ed 00 e0  	.word	0xe000ed00

080031d8 <arch_new_thread>:
; {
 80031d8: b480         	push	{r7}
 80031da: b087         	sub	sp, #0x1c
 80031dc: af00         	add	r7, sp, #0x0
 80031de: 60f8         	str	r0, [r7, #0xc]
 80031e0: 60b9         	str	r1, [r7, #0x8]
 80031e2: 607a         	str	r2, [r7, #0x4]
 80031e4: 603b         	str	r3, [r7]
; 	iframe = Z_STACK_PTR_TO_FRAME(struct __basic_sf, stack_ptr);
 80031e6: 687b         	ldr	r3, [r7, #0x4]
 80031e8: 3b20         	subs	r3, #0x20
 80031ea: 617b         	str	r3, [r7, #0x14]
; 	iframe->pc = (uint32_t)z_thread_entry;
 80031ec: 4a12         	ldr	r2, [pc, #0x48]         @ 0x8003238 <arch_new_thread+0x60>
 80031ee: 697b         	ldr	r3, [r7, #0x14]
 80031f0: 619a         	str	r2, [r3, #0x18]
; 	iframe->pc &= 0xfffffffe;
 80031f2: 697b         	ldr	r3, [r7, #0x14]
 80031f4: 699b         	ldr	r3, [r3, #0x18]
 80031f6: f023 0201    	bic	r2, r3, #0x1
 80031fa: 697b         	ldr	r3, [r7, #0x14]
 80031fc: 619a         	str	r2, [r3, #0x18]
; 	iframe->a1 = (uint32_t)entry;
 80031fe: 683a         	ldr	r2, [r7]
 8003200: 697b         	ldr	r3, [r7, #0x14]
 8003202: 601a         	str	r2, [r3]
; 	iframe->a2 = (uint32_t)p1;
 8003204: 6a3a         	ldr	r2, [r7, #0x20]
 8003206: 697b         	ldr	r3, [r7, #0x14]
 8003208: 605a         	str	r2, [r3, #0x4]
; 	iframe->a3 = (uint32_t)p2;
 800320a: 6a7a         	ldr	r2, [r7, #0x24]
 800320c: 697b         	ldr	r3, [r7, #0x14]
 800320e: 609a         	str	r2, [r3, #0x8]
; 	iframe->a4 = (uint32_t)p3;
 8003210: 6aba         	ldr	r2, [r7, #0x28]
 8003212: 697b         	ldr	r3, [r7, #0x14]
 8003214: 60da         	str	r2, [r3, #0xc]
; 	iframe->xpsr =
 8003216: 697b         	ldr	r3, [r7, #0x14]
 8003218: f04f 7280    	mov.w	r2, #0x1000000
 800321c: 61da         	str	r2, [r3, #0x1c]
; 	thread->callee_saved.psp = (uint32_t)iframe;
 800321e: 697a         	ldr	r2, [r7, #0x14]
 8003220: 68fb         	ldr	r3, [r7, #0xc]
 8003222: 661a         	str	r2, [r3, #0x60]
; 	thread->arch.basepri = 0;
 8003224: 68fb         	ldr	r3, [r7, #0xc]
 8003226: 2200         	movs	r2, #0x0
 8003228: f8c3 20c8    	str.w	r2, [r3, #0xc8]
; }
 800322c: bf00         	nop
 800322e: 371c         	adds	r7, #0x1c
 8003230: 46bd         	mov	sp, r7
 8003232: bc80         	pop	{r7}
 8003234: 4770         	bx	lr
 8003236: bf00         	nop

08003238 <$d>:
 8003238: 11 13 00 08  	.word	0x08001311

0800323c <arch_switch_to_main_thread>:
; {
 800323c: b5f0         	push	{r4, r5, r6, r7, lr}
 800323e: b087         	sub	sp, #0x1c
 8003240: af00         	add	r7, sp, #0x0
 8003242: 60f8         	str	r0, [r7, #0xc]
 8003244: 60b9         	str	r1, [r7, #0x8]
 8003246: 607a         	str	r2, [r7, #0x4]
; 	z_arm_prepare_switch_to_main();
 8003248: f00b fe50    	bl	0x800eeec <z_arm_prepare_switch_to_main> @ imm = #0xbca0
 800324c: 68fb         	ldr	r3, [r7, #0xc]
 800324e: 617b         	str	r3, [r7, #0x14]
; 	_current_cpu->current = thread;
 8003250: 4a0e         	ldr	r2, [pc, #0x38]         @ 0x800328c <arch_switch_to_main_thread+0x50>
 8003252: 697b         	ldr	r3, [r7, #0x14]
 8003254: 6093         	str	r3, [r2, #0x8]
; }
 8003256: bf00         	nop
; 	z_arm_tls_ptr = main_thread->tls;
 8003258: 68fb         	ldr	r3, [r7, #0xc]
 800325a: f8d3 30c4    	ldr.w	r3, [r3, #0xc4]
 800325e: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x8003290 <arch_switch_to_main_thread+0x54>
 8003260: 6013         	str	r3, [r2]
; 	z_thread_mark_switched_in();
 8003262: f007 f8f1    	bl	0x800a448 <z_thread_mark_switched_in> @ imm = #0x71e2
; 	__asm__ volatile (
 8003266: 687d         	ldr	r5, [r7, #0x4]
 8003268: 68be         	ldr	r6, [r7, #0x8]
 800326a: 462c         	mov	r4, r5
 800326c: f386 8809    	msr	psp, r6
 8003270: f04f 0000    	mov.w	r0, #0x0
 8003274: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8003294 <arch_switch_to_main_thread+0x58>
 8003276: 4798         	blx	r3
 8003278: 4620         	mov	r0, r4
 800327a: f04f 0100    	mov.w	r1, #0x0
 800327e: f04f 0200    	mov.w	r2, #0x0
 8003282: f04f 0300    	mov.w	r3, #0x0
 8003286: 4c04         	ldr	r4, [pc, #0x10]         @ 0x8003298 <arch_switch_to_main_thread+0x5c>
 8003288: 4720         	bx	r4
 800328a: bf00         	nop

0800328c <$d>:
 800328c: c0 02 00 20  	.word	0x200002c0
 8003290: f0 05 00 20  	.word	0x200005f0

08003294 <$d>:
 8003294: f9 ee 00 08  	.word	0x0800eef9
 8003298: 11 13 00 08  	.word	0x08001311

0800329c <z_arm_cpu_idle_init>:
; {
 800329c: b480         	push	{r7}
 800329e: af00         	add	r7, sp, #0x0
; 	SCB->SCR = SCB_SCR_SEVONPEND_Msk;
 80032a0: 4b03         	ldr	r3, [pc, #0xc]          @ 0x80032b0 <z_arm_cpu_idle_init+0x14>
 80032a2: 2210         	movs	r2, #0x10
 80032a4: 611a         	str	r2, [r3, #0x10]
; }
 80032a6: bf00         	nop
 80032a8: 46bd         	mov	sp, r7
 80032aa: bc80         	pop	{r7}
 80032ac: 4770         	bx	lr
 80032ae: bf00         	nop

080032b0 <$d>:
 80032b0: 00 ed 00 e0  	.word	0xe000ed00

080032b4 <__NVIC_SetPriority>:
; {
 80032b4: b480         	push	{r7}
 80032b6: b083         	sub	sp, #0xc
 80032b8: af00         	add	r7, sp, #0x0
 80032ba: 4603         	mov	r3, r0
 80032bc: 6039         	str	r1, [r7]
 80032be: 71fb         	strb	r3, [r7, #0x7]
;   if ((int32_t)(IRQn) >= 0)
 80032c0: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 80032c4: 2b00         	cmp	r3, #0x0
 80032c6: db0a         	blt	0x80032de <__NVIC_SetPriority+0x2a> @ imm = #0x14
;     NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80032c8: 683b         	ldr	r3, [r7]
 80032ca: b2da         	uxtb	r2, r3
 80032cc: 490c         	ldr	r1, [pc, #0x30]         @ 0x8003300 <__NVIC_SetPriority+0x4c>
 80032ce: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 80032d2: 0112         	lsls	r2, r2, #0x4
 80032d4: b2d2         	uxtb	r2, r2
 80032d6: 440b         	add	r3, r1
 80032d8: f883 2300    	strb.w	r2, [r3, #0x300]
; }
 80032dc: e00a         	b	0x80032f4 <__NVIC_SetPriority+0x40> @ imm = #0x14
;     SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80032de: 683b         	ldr	r3, [r7]
 80032e0: b2da         	uxtb	r2, r3
 80032e2: 4908         	ldr	r1, [pc, #0x20]         @ 0x8003304 <__NVIC_SetPriority+0x50>
 80032e4: 79fb         	ldrb	r3, [r7, #0x7]
 80032e6: f003 030f    	and	r3, r3, #0xf
 80032ea: 3b04         	subs	r3, #0x4
 80032ec: 0112         	lsls	r2, r2, #0x4
 80032ee: b2d2         	uxtb	r2, r2
 80032f0: 440b         	add	r3, r1
 80032f2: 761a         	strb	r2, [r3, #0x18]
; }
 80032f4: bf00         	nop
 80032f6: 370c         	adds	r7, #0xc
 80032f8: 46bd         	mov	sp, r7
 80032fa: bc80         	pop	{r7}
 80032fc: 4770         	bx	lr
 80032fe: bf00         	nop

08003300 <$d>:
 8003300: 00 e1 00 e0  	.word	0xe000e100
 8003304: 00 ed 00 e0  	.word	0xe000ed00

08003308 <_isr_wrapper>:
; {
 8003308: b580         	push	{r7, lr}
 800330a: b084         	sub	sp, #0x10
 800330c: af00         	add	r7, sp, #0x0
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800330e: f3ef 8305    	mrs	r3, ipsr
 8003312: 607b         	str	r3, [r7, #0x4]
;   return(result);
 8003314: 687b         	ldr	r3, [r7, #0x4]
; 	int32_t irq_number = __get_IPSR();
 8003316: 60fb         	str	r3, [r7, #0xc]
; 	irq_number -= 16;
 8003318: 68fb         	ldr	r3, [r7, #0xc]
 800331a: 3b10         	subs	r3, #0x10
 800331c: 60fb         	str	r3, [r7, #0xc]
; 	struct _isr_table_entry *entry = &_sw_isr_table[irq_number];
 800331e: 68fb         	ldr	r3, [r7, #0xc]
 8003320: 00db         	lsls	r3, r3, #0x3
 8003322: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8003340 <_isr_wrapper+0x38>
 8003324: 4413         	add	r3, r2
 8003326: 60bb         	str	r3, [r7, #0x8]
; 	(entry->isr)(entry->arg);
 8003328: 68bb         	ldr	r3, [r7, #0x8]
 800332a: 685b         	ldr	r3, [r3, #0x4]
 800332c: 68ba         	ldr	r2, [r7, #0x8]
 800332e: 6812         	ldr	r2, [r2]
 8003330: 4610         	mov	r0, r2
 8003332: 4798         	blx	r3
; 	z_arm_exc_exit();
 8003334: f7fe ff88    	bl	0x8002248 <z_arm_int_exit> @ imm = #-0x10f0
; }
 8003338: bf00         	nop
 800333a: 3710         	adds	r7, #0x10
 800333c: 46bd         	mov	sp, r7
 800333e: bd80         	pop	{r7, pc}

08003340 <$d>:
 8003340: 20 47 01 08  	.word	0x08014720

08003344 <cbvprintf>:
; {
 8003344: b580         	push	{r7, lr}
 8003346: b08a         	sub	sp, #0x28
 8003348: af00         	add	r7, sp, #0x0
 800334a: 60f8         	str	r0, [r7, #0xc]
 800334c: 60b9         	str	r1, [r7, #0x8]
 800334e: 607a         	str	r2, [r7, #0x4]
 8003350: 603b         	str	r3, [r7]
; 	struct cb_bits	s = {
 8003352: f107 0310    	add.w	r3, r7, #0x10
 8003356: 2200         	movs	r2, #0x0
 8003358: 601a         	str	r2, [r3]
 800335a: 605a         	str	r2, [r3, #0x4]
 800335c: 609a         	str	r2, [r3, #0x8]
 800335e: 60da         	str	r2, [r3, #0xc]
 8003360: 611a         	str	r2, [r3, #0x10]
 8003362: 615a         	str	r2, [r3, #0x14]
 8003364: 2302         	movs	r3, #0x2
 8003366: 74bb         	strb	r3, [r7, #0x12]
 8003368: 4b08         	ldr	r3, [pc, #0x20]         @ 0x800338c <cbvprintf+0x48>
 800336a: 617b         	str	r3, [r7, #0x14]
 800336c: 68fb         	ldr	r3, [r7, #0xc]
 800336e: 623b         	str	r3, [r7, #0x20]
 8003370: 68bb         	ldr	r3, [r7, #0x8]
 8003372: 627b         	str	r3, [r7, #0x24]
; 	return vfprintf(&s.f, fp, ap);
 8003374: f107 0310    	add.w	r3, r7, #0x10
 8003378: 683a         	ldr	r2, [r7]
 800337a: 6879         	ldr	r1, [r7, #0x4]
 800337c: 4618         	mov	r0, r3
 800337e: f009 fa1d    	bl	0x800c7bc <vfprintf>    @ imm = #0x943a
 8003382: 4603         	mov	r3, r0
; }
 8003384: 4618         	mov	r0, r3
 8003386: 3728         	adds	r7, #0x28
 8003388: 46bd         	mov	sp, r7
 800338a: bd80         	pop	{r7, pc}

0800338c <$d>:
 800338c: 91 ef 00 08  	.word	0x0800ef91

08003390 <z_impl_zephyr_fputc>:
; {
 8003390: b580         	push	{r7, lr}
 8003392: b082         	sub	sp, #0x8
 8003394: af00         	add	r7, sp, #0x0
 8003396: 6078         	str	r0, [r7, #0x4]
 8003398: 6039         	str	r1, [r7]
; 	(*_stdout_hook)(a);
 800339a: 4b04         	ldr	r3, [pc, #0x10]         @ 0x80033ac <z_impl_zephyr_fputc+0x1c>
 800339c: 681b         	ldr	r3, [r3]
 800339e: 6878         	ldr	r0, [r7, #0x4]
 80033a0: 4798         	blx	r3
; 	return 0;
 80033a2: 2300         	movs	r3, #0x0
; }
 80033a4: 4618         	mov	r0, r3
 80033a6: 3708         	adds	r7, #0x8
 80033a8: 46bd         	mov	sp, r7
 80033aa: bd80         	pop	{r7, pc}

080033ac <$d>:
 80033ac: f4 05 00 20  	.word	0x200005f4

080033b0 <__stdout_hook_install>:
; {
 80033b0: b480         	push	{r7}
 80033b2: b083         	sub	sp, #0xc
 80033b4: af00         	add	r7, sp, #0x0
 80033b6: 6078         	str	r0, [r7, #0x4]
; 	_stdout_hook = hook;
 80033b8: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x80033d8 <__stdout_hook_install+0x28>
 80033ba: 687b         	ldr	r3, [r7, #0x4]
 80033bc: 6013         	str	r3, [r2]
; 	__stdout.flags |= _FDEV_SETUP_WRITE;
 80033be: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x80033dc <__stdout_hook_install+0x2c>
 80033c0: 789b         	ldrb	r3, [r3, #0x2]
 80033c2: f043 0302    	orr	r3, r3, #0x2
 80033c6: b2da         	uxtb	r2, r3
 80033c8: 4b04         	ldr	r3, [pc, #0x10]         @ 0x80033dc <__stdout_hook_install+0x2c>
 80033ca: 709a         	strb	r2, [r3, #0x2]
; }
 80033cc: bf00         	nop
 80033ce: 370c         	adds	r7, #0xc
 80033d0: 46bd         	mov	sp, r7
 80033d2: bc80         	pop	{r7}
 80033d4: 4770         	bx	lr
 80033d6: bf00         	nop

080033d8 <$d>:
 80033d8: f4 05 00 20  	.word	0x200005f4
 80033dc: 24 00 00 20  	.word	0x20000024

080033e0 <malloc_prepare>:
; {
 80033e0: b580         	push	{r7, lr}
 80033e2: b082         	sub	sp, #0x8
 80033e4: af00         	add	r7, sp, #0x0
; 	void *heap_base = NULL;
 80033e6: 2300         	movs	r3, #0x0
 80033e8: 607b         	str	r3, [r7, #0x4]
; 	heap_base = UINT_TO_POINTER(HEAP_BASE);
 80033ea: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800341c <malloc_prepare+0x3c>
 80033ec: 3307         	adds	r3, #0x7
 80033ee: f023 0307    	bic	r3, r3, #0x7
 80033f2: 607b         	str	r3, [r7, #0x4]
; 	heap_size = HEAP_SIZE;
 80033f4: 4b09         	ldr	r3, [pc, #0x24]         @ 0x800341c <malloc_prepare+0x3c>
 80033f6: 3307         	adds	r3, #0x7
 80033f8: f023 0307    	bic	r3, r3, #0x7
 80033fc: f1c3 5300    	rsb.w	r3, r3, #0x20000000
 8003400: f503 3300    	add.w	r3, r3, #0x20000
 8003404: 603b         	str	r3, [r7]
; 	sys_heap_init(&z_malloc_heap, heap_base, heap_size);
 8003406: 683a         	ldr	r2, [r7]
 8003408: 6879         	ldr	r1, [r7, #0x4]
 800340a: 4805         	ldr	r0, [pc, #0x14]         @ 0x8003420 <malloc_prepare+0x40>
 800340c: f00a fc88    	bl	0x800dd20 <sys_heap_init> @ imm = #0xa910
; 	return 0;
 8003410: 2300         	movs	r3, #0x0
; }
 8003412: 4618         	mov	r0, r3
 8003414: 3708         	adds	r7, #0x8
 8003416: 46bd         	mov	sp, r7
 8003418: bd80         	pop	{r7, pc}
 800341a: bf00         	nop

0800341c <$d>:
 800341c: 10 20 00 20  	.word	0x20002010
 8003420: f8 05 00 20  	.word	0x200005f8

08003424 <LL_EXTI_EnableIT_0_31>:
; {
 8003424: b480         	push	{r7}
 8003426: b083         	sub	sp, #0xc
 8003428: af00         	add	r7, sp, #0x0
 800342a: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(EXTI->IMR, ExtiLine);
 800342c: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8003444 <LL_EXTI_EnableIT_0_31+0x20>
 800342e: 681a         	ldr	r2, [r3]
 8003430: 4904         	ldr	r1, [pc, #0x10]         @ 0x8003444 <LL_EXTI_EnableIT_0_31+0x20>
 8003432: 687b         	ldr	r3, [r7, #0x4]
 8003434: 4313         	orrs	r3, r2
 8003436: 600b         	str	r3, [r1]
; }
 8003438: bf00         	nop
 800343a: 370c         	adds	r7, #0xc
 800343c: 46bd         	mov	sp, r7
 800343e: bc80         	pop	{r7}
 8003440: 4770         	bx	lr
 8003442: bf00         	nop

08003444 <$d>:
 8003444: 00 3c 01 40  	.word	0x40013c00

08003448 <LL_EXTI_DisableIT_0_31>:
; {
 8003448: b480         	push	{r7}
 800344a: b083         	sub	sp, #0xc
 800344c: af00         	add	r7, sp, #0x0
 800344e: 6078         	str	r0, [r7, #0x4]
;   CLEAR_BIT(EXTI->IMR, ExtiLine);
 8003450: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8003468 <LL_EXTI_DisableIT_0_31+0x20>
 8003452: 681a         	ldr	r2, [r3]
 8003454: 687b         	ldr	r3, [r7, #0x4]
 8003456: 43db         	mvns	r3, r3
 8003458: 4903         	ldr	r1, [pc, #0xc]          @ 0x8003468 <LL_EXTI_DisableIT_0_31+0x20>
 800345a: 4013         	ands	r3, r2
 800345c: 600b         	str	r3, [r1]
; }
 800345e: bf00         	nop
 8003460: 370c         	adds	r7, #0xc
 8003462: 46bd         	mov	sp, r7
 8003464: bc80         	pop	{r7}
 8003466: 4770         	bx	lr

08003468 <$d>:
 8003468: 00 3c 01 40  	.word	0x40013c00

0800346c <LL_EXTI_EnableRisingTrig_0_31>:
; {
 800346c: b480         	push	{r7}
 800346e: b083         	sub	sp, #0xc
 8003470: af00         	add	r7, sp, #0x0
 8003472: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(EXTI->RTSR, ExtiLine);
 8003474: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800348c <LL_EXTI_EnableRisingTrig_0_31+0x20>
 8003476: 689a         	ldr	r2, [r3, #0x8]
 8003478: 4904         	ldr	r1, [pc, #0x10]         @ 0x800348c <LL_EXTI_EnableRisingTrig_0_31+0x20>
 800347a: 687b         	ldr	r3, [r7, #0x4]
 800347c: 4313         	orrs	r3, r2
 800347e: 608b         	str	r3, [r1, #0x8]
; }
 8003480: bf00         	nop
 8003482: 370c         	adds	r7, #0xc
 8003484: 46bd         	mov	sp, r7
 8003486: bc80         	pop	{r7}
 8003488: 4770         	bx	lr
 800348a: bf00         	nop

0800348c <$d>:
 800348c: 00 3c 01 40  	.word	0x40013c00

08003490 <LL_EXTI_DisableRisingTrig_0_31>:
; {
 8003490: b480         	push	{r7}
 8003492: b083         	sub	sp, #0xc
 8003494: af00         	add	r7, sp, #0x0
 8003496: 6078         	str	r0, [r7, #0x4]
;   CLEAR_BIT(EXTI->RTSR, ExtiLine);
 8003498: 4b05         	ldr	r3, [pc, #0x14]         @ 0x80034b0 <LL_EXTI_DisableRisingTrig_0_31+0x20>
 800349a: 689a         	ldr	r2, [r3, #0x8]
 800349c: 687b         	ldr	r3, [r7, #0x4]
 800349e: 43db         	mvns	r3, r3
 80034a0: 4903         	ldr	r1, [pc, #0xc]          @ 0x80034b0 <LL_EXTI_DisableRisingTrig_0_31+0x20>
 80034a2: 4013         	ands	r3, r2
 80034a4: 608b         	str	r3, [r1, #0x8]
; }
 80034a6: bf00         	nop
 80034a8: 370c         	adds	r7, #0xc
 80034aa: 46bd         	mov	sp, r7
 80034ac: bc80         	pop	{r7}
 80034ae: 4770         	bx	lr

080034b0 <$d>:
 80034b0: 00 3c 01 40  	.word	0x40013c00

080034b4 <LL_EXTI_EnableFallingTrig_0_31>:
; {
 80034b4: b480         	push	{r7}
 80034b6: b083         	sub	sp, #0xc
 80034b8: af00         	add	r7, sp, #0x0
 80034ba: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(EXTI->FTSR, ExtiLine);
 80034bc: 4b05         	ldr	r3, [pc, #0x14]         @ 0x80034d4 <LL_EXTI_EnableFallingTrig_0_31+0x20>
 80034be: 68da         	ldr	r2, [r3, #0xc]
 80034c0: 4904         	ldr	r1, [pc, #0x10]         @ 0x80034d4 <LL_EXTI_EnableFallingTrig_0_31+0x20>
 80034c2: 687b         	ldr	r3, [r7, #0x4]
 80034c4: 4313         	orrs	r3, r2
 80034c6: 60cb         	str	r3, [r1, #0xc]
; }
 80034c8: bf00         	nop
 80034ca: 370c         	adds	r7, #0xc
 80034cc: 46bd         	mov	sp, r7
 80034ce: bc80         	pop	{r7}
 80034d0: 4770         	bx	lr
 80034d2: bf00         	nop

080034d4 <$d>:
 80034d4: 00 3c 01 40  	.word	0x40013c00

080034d8 <LL_EXTI_DisableFallingTrig_0_31>:
; {
 80034d8: b480         	push	{r7}
 80034da: b083         	sub	sp, #0xc
 80034dc: af00         	add	r7, sp, #0x0
 80034de: 6078         	str	r0, [r7, #0x4]
;   CLEAR_BIT(EXTI->FTSR, ExtiLine);
 80034e0: 4b05         	ldr	r3, [pc, #0x14]         @ 0x80034f8 <LL_EXTI_DisableFallingTrig_0_31+0x20>
 80034e2: 68da         	ldr	r2, [r3, #0xc]
 80034e4: 687b         	ldr	r3, [r7, #0x4]
 80034e6: 43db         	mvns	r3, r3
 80034e8: 4903         	ldr	r1, [pc, #0xc]          @ 0x80034f8 <LL_EXTI_DisableFallingTrig_0_31+0x20>
 80034ea: 4013         	ands	r3, r2
 80034ec: 60cb         	str	r3, [r1, #0xc]
; }
 80034ee: bf00         	nop
 80034f0: 370c         	adds	r7, #0xc
 80034f2: 46bd         	mov	sp, r7
 80034f4: bc80         	pop	{r7}
 80034f6: 4770         	bx	lr

080034f8 <$d>:
 80034f8: 00 3c 01 40  	.word	0x40013c00

080034fc <LL_EXTI_IsActiveFlag_0_31>:
; {
 80034fc: b480         	push	{r7}
 80034fe: b083         	sub	sp, #0xc
 8003500: af00         	add	r7, sp, #0x0
 8003502: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(EXTI->PR, ExtiLine) == (ExtiLine));
 8003504: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8003524 <LL_EXTI_IsActiveFlag_0_31+0x28>
 8003506: 695a         	ldr	r2, [r3, #0x14]
 8003508: 687b         	ldr	r3, [r7, #0x4]
 800350a: 4013         	ands	r3, r2
 800350c: 687a         	ldr	r2, [r7, #0x4]
 800350e: 429a         	cmp	r2, r3
 8003510: bf0c         	ite	eq
 8003512: 2301         	moveq	r3, #0x1
 8003514: 2300         	movne	r3, #0x0
 8003516: b2db         	uxtb	r3, r3
; }
 8003518: 4618         	mov	r0, r3
 800351a: 370c         	adds	r7, #0xc
 800351c: 46bd         	mov	sp, r7
 800351e: bc80         	pop	{r7}
 8003520: 4770         	bx	lr
 8003522: bf00         	nop

08003524 <$d>:
 8003524: 00 3c 01 40  	.word	0x40013c00

08003528 <LL_EXTI_ClearFlag_0_31>:
; {
 8003528: b480         	push	{r7}
 800352a: b083         	sub	sp, #0xc
 800352c: af00         	add	r7, sp, #0x0
 800352e: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(EXTI->PR, ExtiLine);
 8003530: 4a03         	ldr	r2, [pc, #0xc]          @ 0x8003540 <LL_EXTI_ClearFlag_0_31+0x18>
 8003532: 687b         	ldr	r3, [r7, #0x4]
 8003534: 6153         	str	r3, [r2, #0x14]
; }
 8003536: bf00         	nop
 8003538: 370c         	adds	r7, #0xc
 800353a: 46bd         	mov	sp, r7
 800353c: bc80         	pop	{r7}
 800353e: 4770         	bx	lr

08003540 <$d>:
 8003540: 00 3c 01 40  	.word	0x40013c00

08003544 <LL_SYSCFG_SetEXTISource>:
; {
 8003544: b480         	push	{r7}
 8003546: b087         	sub	sp, #0x1c
 8003548: af00         	add	r7, sp, #0x0
 800354a: 6078         	str	r0, [r7, #0x4]
 800354c: 6039         	str	r1, [r7]
;   MODIFY_REG(SYSCFG->EXTICR[Line & 0xFF], (Line >> 16), Port << POSITION_VAL((Line >> 16)));
 800354e: 4a16         	ldr	r2, [pc, #0x58]         @ 0x80035a8 <LL_SYSCFG_SetEXTISource+0x64>
 8003550: 683b         	ldr	r3, [r7]
 8003552: b2db         	uxtb	r3, r3
 8003554: 3302         	adds	r3, #0x2
 8003556: f852 2023    	ldr.w	r2, [r2, r3, lsl #2]
 800355a: 683b         	ldr	r3, [r7]
 800355c: 0c1b         	lsrs	r3, r3, #0x10
 800355e: 43db         	mvns	r3, r3
 8003560: ea02 0103    	and.w	r1, r2, r3
 8003564: 683b         	ldr	r3, [r7]
 8003566: 0c1b         	lsrs	r3, r3, #0x10
 8003568: 613b         	str	r3, [r7, #0x10]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800356a: 693b         	ldr	r3, [r7, #0x10]
 800356c: fa93 f3a3    	rbit	r3, r3
 8003570: 60fb         	str	r3, [r7, #0xc]
;   return result;
 8003572: 68fb         	ldr	r3, [r7, #0xc]
 8003574: 617b         	str	r3, [r7, #0x14]
;   if (value == 0U)
 8003576: 697b         	ldr	r3, [r7, #0x14]
 8003578: 2b00         	cmp	r3, #0x0
 800357a: d101         	bne	0x8003580 <LL_SYSCFG_SetEXTISource+0x3c> @ imm = #0x2
;     return 32U;
 800357c: 2320         	movs	r3, #0x20
 800357e: e003         	b	0x8003588 <LL_SYSCFG_SetEXTISource+0x44> @ imm = #0x6
;   return __builtin_clz(value);
 8003580: 697b         	ldr	r3, [r7, #0x14]
 8003582: fab3 f383    	clz	r3, r3
 8003586: b2db         	uxtb	r3, r3
;   MODIFY_REG(SYSCFG->EXTICR[Line & 0xFF], (Line >> 16), Port << POSITION_VAL((Line >> 16)));
 8003588: 461a         	mov	r2, r3
 800358a: 687b         	ldr	r3, [r7, #0x4]
 800358c: fa03 f202    	lsl.w	r2, r3, r2
 8003590: 4805         	ldr	r0, [pc, #0x14]         @ 0x80035a8 <LL_SYSCFG_SetEXTISource+0x64>
 8003592: 683b         	ldr	r3, [r7]
 8003594: b2db         	uxtb	r3, r3
 8003596: 430a         	orrs	r2, r1
 8003598: 3302         	adds	r3, #0x2
 800359a: f840 2023    	str.w	r2, [r0, r3, lsl #2]
; }
 800359e: bf00         	nop
 80035a0: 371c         	adds	r7, #0x1c
 80035a2: 46bd         	mov	sp, r7
 80035a4: bc80         	pop	{r7}
 80035a6: 4770         	bx	lr

080035a8 <$d>:
 80035a8: 00 38 01 40  	.word	0x40013800

080035ac <LL_SYSCFG_GetEXTISource>:
; {
 80035ac: b480         	push	{r7}
 80035ae: b087         	sub	sp, #0x1c
 80035b0: af00         	add	r7, sp, #0x0
 80035b2: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_BIT(SYSCFG->EXTICR[Line & 0xFF], (Line >> 16)) >> POSITION_VAL(Line >> 16));
 80035b4: 4a10         	ldr	r2, [pc, #0x40]         @ 0x80035f8 <LL_SYSCFG_GetEXTISource+0x4c>
 80035b6: 687b         	ldr	r3, [r7, #0x4]
 80035b8: b2db         	uxtb	r3, r3
 80035ba: 3302         	adds	r3, #0x2
 80035bc: f852 2023    	ldr.w	r2, [r2, r3, lsl #2]
 80035c0: 687b         	ldr	r3, [r7, #0x4]
 80035c2: 0c1b         	lsrs	r3, r3, #0x10
 80035c4: 4013         	ands	r3, r2
 80035c6: 687a         	ldr	r2, [r7, #0x4]
 80035c8: 0c12         	lsrs	r2, r2, #0x10
 80035ca: 613a         	str	r2, [r7, #0x10]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80035cc: 693a         	ldr	r2, [r7, #0x10]
 80035ce: fa92 f2a2    	rbit	r2, r2
 80035d2: 60fa         	str	r2, [r7, #0xc]
;   return result;
 80035d4: 68fa         	ldr	r2, [r7, #0xc]
 80035d6: 617a         	str	r2, [r7, #0x14]
;   if (value == 0U)
 80035d8: 697a         	ldr	r2, [r7, #0x14]
 80035da: 2a00         	cmp	r2, #0x0
 80035dc: d101         	bne	0x80035e2 <LL_SYSCFG_GetEXTISource+0x36> @ imm = #0x2
;     return 32U;
 80035de: 2220         	movs	r2, #0x20
 80035e0: e003         	b	0x80035ea <LL_SYSCFG_GetEXTISource+0x3e> @ imm = #0x6
;   return __builtin_clz(value);
 80035e2: 697a         	ldr	r2, [r7, #0x14]
 80035e4: fab2 f282    	clz	r2, r2
 80035e8: b2d2         	uxtb	r2, r2
;   return (uint32_t)(READ_BIT(SYSCFG->EXTICR[Line & 0xFF], (Line >> 16)) >> POSITION_VAL(Line >> 16));
 80035ea: 40d3         	lsrs	r3, r2
; }
 80035ec: 4618         	mov	r0, r3
 80035ee: 371c         	adds	r7, #0x1c
 80035f0: 46bd         	mov	sp, r7
 80035f2: bc80         	pop	{r7}
 80035f4: 4770         	bx	lr
 80035f6: bf00         	nop

080035f8 <$d>:
 80035f8: 00 38 01 40  	.word	0x40013800

080035fc <stm32_exti_isr>:
; {
 80035fc: b580         	push	{r7, lr}
 80035fe: b088         	sub	sp, #0x20
 8003600: af00         	add	r7, sp, #0x0
 8003602: 6078         	str	r0, [r7, #0x4]
; 	const struct device *dev = DEVICE_DT_GET(EXTI_NODE);
 8003604: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x8003684 <stm32_exti_isr+0x88>
 8003606: 61bb         	str	r3, [r7, #0x18]
; 	struct stm32_exti_data *data = dev->data;
 8003608: 69bb         	ldr	r3, [r7, #0x18]
 800360a: 691b         	ldr	r3, [r3, #0x10]
 800360c: 617b         	str	r3, [r7, #0x14]
; 	const struct stm32_exti_range *range = exti_range;
 800360e: 687b         	ldr	r3, [r7, #0x4]
 8003610: 613b         	str	r3, [r7, #0x10]
; 	for (uint8_t i = 0; i <= range->len; i++) {
 8003612: 2300         	movs	r3, #0x0
 8003614: 77fb         	strb	r3, [r7, #0x1f]
 8003616: e02b         	b	0x8003670 <stm32_exti_isr+0x74> @ imm = #0x56
; 		line_num = range->start + i;
 8003618: 693b         	ldr	r3, [r7, #0x10]
 800361a: 781b         	ldrb	r3, [r3]
 800361c: 461a         	mov	r2, r3
 800361e: 7ffb         	ldrb	r3, [r7, #0x1f]
 8003620: 4413         	add	r3, r2
 8003622: 60fb         	str	r3, [r7, #0xc]
; 		line = linenum_to_ll_exti_line(line_num);
 8003624: 68fb         	ldr	r3, [r7, #0xc]
 8003626: b2db         	uxtb	r3, r3
 8003628: 4618         	mov	r0, r3
 800362a: f00b fd35    	bl	0x800f098 <linenum_to_ll_exti_line> @ imm = #0xba6a
 800362e: 60b8         	str	r0, [r7, #0x8]
; 		if (stm32_exti_is_pending(line) != 0) {
 8003630: 68b8         	ldr	r0, [r7, #0x8]
 8003632: f00b fd1a    	bl	0x800f06a <stm32_exti_is_pending> @ imm = #0xba34
 8003636: 4603         	mov	r3, r0
 8003638: 2b00         	cmp	r3, #0x0
 800363a: d016         	beq	0x800366a <stm32_exti_isr+0x6e> @ imm = #0x2c
; 			stm32_exti_clear_pending(line);
 800363c: 68b8         	ldr	r0, [r7, #0x8]
 800363e: f00b fd20    	bl	0x800f082 <stm32_exti_clear_pending> @ imm = #0xba40
; 			if (!data->cb[line_num].cb) {
 8003642: 697b         	ldr	r3, [r7, #0x14]
 8003644: 68fa         	ldr	r2, [r7, #0xc]
 8003646: f853 3032    	ldr.w	r3, [r3, r2, lsl #3]
 800364a: 2b00         	cmp	r3, #0x0
 800364c: d00c         	beq	0x8003668 <stm32_exti_isr+0x6c> @ imm = #0x18
; 			data->cb[line_num].cb(line, data->cb[line_num].data);
 800364e: 697b         	ldr	r3, [r7, #0x14]
 8003650: 68fa         	ldr	r2, [r7, #0xc]
 8003652: f853 2032    	ldr.w	r2, [r3, r2, lsl #3]
 8003656: 6979         	ldr	r1, [r7, #0x14]
 8003658: 68fb         	ldr	r3, [r7, #0xc]
 800365a: 00db         	lsls	r3, r3, #0x3
 800365c: 440b         	add	r3, r1
 800365e: 685b         	ldr	r3, [r3, #0x4]
 8003660: 4619         	mov	r1, r3
 8003662: 68b8         	ldr	r0, [r7, #0x8]
 8003664: 4790         	blx	r2
 8003666: e000         	b	0x800366a <stm32_exti_isr+0x6e> @ imm = #0x0
; 				continue;
 8003668: bf00         	nop
; 	for (uint8_t i = 0; i <= range->len; i++) {
 800366a: 7ffb         	ldrb	r3, [r7, #0x1f]
 800366c: 3301         	adds	r3, #0x1
 800366e: 77fb         	strb	r3, [r7, #0x1f]
 8003670: 693b         	ldr	r3, [r7, #0x10]
 8003672: 785b         	ldrb	r3, [r3, #0x1]
 8003674: 7ffa         	ldrb	r2, [r7, #0x1f]
 8003676: 429a         	cmp	r2, r3
 8003678: d9ce         	bls	0x8003618 <stm32_exti_isr+0x1c> @ imm = #-0x64
; }
 800367a: bf00         	nop
 800367c: bf00         	nop
 800367e: 3720         	adds	r7, #0x20
 8003680: 46bd         	mov	sp, r7
 8003682: bd80         	pop	{r7, pc}

08003684 <$d>:
 8003684: cc 45 01 08  	.word	0x080145cc

08003688 <stm32_exti_enable_registers>:
; {
 8003688: b580         	push	{r7, lr}
 800368a: b084         	sub	sp, #0x10
 800368c: af00         	add	r7, sp, #0x0
; 	int ret = 0;
 800368e: 2300         	movs	r3, #0x0
 8003690: 60fb         	str	r3, [r7, #0xc]
; 	const struct device *const clk = DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE);
 8003692: 4b09         	ldr	r3, [pc, #0x24]         @ 0x80036b8 <stm32_exti_enable_registers+0x30>
 8003694: 60bb         	str	r3, [r7, #0x8]
; 	struct stm32_pclken pclken = {
 8003696: 4a09         	ldr	r2, [pc, #0x24]         @ 0x80036bc <stm32_exti_enable_registers+0x34>
 8003698: 463b         	mov	r3, r7
 800369a: e892 0003    	ldm.w	r2, {r0, r1}
 800369e: e883 0003    	stm.w	r3, {r0, r1}
; 	ret = clock_control_on(clk, (clock_control_subsys_t) &pclken);
 80036a2: 463b         	mov	r3, r7
 80036a4: 4619         	mov	r1, r3
 80036a6: 68b8         	ldr	r0, [r7, #0x8]
 80036a8: f00b fca4    	bl	0x800eff4 <clock_control_on> @ imm = #0xb948
 80036ac: 60f8         	str	r0, [r7, #0xc]
; 	return ret;
 80036ae: 68fb         	ldr	r3, [r7, #0xc]
; }
 80036b0: 4618         	mov	r0, r3
 80036b2: 3710         	adds	r7, #0x10
 80036b4: 46bd         	mov	sp, r7
 80036b6: bd80         	pop	{r7, pc}

080036b8 <$d>:
 80036b8: a4 45 01 08  	.word	0x080145a4
 80036bc: e4 51 01 08  	.word	0x080151e4

080036c0 <stm32_fill_irq_table>:
; {
 80036c0: b480         	push	{r7}
 80036c2: b085         	sub	sp, #0x14
 80036c4: af00         	add	r7, sp, #0x0
 80036c6: 4603         	mov	r3, r0
 80036c8: 603a         	str	r2, [r7]
 80036ca: 71fb         	strb	r3, [r7, #0x7]
 80036cc: 460b         	mov	r3, r1
 80036ce: 71bb         	strb	r3, [r7, #0x6]
; 	for (int i = 0; i < len; i++) {
 80036d0: 2300         	movs	r3, #0x0
 80036d2: 60fb         	str	r3, [r7, #0xc]
 80036d4: e00a         	b	0x80036ec <stm32_fill_irq_table+0x2c> @ imm = #0x14
; 		exti_irq_table[start + i] = irqn;
 80036d6: f997 2007    	ldrsb.w	r2, [r7, #0x7]
 80036da: 68fb         	ldr	r3, [r7, #0xc]
 80036dc: 4413         	add	r3, r2
 80036de: 683a         	ldr	r2, [r7]
 80036e0: b251         	sxtb	r1, r2
 80036e2: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8003704 <stm32_fill_irq_table+0x44>
 80036e4: 54d1         	strb	r1, [r2, r3]
; 	for (int i = 0; i < len; i++) {
 80036e6: 68fb         	ldr	r3, [r7, #0xc]
 80036e8: 3301         	adds	r3, #0x1
 80036ea: 60fb         	str	r3, [r7, #0xc]
 80036ec: f997 3006    	ldrsb.w	r3, [r7, #0x6]
 80036f0: 68fa         	ldr	r2, [r7, #0xc]
 80036f2: 429a         	cmp	r2, r3
 80036f4: dbef         	blt	0x80036d6 <stm32_fill_irq_table+0x16> @ imm = #-0x22
; }
 80036f6: bf00         	nop
 80036f8: bf00         	nop
 80036fa: 3714         	adds	r7, #0x14
 80036fc: 46bd         	mov	sp, r7
 80036fe: bc80         	pop	{r7}
 8003700: 4770         	bx	lr
 8003702: bf00         	nop

08003704 <$d>:
 8003704: 34 00 00 20  	.word	0x20000034

08003708 <stm32_exti_init>:
; {
 8003708: b580         	push	{r7, lr}
 800370a: b082         	sub	sp, #0x8
 800370c: af00         	add	r7, sp, #0x0
 800370e: 6078         	str	r0, [r7, #0x4]
; 	DT_FOREACH_PROP_ELEM(DT_NODELABEL(exti),
 8003710: 4b37         	ldr	r3, [pc, #0xdc]         @ 0x80037f0 <stm32_exti_init+0xe8>
 8003712: 781b         	ldrb	r3, [r3]
 8003714: b25b         	sxtb	r3, r3
 8003716: 4a36         	ldr	r2, [pc, #0xd8]         @ 0x80037f0 <stm32_exti_init+0xe8>
 8003718: 7852         	ldrb	r2, [r2, #0x1]
 800371a: b251         	sxtb	r1, r2
 800371c: 2206         	movs	r2, #0x6
 800371e: 4618         	mov	r0, r3
 8003720: f7ff ffce    	bl	0x80036c0 <stm32_fill_irq_table> @ imm = #-0x64
 8003724: 2200         	movs	r2, #0x0
 8003726: 2100         	movs	r1, #0x0
 8003728: 2006         	movs	r0, #0x6
 800372a: f00b fbb2    	bl	0x800ee92 <z_arm_irq_priority_set> @ imm = #0xb764
 800372e: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x80037f4 <stm32_exti_init+0xec>
 8003730: 781b         	ldrb	r3, [r3]
 8003732: b25b         	sxtb	r3, r3
 8003734: 4a2f         	ldr	r2, [pc, #0xbc]         @ 0x80037f4 <stm32_exti_init+0xec>
 8003736: 7852         	ldrb	r2, [r2, #0x1]
 8003738: b251         	sxtb	r1, r2
 800373a: 2207         	movs	r2, #0x7
 800373c: 4618         	mov	r0, r3
 800373e: f7ff ffbf    	bl	0x80036c0 <stm32_fill_irq_table> @ imm = #-0x82
 8003742: 2200         	movs	r2, #0x0
 8003744: 2100         	movs	r1, #0x0
 8003746: 2007         	movs	r0, #0x7
 8003748: f00b fba3    	bl	0x800ee92 <z_arm_irq_priority_set> @ imm = #0xb746
 800374c: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x80037f8 <stm32_exti_init+0xf0>
 800374e: 781b         	ldrb	r3, [r3]
 8003750: b25b         	sxtb	r3, r3
 8003752: 4a29         	ldr	r2, [pc, #0xa4]         @ 0x80037f8 <stm32_exti_init+0xf0>
 8003754: 7852         	ldrb	r2, [r2, #0x1]
 8003756: b251         	sxtb	r1, r2
 8003758: 2208         	movs	r2, #0x8
 800375a: 4618         	mov	r0, r3
 800375c: f7ff ffb0    	bl	0x80036c0 <stm32_fill_irq_table> @ imm = #-0xa0
 8003760: 2200         	movs	r2, #0x0
 8003762: 2100         	movs	r1, #0x0
 8003764: 2008         	movs	r0, #0x8
 8003766: f00b fb94    	bl	0x800ee92 <z_arm_irq_priority_set> @ imm = #0xb728
 800376a: 4b24         	ldr	r3, [pc, #0x90]         @ 0x80037fc <stm32_exti_init+0xf4>
 800376c: 781b         	ldrb	r3, [r3]
 800376e: b25b         	sxtb	r3, r3
 8003770: 4a22         	ldr	r2, [pc, #0x88]         @ 0x80037fc <stm32_exti_init+0xf4>
 8003772: 7852         	ldrb	r2, [r2, #0x1]
 8003774: b251         	sxtb	r1, r2
 8003776: 2209         	movs	r2, #0x9
 8003778: 4618         	mov	r0, r3
 800377a: f7ff ffa1    	bl	0x80036c0 <stm32_fill_irq_table> @ imm = #-0xbe
 800377e: 2200         	movs	r2, #0x0
 8003780: 2100         	movs	r1, #0x0
 8003782: 2009         	movs	r0, #0x9
 8003784: f00b fb85    	bl	0x800ee92 <z_arm_irq_priority_set> @ imm = #0xb70a
 8003788: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x8003800 <stm32_exti_init+0xf8>
 800378a: 781b         	ldrb	r3, [r3]
 800378c: b25b         	sxtb	r3, r3
 800378e: 4a1c         	ldr	r2, [pc, #0x70]         @ 0x8003800 <stm32_exti_init+0xf8>
 8003790: 7852         	ldrb	r2, [r2, #0x1]
 8003792: b251         	sxtb	r1, r2
 8003794: 220a         	movs	r2, #0xa
 8003796: 4618         	mov	r0, r3
 8003798: f7ff ff92    	bl	0x80036c0 <stm32_fill_irq_table> @ imm = #-0xdc
 800379c: 2200         	movs	r2, #0x0
 800379e: 2100         	movs	r1, #0x0
 80037a0: 200a         	movs	r0, #0xa
 80037a2: f00b fb76    	bl	0x800ee92 <z_arm_irq_priority_set> @ imm = #0xb6ec
 80037a6: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x8003804 <stm32_exti_init+0xfc>
 80037a8: 781b         	ldrb	r3, [r3]
 80037aa: b25b         	sxtb	r3, r3
 80037ac: 4a15         	ldr	r2, [pc, #0x54]         @ 0x8003804 <stm32_exti_init+0xfc>
 80037ae: 7852         	ldrb	r2, [r2, #0x1]
 80037b0: b251         	sxtb	r1, r2
 80037b2: 2217         	movs	r2, #0x17
 80037b4: 4618         	mov	r0, r3
 80037b6: f7ff ff83    	bl	0x80036c0 <stm32_fill_irq_table> @ imm = #-0xfa
 80037ba: 2200         	movs	r2, #0x0
 80037bc: 2100         	movs	r1, #0x0
 80037be: 2017         	movs	r0, #0x17
 80037c0: f00b fb67    	bl	0x800ee92 <z_arm_irq_priority_set> @ imm = #0xb6ce
 80037c4: 4b10         	ldr	r3, [pc, #0x40]         @ 0x8003808 <stm32_exti_init+0x100>
 80037c6: 781b         	ldrb	r3, [r3]
 80037c8: b25b         	sxtb	r3, r3
 80037ca: 4a0f         	ldr	r2, [pc, #0x3c]         @ 0x8003808 <stm32_exti_init+0x100>
 80037cc: 7852         	ldrb	r2, [r2, #0x1]
 80037ce: b251         	sxtb	r1, r2
 80037d0: 2228         	movs	r2, #0x28
 80037d2: 4618         	mov	r0, r3
 80037d4: f7ff ff74    	bl	0x80036c0 <stm32_fill_irq_table> @ imm = #-0x118
 80037d8: 2200         	movs	r2, #0x0
 80037da: 2100         	movs	r1, #0x0
 80037dc: 2028         	movs	r0, #0x28
 80037de: f00b fb58    	bl	0x800ee92 <z_arm_irq_priority_set> @ imm = #0xb6b0
; 	return stm32_exti_enable_registers();
 80037e2: f7ff ff51    	bl	0x8003688 <stm32_exti_enable_registers> @ imm = #-0x15e
 80037e6: 4603         	mov	r3, r0
; }
 80037e8: 4618         	mov	r0, r3
 80037ea: 3708         	adds	r7, #0x8
 80037ec: 46bd         	mov	sp, r7
 80037ee: bd80         	pop	{r7, pc}

080037f0 <$d>:
 80037f0: 9c 62 01 08  	.word	0x0801629c
 80037f4: a0 62 01 08  	.word	0x080162a0
 80037f8: a4 62 01 08  	.word	0x080162a4
 80037fc: a8 62 01 08  	.word	0x080162a8
 8003800: ac 62 01 08  	.word	0x080162ac
 8003804: b0 62 01 08  	.word	0x080162b0
 8003808: b4 62 01 08  	.word	0x080162b4

0800380c <stm32_gpio_intc_enable_line>:
; {
 800380c: b580         	push	{r7, lr}
 800380e: b084         	sub	sp, #0x10
 8003810: af00         	add	r7, sp, #0x0
 8003812: 6078         	str	r0, [r7, #0x4]
; 	uint32_t line_num = ll_exti_line_to_linenum(line);
 8003814: 6878         	ldr	r0, [r7, #0x4]
 8003816: f00b fc4d    	bl	0x800f0b4 <ll_exti_line_to_linenum> @ imm = #0xb89a
 800381a: 4603         	mov	r3, r0
 800381c: 60fb         	str	r3, [r7, #0xc]
; 	irqnum = exti_irq_table[line_num];
 800381e: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8003840 <stm32_gpio_intc_enable_line+0x34>
 8003820: 68fb         	ldr	r3, [r7, #0xc]
 8003822: 4413         	add	r3, r2
 8003824: f993 3000    	ldrsb.w	r3, [r3]
 8003828: 60bb         	str	r3, [r7, #0x8]
; 	LL_EXTI_EnableIT_0_31(line);
 800382a: 6878         	ldr	r0, [r7, #0x4]
 800382c: f7ff fdfa    	bl	0x8003424 <LL_EXTI_EnableIT_0_31> @ imm = #-0x40c
; 	irq_enable(irqnum);
 8003830: 68b8         	ldr	r0, [r7, #0x8]
 8003832: f00b fb21    	bl	0x800ee78 <arch_irq_enable> @ imm = #0xb642
; }
 8003836: bf00         	nop
 8003838: 3710         	adds	r7, #0x10
 800383a: 46bd         	mov	sp, r7
 800383c: bd80         	pop	{r7, pc}
 800383e: bf00         	nop

08003840 <$d>:
 8003840: 34 00 00 20  	.word	0x20000034

08003844 <stm32_gpio_intc_select_line_trigger>:
; {
 8003844: b580         	push	{r7, lr}
 8003846: b082         	sub	sp, #0x8
 8003848: af00         	add	r7, sp, #0x0
 800384a: 6078         	str	r0, [r7, #0x4]
 800384c: 6039         	str	r1, [r7]
; 	z_stm32_hsem_lock(CFG_HW_EXTI_SEMID, HSEM_LOCK_DEFAULT_RETRY);
 800384e: f44f 1180    	mov.w	r1, #0x100000
 8003852: 2000         	movs	r0, #0x0
 8003854: f00b fbe0    	bl	0x800f018 <z_stm32_hsem_lock> @ imm = #0xb7c0
; 	switch (trg) {
 8003858: 683b         	ldr	r3, [r7]
 800385a: 2b03         	cmp	r3, #0x3
 800385c: d826         	bhi	0x80038ac <stm32_gpio_intc_select_line_trigger+0x68> @ imm = #0x4c
 800385e: a201         	adr	r2, #4 <stm32_gpio_intc_select_line_trigger+0x1f>
 8003860: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]

08003864 <$d>:
 8003864: 75 38 00 08  	.word	0x08003875
 8003868: 83 38 00 08  	.word	0x08003883
 800386c: 91 38 00 08  	.word	0x08003891
 8003870: 9f 38 00 08  	.word	0x0800389f

08003874 <$t>:
; 		LL_EXTI_DisableRisingTrig_0_31(line);
 8003874: 6878         	ldr	r0, [r7, #0x4]
 8003876: f7ff fe0b    	bl	0x8003490 <LL_EXTI_DisableRisingTrig_0_31> @ imm = #-0x3ea
; 		LL_EXTI_DisableFallingTrig_0_31(line);
 800387a: 6878         	ldr	r0, [r7, #0x4]
 800387c: f7ff fe2c    	bl	0x80034d8 <LL_EXTI_DisableFallingTrig_0_31> @ imm = #-0x3a8
; 		break;
 8003880: e015         	b	0x80038ae <stm32_gpio_intc_select_line_trigger+0x6a> @ imm = #0x2a
; 		LL_EXTI_EnableRisingTrig_0_31(line);
 8003882: 6878         	ldr	r0, [r7, #0x4]
 8003884: f7ff fdf2    	bl	0x800346c <LL_EXTI_EnableRisingTrig_0_31> @ imm = #-0x41c
; 		LL_EXTI_DisableFallingTrig_0_31(line);
 8003888: 6878         	ldr	r0, [r7, #0x4]
 800388a: f7ff fe25    	bl	0x80034d8 <LL_EXTI_DisableFallingTrig_0_31> @ imm = #-0x3b6
; 		break;
 800388e: e00e         	b	0x80038ae <stm32_gpio_intc_select_line_trigger+0x6a> @ imm = #0x1c
; 		LL_EXTI_EnableFallingTrig_0_31(line);
 8003890: 6878         	ldr	r0, [r7, #0x4]
 8003892: f7ff fe0f    	bl	0x80034b4 <LL_EXTI_EnableFallingTrig_0_31> @ imm = #-0x3e2
; 		LL_EXTI_DisableRisingTrig_0_31(line);
 8003896: 6878         	ldr	r0, [r7, #0x4]
 8003898: f7ff fdfa    	bl	0x8003490 <LL_EXTI_DisableRisingTrig_0_31> @ imm = #-0x40c
; 		break;
 800389c: e007         	b	0x80038ae <stm32_gpio_intc_select_line_trigger+0x6a> @ imm = #0xe
; 		LL_EXTI_EnableRisingTrig_0_31(line);
 800389e: 6878         	ldr	r0, [r7, #0x4]
 80038a0: f7ff fde4    	bl	0x800346c <LL_EXTI_EnableRisingTrig_0_31> @ imm = #-0x438
; 		LL_EXTI_EnableFallingTrig_0_31(line);
 80038a4: 6878         	ldr	r0, [r7, #0x4]
 80038a6: f7ff fe05    	bl	0x80034b4 <LL_EXTI_EnableFallingTrig_0_31> @ imm = #-0x3f6
; 		break;
 80038aa: e000         	b	0x80038ae <stm32_gpio_intc_select_line_trigger+0x6a> @ imm = #0x0
; 		break;
 80038ac: bf00         	nop
; 	z_stm32_hsem_unlock(CFG_HW_EXTI_SEMID);
 80038ae: 2000         	movs	r0, #0x0
 80038b0: f00b fbbc    	bl	0x800f02c <z_stm32_hsem_unlock> @ imm = #0xb778
; }
 80038b4: bf00         	nop
 80038b6: 3708         	adds	r7, #0x8
 80038b8: 46bd         	mov	sp, r7
 80038ba: bd80         	pop	{r7, pc}

080038bc <stm32_gpio_intc_set_irq_callback>:
; {
 80038bc: b580         	push	{r7, lr}
 80038be: b088         	sub	sp, #0x20
 80038c0: af00         	add	r7, sp, #0x0
 80038c2: 60f8         	str	r0, [r7, #0xc]
 80038c4: 60b9         	str	r1, [r7, #0x8]
 80038c6: 607a         	str	r2, [r7, #0x4]
; 	const struct device *const dev = DEVICE_DT_GET(EXTI_NODE);
 80038c8: 4b19         	ldr	r3, [pc, #0x64]         @ 0x8003930 <stm32_gpio_intc_set_irq_callback+0x74>
 80038ca: 61fb         	str	r3, [r7, #0x1c]
; 	struct stm32_exti_data *data = dev->data;
 80038cc: 69fb         	ldr	r3, [r7, #0x1c]
 80038ce: 691b         	ldr	r3, [r3, #0x10]
 80038d0: 61bb         	str	r3, [r7, #0x18]
; 	uint32_t line_num = ll_exti_line_to_linenum(line);
 80038d2: 68f8         	ldr	r0, [r7, #0xc]
 80038d4: f00b fbee    	bl	0x800f0b4 <ll_exti_line_to_linenum> @ imm = #0xb7dc
 80038d8: 4603         	mov	r3, r0
 80038da: 617b         	str	r3, [r7, #0x14]
; 	if ((data->cb[line_num].cb == cb) && (data->cb[line_num].data == user)) {
 80038dc: 69bb         	ldr	r3, [r7, #0x18]
 80038de: 697a         	ldr	r2, [r7, #0x14]
 80038e0: f853 3032    	ldr.w	r3, [r3, r2, lsl #3]
 80038e4: 68ba         	ldr	r2, [r7, #0x8]
 80038e6: 429a         	cmp	r2, r3
 80038e8: d109         	bne	0x80038fe <stm32_gpio_intc_set_irq_callback+0x42> @ imm = #0x12
 80038ea: 69ba         	ldr	r2, [r7, #0x18]
 80038ec: 697b         	ldr	r3, [r7, #0x14]
 80038ee: 00db         	lsls	r3, r3, #0x3
 80038f0: 4413         	add	r3, r2
 80038f2: 685b         	ldr	r3, [r3, #0x4]
 80038f4: 687a         	ldr	r2, [r7, #0x4]
 80038f6: 429a         	cmp	r2, r3
 80038f8: d101         	bne	0x80038fe <stm32_gpio_intc_set_irq_callback+0x42> @ imm = #0x2
; 		return 0;
 80038fa: 2300         	movs	r3, #0x0
 80038fc: e014         	b	0x8003928 <stm32_gpio_intc_set_irq_callback+0x6c> @ imm = #0x28
; 	if (data->cb[line_num].cb != NULL) {
 80038fe: 69bb         	ldr	r3, [r7, #0x18]
 8003900: 697a         	ldr	r2, [r7, #0x14]
 8003902: f853 3032    	ldr.w	r3, [r3, r2, lsl #3]
 8003906: 2b00         	cmp	r3, #0x0
 8003908: d002         	beq	0x8003910 <stm32_gpio_intc_set_irq_callback+0x54> @ imm = #0x4
; 		return -EBUSY;
 800390a: f06f 030f    	mvn	r3, #0xf
 800390e: e00b         	b	0x8003928 <stm32_gpio_intc_set_irq_callback+0x6c> @ imm = #0x16
; 	data->cb[line_num].cb = cb;
 8003910: 69bb         	ldr	r3, [r7, #0x18]
 8003912: 697a         	ldr	r2, [r7, #0x14]
 8003914: 68b9         	ldr	r1, [r7, #0x8]
 8003916: f843 1032    	str.w	r1, [r3, r2, lsl #3]
; 	data->cb[line_num].data = user;
 800391a: 69ba         	ldr	r2, [r7, #0x18]
 800391c: 697b         	ldr	r3, [r7, #0x14]
 800391e: 00db         	lsls	r3, r3, #0x3
 8003920: 4413         	add	r3, r2
 8003922: 687a         	ldr	r2, [r7, #0x4]
 8003924: 605a         	str	r2, [r3, #0x4]
; 	return 0;
 8003926: 2300         	movs	r3, #0x0
; }
 8003928: 4618         	mov	r0, r3
 800392a: 3720         	adds	r7, #0x20
 800392c: 46bd         	mov	sp, r7
 800392e: bd80         	pop	{r7, pc}

08003930 <$d>:
 8003930: cc 45 01 08  	.word	0x080145cc

08003934 <stm32_gpio_intc_remove_irq_callback>:
; {
 8003934: b580         	push	{r7, lr}
 8003936: b086         	sub	sp, #0x18
 8003938: af00         	add	r7, sp, #0x0
 800393a: 6078         	str	r0, [r7, #0x4]
; 	const struct device *const dev = DEVICE_DT_GET(EXTI_NODE);
 800393c: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8003970 <stm32_gpio_intc_remove_irq_callback+0x3c>
 800393e: 617b         	str	r3, [r7, #0x14]
; 	struct stm32_exti_data *data = dev->data;
 8003940: 697b         	ldr	r3, [r7, #0x14]
 8003942: 691b         	ldr	r3, [r3, #0x10]
 8003944: 613b         	str	r3, [r7, #0x10]
; 	uint32_t line_num = ll_exti_line_to_linenum(line);
 8003946: 6878         	ldr	r0, [r7, #0x4]
 8003948: f00b fbb4    	bl	0x800f0b4 <ll_exti_line_to_linenum> @ imm = #0xb768
 800394c: 4603         	mov	r3, r0
 800394e: 60fb         	str	r3, [r7, #0xc]
; 	data->cb[line_num].cb = NULL;
 8003950: 693b         	ldr	r3, [r7, #0x10]
 8003952: 68fa         	ldr	r2, [r7, #0xc]
 8003954: 2100         	movs	r1, #0x0
 8003956: f843 1032    	str.w	r1, [r3, r2, lsl #3]
; 	data->cb[line_num].data = NULL;
 800395a: 693a         	ldr	r2, [r7, #0x10]
 800395c: 68fb         	ldr	r3, [r7, #0xc]
 800395e: 00db         	lsls	r3, r3, #0x3
 8003960: 4413         	add	r3, r2
 8003962: 2200         	movs	r2, #0x0
 8003964: 605a         	str	r2, [r3, #0x4]
; }
 8003966: bf00         	nop
 8003968: 3718         	adds	r7, #0x18
 800396a: 46bd         	mov	sp, r7
 800396c: bd80         	pop	{r7, pc}
 800396e: bf00         	nop

08003970 <$d>:
 8003970: cc 45 01 08  	.word	0x080145cc

08003974 <z_impl_can_send>:
; {
 8003974: b590         	push	{r4, r7, lr}
 8003976: b097         	sub	sp, #0x5c
 8003978: af08         	add	r7, sp, #0x20
 800397a: 60f8         	str	r0, [r7, #0xc]
 800397c: 60b9         	str	r1, [r7, #0x8]
 800397e: e9c7 2300    	strd	r2, r3, [r7]
; 	const struct can_driver_api *api = (const struct can_driver_api *)dev->api;
 8003982: 68fb         	ldr	r3, [r7, #0xc]
 8003984: 689b         	ldr	r3, [r3, #0x8]
 8003986: 62fb         	str	r3, [r7, #0x2c]
; 	CHECKIF(frame == NULL) {
 8003988: 68bb         	ldr	r3, [r7, #0x8]
 800398a: 2b00         	cmp	r3, #0x0
 800398c: d102         	bne	0x8003994 <z_impl_can_send+0x20> @ imm = #0x4
; 		return -EINVAL;
 800398e: f06f 0315    	mvn	r3, #0x15
 8003992: e089         	b	0x8003aa8 <z_impl_can_send+0x134> @ imm = #0x112
; 	if ((frame->flags & CAN_FRAME_IDE) != 0U) {
 8003994: 68bb         	ldr	r3, [r7, #0x8]
 8003996: 795b         	ldrb	r3, [r3, #0x5]
 8003998: f003 0301    	and	r3, r3, #0x1
 800399c: 2b00         	cmp	r3, #0x0
 800399e: d003         	beq	0x80039a8 <z_impl_can_send+0x34> @ imm = #0x6
; 		id_mask = CAN_EXT_ID_MASK;
 80039a0: f06f 4360    	mvn	r3, #0xe0000000
 80039a4: 633b         	str	r3, [r7, #0x30]
 80039a6: e002         	b	0x80039ae <z_impl_can_send+0x3a> @ imm = #0x4
; 		id_mask = CAN_STD_ID_MASK;
 80039a8: f240 73ff    	movw	r3, #0x7ff
 80039ac: 633b         	str	r3, [r7, #0x30]
; 	CHECKIF((frame->id & ~(id_mask)) != 0U) {
 80039ae: 68bb         	ldr	r3, [r7, #0x8]
 80039b0: 681a         	ldr	r2, [r3]
 80039b2: 6b3b         	ldr	r3, [r7, #0x30]
 80039b4: 43db         	mvns	r3, r3
 80039b6: 4013         	ands	r3, r2
 80039b8: 2b00         	cmp	r3, #0x0
 80039ba: d040         	beq	0x8003a3e <z_impl_can_send+0xca> @ imm = #0x80
; 		LOG_ERR("invalid frame with %s (%d-bit) CAN ID 0x%0*x",
 80039bc: 2303         	movs	r3, #0x3
 80039be: 2b00         	cmp	r3, #0x0
 80039c0: d03a         	beq	0x8003a38 <z_impl_can_send+0xc4> @ imm = #0x74
 80039c2: 2301         	movs	r3, #0x1
 80039c4: f887 302b    	strb.w	r3, [r7, #0x2b]
 80039c8: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 80039cc: f083 0301    	eor	r3, r3, #0x1
 80039d0: b2db         	uxtb	r3, r3
 80039d2: 2b00         	cmp	r3, #0x0
 80039d4: d130         	bne	0x8003a38 <z_impl_can_send+0xc4> @ imm = #0x60
 80039d6: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x8003ab0 <z_impl_can_send+0x13c>
 80039d8: 681c         	ldr	r4, [r3]
 80039da: 68bb         	ldr	r3, [r7, #0x8]
 80039dc: 795b         	ldrb	r3, [r3, #0x5]
 80039de: f003 0301    	and	r3, r3, #0x1
 80039e2: 2b00         	cmp	r3, #0x0
 80039e4: d001         	beq	0x80039ea <z_impl_can_send+0x76> @ imm = #0x2
 80039e6: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x8003ab4 <z_impl_can_send+0x140>
 80039e8: e000         	b	0x80039ec <z_impl_can_send+0x78> @ imm = #0x0
 80039ea: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x8003ab8 <z_impl_can_send+0x144>
 80039ec: 68ba         	ldr	r2, [r7, #0x8]
 80039ee: 7952         	ldrb	r2, [r2, #0x5]
 80039f0: f002 0201    	and	r2, r2, #0x1
 80039f4: 2a00         	cmp	r2, #0x0
 80039f6: d001         	beq	0x80039fc <z_impl_can_send+0x88> @ imm = #0x2
 80039f8: 221d         	movs	r2, #0x1d
 80039fa: e000         	b	0x80039fe <z_impl_can_send+0x8a> @ imm = #0x0
 80039fc: 220b         	movs	r2, #0xb
 80039fe: 68b9         	ldr	r1, [r7, #0x8]
 8003a00: 7949         	ldrb	r1, [r1, #0x5]
 8003a02: f001 0101    	and	r1, r1, #0x1
 8003a06: 2900         	cmp	r1, #0x0
 8003a08: d001         	beq	0x8003a0e <z_impl_can_send+0x9a> @ imm = #0x2
 8003a0a: 2108         	movs	r1, #0x8
 8003a0c: e000         	b	0x8003a10 <z_impl_can_send+0x9c> @ imm = #0x0
 8003a0e: 2103         	movs	r1, #0x3
 8003a10: 68b8         	ldr	r0, [r7, #0x8]
 8003a12: 6800         	ldr	r0, [r0]
 8003a14: 9006         	str	r0, [sp, #0x18]
 8003a16: 9105         	str	r1, [sp, #0x14]
 8003a18: 9204         	str	r2, [sp, #0x10]
 8003a1a: 9303         	str	r3, [sp, #0xc]
 8003a1c: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x8003abc <z_impl_can_send+0x148>
 8003a1e: 9302         	str	r3, [sp, #0x8]
 8003a20: 2300         	movs	r3, #0x0
 8003a22: 9301         	str	r3, [sp, #0x4]
 8003a24: 2300         	movs	r3, #0x0
 8003a26: 9300         	str	r3, [sp]
 8003a28: 2300         	movs	r3, #0x0
 8003a2a: 2201         	movs	r2, #0x1
 8003a2c: 4621         	mov	r1, r4
 8003a2e: 2000         	movs	r0, #0x0
 8003a30: f00b fc2e    	bl	0x800f290 <z_log_msg_runtime_create> @ imm = #0xb85c
 8003a34: 2300         	movs	r3, #0x0
 8003a36: 627b         	str	r3, [r7, #0x24]
; 		return -EINVAL;
 8003a38: f06f 0315    	mvn	r3, #0x15
 8003a3c: e034         	b	0x8003aa8 <z_impl_can_send+0x134> @ imm = #0x68
; 	if (callback == NULL) {
 8003a3e: 6cbb         	ldr	r3, [r7, #0x48]
 8003a40: 2b00         	cmp	r3, #0x0
 8003a42: d125         	bne	0x8003a90 <z_impl_can_send+0x11c> @ imm = #0x4a
; 		k_sem_init(&ctx.done, 0, 1);
 8003a44: f107 0310    	add.w	r3, r7, #0x10
 8003a48: 2201         	movs	r2, #0x1
 8003a4a: 2100         	movs	r1, #0x0
 8003a4c: 4618         	mov	r0, r3
 8003a4e: f00b fb8e    	bl	0x800f16e <k_sem_init>  @ imm = #0xb71c
; 		err = api->send(dev, frame, timeout, can_tx_default_cb, &ctx);
 8003a52: 6afb         	ldr	r3, [r7, #0x2c]
 8003a54: 695c         	ldr	r4, [r3, #0x14]
 8003a56: f107 0310    	add.w	r3, r7, #0x10
 8003a5a: 9301         	str	r3, [sp, #0x4]
 8003a5c: 4b18         	ldr	r3, [pc, #0x60]         @ 0x8003ac0 <z_impl_can_send+0x14c>
 8003a5e: 9300         	str	r3, [sp]
 8003a60: e9d7 2300    	ldrd	r2, r3, [r7]
 8003a64: 68b9         	ldr	r1, [r7, #0x8]
 8003a66: 68f8         	ldr	r0, [r7, #0xc]
 8003a68: 47a0         	blx	r4
 8003a6a: 6378         	str	r0, [r7, #0x34]
; 		if (err != 0) {
 8003a6c: 6b7b         	ldr	r3, [r7, #0x34]
 8003a6e: 2b00         	cmp	r3, #0x0
 8003a70: d001         	beq	0x8003a76 <z_impl_can_send+0x102> @ imm = #0x2
; 			return err;
 8003a72: 6b7b         	ldr	r3, [r7, #0x34]
 8003a74: e018         	b	0x8003aa8 <z_impl_can_send+0x134> @ imm = #0x30
; 		k_sem_take(&ctx.done, K_FOREVER);
 8003a76: f04f 30ff    	mov.w	r0, #0xffffffff
 8003a7a: f04f 31ff    	mov.w	r1, #0xffffffff
 8003a7e: f107 0410    	add.w	r4, r7, #0x10
 8003a82: 4602         	mov	r2, r0
 8003a84: 460b         	mov	r3, r1
 8003a86: 4620         	mov	r0, r4
 8003a88: f00b fb81    	bl	0x800f18e <k_sem_take>  @ imm = #0xb702
; 		return ctx.status;
 8003a8c: 6a3b         	ldr	r3, [r7, #0x20]
 8003a8e: e00b         	b	0x8003aa8 <z_impl_can_send+0x134> @ imm = #0x16
; 	return api->send(dev, frame, timeout, callback, user_data);
 8003a90: 6afb         	ldr	r3, [r7, #0x2c]
 8003a92: 695c         	ldr	r4, [r3, #0x14]
 8003a94: 6cfb         	ldr	r3, [r7, #0x4c]
 8003a96: 9301         	str	r3, [sp, #0x4]
 8003a98: 6cbb         	ldr	r3, [r7, #0x48]
 8003a9a: 9300         	str	r3, [sp]
 8003a9c: e9d7 2300    	ldrd	r2, r3, [r7]
 8003aa0: 68b9         	ldr	r1, [r7, #0x8]
 8003aa2: 68f8         	ldr	r0, [r7, #0xc]
 8003aa4: 47a0         	blx	r4
 8003aa6: 4603         	mov	r3, r0
; }
 8003aa8: 4618         	mov	r0, r3
 8003aaa: 373c         	adds	r7, #0x3c
 8003aac: 46bd         	mov	sp, r7
 8003aae: bd90         	pop	{r4, r7, pc}

08003ab0 <$d>:
 8003ab0: 44 00 00 20  	.word	0x20000044
 8003ab4: 18 52 01 08  	.word	0x08015218
 8003ab8: 24 52 01 08  	.word	0x08015224
 8003abc: 30 52 01 08  	.word	0x08015230
 8003ac0: cd f2 00 08  	.word	0x0800f2cd

08003ac4 <can_msgq_put>:
; {
 8003ac4: b580         	push	{r7, lr}
 8003ac6: b08e         	sub	sp, #0x38
 8003ac8: af06         	add	r7, sp, #0x18
 8003aca: 60f8         	str	r0, [r7, #0xc]
 8003acc: 60b9         	str	r1, [r7, #0x8]
 8003ace: 607a         	str	r2, [r7, #0x4]
; 	struct k_msgq *msgq = (struct k_msgq *)user_data;
 8003ad0: 687b         	ldr	r3, [r7, #0x4]
 8003ad2: 61fb         	str	r3, [r7, #0x1c]
; 	ret = k_msgq_put(msgq, frame, K_NO_WAIT);
 8003ad4: f04f 0200    	mov.w	r2, #0x0
 8003ad8: f04f 0300    	mov.w	r3, #0x0
 8003adc: 68b9         	ldr	r1, [r7, #0x8]
 8003ade: 69f8         	ldr	r0, [r7, #0x1c]
 8003ae0: f00b fb70    	bl	0x800f1c4 <k_msgq_put>  @ imm = #0xb6e0
 8003ae4: 61b8         	str	r0, [r7, #0x18]
; 	if (ret) {
 8003ae6: 69bb         	ldr	r3, [r7, #0x18]
 8003ae8: 2b00         	cmp	r3, #0x0
 8003aea: d01e         	beq	0x8003b2a <can_msgq_put+0x66> @ imm = #0x3c
; 		LOG_ERR("Msgq %p overflowed. Frame ID: 0x%x", msgq, frame->id);
 8003aec: 2303         	movs	r3, #0x3
 8003aee: 2b00         	cmp	r3, #0x0
 8003af0: d01b         	beq	0x8003b2a <can_msgq_put+0x66> @ imm = #0x36
 8003af2: 2301         	movs	r3, #0x1
 8003af4: 75fb         	strb	r3, [r7, #0x17]
 8003af6: 7dfb         	ldrb	r3, [r7, #0x17]
 8003af8: f083 0301    	eor	r3, r3, #0x1
 8003afc: b2db         	uxtb	r3, r3
 8003afe: 2b00         	cmp	r3, #0x0
 8003b00: d113         	bne	0x8003b2a <can_msgq_put+0x66> @ imm = #0x26
 8003b02: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8003b34 <can_msgq_put+0x70>
 8003b04: 6819         	ldr	r1, [r3]
 8003b06: 68bb         	ldr	r3, [r7, #0x8]
 8003b08: 681b         	ldr	r3, [r3]
 8003b0a: 9304         	str	r3, [sp, #0x10]
 8003b0c: 69fb         	ldr	r3, [r7, #0x1c]
 8003b0e: 9303         	str	r3, [sp, #0xc]
 8003b10: 4b09         	ldr	r3, [pc, #0x24]         @ 0x8003b38 <can_msgq_put+0x74>
 8003b12: 9302         	str	r3, [sp, #0x8]
 8003b14: 2300         	movs	r3, #0x0
 8003b16: 9301         	str	r3, [sp, #0x4]
 8003b18: 2300         	movs	r3, #0x0
 8003b1a: 9300         	str	r3, [sp]
 8003b1c: 2300         	movs	r3, #0x0
 8003b1e: 2201         	movs	r2, #0x1
 8003b20: 2000         	movs	r0, #0x0
 8003b22: f00b fbb5    	bl	0x800f290 <z_log_msg_runtime_create> @ imm = #0xb76a
 8003b26: 2300         	movs	r3, #0x0
 8003b28: 613b         	str	r3, [r7, #0x10]
; }
 8003b2a: bf00         	nop
 8003b2c: 3720         	adds	r7, #0x20
 8003b2e: 46bd         	mov	sp, r7
 8003b30: bd80         	pop	{r7, pc}
 8003b32: bf00         	nop

08003b34 <$d>:
 8003b34: 44 00 00 20  	.word	0x20000044
 8003b38: a4 52 01 08  	.word	0x080152a4

08003b3c <z_impl_can_add_rx_filter_msgq>:
; {
 8003b3c: b590         	push	{r4, r7, lr}
 8003b3e: b087         	sub	sp, #0x1c
 8003b40: af00         	add	r7, sp, #0x0
 8003b42: 60f8         	str	r0, [r7, #0xc]
 8003b44: 60b9         	str	r1, [r7, #0x8]
 8003b46: 607a         	str	r2, [r7, #0x4]
; 	const struct can_driver_api *api = dev->api;
 8003b48: 68fb         	ldr	r3, [r7, #0xc]
 8003b4a: 689b         	ldr	r3, [r3, #0x8]
 8003b4c: 617b         	str	r3, [r7, #0x14]
; 	return api->add_rx_filter(dev, can_msgq_put, msgq, filter);
 8003b4e: 697b         	ldr	r3, [r7, #0x14]
 8003b50: 699c         	ldr	r4, [r3, #0x18]
 8003b52: 687b         	ldr	r3, [r7, #0x4]
 8003b54: 68ba         	ldr	r2, [r7, #0x8]
 8003b56: 4904         	ldr	r1, [pc, #0x10]         @ 0x8003b68 <z_impl_can_add_rx_filter_msgq+0x2c>
 8003b58: 68f8         	ldr	r0, [r7, #0xc]
 8003b5a: 47a0         	blx	r4
 8003b5c: 4603         	mov	r3, r0
; }
 8003b5e: 4618         	mov	r0, r3
 8003b60: 371c         	adds	r7, #0x1c
 8003b62: 46bd         	mov	sp, r7
 8003b64: bd90         	pop	{r4, r7, pc}
 8003b66: bf00         	nop

08003b68 <$d>:
 8003b68: c5 3a 00 08  	.word	0x08003ac5

08003b6c <update_sample_pnt>:
; {
 8003b6c: b480         	push	{r7}
 8003b6e: b089         	sub	sp, #0x24
 8003b70: af00         	add	r7, sp, #0x0
 8003b72: 60f8         	str	r0, [r7, #0xc]
 8003b74: 60b9         	str	r1, [r7, #0x8]
 8003b76: 607a         	str	r2, [r7, #0x4]
 8003b78: 603b         	str	r3, [r7]
; 	uint16_t tseg1_max = max->phase_seg1 + max->prop_seg;
 8003b7a: 6abb         	ldr	r3, [r7, #0x28]
 8003b7c: 889a         	ldrh	r2, [r3, #0x4]
 8003b7e: 6abb         	ldr	r3, [r7, #0x28]
 8003b80: 885b         	ldrh	r3, [r3, #0x2]
 8003b82: 4413         	add	r3, r2
 8003b84: 837b         	strh	r3, [r7, #0x1a]
; 	uint16_t tseg1_min = min->phase_seg1 + min->prop_seg;
 8003b86: 683b         	ldr	r3, [r7]
 8003b88: 889a         	ldrh	r2, [r3, #0x4]
 8003b8a: 683b         	ldr	r3, [r7]
 8003b8c: 885b         	ldrh	r3, [r3, #0x2]
 8003b8e: 4413         	add	r3, r2
 8003b90: 833b         	strh	r3, [r7, #0x18]
; 	tseg2 = total_tq - (total_tq * sample_pnt) / 1000;
 8003b92: 68fb         	ldr	r3, [r7, #0xc]
 8003b94: b29a         	uxth	r2, r3
 8003b96: 68fb         	ldr	r3, [r7, #0xc]
 8003b98: 68b9         	ldr	r1, [r7, #0x8]
 8003b9a: fb01 f303    	mul	r3, r1, r3
 8003b9e: 4952         	ldr	r1, [pc, #0x148]        @ 0x8003ce8 <update_sample_pnt+0x17c>
 8003ba0: fba1 1303    	umull	r1, r3, r1, r3
 8003ba4: 099b         	lsrs	r3, r3, #0x6
 8003ba6: b29b         	uxth	r3, r3
 8003ba8: 1ad3         	subs	r3, r2, r3
 8003baa: 83bb         	strh	r3, [r7, #0x1c]
; 	tseg2 = CLAMP(tseg2, min->phase_seg2, max->phase_seg2);
 8003bac: 683b         	ldr	r3, [r7]
 8003bae: 88db         	ldrh	r3, [r3, #0x6]
 8003bb0: 8bba         	ldrh	r2, [r7, #0x1c]
 8003bb2: 429a         	cmp	r2, r3
 8003bb4: d802         	bhi	0x8003bbc <update_sample_pnt+0x50> @ imm = #0x4
 8003bb6: 683b         	ldr	r3, [r7]
 8003bb8: 88db         	ldrh	r3, [r3, #0x6]
 8003bba: e006         	b	0x8003bca <update_sample_pnt+0x5e> @ imm = #0xc
 8003bbc: 6abb         	ldr	r3, [r7, #0x28]
 8003bbe: 88db         	ldrh	r3, [r3, #0x6]
 8003bc0: 8bba         	ldrh	r2, [r7, #0x1c]
 8003bc2: 4293         	cmp	r3, r2
 8003bc4: bf28         	it	hs
 8003bc6: 4613         	movhs	r3, r2
 8003bc8: b29b         	uxth	r3, r3
 8003bca: 83bb         	strh	r3, [r7, #0x1c]
; 	tseg1 = total_tq - CAN_SYNC_SEG - tseg2;
 8003bcc: 68fb         	ldr	r3, [r7, #0xc]
 8003bce: b29a         	uxth	r2, r3
 8003bd0: 8bbb         	ldrh	r3, [r7, #0x1c]
 8003bd2: 1ad3         	subs	r3, r2, r3
 8003bd4: b29b         	uxth	r3, r3
 8003bd6: 3b01         	subs	r3, #0x1
 8003bd8: 83fb         	strh	r3, [r7, #0x1e]
; 	if (tseg1 > tseg1_max) {
 8003bda: 8bfa         	ldrh	r2, [r7, #0x1e]
 8003bdc: 8b7b         	ldrh	r3, [r7, #0x1a]
 8003bde: 429a         	cmp	r2, r3
 8003be0: d910         	bls	0x8003c04 <update_sample_pnt+0x98> @ imm = #0x20
; 		tseg1 = tseg1_max;
 8003be2: 8b7b         	ldrh	r3, [r7, #0x1a]
 8003be4: 83fb         	strh	r3, [r7, #0x1e]
; 		tseg2 = total_tq - CAN_SYNC_SEG - tseg1;
 8003be6: 68fb         	ldr	r3, [r7, #0xc]
 8003be8: b29a         	uxth	r2, r3
 8003bea: 8bfb         	ldrh	r3, [r7, #0x1e]
 8003bec: 1ad3         	subs	r3, r2, r3
 8003bee: b29b         	uxth	r3, r3
 8003bf0: 3b01         	subs	r3, #0x1
 8003bf2: 83bb         	strh	r3, [r7, #0x1c]
; 		if (tseg2 > max->phase_seg2) {
 8003bf4: 6abb         	ldr	r3, [r7, #0x28]
 8003bf6: 88db         	ldrh	r3, [r3, #0x6]
 8003bf8: 8bba         	ldrh	r2, [r7, #0x1c]
 8003bfa: 429a         	cmp	r2, r3
 8003bfc: d917         	bls	0x8003c2e <update_sample_pnt+0xc2> @ imm = #0x2e
; 			return -ENOTSUP;
 8003bfe: f06f 0385    	mvn	r3, #0x85
 8003c02: e06c         	b	0x8003cde <update_sample_pnt+0x172> @ imm = #0xd8
; 	} else if (tseg1 < tseg1_min) {
 8003c04: 8bfa         	ldrh	r2, [r7, #0x1e]
 8003c06: 8b3b         	ldrh	r3, [r7, #0x18]
 8003c08: 429a         	cmp	r2, r3
 8003c0a: d210         	bhs	0x8003c2e <update_sample_pnt+0xc2> @ imm = #0x20
; 		tseg1 = tseg1_min;
 8003c0c: 8b3b         	ldrh	r3, [r7, #0x18]
 8003c0e: 83fb         	strh	r3, [r7, #0x1e]
; 		tseg2 = total_tq - CAN_SYNC_SEG - tseg1;
 8003c10: 68fb         	ldr	r3, [r7, #0xc]
 8003c12: b29a         	uxth	r2, r3
 8003c14: 8bfb         	ldrh	r3, [r7, #0x1e]
 8003c16: 1ad3         	subs	r3, r2, r3
 8003c18: b29b         	uxth	r3, r3
 8003c1a: 3b01         	subs	r3, #0x1
 8003c1c: 83bb         	strh	r3, [r7, #0x1c]
; 		if (tseg2 < min->phase_seg2) {
 8003c1e: 683b         	ldr	r3, [r7]
 8003c20: 88db         	ldrh	r3, [r3, #0x6]
 8003c22: 8bba         	ldrh	r2, [r7, #0x1c]
 8003c24: 429a         	cmp	r2, r3
 8003c26: d202         	bhs	0x8003c2e <update_sample_pnt+0xc2> @ imm = #0x4
; 			return -ENOTSUP;
 8003c28: f06f 0385    	mvn	r3, #0x85
 8003c2c: e057         	b	0x8003cde <update_sample_pnt+0x172> @ imm = #0xae
; 	res->phase_seg2 = tseg2;
 8003c2e: 687b         	ldr	r3, [r7, #0x4]
 8003c30: 8bba         	ldrh	r2, [r7, #0x1c]
 8003c32: 80da         	strh	r2, [r3, #0x6]
; 	res->prop_seg = CLAMP(tseg1 / 2, min->prop_seg, max->prop_seg);
 8003c34: 8bfb         	ldrh	r3, [r7, #0x1e]
 8003c36: 085b         	lsrs	r3, r3, #0x1
 8003c38: b29a         	uxth	r2, r3
 8003c3a: 683b         	ldr	r3, [r7]
 8003c3c: 885b         	ldrh	r3, [r3, #0x2]
 8003c3e: 429a         	cmp	r2, r3
 8003c40: d802         	bhi	0x8003c48 <update_sample_pnt+0xdc> @ imm = #0x4
 8003c42: 683b         	ldr	r3, [r7]
 8003c44: 885b         	ldrh	r3, [r3, #0x2]
 8003c46: e008         	b	0x8003c5a <update_sample_pnt+0xee> @ imm = #0x10
 8003c48: 6abb         	ldr	r3, [r7, #0x28]
 8003c4a: 885a         	ldrh	r2, [r3, #0x2]
 8003c4c: 8bfb         	ldrh	r3, [r7, #0x1e]
 8003c4e: 085b         	lsrs	r3, r3, #0x1
 8003c50: b29b         	uxth	r3, r3
 8003c52: 4293         	cmp	r3, r2
 8003c54: bf28         	it	hs
 8003c56: 4613         	movhs	r3, r2
 8003c58: b29b         	uxth	r3, r3
 8003c5a: 687a         	ldr	r2, [r7, #0x4]
 8003c5c: 8053         	strh	r3, [r2, #0x2]
; 	res->phase_seg1 = tseg1 - res->prop_seg;
 8003c5e: 687b         	ldr	r3, [r7, #0x4]
 8003c60: 885b         	ldrh	r3, [r3, #0x2]
 8003c62: 8bfa         	ldrh	r2, [r7, #0x1e]
 8003c64: 1ad3         	subs	r3, r2, r3
 8003c66: b29a         	uxth	r2, r3
 8003c68: 687b         	ldr	r3, [r7, #0x4]
 8003c6a: 809a         	strh	r2, [r3, #0x4]
; 	if (res->phase_seg1 > max->phase_seg1) {
 8003c6c: 687b         	ldr	r3, [r7, #0x4]
 8003c6e: 889a         	ldrh	r2, [r3, #0x4]
 8003c70: 6abb         	ldr	r3, [r7, #0x28]
 8003c72: 889b         	ldrh	r3, [r3, #0x4]
 8003c74: 429a         	cmp	r2, r3
 8003c76: d90b         	bls	0x8003c90 <update_sample_pnt+0x124> @ imm = #0x16
; 		res->phase_seg1 = max->phase_seg1;
 8003c78: 6abb         	ldr	r3, [r7, #0x28]
 8003c7a: 889a         	ldrh	r2, [r3, #0x4]
 8003c7c: 687b         	ldr	r3, [r7, #0x4]
 8003c7e: 809a         	strh	r2, [r3, #0x4]
; 		res->prop_seg = tseg1 - res->phase_seg1;
 8003c80: 687b         	ldr	r3, [r7, #0x4]
 8003c82: 889b         	ldrh	r3, [r3, #0x4]
 8003c84: 8bfa         	ldrh	r2, [r7, #0x1e]
 8003c86: 1ad3         	subs	r3, r2, r3
 8003c88: b29a         	uxth	r2, r3
 8003c8a: 687b         	ldr	r3, [r7, #0x4]
 8003c8c: 805a         	strh	r2, [r3, #0x2]
 8003c8e: e010         	b	0x8003cb2 <update_sample_pnt+0x146> @ imm = #0x20
; 	} else if (res->phase_seg1 < min->phase_seg1) {
 8003c90: 687b         	ldr	r3, [r7, #0x4]
 8003c92: 889a         	ldrh	r2, [r3, #0x4]
 8003c94: 683b         	ldr	r3, [r7]
 8003c96: 889b         	ldrh	r3, [r3, #0x4]
 8003c98: 429a         	cmp	r2, r3
 8003c9a: d20a         	bhs	0x8003cb2 <update_sample_pnt+0x146> @ imm = #0x14
; 		res->phase_seg1 = min->phase_seg1;
 8003c9c: 683b         	ldr	r3, [r7]
 8003c9e: 889a         	ldrh	r2, [r3, #0x4]
 8003ca0: 687b         	ldr	r3, [r7, #0x4]
 8003ca2: 809a         	strh	r2, [r3, #0x4]
; 		res->prop_seg = tseg1 - res->phase_seg1;
 8003ca4: 687b         	ldr	r3, [r7, #0x4]
 8003ca6: 889b         	ldrh	r3, [r3, #0x4]
 8003ca8: 8bfa         	ldrh	r2, [r7, #0x1e]
 8003caa: 1ad3         	subs	r3, r2, r3
 8003cac: b29a         	uxth	r2, r3
 8003cae: 687b         	ldr	r3, [r7, #0x4]
 8003cb0: 805a         	strh	r2, [r3, #0x2]
; 	sample_pnt_res = (CAN_SYNC_SEG + tseg1) * 1000 / total_tq;
 8003cb2: 8bfb         	ldrh	r3, [r7, #0x1e]
 8003cb4: 3301         	adds	r3, #0x1
 8003cb6: f44f 727a    	mov.w	r2, #0x3e8
 8003cba: fb02 f303    	mul	r3, r2, r3
 8003cbe: 461a         	mov	r2, r3
 8003cc0: 68fb         	ldr	r3, [r7, #0xc]
 8003cc2: fbb2 f3f3    	udiv	r3, r2, r3
 8003cc6: 617b         	str	r3, [r7, #0x14]
; 		sample_pnt_res - sample_pnt :
 8003cc8: 697a         	ldr	r2, [r7, #0x14]
 8003cca: 68bb         	ldr	r3, [r7, #0x8]
 8003ccc: 429a         	cmp	r2, r3
 8003cce: d903         	bls	0x8003cd8 <update_sample_pnt+0x16c> @ imm = #0x6
 8003cd0: 697a         	ldr	r2, [r7, #0x14]
 8003cd2: 68bb         	ldr	r3, [r7, #0x8]
 8003cd4: 1ad3         	subs	r3, r2, r3
 8003cd6: e002         	b	0x8003cde <update_sample_pnt+0x172> @ imm = #0x4
; 		sample_pnt - sample_pnt_res;
 8003cd8: 68ba         	ldr	r2, [r7, #0x8]
 8003cda: 697b         	ldr	r3, [r7, #0x14]
 8003cdc: 1ad3         	subs	r3, r2, r3
; }
 8003cde: 4618         	mov	r0, r3
 8003ce0: 3724         	adds	r7, #0x24
 8003ce2: 46bd         	mov	sp, r7
 8003ce4: bc80         	pop	{r7}
 8003ce6: 4770         	bx	lr

08003ce8 <$d>:
 8003ce8: d3 4d 62 10  	.word	0x10624dd3

08003cec <sample_point_for_bitrate>:
; {
 8003cec: b480         	push	{r7}
 8003cee: b085         	sub	sp, #0x14
 8003cf0: af00         	add	r7, sp, #0x0
 8003cf2: 6078         	str	r0, [r7, #0x4]
; 	if (bitrate > 800000) {
 8003cf4: 687b         	ldr	r3, [r7, #0x4]
 8003cf6: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x8003d28 <sample_point_for_bitrate+0x3c>
 8003cf8: 4293         	cmp	r3, r2
 8003cfa: d903         	bls	0x8003d04 <sample_point_for_bitrate+0x18> @ imm = #0x6
; 		sample_pnt = 750;
 8003cfc: f240 23ee    	movw	r3, #0x2ee
 8003d00: 81fb         	strh	r3, [r7, #0xe]
 8003d02: e00a         	b	0x8003d1a <sample_point_for_bitrate+0x2e> @ imm = #0x14
; 	} else if (bitrate > 500000) {
 8003d04: 687b         	ldr	r3, [r7, #0x4]
 8003d06: 4a09         	ldr	r2, [pc, #0x24]         @ 0x8003d2c <sample_point_for_bitrate+0x40>
 8003d08: 4293         	cmp	r3, r2
 8003d0a: d903         	bls	0x8003d14 <sample_point_for_bitrate+0x28> @ imm = #0x6
; 		sample_pnt = 800;
 8003d0c: f44f 7348    	mov.w	r3, #0x320
 8003d10: 81fb         	strh	r3, [r7, #0xe]
 8003d12: e002         	b	0x8003d1a <sample_point_for_bitrate+0x2e> @ imm = #0x4
; 		sample_pnt = 875;
 8003d14: f240 336b    	movw	r3, #0x36b
 8003d18: 81fb         	strh	r3, [r7, #0xe]
; 	return sample_pnt;
 8003d1a: 89fb         	ldrh	r3, [r7, #0xe]
; }
 8003d1c: 4618         	mov	r0, r3
 8003d1e: 3714         	adds	r7, #0x14
 8003d20: 46bd         	mov	sp, r7
 8003d22: bc80         	pop	{r7}
 8003d24: 4770         	bx	lr
 8003d26: bf00         	nop

08003d28 <$d>:
 8003d28: 00 35 0c 00  	.word	0x000c3500
 8003d2c: 20 a1 07 00  	.word	0x0007a120

08003d30 <can_calc_timing_internal>:
; {
 8003d30: b580         	push	{r7, lr}
 8003d32: b094         	sub	sp, #0x50
 8003d34: af06         	add	r7, sp, #0x18
 8003d36: 60f8         	str	r0, [r7, #0xc]
 8003d38: 60b9         	str	r1, [r7, #0x8]
 8003d3a: 607a         	str	r2, [r7, #0x4]
 8003d3c: 603b         	str	r3, [r7]
; 	uint32_t total_tq = CAN_SYNC_SEG + max->prop_seg + max->phase_seg1 + max->phase_seg2;
 8003d3e: 683b         	ldr	r3, [r7]
 8003d40: 885b         	ldrh	r3, [r3, #0x2]
 8003d42: 3301         	adds	r3, #0x1
 8003d44: 683a         	ldr	r2, [r7]
 8003d46: 8892         	ldrh	r2, [r2, #0x4]
 8003d48: 4413         	add	r3, r2
 8003d4a: 683a         	ldr	r2, [r7]
 8003d4c: 88d2         	ldrh	r2, [r2, #0x6]
 8003d4e: 4413         	add	r3, r2
 8003d50: 62fb         	str	r3, [r7, #0x2c]
; 	struct can_timing tmp_res = { 0 };
 8003d52: f107 0314    	add.w	r3, r7, #0x14
 8003d56: 2200         	movs	r2, #0x0
 8003d58: 601a         	str	r2, [r3]
 8003d5a: 605a         	str	r2, [r3, #0x4]
 8003d5c: 811a         	strh	r2, [r3, #0x8]
; 	int err_min = INT_MAX;
 8003d5e: f06f 4300    	mvn	r3, #0x80000000
 8003d62: 637b         	str	r3, [r7, #0x34]
; 	if (bitrate == 0 || sample_pnt >= 1000) {
 8003d64: 6c3b         	ldr	r3, [r7, #0x40]
 8003d66: 2b00         	cmp	r3, #0x0
 8003d68: d004         	beq	0x8003d74 <can_calc_timing_internal+0x44> @ imm = #0x8
 8003d6a: f8b7 3044    	ldrh.w	r3, [r7, #0x44]
 8003d6e: f5b3 7f7a    	cmp.w	r3, #0x3e8
 8003d72: d302         	blo	0x8003d7a <can_calc_timing_internal+0x4a> @ imm = #0x4
; 		return -EINVAL;
 8003d74: f06f 0315    	mvn	r3, #0x15
 8003d78: e0b7         	b	0x8003eea <can_calc_timing_internal+0x1ba> @ imm = #0x16e
; 	err = can_get_core_clock(dev, &core_clock);
 8003d7a: f107 0310    	add.w	r3, r7, #0x10
 8003d7e: 4619         	mov	r1, r3
 8003d80: 68f8         	ldr	r0, [r7, #0xc]
 8003d82: f00b fa5f    	bl	0x800f244 <can_get_core_clock> @ imm = #0xb4be
 8003d86: 62b8         	str	r0, [r7, #0x28]
; 	if (err != 0) {
 8003d88: 6abb         	ldr	r3, [r7, #0x28]
 8003d8a: 2b00         	cmp	r3, #0x0
 8003d8c: d002         	beq	0x8003d94 <can_calc_timing_internal+0x64> @ imm = #0x4
; 		return -EIO;
 8003d8e: f06f 0304    	mvn	r3, #0x4
 8003d92: e0aa         	b	0x8003eea <can_calc_timing_internal+0x1ba> @ imm = #0x154
; 	if (sample_pnt == 0U) {
 8003d94: f8b7 3044    	ldrh.w	r3, [r7, #0x44]
 8003d98: 2b00         	cmp	r3, #0x0
 8003d9a: d105         	bne	0x8003da8 <can_calc_timing_internal+0x78> @ imm = #0xa
; 		sample_pnt = sample_point_for_bitrate(bitrate);
 8003d9c: 6c38         	ldr	r0, [r7, #0x40]
 8003d9e: f7ff ffa5    	bl	0x8003cec <sample_point_for_bitrate> @ imm = #-0xb6
 8003da2: 4603         	mov	r3, r0
 8003da4: f8a7 3044    	strh.w	r3, [r7, #0x44]
; 	for (prescaler = MAX(core_clock / (total_tq * bitrate), min->prescaler);
 8003da8: 687b         	ldr	r3, [r7, #0x4]
 8003daa: 891b         	ldrh	r3, [r3, #0x8]
 8003dac: 4618         	mov	r0, r3
 8003dae: 693a         	ldr	r2, [r7, #0x10]
 8003db0: 6afb         	ldr	r3, [r7, #0x2c]
 8003db2: 6c39         	ldr	r1, [r7, #0x40]
 8003db4: fb01 f303    	mul	r3, r1, r3
 8003db8: fbb2 f3f3    	udiv	r3, r2, r3
 8003dbc: 4283         	cmp	r3, r0
 8003dbe: bf38         	it	lo
 8003dc0: 4603         	movlo	r3, r0
 8003dc2: 633b         	str	r3, [r7, #0x30]
 8003dc4: e03e         	b	0x8003e44 <can_calc_timing_internal+0x114> @ imm = #0x7c
; 		if (core_clock % (prescaler * bitrate)) {
 8003dc6: 693b         	ldr	r3, [r7, #0x10]
 8003dc8: 6b3a         	ldr	r2, [r7, #0x30]
 8003dca: 6c39         	ldr	r1, [r7, #0x40]
 8003dcc: fb01 f202    	mul	r2, r1, r2
 8003dd0: fbb3 f1f2    	udiv	r1, r3, r2
 8003dd4: fb01 f202    	mul	r2, r1, r2
 8003dd8: 1a9b         	subs	r3, r3, r2
 8003dda: 2b00         	cmp	r3, #0x0
 8003ddc: d12c         	bne	0x8003e38 <can_calc_timing_internal+0x108> @ imm = #0x58
; 		total_tq = core_clock / (prescaler * bitrate);
 8003dde: 693a         	ldr	r2, [r7, #0x10]
 8003de0: 6b3b         	ldr	r3, [r7, #0x30]
 8003de2: 6c39         	ldr	r1, [r7, #0x40]
 8003de4: fb01 f303    	mul	r3, r1, r3
 8003de8: fbb2 f3f3    	udiv	r3, r2, r3
 8003dec: 62fb         	str	r3, [r7, #0x2c]
; 		err = update_sample_pnt(total_tq, sample_pnt, &tmp_res, min, max);
 8003dee: f8b7 1044    	ldrh.w	r1, [r7, #0x44]
 8003df2: f107 0214    	add.w	r2, r7, #0x14
 8003df6: 683b         	ldr	r3, [r7]
 8003df8: 9300         	str	r3, [sp]
 8003dfa: 687b         	ldr	r3, [r7, #0x4]
 8003dfc: 6af8         	ldr	r0, [r7, #0x2c]
 8003dfe: f7ff feb5    	bl	0x8003b6c <update_sample_pnt> @ imm = #-0x296
 8003e02: 62b8         	str	r0, [r7, #0x28]
; 		if (err < 0) {
 8003e04: 6abb         	ldr	r3, [r7, #0x28]
 8003e06: 2b00         	cmp	r3, #0x0
 8003e08: db18         	blt	0x8003e3c <can_calc_timing_internal+0x10c> @ imm = #0x30
; 		if (err < err_min) {
 8003e0a: 6aba         	ldr	r2, [r7, #0x28]
 8003e0c: 6b7b         	ldr	r3, [r7, #0x34]
 8003e0e: 429a         	cmp	r2, r3
 8003e10: da15         	bge	0x8003e3e <can_calc_timing_internal+0x10e> @ imm = #0x2a
; 			err_min = err;
 8003e12: 6abb         	ldr	r3, [r7, #0x28]
 8003e14: 637b         	str	r3, [r7, #0x34]
; 			res->prop_seg = tmp_res.prop_seg;
 8003e16: 8afa         	ldrh	r2, [r7, #0x16]
 8003e18: 68bb         	ldr	r3, [r7, #0x8]
 8003e1a: 805a         	strh	r2, [r3, #0x2]
; 			res->phase_seg1 = tmp_res.phase_seg1;
 8003e1c: 8b3a         	ldrh	r2, [r7, #0x18]
 8003e1e: 68bb         	ldr	r3, [r7, #0x8]
 8003e20: 809a         	strh	r2, [r3, #0x4]
; 			res->phase_seg2 = tmp_res.phase_seg2;
 8003e22: 8b7a         	ldrh	r2, [r7, #0x1a]
 8003e24: 68bb         	ldr	r3, [r7, #0x8]
 8003e26: 80da         	strh	r2, [r3, #0x6]
; 			res->prescaler = (uint16_t)prescaler;
 8003e28: 6b3b         	ldr	r3, [r7, #0x30]
 8003e2a: b29a         	uxth	r2, r3
 8003e2c: 68bb         	ldr	r3, [r7, #0x8]
 8003e2e: 811a         	strh	r2, [r3, #0x8]
; 			if (err == 0) {
 8003e30: 6abb         	ldr	r3, [r7, #0x28]
 8003e32: 2b00         	cmp	r3, #0x0
 8003e34: d00d         	beq	0x8003e52 <can_calc_timing_internal+0x122> @ imm = #0x1a
 8003e36: e002         	b	0x8003e3e <can_calc_timing_internal+0x10e> @ imm = #0x4
; 			continue;
 8003e38: bf00         	nop
 8003e3a: e000         	b	0x8003e3e <can_calc_timing_internal+0x10e> @ imm = #0x0
; 			continue;
 8003e3c: bf00         	nop
; 	     prescaler++) {
 8003e3e: 6b3b         	ldr	r3, [r7, #0x30]
 8003e40: 3301         	adds	r3, #0x1
 8003e42: 633b         	str	r3, [r7, #0x30]
; 	     prescaler <= max->prescaler;
 8003e44: 683b         	ldr	r3, [r7]
 8003e46: 891b         	ldrh	r3, [r3, #0x8]
 8003e48: 461a         	mov	r2, r3
 8003e4a: 6b3b         	ldr	r3, [r7, #0x30]
 8003e4c: 4293         	cmp	r3, r2
 8003e4e: ddba         	ble	0x8003dc6 <can_calc_timing_internal+0x96> @ imm = #-0x8c
 8003e50: e000         	b	0x8003e54 <can_calc_timing_internal+0x124> @ imm = #0x0
; 				break;
 8003e52: bf00         	nop
; 	if (err_min != 0U) {
 8003e54: 6b7b         	ldr	r3, [r7, #0x34]
 8003e56: 2b00         	cmp	r3, #0x0
 8003e58: d01f         	beq	0x8003e9a <can_calc_timing_internal+0x16a> @ imm = #0x3e
; 		LOG_DBG("Sample point error: %d 1/1000", err_min);
 8003e5a: 2303         	movs	r3, #0x3
 8003e5c: 2b03         	cmp	r3, #0x3
 8003e5e: d91c         	bls	0x8003e9a <can_calc_timing_internal+0x16a> @ imm = #0x38
 8003e60: 2301         	movs	r3, #0x1
 8003e62: f887 3027    	strb.w	r3, [r7, #0x27]
 8003e66: f897 3027    	ldrb.w	r3, [r7, #0x27]
 8003e6a: f083 0301    	eor	r3, r3, #0x1
 8003e6e: b2db         	uxtb	r3, r3
 8003e70: 2b00         	cmp	r3, #0x0
 8003e72: d112         	bne	0x8003e9a <can_calc_timing_internal+0x16a> @ imm = #0x24
 8003e74: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x8003ef4 <can_calc_timing_internal+0x1c4>
 8003e76: 6819         	ldr	r1, [r3]
 8003e78: 6b7b         	ldr	r3, [r7, #0x34]
 8003e7a: 9304         	str	r3, [sp, #0x10]
 8003e7c: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x8003ef8 <can_calc_timing_internal+0x1c8>
 8003e7e: 9303         	str	r3, [sp, #0xc]
 8003e80: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x8003efc <can_calc_timing_internal+0x1cc>
 8003e82: 9302         	str	r3, [sp, #0x8]
 8003e84: 2308         	movs	r3, #0x8
 8003e86: 9301         	str	r3, [sp, #0x4]
 8003e88: 2300         	movs	r3, #0x0
 8003e8a: 9300         	str	r3, [sp]
 8003e8c: 2300         	movs	r3, #0x0
 8003e8e: 2204         	movs	r2, #0x4
 8003e90: 2000         	movs	r0, #0x0
 8003e92: f00b f9fd    	bl	0x800f290 <z_log_msg_runtime_create> @ imm = #0xb3fa
 8003e96: 2300         	movs	r3, #0x0
 8003e98: 623b         	str	r3, [r7, #0x20]
; 	res->sjw = MIN(res->phase_seg1, res->phase_seg2 / 2);
 8003e9a: 68bb         	ldr	r3, [r7, #0x8]
 8003e9c: 88db         	ldrh	r3, [r3, #0x6]
 8003e9e: 085b         	lsrs	r3, r3, #0x1
 8003ea0: b29a         	uxth	r2, r3
 8003ea2: 68bb         	ldr	r3, [r7, #0x8]
 8003ea4: 889b         	ldrh	r3, [r3, #0x4]
 8003ea6: 4293         	cmp	r3, r2
 8003ea8: bf28         	it	hs
 8003eaa: 4613         	movhs	r3, r2
 8003eac: b29a         	uxth	r2, r3
 8003eae: 68bb         	ldr	r3, [r7, #0x8]
 8003eb0: 801a         	strh	r2, [r3]
; 	res->sjw = CLAMP(res->sjw, min->sjw, max->sjw);
 8003eb2: 68bb         	ldr	r3, [r7, #0x8]
 8003eb4: 881a         	ldrh	r2, [r3]
 8003eb6: 687b         	ldr	r3, [r7, #0x4]
 8003eb8: 881b         	ldrh	r3, [r3]
 8003eba: 429a         	cmp	r2, r3
 8003ebc: d802         	bhi	0x8003ec4 <can_calc_timing_internal+0x194> @ imm = #0x4
 8003ebe: 687b         	ldr	r3, [r7, #0x4]
 8003ec0: 881b         	ldrh	r3, [r3]
 8003ec2: e007         	b	0x8003ed4 <can_calc_timing_internal+0x1a4> @ imm = #0xe
 8003ec4: 683b         	ldr	r3, [r7]
 8003ec6: 881a         	ldrh	r2, [r3]
 8003ec8: 68bb         	ldr	r3, [r7, #0x8]
 8003eca: 881b         	ldrh	r3, [r3]
 8003ecc: 4293         	cmp	r3, r2
 8003ece: bf28         	it	hs
 8003ed0: 4613         	movhs	r3, r2
 8003ed2: b29b         	uxth	r3, r3
 8003ed4: 68ba         	ldr	r2, [r7, #0x8]
 8003ed6: 8013         	strh	r3, [r2]
; 	return err_min == INT_MAX ? -ENOTSUP : err_min;
 8003ed8: 6b7b         	ldr	r3, [r7, #0x34]
 8003eda: f06f 4200    	mvn	r2, #0x80000000
 8003ede: 4293         	cmp	r3, r2
 8003ee0: d001         	beq	0x8003ee6 <can_calc_timing_internal+0x1b6> @ imm = #0x2
 8003ee2: 6b7b         	ldr	r3, [r7, #0x34]
 8003ee4: e001         	b	0x8003eea <can_calc_timing_internal+0x1ba> @ imm = #0x2
 8003ee6: f06f 0385    	mvn	r3, #0x85
; }
 8003eea: 4618         	mov	r0, r3
 8003eec: 3738         	adds	r7, #0x38
 8003eee: 46bd         	mov	sp, r7
 8003ef0: bd80         	pop	{r7, pc}
 8003ef2: bf00         	nop

08003ef4 <$d>:
 8003ef4: 44 00 00 20  	.word	0x20000044
 8003ef8: b8 62 01 08  	.word	0x080162b8
 8003efc: c8 52 01 08  	.word	0x080152c8

08003f00 <z_impl_can_calc_timing>:
; {
 8003f00: b580         	push	{r7, lr}
 8003f02: b088         	sub	sp, #0x20
 8003f04: af02         	add	r7, sp, #0x8
 8003f06: 60f8         	str	r0, [r7, #0xc]
 8003f08: 60b9         	str	r1, [r7, #0x8]
 8003f0a: 607a         	str	r2, [r7, #0x4]
 8003f0c: 807b         	strh	r3, [r7, #0x2]
; 	const struct can_timing *min = can_get_timing_min(dev);
 8003f0e: 68f8         	ldr	r0, [r7, #0xc]
 8003f10: f00b f9a6    	bl	0x800f260 <can_get_timing_min> @ imm = #0xb34c
 8003f14: 6178         	str	r0, [r7, #0x14]
; 	const struct can_timing *max = can_get_timing_max(dev);
 8003f16: 68f8         	ldr	r0, [r7, #0xc]
 8003f18: f00b f9ae    	bl	0x800f278 <can_get_timing_max> @ imm = #0xb35c
 8003f1c: 6138         	str	r0, [r7, #0x10]
; 	if (bitrate > 1000000) {
 8003f1e: 687b         	ldr	r3, [r7, #0x4]
 8003f20: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x8003f4c <z_impl_can_calc_timing+0x4c>
 8003f22: 4293         	cmp	r3, r2
 8003f24: d902         	bls	0x8003f2c <z_impl_can_calc_timing+0x2c> @ imm = #0x4
; 		return -EINVAL;
 8003f26: f06f 0315    	mvn	r3, #0x15
 8003f2a: e00a         	b	0x8003f42 <z_impl_can_calc_timing+0x42> @ imm = #0x14
; 	return can_calc_timing_internal(dev, res, min, max, bitrate, sample_pnt);
 8003f2c: 887b         	ldrh	r3, [r7, #0x2]
 8003f2e: 9301         	str	r3, [sp, #0x4]
 8003f30: 687b         	ldr	r3, [r7, #0x4]
 8003f32: 9300         	str	r3, [sp]
 8003f34: 693b         	ldr	r3, [r7, #0x10]
 8003f36: 697a         	ldr	r2, [r7, #0x14]
 8003f38: 68b9         	ldr	r1, [r7, #0x8]
 8003f3a: 68f8         	ldr	r0, [r7, #0xc]
 8003f3c: f7ff fef8    	bl	0x8003d30 <can_calc_timing_internal> @ imm = #-0x210
 8003f40: 4603         	mov	r3, r0
; }
 8003f42: 4618         	mov	r0, r3
 8003f44: 3718         	adds	r7, #0x18
 8003f46: 46bd         	mov	sp, r7
 8003f48: bd80         	pop	{r7, pc}
 8003f4a: bf00         	nop

08003f4c <$d>:
 8003f4c: 40 42 0f 00  	.word	0x000f4240

08003f50 <can_stm32_rx_isr_handler>:
; {
 8003f50: b580         	push	{r7, lr}
 8003f52: b098         	sub	sp, #0x60
 8003f54: af06         	add	r7, sp, #0x18
 8003f56: 6078         	str	r0, [r7, #0x4]
; 	struct can_stm32_data *data = dev->data;
 8003f58: 687b         	ldr	r3, [r7, #0x4]
 8003f5a: 691b         	ldr	r3, [r3, #0x10]
 8003f5c: 63fb         	str	r3, [r7, #0x3c]
; 	const struct can_stm32_config *cfg = dev->config;
 8003f5e: 687b         	ldr	r3, [r7, #0x4]
 8003f60: 685b         	ldr	r3, [r3, #0x4]
 8003f62: 63bb         	str	r3, [r7, #0x38]
; 	CAN_TypeDef *can = cfg->can;
 8003f64: 6bbb         	ldr	r3, [r7, #0x38]
 8003f66: 695b         	ldr	r3, [r3, #0x14]
 8003f68: 637b         	str	r3, [r7, #0x34]
; 	can_rx_callback_t callback = NULL;
 8003f6a: 2300         	movs	r3, #0x0
 8003f6c: 643b         	str	r3, [r7, #0x40]
; 	while (can->RF0R & CAN_RF0R_FMP0) {
 8003f6e: e061         	b	0x8004034 <can_stm32_rx_isr_handler+0xe4> @ imm = #0xc2
; 		mbox = &can->sFIFOMailBox[0];
 8003f70: 6b7b         	ldr	r3, [r7, #0x34]
 8003f72: f503 73d8    	add.w	r3, r3, #0x1b0
 8003f76: 62bb         	str	r3, [r7, #0x28]
; 		filter_id = ((mbox->RDTR & CAN_RDT0R_FMI) >> CAN_RDT0R_FMI_Pos);
 8003f78: 6abb         	ldr	r3, [r7, #0x28]
 8003f7a: 685b         	ldr	r3, [r3, #0x4]
 8003f7c: 0a1b         	lsrs	r3, r3, #0x8
 8003f7e: b2db         	uxtb	r3, r3
 8003f80: 627b         	str	r3, [r7, #0x24]
; 		LOG_DBG("Message on filter_id %d", filter_id);
 8003f82: 2303         	movs	r3, #0x3
 8003f84: 2b03         	cmp	r3, #0x3
 8003f86: d91c         	bls	0x8003fc2 <can_stm32_rx_isr_handler+0x72> @ imm = #0x38
 8003f88: 2301         	movs	r3, #0x1
 8003f8a: f887 3023    	strb.w	r3, [r7, #0x23]
 8003f8e: f897 3023    	ldrb.w	r3, [r7, #0x23]
 8003f92: f083 0301    	eor	r3, r3, #0x1
 8003f96: b2db         	uxtb	r3, r3
 8003f98: 2b00         	cmp	r3, #0x0
 8003f9a: d112         	bne	0x8003fc2 <can_stm32_rx_isr_handler+0x72> @ imm = #0x24
 8003f9c: 4b3c         	ldr	r3, [pc, #0xf0]         @ 0x8004090 <can_stm32_rx_isr_handler+0x140>
 8003f9e: 6819         	ldr	r1, [r3]
 8003fa0: 6a7b         	ldr	r3, [r7, #0x24]
 8003fa2: 9304         	str	r3, [sp, #0x10]
 8003fa4: 4b3b         	ldr	r3, [pc, #0xec]         @ 0x8004094 <can_stm32_rx_isr_handler+0x144>
 8003fa6: 9303         	str	r3, [sp, #0xc]
 8003fa8: 4b3b         	ldr	r3, [pc, #0xec]         @ 0x8004098 <can_stm32_rx_isr_handler+0x148>
 8003faa: 9302         	str	r3, [sp, #0x8]
 8003fac: 2308         	movs	r3, #0x8
 8003fae: 9301         	str	r3, [sp, #0x4]
 8003fb0: 2300         	movs	r3, #0x0
 8003fb2: 9300         	str	r3, [sp]
 8003fb4: 2300         	movs	r3, #0x0
 8003fb6: 2204         	movs	r2, #0x4
 8003fb8: 2000         	movs	r0, #0x0
 8003fba: f00b fb26    	bl	0x800f60a <z_log_msg_runtime_create> @ imm = #0xb64c
 8003fbe: 2300         	movs	r3, #0x0
 8003fc0: 61fb         	str	r3, [r7, #0x1c]
; 		can_stm32_rx_fifo_pop(mbox, &frame);
 8003fc2: f107 0308    	add.w	r3, r7, #0x8
 8003fc6: 4619         	mov	r1, r3
 8003fc8: 6ab8         	ldr	r0, [r7, #0x28]
 8003fca: f00b fb55    	bl	0x800f678 <can_stm32_rx_fifo_pop> @ imm = #0xb6aa
; 		if (filter_id < CONFIG_CAN_MAX_EXT_ID_FILTER) {
 8003fce: 6a7b         	ldr	r3, [r7, #0x24]
 8003fd0: 2b06         	cmp	r3, #0x6
 8003fd2: dc0d         	bgt	0x8003ff0 <can_stm32_rx_isr_handler+0xa0> @ imm = #0x1a
; 			callback = data->rx_cb_ext[filter_id];
 8003fd4: 6bfa         	ldr	r2, [r7, #0x3c]
 8003fd6: 6a7b         	ldr	r3, [r7, #0x24]
 8003fd8: 3320         	adds	r3, #0x20
 8003fda: 009b         	lsls	r3, r3, #0x2
 8003fdc: 4413         	add	r3, r2
 8003fde: 685b         	ldr	r3, [r3, #0x4]
 8003fe0: 643b         	str	r3, [r7, #0x40]
; 			cb_arg = data->cb_arg_ext[filter_id];
 8003fe2: 6bfb         	ldr	r3, [r7, #0x3c]
 8003fe4: 6a7a         	ldr	r2, [r7, #0x24]
 8003fe6: 3236         	adds	r2, #0x36
 8003fe8: f853 3022    	ldr.w	r3, [r3, r2, lsl #2]
 8003fec: 647b         	str	r3, [r7, #0x44]
 8003fee: e012         	b	0x8004016 <can_stm32_rx_isr_handler+0xc6> @ imm = #0x24
; 		} else if (filter_id < CAN_STM32_MAX_FILTER_ID) {
 8003ff0: 6a7b         	ldr	r3, [r7, #0x24]
 8003ff2: 2b22         	cmp	r3, #0x22
 8003ff4: dc0f         	bgt	0x8004016 <can_stm32_rx_isr_handler+0xc6> @ imm = #0x1e
; 			index = filter_id - CONFIG_CAN_MAX_EXT_ID_FILTER;
 8003ff6: 6a7b         	ldr	r3, [r7, #0x24]
 8003ff8: 3b07         	subs	r3, #0x7
 8003ffa: 61bb         	str	r3, [r7, #0x18]
; 			callback = data->rx_cb_std[index];
 8003ffc: 6bfa         	ldr	r2, [r7, #0x3c]
 8003ffe: 69bb         	ldr	r3, [r7, #0x18]
 8004000: 3312         	adds	r3, #0x12
 8004002: 009b         	lsls	r3, r3, #0x2
 8004004: 4413         	add	r3, r2
 8004006: 685b         	ldr	r3, [r3, #0x4]
 8004008: 643b         	str	r3, [r7, #0x40]
; 			cb_arg = data->cb_arg_std[index];
 800400a: 6bfb         	ldr	r3, [r7, #0x3c]
 800400c: 69ba         	ldr	r2, [r7, #0x18]
 800400e: 3228         	adds	r2, #0x28
 8004010: f853 3022    	ldr.w	r3, [r3, r2, lsl #2]
 8004014: 647b         	str	r3, [r7, #0x44]
; 		if (callback) {
 8004016: 6c3b         	ldr	r3, [r7, #0x40]
 8004018: 2b00         	cmp	r3, #0x0
 800401a: d005         	beq	0x8004028 <can_stm32_rx_isr_handler+0xd8> @ imm = #0xa
; 			callback(dev, &frame, cb_arg);
 800401c: f107 0108    	add.w	r1, r7, #0x8
 8004020: 6c3b         	ldr	r3, [r7, #0x40]
 8004022: 6c7a         	ldr	r2, [r7, #0x44]
 8004024: 6878         	ldr	r0, [r7, #0x4]
 8004026: 4798         	blx	r3
; 		can->RF0R |= CAN_RF0R_RFOM0;
 8004028: 6b7b         	ldr	r3, [r7, #0x34]
 800402a: 68db         	ldr	r3, [r3, #0xc]
 800402c: f043 0220    	orr	r2, r3, #0x20
 8004030: 6b7b         	ldr	r3, [r7, #0x34]
 8004032: 60da         	str	r2, [r3, #0xc]
; 	while (can->RF0R & CAN_RF0R_FMP0) {
 8004034: 6b7b         	ldr	r3, [r7, #0x34]
 8004036: 68db         	ldr	r3, [r3, #0xc]
 8004038: f003 0303    	and	r3, r3, #0x3
 800403c: 2b00         	cmp	r3, #0x0
 800403e: d197         	bne	0x8003f70 <can_stm32_rx_isr_handler+0x20> @ imm = #-0xd2
; 	if (can->RF0R & CAN_RF0R_FOVR0) {
 8004040: 6b7b         	ldr	r3, [r7, #0x34]
 8004042: 68db         	ldr	r3, [r3, #0xc]
 8004044: f003 0310    	and	r3, r3, #0x10
 8004048: 2b00         	cmp	r3, #0x0
 800404a: d01c         	beq	0x8004086 <can_stm32_rx_isr_handler+0x136> @ imm = #0x38
; 		LOG_ERR("RX FIFO Overflow");
 800404c: 2303         	movs	r3, #0x3
 800404e: 2b00         	cmp	r3, #0x0
 8004050: d019         	beq	0x8004086 <can_stm32_rx_isr_handler+0x136> @ imm = #0x32
 8004052: 2301         	movs	r3, #0x1
 8004054: f887 3033    	strb.w	r3, [r7, #0x33]
 8004058: f897 3033    	ldrb.w	r3, [r7, #0x33]
 800405c: f083 0301    	eor	r3, r3, #0x1
 8004060: b2db         	uxtb	r3, r3
 8004062: 2b00         	cmp	r3, #0x0
 8004064: d10f         	bne	0x8004086 <can_stm32_rx_isr_handler+0x136> @ imm = #0x1e
 8004066: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8004090 <can_stm32_rx_isr_handler+0x140>
 8004068: 6819         	ldr	r1, [r3]
 800406a: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800409c <can_stm32_rx_isr_handler+0x14c>
 800406c: 9302         	str	r3, [sp, #0x8]
 800406e: 2300         	movs	r3, #0x0
 8004070: 9301         	str	r3, [sp, #0x4]
 8004072: 2300         	movs	r3, #0x0
 8004074: 9300         	str	r3, [sp]
 8004076: 2300         	movs	r3, #0x0
 8004078: 2201         	movs	r2, #0x1
 800407a: 2000         	movs	r0, #0x0
 800407c: f00b fac5    	bl	0x800f60a <z_log_msg_runtime_create> @ imm = #0xb58a
 8004080: 2300         	movs	r3, #0x0
 8004082: 62fb         	str	r3, [r7, #0x2c]
; }
 8004084: e7ff         	b	0x8004086 <can_stm32_rx_isr_handler+0x136> @ imm = #-0x2
 8004086: bf00         	nop
 8004088: 3748         	adds	r7, #0x48
 800408a: 46bd         	mov	sp, r7
 800408c: bd80         	pop	{r7, pc}
 800408e: bf00         	nop

08004090 <$d>:
 8004090: 48 00 00 20  	.word	0x20000048
 8004094: b0 63 01 08  	.word	0x080163b0
 8004098: f8 52 01 08  	.word	0x080152f8
 800409c: 14 53 01 08  	.word	0x08015314

080040a0 <can_stm32_enter_init_mode>:
; {
 80040a0: b580         	push	{r7, lr}
 80040a2: b084         	sub	sp, #0x10
 80040a4: af00         	add	r7, sp, #0x0
 80040a6: 6078         	str	r0, [r7, #0x4]
; 	can->MCR |= CAN_MCR_INRQ;
 80040a8: 687b         	ldr	r3, [r7, #0x4]
 80040aa: 681b         	ldr	r3, [r3]
 80040ac: f043 0201    	orr	r2, r3, #0x1
 80040b0: 687b         	ldr	r3, [r7, #0x4]
 80040b2: 601a         	str	r2, [r3]
; 	start_time = k_cycle_get_32();
 80040b4: f00b f9af    	bl	0x800f416 <k_cycle_get_32> @ imm = #0xb35e
 80040b8: 60f8         	str	r0, [r7, #0xc]
; 	while ((can->MSR & CAN_MSR_INAK) == 0U) {
 80040ba: e010         	b	0x80040de <can_stm32_enter_init_mode+0x3e> @ imm = #0x20
; 		if (k_cycle_get_32() - start_time > CAN_INIT_TIMEOUT) {
 80040bc: f00b f9ab    	bl	0x800f416 <k_cycle_get_32> @ imm = #0xb356
 80040c0: 4602         	mov	r2, r0
 80040c2: 68fb         	ldr	r3, [r7, #0xc]
 80040c4: 1ad3         	subs	r3, r2, r3
 80040c6: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x80040f4 <can_stm32_enter_init_mode+0x54>
 80040c8: 4293         	cmp	r3, r2
 80040ca: d908         	bls	0x80040de <can_stm32_enter_init_mode+0x3e> @ imm = #0x10
; 			can->MCR &= ~CAN_MCR_INRQ;
 80040cc: 687b         	ldr	r3, [r7, #0x4]
 80040ce: 681b         	ldr	r3, [r3]
 80040d0: f023 0201    	bic	r2, r3, #0x1
 80040d4: 687b         	ldr	r3, [r7, #0x4]
 80040d6: 601a         	str	r2, [r3]
; 			return -EAGAIN;
 80040d8: f06f 030a    	mvn	r3, #0xa
 80040dc: e006         	b	0x80040ec <can_stm32_enter_init_mode+0x4c> @ imm = #0xc
; 	while ((can->MSR & CAN_MSR_INAK) == 0U) {
 80040de: 687b         	ldr	r3, [r7, #0x4]
 80040e0: 685b         	ldr	r3, [r3, #0x4]
 80040e2: f003 0301    	and	r3, r3, #0x1
 80040e6: 2b00         	cmp	r3, #0x0
 80040e8: d0e8         	beq	0x80040bc <can_stm32_enter_init_mode+0x1c> @ imm = #-0x30
; 	return 0;
 80040ea: 2300         	movs	r3, #0x0
; }
 80040ec: 4618         	mov	r0, r3
 80040ee: 3710         	adds	r7, #0x10
 80040f0: 46bd         	mov	sp, r7
 80040f2: bd80         	pop	{r7, pc}

080040f4 <$d>:
 80040f4: 80 a2 19 00  	.word	0x0019a280

080040f8 <can_stm32_leave_init_mode>:
; {
 80040f8: b580         	push	{r7, lr}
 80040fa: b084         	sub	sp, #0x10
 80040fc: af00         	add	r7, sp, #0x0
 80040fe: 6078         	str	r0, [r7, #0x4]
; 	can->MCR &= ~CAN_MCR_INRQ;
 8004100: 687b         	ldr	r3, [r7, #0x4]
 8004102: 681b         	ldr	r3, [r3]
 8004104: f023 0201    	bic	r2, r3, #0x1
 8004108: 687b         	ldr	r3, [r7, #0x4]
 800410a: 601a         	str	r2, [r3]
; 	start_time = k_cycle_get_32();
 800410c: f00b f983    	bl	0x800f416 <k_cycle_get_32> @ imm = #0xb306
 8004110: 60f8         	str	r0, [r7, #0xc]
; 	while ((can->MSR & CAN_MSR_INAK) != 0U) {
 8004112: e00a         	b	0x800412a <can_stm32_leave_init_mode+0x32> @ imm = #0x14
; 		if (k_cycle_get_32() - start_time > CAN_INIT_TIMEOUT) {
 8004114: f00b f97f    	bl	0x800f416 <k_cycle_get_32> @ imm = #0xb2fe
 8004118: 4602         	mov	r2, r0
 800411a: 68fb         	ldr	r3, [r7, #0xc]
 800411c: 1ad3         	subs	r3, r2, r3
 800411e: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8004140 <can_stm32_leave_init_mode+0x48>
 8004120: 4293         	cmp	r3, r2
 8004122: d902         	bls	0x800412a <can_stm32_leave_init_mode+0x32> @ imm = #0x4
; 			return -EAGAIN;
 8004124: f06f 030a    	mvn	r3, #0xa
 8004128: e006         	b	0x8004138 <can_stm32_leave_init_mode+0x40> @ imm = #0xc
; 	while ((can->MSR & CAN_MSR_INAK) != 0U) {
 800412a: 687b         	ldr	r3, [r7, #0x4]
 800412c: 685b         	ldr	r3, [r3, #0x4]
 800412e: f003 0301    	and	r3, r3, #0x1
 8004132: 2b00         	cmp	r3, #0x0
 8004134: d1ee         	bne	0x8004114 <can_stm32_leave_init_mode+0x1c> @ imm = #-0x24
; 	return 0;
 8004136: 2300         	movs	r3, #0x0
; }
 8004138: 4618         	mov	r0, r3
 800413a: 3710         	adds	r7, #0x10
 800413c: 46bd         	mov	sp, r7
 800413e: bd80         	pop	{r7, pc}

08004140 <$d>:
 8004140: 80 a2 19 00  	.word	0x0019a280

08004144 <can_stm32_leave_sleep_mode>:
; {
 8004144: b580         	push	{r7, lr}
 8004146: b084         	sub	sp, #0x10
 8004148: af00         	add	r7, sp, #0x0
 800414a: 6078         	str	r0, [r7, #0x4]
; 	can->MCR &= ~CAN_MCR_SLEEP;
 800414c: 687b         	ldr	r3, [r7, #0x4]
 800414e: 681b         	ldr	r3, [r3]
 8004150: f023 0202    	bic	r2, r3, #0x2
 8004154: 687b         	ldr	r3, [r7, #0x4]
 8004156: 601a         	str	r2, [r3]
; 	start_time = k_cycle_get_32();
 8004158: f00b f95d    	bl	0x800f416 <k_cycle_get_32> @ imm = #0xb2ba
 800415c: 60f8         	str	r0, [r7, #0xc]
; 	while ((can->MSR & CAN_MSR_SLAK) != 0) {
 800415e: e00a         	b	0x8004176 <can_stm32_leave_sleep_mode+0x32> @ imm = #0x14
; 		if (k_cycle_get_32() - start_time > CAN_INIT_TIMEOUT) {
 8004160: f00b f959    	bl	0x800f416 <k_cycle_get_32> @ imm = #0xb2b2
 8004164: 4602         	mov	r2, r0
 8004166: 68fb         	ldr	r3, [r7, #0xc]
 8004168: 1ad3         	subs	r3, r2, r3
 800416a: 4a08         	ldr	r2, [pc, #0x20]         @ 0x800418c <can_stm32_leave_sleep_mode+0x48>
 800416c: 4293         	cmp	r3, r2
 800416e: d902         	bls	0x8004176 <can_stm32_leave_sleep_mode+0x32> @ imm = #0x4
; 			return -EAGAIN;
 8004170: f06f 030a    	mvn	r3, #0xa
 8004174: e006         	b	0x8004184 <can_stm32_leave_sleep_mode+0x40> @ imm = #0xc
; 	while ((can->MSR & CAN_MSR_SLAK) != 0) {
 8004176: 687b         	ldr	r3, [r7, #0x4]
 8004178: 685b         	ldr	r3, [r3, #0x4]
 800417a: f003 0302    	and	r3, r3, #0x2
 800417e: 2b00         	cmp	r3, #0x0
 8004180: d1ee         	bne	0x8004160 <can_stm32_leave_sleep_mode+0x1c> @ imm = #-0x24
; 	return 0;
 8004182: 2300         	movs	r3, #0x0
; }
 8004184: 4618         	mov	r0, r3
 8004186: 3710         	adds	r7, #0x10
 8004188: 46bd         	mov	sp, r7
 800418a: bd80         	pop	{r7, pc}

0800418c <$d>:
 800418c: 80 a2 19 00  	.word	0x0019a280

08004190 <can_stm32_start>:
; {
 8004190: b580         	push	{r7, lr}
 8004192: b08e         	sub	sp, #0x38
 8004194: af04         	add	r7, sp, #0x10
 8004196: 6078         	str	r0, [r7, #0x4]
; 	const struct can_stm32_config *cfg = dev->config;
 8004198: 687b         	ldr	r3, [r7, #0x4]
 800419a: 685b         	ldr	r3, [r3, #0x4]
 800419c: 623b         	str	r3, [r7, #0x20]
; 	struct can_stm32_data *data = dev->data;
 800419e: 687b         	ldr	r3, [r7, #0x4]
 80041a0: 691b         	ldr	r3, [r3, #0x10]
 80041a2: 61fb         	str	r3, [r7, #0x1c]
; 	CAN_TypeDef *can = cfg->can;
 80041a4: 6a3b         	ldr	r3, [r7, #0x20]
 80041a6: 695b         	ldr	r3, [r3, #0x14]
 80041a8: 61bb         	str	r3, [r7, #0x18]
; 	int ret = 0;
 80041aa: 2300         	movs	r3, #0x0
 80041ac: 627b         	str	r3, [r7, #0x24]
; 	k_mutex_lock(&data->inst_mutex, K_FOREVER);
 80041ae: 69fb         	ldr	r3, [r7, #0x1c]
 80041b0: f103 0110    	add.w	r1, r3, #0x10
 80041b4: f04f 32ff    	mov.w	r2, #0xffffffff
 80041b8: f04f 33ff    	mov.w	r3, #0xffffffff
 80041bc: 4608         	mov	r0, r1
 80041be: f00b f93d    	bl	0x800f43c <k_mutex_lock> @ imm = #0xb27a
; 	if (data->common.started) {
 80041c2: 69fb         	ldr	r3, [r7, #0x1c]
 80041c4: 791b         	ldrb	r3, [r3, #0x4]
 80041c6: 2b00         	cmp	r3, #0x0
 80041c8: d003         	beq	0x80041d2 <can_stm32_start+0x42> @ imm = #0x6
; 		ret = -EALREADY;
 80041ca: f06f 0377    	mvn	r3, #0x77
 80041ce: 627b         	str	r3, [r7, #0x24]
; 		goto unlock;
 80041d0: e05e         	b	0x8004290 <can_stm32_start+0x100> @ imm = #0xbc
; 	if (cfg->common.phy != NULL) {
 80041d2: 6a3b         	ldr	r3, [r7, #0x20]
 80041d4: 681b         	ldr	r3, [r3]
 80041d6: 2b00         	cmp	r3, #0x0
 80041d8: d029         	beq	0x800422e <can_stm32_start+0x9e> @ imm = #0x52
; 		ret = can_transceiver_enable(cfg->common.phy, data->common.mode);
 80041da: 6a3b         	ldr	r3, [r7, #0x20]
 80041dc: 681a         	ldr	r2, [r3]
 80041de: 69fb         	ldr	r3, [r7, #0x1c]
 80041e0: 681b         	ldr	r3, [r3]
 80041e2: 4619         	mov	r1, r3
 80041e4: 4610         	mov	r0, r2
 80041e6: f00b f990    	bl	0x800f50a <can_transceiver_enable> @ imm = #0xb320
 80041ea: 6278         	str	r0, [r7, #0x24]
; 		if (ret != 0) {
 80041ec: 6a7b         	ldr	r3, [r7, #0x24]
 80041ee: 2b00         	cmp	r3, #0x0
 80041f0: d01d         	beq	0x800422e <can_stm32_start+0x9e> @ imm = #0x3a
; 			LOG_ERR("failed to enable CAN transceiver (err %d)", ret);
 80041f2: 2303         	movs	r3, #0x3
 80041f4: 2b00         	cmp	r3, #0x0
 80041f6: d019         	beq	0x800422c <can_stm32_start+0x9c> @ imm = #0x32
 80041f8: 2301         	movs	r3, #0x1
 80041fa: 75fb         	strb	r3, [r7, #0x17]
 80041fc: 7dfb         	ldrb	r3, [r7, #0x17]
 80041fe: f083 0301    	eor	r3, r3, #0x1
 8004202: b2db         	uxtb	r3, r3
 8004204: 2b00         	cmp	r3, #0x0
 8004206: d111         	bne	0x800422c <can_stm32_start+0x9c> @ imm = #0x22
 8004208: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x80042a8 <can_stm32_start+0x118>
 800420a: 6819         	ldr	r1, [r3]
 800420c: 6a7b         	ldr	r3, [r7, #0x24]
 800420e: 9303         	str	r3, [sp, #0xc]
 8004210: 4b26         	ldr	r3, [pc, #0x98]         @ 0x80042ac <can_stm32_start+0x11c>
 8004212: 9302         	str	r3, [sp, #0x8]
 8004214: 2300         	movs	r3, #0x0
 8004216: 9301         	str	r3, [sp, #0x4]
 8004218: 2300         	movs	r3, #0x0
 800421a: 9300         	str	r3, [sp]
 800421c: 2300         	movs	r3, #0x0
 800421e: 2201         	movs	r2, #0x1
 8004220: 2000         	movs	r0, #0x0
 8004222: f00b f9f2    	bl	0x800f60a <z_log_msg_runtime_create> @ imm = #0xb3e4
 8004226: 2300         	movs	r3, #0x0
 8004228: 613b         	str	r3, [r7, #0x10]
; 			goto unlock;
 800422a: e031         	b	0x8004290 <can_stm32_start+0x100> @ imm = #0x62
 800422c: e030         	b	0x8004290 <can_stm32_start+0x100> @ imm = #0x60
; 	ret = can_stm32_leave_init_mode(can);
 800422e: 69b8         	ldr	r0, [r7, #0x18]
 8004230: f7ff ff62    	bl	0x80040f8 <can_stm32_leave_init_mode> @ imm = #-0x13c
 8004234: 6278         	str	r0, [r7, #0x24]
; 	if (ret < 0) {
 8004236: 6a7b         	ldr	r3, [r7, #0x24]
 8004238: 2b00         	cmp	r3, #0x0
 800423a: da26         	bge	0x800428a <can_stm32_start+0xfa> @ imm = #0x4c
; 		LOG_ERR("Failed to leave init mode");
 800423c: 2303         	movs	r3, #0x3
 800423e: 2b00         	cmp	r3, #0x0
 8004240: d016         	beq	0x8004270 <can_stm32_start+0xe0> @ imm = #0x2c
 8004242: 2301         	movs	r3, #0x1
 8004244: 73fb         	strb	r3, [r7, #0xf]
 8004246: 7bfb         	ldrb	r3, [r7, #0xf]
 8004248: f083 0301    	eor	r3, r3, #0x1
 800424c: b2db         	uxtb	r3, r3
 800424e: 2b00         	cmp	r3, #0x0
 8004250: d10e         	bne	0x8004270 <can_stm32_start+0xe0> @ imm = #0x1c
 8004252: 4b15         	ldr	r3, [pc, #0x54]         @ 0x80042a8 <can_stm32_start+0x118>
 8004254: 6819         	ldr	r1, [r3]
 8004256: 4b16         	ldr	r3, [pc, #0x58]         @ 0x80042b0 <can_stm32_start+0x120>
 8004258: 9302         	str	r3, [sp, #0x8]
 800425a: 2300         	movs	r3, #0x0
 800425c: 9301         	str	r3, [sp, #0x4]
 800425e: 2300         	movs	r3, #0x0
 8004260: 9300         	str	r3, [sp]
 8004262: 2300         	movs	r3, #0x0
 8004264: 2201         	movs	r2, #0x1
 8004266: 2000         	movs	r0, #0x0
 8004268: f00b f9cf    	bl	0x800f60a <z_log_msg_runtime_create> @ imm = #0xb39e
 800426c: 2300         	movs	r3, #0x0
 800426e: 60bb         	str	r3, [r7, #0x8]
; 		if (cfg->common.phy != NULL) {
 8004270: 6a3b         	ldr	r3, [r7, #0x20]
 8004272: 681b         	ldr	r3, [r3]
 8004274: 2b00         	cmp	r3, #0x0
 8004276: d004         	beq	0x8004282 <can_stm32_start+0xf2> @ imm = #0x8
; 			(void)can_transceiver_disable(cfg->common.phy);
 8004278: 6a3b         	ldr	r3, [r7, #0x20]
 800427a: 681b         	ldr	r3, [r3]
 800427c: 4618         	mov	r0, r3
 800427e: f00b f956    	bl	0x800f52e <can_transceiver_disable> @ imm = #0xb2ac
; 		ret = -EIO;
 8004282: f06f 0304    	mvn	r3, #0x4
 8004286: 627b         	str	r3, [r7, #0x24]
; 		goto unlock;
 8004288: e002         	b	0x8004290 <can_stm32_start+0x100> @ imm = #0x4
; 	data->common.started = true;
 800428a: 69fb         	ldr	r3, [r7, #0x1c]
 800428c: 2201         	movs	r2, #0x1
 800428e: 711a         	strb	r2, [r3, #0x4]
; 	k_mutex_unlock(&data->inst_mutex);
 8004290: 69fb         	ldr	r3, [r7, #0x1c]
 8004292: 3310         	adds	r3, #0x10
 8004294: 4618         	mov	r0, r3
 8004296: f00b f8e1    	bl	0x800f45c <k_mutex_unlock> @ imm = #0xb1c2
; 	return ret;
 800429a: 6a79         	ldr	r1, [r7, #0x24]
 800429c: 460b         	mov	r3, r1
; }
 800429e: 4618         	mov	r0, r3
 80042a0: 3728         	adds	r7, #0x28
 80042a2: 46bd         	mov	sp, r7
 80042a4: bd80         	pop	{r7, pc}
 80042a6: bf00         	nop

080042a8 <$d>:
 80042a8: 48 00 00 20  	.word	0x20000048
 80042ac: 28 53 01 08  	.word	0x08015328
 80042b0: 54 53 01 08  	.word	0x08015354

080042b4 <can_stm32_stop>:
; {
 80042b4: b580         	push	{r7, lr}
 80042b6: b08e         	sub	sp, #0x38
 80042b8: af04         	add	r7, sp, #0x10
 80042ba: 6078         	str	r0, [r7, #0x4]
; 	const struct can_stm32_config *cfg = dev->config;
 80042bc: 687b         	ldr	r3, [r7, #0x4]
 80042be: 685b         	ldr	r3, [r3, #0x4]
 80042c0: 623b         	str	r3, [r7, #0x20]
; 	struct can_stm32_data *data = dev->data;
 80042c2: 687b         	ldr	r3, [r7, #0x4]
 80042c4: 691b         	ldr	r3, [r3, #0x10]
 80042c6: 61fb         	str	r3, [r7, #0x1c]
; 	CAN_TypeDef *can = cfg->can;
 80042c8: 6a3b         	ldr	r3, [r7, #0x20]
 80042ca: 695b         	ldr	r3, [r3, #0x14]
 80042cc: 61bb         	str	r3, [r7, #0x18]
; 	int ret = 0;
 80042ce: 2300         	movs	r3, #0x0
 80042d0: 627b         	str	r3, [r7, #0x24]
; 	k_mutex_lock(&data->inst_mutex, K_FOREVER);
 80042d2: 69fb         	ldr	r3, [r7, #0x1c]
 80042d4: f103 0110    	add.w	r1, r3, #0x10
 80042d8: f04f 32ff    	mov.w	r2, #0xffffffff
 80042dc: f04f 33ff    	mov.w	r3, #0xffffffff
 80042e0: 4608         	mov	r0, r1
 80042e2: f00b f8ab    	bl	0x800f43c <k_mutex_lock> @ imm = #0xb156
; 	if (!data->common.started) {
 80042e6: 69fb         	ldr	r3, [r7, #0x1c]
 80042e8: 791b         	ldrb	r3, [r3, #0x4]
 80042ea: f083 0301    	eor	r3, r3, #0x1
 80042ee: b2db         	uxtb	r3, r3
 80042f0: 2b00         	cmp	r3, #0x0
 80042f2: d003         	beq	0x80042fc <can_stm32_stop+0x48> @ imm = #0x6
; 		ret = -EALREADY;
 80042f4: f06f 0377    	mvn	r3, #0x77
 80042f8: 627b         	str	r3, [r7, #0x24]
; 		goto unlock;
 80042fa: e072         	b	0x80043e2 <can_stm32_stop+0x12e> @ imm = #0xe4
; 	ret = can_stm32_enter_init_mode(can);
 80042fc: 69b8         	ldr	r0, [r7, #0x18]
 80042fe: f7ff fecf    	bl	0x80040a0 <can_stm32_enter_init_mode> @ imm = #-0x262
 8004302: 6278         	str	r0, [r7, #0x24]
; 	if (ret < 0) {
 8004304: 6a7b         	ldr	r3, [r7, #0x24]
 8004306: 2b00         	cmp	r3, #0x0
 8004308: da1d         	bge	0x8004346 <can_stm32_stop+0x92> @ imm = #0x3a
; 		LOG_ERR("Failed to enter init mode");
 800430a: 2303         	movs	r3, #0x3
 800430c: 2b00         	cmp	r3, #0x0
 800430e: d016         	beq	0x800433e <can_stm32_stop+0x8a> @ imm = #0x2c
 8004310: 2301         	movs	r3, #0x1
 8004312: 73fb         	strb	r3, [r7, #0xf]
 8004314: 7bfb         	ldrb	r3, [r7, #0xf]
 8004316: f083 0301    	eor	r3, r3, #0x1
 800431a: b2db         	uxtb	r3, r3
 800431c: 2b00         	cmp	r3, #0x0
 800431e: d10e         	bne	0x800433e <can_stm32_stop+0x8a> @ imm = #0x1c
 8004320: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x80043f8 <can_stm32_stop+0x144>
 8004322: 6819         	ldr	r1, [r3]
 8004324: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x80043fc <can_stm32_stop+0x148>
 8004326: 9302         	str	r3, [sp, #0x8]
 8004328: 2300         	movs	r3, #0x0
 800432a: 9301         	str	r3, [sp, #0x4]
 800432c: 2300         	movs	r3, #0x0
 800432e: 9300         	str	r3, [sp]
 8004330: 2300         	movs	r3, #0x0
 8004332: 2201         	movs	r2, #0x1
 8004334: 2000         	movs	r0, #0x0
 8004336: f00b f968    	bl	0x800f60a <z_log_msg_runtime_create> @ imm = #0xb2d0
 800433a: 2300         	movs	r3, #0x0
 800433c: 60bb         	str	r3, [r7, #0x8]
; 		ret = -EIO;
 800433e: f06f 0304    	mvn	r3, #0x4
 8004342: 627b         	str	r3, [r7, #0x24]
; 		goto unlock;
 8004344: e04d         	b	0x80043e2 <can_stm32_stop+0x12e> @ imm = #0x9a
; 	can_stm32_signal_tx_complete(dev, &data->mb0, -ENETDOWN);
 8004346: 69fb         	ldr	r3, [r7, #0x1c]
 8004348: 3334         	adds	r3, #0x34
 800434a: f06f 0272    	mvn	r2, #0x72
 800434e: 4619         	mov	r1, r3
 8004350: 6878         	ldr	r0, [r7, #0x4]
 8004352: f00b f978    	bl	0x800f646 <can_stm32_signal_tx_complete> @ imm = #0xb2f0
; 	can_stm32_signal_tx_complete(dev, &data->mb1, -ENETDOWN);
 8004356: 69fb         	ldr	r3, [r7, #0x1c]
 8004358: 333c         	adds	r3, #0x3c
 800435a: f06f 0272    	mvn	r2, #0x72
 800435e: 4619         	mov	r1, r3
 8004360: 6878         	ldr	r0, [r7, #0x4]
 8004362: f00b f970    	bl	0x800f646 <can_stm32_signal_tx_complete> @ imm = #0xb2e0
; 	can_stm32_signal_tx_complete(dev, &data->mb2, -ENETDOWN);
 8004366: 69fb         	ldr	r3, [r7, #0x1c]
 8004368: 3344         	adds	r3, #0x44
 800436a: f06f 0272    	mvn	r2, #0x72
 800436e: 4619         	mov	r1, r3
 8004370: 6878         	ldr	r0, [r7, #0x4]
 8004372: f00b f968    	bl	0x800f646 <can_stm32_signal_tx_complete> @ imm = #0xb2d0
; 	can->TSR |= CAN_TSR_ABRQ2 | CAN_TSR_ABRQ1 | CAN_TSR_ABRQ0;
 8004376: 69bb         	ldr	r3, [r7, #0x18]
 8004378: 689b         	ldr	r3, [r3, #0x8]
 800437a: f043 1380    	orr	r3, r3, #0x800080
 800437e: f443 4300    	orr	r3, r3, #0x8000
 8004382: 69ba         	ldr	r2, [r7, #0x18]
 8004384: 6093         	str	r3, [r2, #0x8]
; 	if (cfg->common.phy != NULL) {
 8004386: 6a3b         	ldr	r3, [r7, #0x20]
 8004388: 681b         	ldr	r3, [r3]
 800438a: 2b00         	cmp	r3, #0x0
 800438c: d026         	beq	0x80043dc <can_stm32_stop+0x128> @ imm = #0x4c
; 		ret = can_transceiver_disable(cfg->common.phy);
 800438e: 6a3b         	ldr	r3, [r7, #0x20]
 8004390: 681b         	ldr	r3, [r3]
 8004392: 4618         	mov	r0, r3
 8004394: f00b f8cb    	bl	0x800f52e <can_transceiver_disable> @ imm = #0xb196
 8004398: 6278         	str	r0, [r7, #0x24]
; 		if (ret != 0) {
 800439a: 6a7b         	ldr	r3, [r7, #0x24]
 800439c: 2b00         	cmp	r3, #0x0
 800439e: d01d         	beq	0x80043dc <can_stm32_stop+0x128> @ imm = #0x3a
; 			LOG_ERR("failed to enable CAN transceiver (err %d)", ret);
 80043a0: 2303         	movs	r3, #0x3
 80043a2: 2b00         	cmp	r3, #0x0
 80043a4: d019         	beq	0x80043da <can_stm32_stop+0x126> @ imm = #0x32
 80043a6: 2301         	movs	r3, #0x1
 80043a8: 75fb         	strb	r3, [r7, #0x17]
 80043aa: 7dfb         	ldrb	r3, [r7, #0x17]
 80043ac: f083 0301    	eor	r3, r3, #0x1
 80043b0: b2db         	uxtb	r3, r3
 80043b2: 2b00         	cmp	r3, #0x0
 80043b4: d111         	bne	0x80043da <can_stm32_stop+0x126> @ imm = #0x22
 80043b6: 4b10         	ldr	r3, [pc, #0x40]         @ 0x80043f8 <can_stm32_stop+0x144>
 80043b8: 6819         	ldr	r1, [r3]
 80043ba: 6a7b         	ldr	r3, [r7, #0x24]
 80043bc: 9303         	str	r3, [sp, #0xc]
 80043be: 4b10         	ldr	r3, [pc, #0x40]         @ 0x8004400 <can_stm32_stop+0x14c>
 80043c0: 9302         	str	r3, [sp, #0x8]
 80043c2: 2300         	movs	r3, #0x0
 80043c4: 9301         	str	r3, [sp, #0x4]
 80043c6: 2300         	movs	r3, #0x0
 80043c8: 9300         	str	r3, [sp]
 80043ca: 2300         	movs	r3, #0x0
 80043cc: 2201         	movs	r2, #0x1
 80043ce: 2000         	movs	r0, #0x0
 80043d0: f00b f91b    	bl	0x800f60a <z_log_msg_runtime_create> @ imm = #0xb236
 80043d4: 2300         	movs	r3, #0x0
 80043d6: 613b         	str	r3, [r7, #0x10]
; 			goto unlock;
 80043d8: e003         	b	0x80043e2 <can_stm32_stop+0x12e> @ imm = #0x6
 80043da: e002         	b	0x80043e2 <can_stm32_stop+0x12e> @ imm = #0x4
; 	data->common.started = false;
 80043dc: 69fb         	ldr	r3, [r7, #0x1c]
 80043de: 2200         	movs	r2, #0x0
 80043e0: 711a         	strb	r2, [r3, #0x4]
; 	k_mutex_unlock(&data->inst_mutex);
 80043e2: 69fb         	ldr	r3, [r7, #0x1c]
 80043e4: 3310         	adds	r3, #0x10
 80043e6: 4618         	mov	r0, r3
 80043e8: f00b f838    	bl	0x800f45c <k_mutex_unlock> @ imm = #0xb070
; 	return ret;
 80043ec: 6a79         	ldr	r1, [r7, #0x24]
 80043ee: 460b         	mov	r3, r1
; }
 80043f0: 4618         	mov	r0, r3
 80043f2: 3728         	adds	r7, #0x28
 80043f4: 46bd         	mov	sp, r7
 80043f6: bd80         	pop	{r7, pc}

080043f8 <$d>:
 80043f8: 48 00 00 20  	.word	0x20000048
 80043fc: 70 53 01 08  	.word	0x08015370
 8004400: 28 53 01 08  	.word	0x08015328

08004404 <can_stm32_set_mode>:
; {
 8004404: b580         	push	{r7, lr}
 8004406: b090         	sub	sp, #0x40
 8004408: af06         	add	r7, sp, #0x18
 800440a: 6078         	str	r0, [r7, #0x4]
 800440c: 6039         	str	r1, [r7]
; 	can_mode_t supported = CAN_MODE_LOOPBACK | CAN_MODE_LISTENONLY | CAN_MODE_ONE_SHOT;
 800440e: 230b         	movs	r3, #0xb
 8004410: 627b         	str	r3, [r7, #0x24]
; 	const struct can_stm32_config *cfg = dev->config;
 8004412: 687b         	ldr	r3, [r7, #0x4]
 8004414: 685b         	ldr	r3, [r3, #0x4]
 8004416: 623b         	str	r3, [r7, #0x20]
; 	CAN_TypeDef *can = cfg->can;
 8004418: 6a3b         	ldr	r3, [r7, #0x20]
 800441a: 695b         	ldr	r3, [r3, #0x14]
 800441c: 61fb         	str	r3, [r7, #0x1c]
; 	struct can_stm32_data *data = dev->data;
 800441e: 687b         	ldr	r3, [r7, #0x4]
 8004420: 691b         	ldr	r3, [r3, #0x10]
 8004422: 61bb         	str	r3, [r7, #0x18]
; 	LOG_DBG("Set mode %d", mode);
 8004424: 2303         	movs	r3, #0x3
 8004426: 2b03         	cmp	r3, #0x3
 8004428: d91a         	bls	0x8004460 <can_stm32_set_mode+0x5c> @ imm = #0x34
 800442a: 2301         	movs	r3, #0x1
 800442c: 75fb         	strb	r3, [r7, #0x17]
 800442e: 7dfb         	ldrb	r3, [r7, #0x17]
 8004430: f083 0301    	eor	r3, r3, #0x1
 8004434: b2db         	uxtb	r3, r3
 8004436: 2b00         	cmp	r3, #0x0
 8004438: d112         	bne	0x8004460 <can_stm32_set_mode+0x5c> @ imm = #0x24
 800443a: 4b46         	ldr	r3, [pc, #0x118]        @ 0x8004554 <can_stm32_set_mode+0x150>
 800443c: 6819         	ldr	r1, [r3]
 800443e: 683b         	ldr	r3, [r7]
 8004440: 9304         	str	r3, [sp, #0x10]
 8004442: 4b45         	ldr	r3, [pc, #0x114]        @ 0x8004558 <can_stm32_set_mode+0x154>
 8004444: 9303         	str	r3, [sp, #0xc]
 8004446: 4b45         	ldr	r3, [pc, #0x114]        @ 0x800455c <can_stm32_set_mode+0x158>
 8004448: 9302         	str	r3, [sp, #0x8]
 800444a: 2308         	movs	r3, #0x8
 800444c: 9301         	str	r3, [sp, #0x4]
 800444e: 2300         	movs	r3, #0x0
 8004450: 9300         	str	r3, [sp]
 8004452: 2300         	movs	r3, #0x0
 8004454: 2204         	movs	r2, #0x4
 8004456: 2000         	movs	r0, #0x0
 8004458: f00b f8d7    	bl	0x800f60a <z_log_msg_runtime_create> @ imm = #0xb1ae
 800445c: 2300         	movs	r3, #0x0
 800445e: 613b         	str	r3, [r7, #0x10]
; 	if ((mode & ~(supported)) != 0) {
 8004460: 6a7b         	ldr	r3, [r7, #0x24]
 8004462: 43da         	mvns	r2, r3
 8004464: 683b         	ldr	r3, [r7]
 8004466: 4013         	ands	r3, r2
 8004468: 2b00         	cmp	r3, #0x0
 800446a: d01e         	beq	0x80044aa <can_stm32_set_mode+0xa6> @ imm = #0x3c
; 		LOG_ERR("unsupported mode: 0x%08x", mode);
 800446c: 2303         	movs	r3, #0x3
 800446e: 2b00         	cmp	r3, #0x0
 8004470: d018         	beq	0x80044a4 <can_stm32_set_mode+0xa0> @ imm = #0x30
 8004472: 2301         	movs	r3, #0x1
 8004474: 73fb         	strb	r3, [r7, #0xf]
 8004476: 7bfb         	ldrb	r3, [r7, #0xf]
 8004478: f083 0301    	eor	r3, r3, #0x1
 800447c: b2db         	uxtb	r3, r3
 800447e: 2b00         	cmp	r3, #0x0
 8004480: d110         	bne	0x80044a4 <can_stm32_set_mode+0xa0> @ imm = #0x20
 8004482: 4b34         	ldr	r3, [pc, #0xd0]         @ 0x8004554 <can_stm32_set_mode+0x150>
 8004484: 6819         	ldr	r1, [r3]
 8004486: 683b         	ldr	r3, [r7]
 8004488: 9303         	str	r3, [sp, #0xc]
 800448a: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x8004560 <can_stm32_set_mode+0x15c>
 800448c: 9302         	str	r3, [sp, #0x8]
 800448e: 2300         	movs	r3, #0x0
 8004490: 9301         	str	r3, [sp, #0x4]
 8004492: 2300         	movs	r3, #0x0
 8004494: 9300         	str	r3, [sp]
 8004496: 2300         	movs	r3, #0x0
 8004498: 2201         	movs	r2, #0x1
 800449a: 2000         	movs	r0, #0x0
 800449c: f00b f8b5    	bl	0x800f60a <z_log_msg_runtime_create> @ imm = #0xb16a
 80044a0: 2300         	movs	r3, #0x0
 80044a2: 60bb         	str	r3, [r7, #0x8]
; 		return -ENOTSUP;
 80044a4: f06f 0185    	mvn	r1, #0x85
 80044a8: e04f         	b	0x800454a <can_stm32_set_mode+0x146> @ imm = #0x9e
; 	if (data->common.started) {
 80044aa: 69bb         	ldr	r3, [r7, #0x18]
 80044ac: 791b         	ldrb	r3, [r3, #0x4]
 80044ae: 2b00         	cmp	r3, #0x0
 80044b0: d002         	beq	0x80044b8 <can_stm32_set_mode+0xb4> @ imm = #0x4
; 		return -EBUSY;
 80044b2: f06f 010f    	mvn	r1, #0xf
 80044b6: e048         	b	0x800454a <can_stm32_set_mode+0x146> @ imm = #0x90
; 	k_mutex_lock(&data->inst_mutex, K_FOREVER);
 80044b8: 69bb         	ldr	r3, [r7, #0x18]
 80044ba: f103 0110    	add.w	r1, r3, #0x10
 80044be: f04f 32ff    	mov.w	r2, #0xffffffff
 80044c2: f04f 33ff    	mov.w	r3, #0xffffffff
 80044c6: 4608         	mov	r0, r1
 80044c8: f00a ffb8    	bl	0x800f43c <k_mutex_lock> @ imm = #0xaf70
; 	if ((mode & CAN_MODE_LOOPBACK) != 0) {
 80044cc: 683b         	ldr	r3, [r7]
 80044ce: f003 0301    	and	r3, r3, #0x1
 80044d2: 2b00         	cmp	r3, #0x0
 80044d4: d006         	beq	0x80044e4 <can_stm32_set_mode+0xe0> @ imm = #0xc
; 		can->BTR |= CAN_BTR_LBKM;
 80044d6: 69fb         	ldr	r3, [r7, #0x1c]
 80044d8: 69db         	ldr	r3, [r3, #0x1c]
 80044da: f043 4280    	orr	r2, r3, #0x40000000
 80044de: 69fb         	ldr	r3, [r7, #0x1c]
 80044e0: 61da         	str	r2, [r3, #0x1c]
 80044e2: e005         	b	0x80044f0 <can_stm32_set_mode+0xec> @ imm = #0xa
; 		can->BTR &= ~CAN_BTR_LBKM;
 80044e4: 69fb         	ldr	r3, [r7, #0x1c]
 80044e6: 69db         	ldr	r3, [r3, #0x1c]
 80044e8: f023 4280    	bic	r2, r3, #0x40000000
 80044ec: 69fb         	ldr	r3, [r7, #0x1c]
 80044ee: 61da         	str	r2, [r3, #0x1c]
; 	if ((mode & CAN_MODE_LISTENONLY) != 0) {
 80044f0: 683b         	ldr	r3, [r7]
 80044f2: f003 0302    	and	r3, r3, #0x2
 80044f6: 2b00         	cmp	r3, #0x0
 80044f8: d006         	beq	0x8004508 <can_stm32_set_mode+0x104> @ imm = #0xc
; 		can->BTR |= CAN_BTR_SILM;
 80044fa: 69fb         	ldr	r3, [r7, #0x1c]
 80044fc: 69db         	ldr	r3, [r3, #0x1c]
 80044fe: f043 4200    	orr	r2, r3, #0x80000000
 8004502: 69fb         	ldr	r3, [r7, #0x1c]
 8004504: 61da         	str	r2, [r3, #0x1c]
 8004506: e005         	b	0x8004514 <can_stm32_set_mode+0x110> @ imm = #0xa
; 		can->BTR &= ~CAN_BTR_SILM;
 8004508: 69fb         	ldr	r3, [r7, #0x1c]
 800450a: 69db         	ldr	r3, [r3, #0x1c]
 800450c: f023 4200    	bic	r2, r3, #0x80000000
 8004510: 69fb         	ldr	r3, [r7, #0x1c]
 8004512: 61da         	str	r2, [r3, #0x1c]
; 	if ((mode & CAN_MODE_ONE_SHOT) != 0) {
 8004514: 683b         	ldr	r3, [r7]
 8004516: f003 0308    	and	r3, r3, #0x8
 800451a: 2b00         	cmp	r3, #0x0
 800451c: d006         	beq	0x800452c <can_stm32_set_mode+0x128> @ imm = #0xc
; 		can->MCR |= CAN_MCR_NART;
 800451e: 69fb         	ldr	r3, [r7, #0x1c]
 8004520: 681b         	ldr	r3, [r3]
 8004522: f043 0210    	orr	r2, r3, #0x10
 8004526: 69fb         	ldr	r3, [r7, #0x1c]
 8004528: 601a         	str	r2, [r3]
 800452a: e005         	b	0x8004538 <can_stm32_set_mode+0x134> @ imm = #0xa
; 		can->MCR &= ~CAN_MCR_NART;
 800452c: 69fb         	ldr	r3, [r7, #0x1c]
 800452e: 681b         	ldr	r3, [r3]
 8004530: f023 0210    	bic	r2, r3, #0x10
 8004534: 69fb         	ldr	r3, [r7, #0x1c]
 8004536: 601a         	str	r2, [r3]
; 	data->common.mode = mode;
 8004538: 69bb         	ldr	r3, [r7, #0x18]
 800453a: 683a         	ldr	r2, [r7]
 800453c: 601a         	str	r2, [r3]
; 	k_mutex_unlock(&data->inst_mutex);
 800453e: 69bb         	ldr	r3, [r7, #0x18]
 8004540: 3310         	adds	r3, #0x10
 8004542: 4618         	mov	r0, r3
 8004544: f00a ff8a    	bl	0x800f45c <k_mutex_unlock> @ imm = #0xaf14
; 	return 0;
 8004548: 2100         	movs	r1, #0x0
; }
 800454a: 460b         	mov	r3, r1
 800454c: 4618         	mov	r0, r3
 800454e: 3728         	adds	r7, #0x28
 8004550: 46bd         	mov	sp, r7
 8004552: bd80         	pop	{r7, pc}

08004554 <$d>:
 8004554: 48 00 00 20  	.word	0x20000048
 8004558: cc 63 01 08  	.word	0x080163cc
 800455c: 8c 53 01 08  	.word	0x0801538c
 8004560: 9c 53 01 08  	.word	0x0801539c

08004564 <can_stm32_set_timing>:
; {
 8004564: b580         	push	{r7, lr}
 8004566: b086         	sub	sp, #0x18
 8004568: af00         	add	r7, sp, #0x0
 800456a: 6078         	str	r0, [r7, #0x4]
 800456c: 6039         	str	r1, [r7]
; 	const struct can_stm32_config *cfg = dev->config;
 800456e: 687b         	ldr	r3, [r7, #0x4]
 8004570: 685b         	ldr	r3, [r3, #0x4]
 8004572: 617b         	str	r3, [r7, #0x14]
; 	CAN_TypeDef *can = cfg->can;
 8004574: 697b         	ldr	r3, [r7, #0x14]
 8004576: 695b         	ldr	r3, [r3, #0x14]
 8004578: 613b         	str	r3, [r7, #0x10]
; 	struct can_stm32_data *data = dev->data;
 800457a: 687b         	ldr	r3, [r7, #0x4]
 800457c: 691b         	ldr	r3, [r3, #0x10]
 800457e: 60fb         	str	r3, [r7, #0xc]
; 	k_mutex_lock(&data->inst_mutex, K_FOREVER);
 8004580: 68fb         	ldr	r3, [r7, #0xc]
 8004582: f103 0110    	add.w	r1, r3, #0x10
 8004586: f04f 32ff    	mov.w	r2, #0xffffffff
 800458a: f04f 33ff    	mov.w	r3, #0xffffffff
 800458e: 4608         	mov	r0, r1
 8004590: f00a ff54    	bl	0x800f43c <k_mutex_lock> @ imm = #0xaea8
; 	if (data->common.started) {
 8004594: 68fb         	ldr	r3, [r7, #0xc]
 8004596: 791b         	ldrb	r3, [r3, #0x4]
 8004598: 2b00         	cmp	r3, #0x0
 800459a: d007         	beq	0x80045ac <can_stm32_set_timing+0x48> @ imm = #0xe
; 		k_mutex_unlock(&data->inst_mutex);
 800459c: 68fb         	ldr	r3, [r7, #0xc]
 800459e: 3310         	adds	r3, #0x10
 80045a0: 4618         	mov	r0, r3
 80045a2: f00a ff5b    	bl	0x800f45c <k_mutex_unlock> @ imm = #0xaeb6
; 		return -EBUSY;
 80045a6: f06f 010f    	mvn	r1, #0xf
 80045aa: e026         	b	0x80045fa <can_stm32_set_timing+0x96> @ imm = #0x4c
; 	can->BTR = (can->BTR & ~(CAN_BTR_SJW_Msk | CAN_BTR_BRP_Msk |
 80045ac: 693b         	ldr	r3, [r7, #0x10]
 80045ae: 69da         	ldr	r2, [r3, #0x1c]
 80045b0: 4b14         	ldr	r3, [pc, #0x50]         @ 0x8004604 <can_stm32_set_timing+0xa0>
 80045b2: 4013         	ands	r3, r2
; 	     (((timing->sjw        - 1) << CAN_BTR_SJW_Pos) & CAN_BTR_SJW_Msk) |
 80045b4: 683a         	ldr	r2, [r7]
 80045b6: 8812         	ldrh	r2, [r2]
 80045b8: 3a01         	subs	r2, #0x1
 80045ba: 0612         	lsls	r2, r2, #0x18
 80045bc: f002 7240    	and	r2, r2, #0x3000000
; 				 CAN_BTR_TS1_Msk | CAN_BTR_TS2_Msk)) |
 80045c0: 431a         	orrs	r2, r3
; 	     (((timing->phase_seg1 - 1) << CAN_BTR_TS1_Pos) & CAN_BTR_TS1_Msk) |
 80045c2: 683b         	ldr	r3, [r7]
 80045c4: 889b         	ldrh	r3, [r3, #0x4]
 80045c6: 3b01         	subs	r3, #0x1
 80045c8: 041b         	lsls	r3, r3, #0x10
 80045ca: f403 2370    	and	r3, r3, #0xf0000
; 	     (((timing->sjw        - 1) << CAN_BTR_SJW_Pos) & CAN_BTR_SJW_Msk) |
 80045ce: 431a         	orrs	r2, r3
; 	     (((timing->phase_seg2 - 1) << CAN_BTR_TS2_Pos) & CAN_BTR_TS2_Msk) |
 80045d0: 683b         	ldr	r3, [r7]
 80045d2: 88db         	ldrh	r3, [r3, #0x6]
 80045d4: 3b01         	subs	r3, #0x1
 80045d6: 051b         	lsls	r3, r3, #0x14
 80045d8: f403 03e0    	and	r3, r3, #0x700000
; 	     (((timing->phase_seg1 - 1) << CAN_BTR_TS1_Pos) & CAN_BTR_TS1_Msk) |
 80045dc: 431a         	orrs	r2, r3
; 	     (((timing->prescaler  - 1) << CAN_BTR_BRP_Pos) & CAN_BTR_BRP_Msk);
 80045de: 683b         	ldr	r3, [r7]
 80045e0: 891b         	ldrh	r3, [r3, #0x8]
 80045e2: 3b01         	subs	r3, #0x1
 80045e4: f3c3 0309    	ubfx	r3, r3, #0x0, #0xa
; 	     (((timing->phase_seg2 - 1) << CAN_BTR_TS2_Pos) & CAN_BTR_TS2_Msk) |
 80045e8: 431a         	orrs	r2, r3
; 	can->BTR = (can->BTR & ~(CAN_BTR_SJW_Msk | CAN_BTR_BRP_Msk |
 80045ea: 693b         	ldr	r3, [r7, #0x10]
 80045ec: 61da         	str	r2, [r3, #0x1c]
; 	k_mutex_unlock(&data->inst_mutex);
 80045ee: 68fb         	ldr	r3, [r7, #0xc]
 80045f0: 3310         	adds	r3, #0x10
 80045f2: 4618         	mov	r0, r3
 80045f4: f00a ff32    	bl	0x800f45c <k_mutex_unlock> @ imm = #0xae64
; 	return 0;
 80045f8: 2100         	movs	r1, #0x0
; }
 80045fa: 460b         	mov	r3, r1
 80045fc: 4618         	mov	r0, r3
 80045fe: 3718         	adds	r7, #0x18
 8004600: 46bd         	mov	sp, r7
 8004602: bd80         	pop	{r7, pc}

08004604 <$d>:
 8004604: 00 fc 80 fc  	.word	0xfc80fc00

08004608 <can_stm32_get_core_clock>:
; {
 8004608: b580         	push	{r7, lr}
 800460a: b08c         	sub	sp, #0x30
 800460c: af04         	add	r7, sp, #0x10
 800460e: 6078         	str	r0, [r7, #0x4]
 8004610: 6039         	str	r1, [r7]
; 	const struct can_stm32_config *cfg = dev->config;
 8004612: 687b         	ldr	r3, [r7, #0x4]
 8004614: 685b         	ldr	r3, [r3, #0x4]
 8004616: 61fb         	str	r3, [r7, #0x1c]
; 	clock = DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE);
 8004618: 4b18         	ldr	r3, [pc, #0x60]         @ 0x800467c <can_stm32_get_core_clock+0x74>
 800461a: 61bb         	str	r3, [r7, #0x18]
; 				     (clock_control_subsys_t) &cfg->pclken,
 800461c: 69fb         	ldr	r3, [r7, #0x1c]
 800461e: 331c         	adds	r3, #0x1c
; 	ret = clock_control_get_rate(clock,
 8004620: 683a         	ldr	r2, [r7]
 8004622: 4619         	mov	r1, r3
 8004624: 69b8         	ldr	r0, [r7, #0x18]
 8004626: f00a ffa4    	bl	0x800f572 <clock_control_get_rate> @ imm = #0xaf48
 800462a: 6178         	str	r0, [r7, #0x14]
; 	if (ret != 0) {
 800462c: 697b         	ldr	r3, [r7, #0x14]
 800462e: 2b00         	cmp	r3, #0x0
 8004630: d01e         	beq	0x8004670 <can_stm32_get_core_clock+0x68> @ imm = #0x3c
; 		LOG_ERR("Failed call clock_control_get_rate: return [%d]", ret);
 8004632: 2303         	movs	r3, #0x3
 8004634: 2b00         	cmp	r3, #0x0
 8004636: d018         	beq	0x800466a <can_stm32_get_core_clock+0x62> @ imm = #0x30
 8004638: 2301         	movs	r3, #0x1
 800463a: 74fb         	strb	r3, [r7, #0x13]
 800463c: 7cfb         	ldrb	r3, [r7, #0x13]
 800463e: f083 0301    	eor	r3, r3, #0x1
 8004642: b2db         	uxtb	r3, r3
 8004644: 2b00         	cmp	r3, #0x0
 8004646: d110         	bne	0x800466a <can_stm32_get_core_clock+0x62> @ imm = #0x20
 8004648: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8004680 <can_stm32_get_core_clock+0x78>
 800464a: 6819         	ldr	r1, [r3]
 800464c: 697b         	ldr	r3, [r7, #0x14]
 800464e: 9303         	str	r3, [sp, #0xc]
 8004650: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8004684 <can_stm32_get_core_clock+0x7c>
 8004652: 9302         	str	r3, [sp, #0x8]
 8004654: 2300         	movs	r3, #0x0
 8004656: 9301         	str	r3, [sp, #0x4]
 8004658: 2300         	movs	r3, #0x0
 800465a: 9300         	str	r3, [sp]
 800465c: 2300         	movs	r3, #0x0
 800465e: 2201         	movs	r2, #0x1
 8004660: 2000         	movs	r0, #0x0
 8004662: f00a ffd2    	bl	0x800f60a <z_log_msg_runtime_create> @ imm = #0xafa4
 8004666: 2300         	movs	r3, #0x0
 8004668: 60fb         	str	r3, [r7, #0xc]
; 		return -EIO;
 800466a: f06f 0304    	mvn	r3, #0x4
 800466e: e000         	b	0x8004672 <can_stm32_get_core_clock+0x6a> @ imm = #0x0
; 	return 0;
 8004670: 2300         	movs	r3, #0x0
; }
 8004672: 4618         	mov	r0, r3
 8004674: 3720         	adds	r7, #0x20
 8004676: 46bd         	mov	sp, r7
 8004678: bd80         	pop	{r7, pc}
 800467a: bf00         	nop

0800467c <$d>:
 800467c: a4 45 01 08  	.word	0x080145a4
 8004680: 48 00 00 20  	.word	0x20000048
 8004684: b8 53 01 08  	.word	0x080153b8

08004688 <can_stm32_init>:
; {
 8004688: b580         	push	{r7, lr}
 800468a: b0a6         	sub	sp, #0x98
 800468c: af08         	add	r7, sp, #0x20
 800468e: 6078         	str	r0, [r7, #0x4]
; 	const struct can_stm32_config *cfg = dev->config;
 8004690: 687b         	ldr	r3, [r7, #0x4]
 8004692: 685b         	ldr	r3, [r3, #0x4]
 8004694: 663b         	str	r3, [r7, #0x60]
; 	struct can_stm32_data *data = dev->data;
 8004696: 687b         	ldr	r3, [r7, #0x4]
 8004698: 691b         	ldr	r3, [r3, #0x10]
 800469a: 66bb         	str	r3, [r7, #0x68]
; 	CAN_TypeDef *can = cfg->can;
 800469c: 6e3b         	ldr	r3, [r7, #0x60]
 800469e: 695b         	ldr	r3, [r3, #0x14]
 80046a0: 667b         	str	r3, [r7, #0x64]
; 	struct can_timing timing = { 0 };
 80046a2: f107 030c    	add.w	r3, r7, #0xc
 80046a6: 2200         	movs	r2, #0x0
 80046a8: 601a         	str	r2, [r3]
 80046aa: 605a         	str	r2, [r3, #0x4]
 80046ac: 811a         	strh	r2, [r3, #0x8]
; 	k_mutex_init(&filter_mutex);
 80046ae: 4886         	ldr	r0, [pc, #0x218]        @ 0x80048c8 <can_stm32_init+0x240>
 80046b0: f00a feb8    	bl	0x800f424 <k_mutex_init> @ imm = #0xad70
; 	k_mutex_init(&data->inst_mutex);
 80046b4: 6ebb         	ldr	r3, [r7, #0x68]
 80046b6: 3310         	adds	r3, #0x10
 80046b8: 4618         	mov	r0, r3
 80046ba: f00a feb3    	bl	0x800f424 <k_mutex_init> @ imm = #0xad66
; 	k_sem_init(&data->tx_int_sem, 0, 1);
 80046be: 6ebb         	ldr	r3, [r7, #0x68]
 80046c0: 3324         	adds	r3, #0x24
 80046c2: 2201         	movs	r2, #0x1
 80046c4: 2100         	movs	r1, #0x0
 80046c6: 4618         	mov	r0, r3
 80046c8: f00a fed4    	bl	0x800f474 <k_sem_init>  @ imm = #0xada8
; 	if (cfg->common.phy != NULL) {
 80046cc: 6e3b         	ldr	r3, [r7, #0x60]
 80046ce: 681b         	ldr	r3, [r3]
 80046d0: 2b00         	cmp	r3, #0x0
 80046d2: d029         	beq	0x8004728 <can_stm32_init+0xa0> @ imm = #0x52
; 		if (!device_is_ready(cfg->common.phy)) {
 80046d4: 6e3b         	ldr	r3, [r7, #0x60]
 80046d6: 681b         	ldr	r3, [r3]
 80046d8: 4618         	mov	r0, r3
 80046da: f00a fe89    	bl	0x800f3f0 <device_is_ready> @ imm = #0xad12
 80046de: 4603         	mov	r3, r0
 80046e0: f083 0301    	eor	r3, r3, #0x1
 80046e4: b2db         	uxtb	r3, r3
 80046e6: 2b00         	cmp	r3, #0x0
 80046e8: d01e         	beq	0x8004728 <can_stm32_init+0xa0> @ imm = #0x3c
; 			LOG_ERR("CAN transceiver not ready");
 80046ea: 2303         	movs	r3, #0x3
 80046ec: 2b00         	cmp	r3, #0x0
 80046ee: d018         	beq	0x8004722 <can_stm32_init+0x9a> @ imm = #0x30
 80046f0: 2301         	movs	r3, #0x1
 80046f2: f887 306f    	strb.w	r3, [r7, #0x6f]
 80046f6: f897 306f    	ldrb.w	r3, [r7, #0x6f]
 80046fa: f083 0301    	eor	r3, r3, #0x1
 80046fe: b2db         	uxtb	r3, r3
 8004700: 2b00         	cmp	r3, #0x0
 8004702: d10e         	bne	0x8004722 <can_stm32_init+0x9a> @ imm = #0x1c
 8004704: 4b71         	ldr	r3, [pc, #0x1c4]        @ 0x80048cc <can_stm32_init+0x244>
 8004706: 6819         	ldr	r1, [r3]
 8004708: 4b71         	ldr	r3, [pc, #0x1c4]        @ 0x80048d0 <can_stm32_init+0x248>
 800470a: 9302         	str	r3, [sp, #0x8]
 800470c: 2300         	movs	r3, #0x0
 800470e: 9301         	str	r3, [sp, #0x4]
 8004710: 2300         	movs	r3, #0x0
 8004712: 9300         	str	r3, [sp]
 8004714: 2300         	movs	r3, #0x0
 8004716: 2201         	movs	r2, #0x1
 8004718: 2000         	movs	r0, #0x0
 800471a: f00a ff76    	bl	0x800f60a <z_log_msg_runtime_create> @ imm = #0xaeec
 800471e: 2300         	movs	r3, #0x0
 8004720: 673b         	str	r3, [r7, #0x70]
; 			return -ENODEV;
 8004722: f06f 0312    	mvn	r3, #0x12
 8004726: e1a8         	b	0x8004a7a <can_stm32_init+0x3f2> @ imm = #0x350
; 	clock = DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE);
 8004728: 4b6a         	ldr	r3, [pc, #0x1a8]        @ 0x80048d4 <can_stm32_init+0x24c>
 800472a: 677b         	str	r3, [r7, #0x74]
; 	if (!device_is_ready(clock)) {
 800472c: 6f78         	ldr	r0, [r7, #0x74]
 800472e: f00a fe5f    	bl	0x800f3f0 <device_is_ready> @ imm = #0xacbe
 8004732: 4603         	mov	r3, r0
 8004734: f083 0301    	eor	r3, r3, #0x1
 8004738: b2db         	uxtb	r3, r3
 800473a: 2b00         	cmp	r3, #0x0
 800473c: d01c         	beq	0x8004778 <can_stm32_init+0xf0> @ imm = #0x38
; 		LOG_ERR("clock control device not ready");
 800473e: 2303         	movs	r3, #0x3
 8004740: 2b00         	cmp	r3, #0x0
 8004742: d016         	beq	0x8004772 <can_stm32_init+0xea> @ imm = #0x2c
 8004744: 2301         	movs	r3, #0x1
 8004746: 77fb         	strb	r3, [r7, #0x1f]
 8004748: 7ffb         	ldrb	r3, [r7, #0x1f]
 800474a: f083 0301    	eor	r3, r3, #0x1
 800474e: b2db         	uxtb	r3, r3
 8004750: 2b00         	cmp	r3, #0x0
 8004752: d10e         	bne	0x8004772 <can_stm32_init+0xea> @ imm = #0x1c
 8004754: 4b5d         	ldr	r3, [pc, #0x174]        @ 0x80048cc <can_stm32_init+0x244>
 8004756: 6819         	ldr	r1, [r3]
 8004758: 4b5f         	ldr	r3, [pc, #0x17c]        @ 0x80048d8 <can_stm32_init+0x250>
 800475a: 9302         	str	r3, [sp, #0x8]
 800475c: 2300         	movs	r3, #0x0
 800475e: 9301         	str	r3, [sp, #0x4]
 8004760: 2300         	movs	r3, #0x0
 8004762: 9300         	str	r3, [sp]
 8004764: 2300         	movs	r3, #0x0
 8004766: 2201         	movs	r2, #0x1
 8004768: 2000         	movs	r0, #0x0
 800476a: f00a ff4e    	bl	0x800f60a <z_log_msg_runtime_create> @ imm = #0xae9c
 800476e: 2300         	movs	r3, #0x0
 8004770: 61bb         	str	r3, [r7, #0x18]
; 		return -ENODEV;
 8004772: f06f 0312    	mvn	r3, #0x12
 8004776: e180         	b	0x8004a7a <can_stm32_init+0x3f2> @ imm = #0x300
; 	ret = clock_control_on(clock, (clock_control_subsys_t) &cfg->pclken);
 8004778: 6e3b         	ldr	r3, [r7, #0x60]
 800477a: 331c         	adds	r3, #0x1c
 800477c: 4619         	mov	r1, r3
 800477e: 6f78         	ldr	r0, [r7, #0x74]
 8004780: f00a fee5    	bl	0x800f54e <clock_control_on> @ imm = #0xadca
 8004784: 65f8         	str	r0, [r7, #0x5c]
; 	if (ret != 0) {
 8004786: 6dfb         	ldr	r3, [r7, #0x5c]
 8004788: 2b00         	cmp	r3, #0x0
 800478a: d020         	beq	0x80047ce <can_stm32_init+0x146> @ imm = #0x40
; 		LOG_ERR("HAL_CAN_Init clock control on failed: %d", ret);
 800478c: 2303         	movs	r3, #0x3
 800478e: 2b00         	cmp	r3, #0x0
 8004790: d01a         	beq	0x80047c8 <can_stm32_init+0x140> @ imm = #0x34
 8004792: 2301         	movs	r3, #0x1
 8004794: f887 3027    	strb.w	r3, [r7, #0x27]
 8004798: f897 3027    	ldrb.w	r3, [r7, #0x27]
 800479c: f083 0301    	eor	r3, r3, #0x1
 80047a0: b2db         	uxtb	r3, r3
 80047a2: 2b00         	cmp	r3, #0x0
 80047a4: d110         	bne	0x80047c8 <can_stm32_init+0x140> @ imm = #0x20
 80047a6: 4b49         	ldr	r3, [pc, #0x124]        @ 0x80048cc <can_stm32_init+0x244>
 80047a8: 6819         	ldr	r1, [r3]
 80047aa: 6dfb         	ldr	r3, [r7, #0x5c]
 80047ac: 9303         	str	r3, [sp, #0xc]
 80047ae: 4b4b         	ldr	r3, [pc, #0x12c]        @ 0x80048dc <can_stm32_init+0x254>
 80047b0: 9302         	str	r3, [sp, #0x8]
 80047b2: 2300         	movs	r3, #0x0
 80047b4: 9301         	str	r3, [sp, #0x4]
 80047b6: 2300         	movs	r3, #0x0
 80047b8: 9300         	str	r3, [sp]
 80047ba: 2300         	movs	r3, #0x0
 80047bc: 2201         	movs	r2, #0x1
 80047be: 2000         	movs	r0, #0x0
 80047c0: f00a ff23    	bl	0x800f60a <z_log_msg_runtime_create> @ imm = #0xae46
 80047c4: 2300         	movs	r3, #0x0
 80047c6: 623b         	str	r3, [r7, #0x20]
; 		return -EIO;
 80047c8: f06f 0304    	mvn	r3, #0x4
 80047cc: e155         	b	0x8004a7a <can_stm32_init+0x3f2> @ imm = #0x2aa
; 	ret = pinctrl_apply_state(cfg->pcfg, PINCTRL_STATE_DEFAULT);
 80047ce: 6e3b         	ldr	r3, [r7, #0x60]
 80047d0: 6a9b         	ldr	r3, [r3, #0x28]
 80047d2: 2100         	movs	r1, #0x0
 80047d4: 4618         	mov	r0, r3
 80047d6: f00a fefb    	bl	0x800f5d0 <pinctrl_apply_state> @ imm = #0xadf6
 80047da: 65f8         	str	r0, [r7, #0x5c]
; 	if (ret < 0) {
 80047dc: 6dfb         	ldr	r3, [r7, #0x5c]
 80047de: 2b00         	cmp	r3, #0x0
 80047e0: da1f         	bge	0x8004822 <can_stm32_init+0x19a> @ imm = #0x3e
; 		LOG_ERR("CAN pinctrl setup failed (%d)", ret);
 80047e2: 2303         	movs	r3, #0x3
 80047e4: 2b00         	cmp	r3, #0x0
 80047e6: d01a         	beq	0x800481e <can_stm32_init+0x196> @ imm = #0x34
 80047e8: 2301         	movs	r3, #0x1
 80047ea: f887 302f    	strb.w	r3, [r7, #0x2f]
 80047ee: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 80047f2: f083 0301    	eor	r3, r3, #0x1
 80047f6: b2db         	uxtb	r3, r3
 80047f8: 2b00         	cmp	r3, #0x0
 80047fa: d110         	bne	0x800481e <can_stm32_init+0x196> @ imm = #0x20
 80047fc: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x80048cc <can_stm32_init+0x244>
 80047fe: 6819         	ldr	r1, [r3]
 8004800: 6dfb         	ldr	r3, [r7, #0x5c]
 8004802: 9303         	str	r3, [sp, #0xc]
 8004804: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x80048e0 <can_stm32_init+0x258>
 8004806: 9302         	str	r3, [sp, #0x8]
 8004808: 2300         	movs	r3, #0x0
 800480a: 9301         	str	r3, [sp, #0x4]
 800480c: 2300         	movs	r3, #0x0
 800480e: 9300         	str	r3, [sp]
 8004810: 2300         	movs	r3, #0x0
 8004812: 2201         	movs	r2, #0x1
 8004814: 2000         	movs	r0, #0x0
 8004816: f00a fef8    	bl	0x800f60a <z_log_msg_runtime_create> @ imm = #0xadf0
 800481a: 2300         	movs	r3, #0x0
 800481c: 62bb         	str	r3, [r7, #0x28]
; 		return ret;
 800481e: 6dfb         	ldr	r3, [r7, #0x5c]
 8004820: e12b         	b	0x8004a7a <can_stm32_init+0x3f2> @ imm = #0x256
; 	ret = can_stm32_enter_init_mode(can);
 8004822: 6e78         	ldr	r0, [r7, #0x64]
 8004824: f7ff fc3c    	bl	0x80040a0 <can_stm32_enter_init_mode> @ imm = #-0x788
 8004828: 65f8         	str	r0, [r7, #0x5c]
; 	if (ret) {
 800482a: 6dfb         	ldr	r3, [r7, #0x5c]
 800482c: 2b00         	cmp	r3, #0x0
 800482e: d01d         	beq	0x800486c <can_stm32_init+0x1e4> @ imm = #0x3a
; 		LOG_ERR("Failed to enter init mode");
 8004830: 2303         	movs	r3, #0x3
 8004832: 2b00         	cmp	r3, #0x0
 8004834: d018         	beq	0x8004868 <can_stm32_init+0x1e0> @ imm = #0x30
 8004836: 2301         	movs	r3, #0x1
 8004838: f887 3037    	strb.w	r3, [r7, #0x37]
 800483c: f897 3037    	ldrb.w	r3, [r7, #0x37]
 8004840: f083 0301    	eor	r3, r3, #0x1
 8004844: b2db         	uxtb	r3, r3
 8004846: 2b00         	cmp	r3, #0x0
 8004848: d10e         	bne	0x8004868 <can_stm32_init+0x1e0> @ imm = #0x1c
 800484a: 4b20         	ldr	r3, [pc, #0x80]         @ 0x80048cc <can_stm32_init+0x244>
 800484c: 6819         	ldr	r1, [r3]
 800484e: 4b25         	ldr	r3, [pc, #0x94]         @ 0x80048e4 <can_stm32_init+0x25c>
 8004850: 9302         	str	r3, [sp, #0x8]
 8004852: 2300         	movs	r3, #0x0
 8004854: 9301         	str	r3, [sp, #0x4]
 8004856: 2300         	movs	r3, #0x0
 8004858: 9300         	str	r3, [sp]
 800485a: 2300         	movs	r3, #0x0
 800485c: 2201         	movs	r2, #0x1
 800485e: 2000         	movs	r0, #0x0
 8004860: f00a fed3    	bl	0x800f60a <z_log_msg_runtime_create> @ imm = #0xada6
 8004864: 2300         	movs	r3, #0x0
 8004866: 633b         	str	r3, [r7, #0x30]
; 		return ret;
 8004868: 6dfb         	ldr	r3, [r7, #0x5c]
 800486a: e106         	b	0x8004a7a <can_stm32_init+0x3f2> @ imm = #0x20c
; 	ret = can_stm32_leave_sleep_mode(can);
 800486c: 6e78         	ldr	r0, [r7, #0x64]
 800486e: f7ff fc69    	bl	0x8004144 <can_stm32_leave_sleep_mode> @ imm = #-0x72e
 8004872: 65f8         	str	r0, [r7, #0x5c]
; 	if (ret) {
 8004874: 6dfb         	ldr	r3, [r7, #0x5c]
 8004876: 2b00         	cmp	r3, #0x0
 8004878: d01d         	beq	0x80048b6 <can_stm32_init+0x22e> @ imm = #0x3a
; 		LOG_ERR("Failed to exit sleep mode");
 800487a: 2303         	movs	r3, #0x3
 800487c: 2b00         	cmp	r3, #0x0
 800487e: d018         	beq	0x80048b2 <can_stm32_init+0x22a> @ imm = #0x30
 8004880: 2301         	movs	r3, #0x1
 8004882: f887 303f    	strb.w	r3, [r7, #0x3f]
 8004886: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 800488a: f083 0301    	eor	r3, r3, #0x1
 800488e: b2db         	uxtb	r3, r3
 8004890: 2b00         	cmp	r3, #0x0
 8004892: d10e         	bne	0x80048b2 <can_stm32_init+0x22a> @ imm = #0x1c
 8004894: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x80048cc <can_stm32_init+0x244>
 8004896: 6819         	ldr	r1, [r3]
 8004898: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x80048e8 <can_stm32_init+0x260>
 800489a: 9302         	str	r3, [sp, #0x8]
 800489c: 2300         	movs	r3, #0x0
 800489e: 9301         	str	r3, [sp, #0x4]
 80048a0: 2300         	movs	r3, #0x0
 80048a2: 9300         	str	r3, [sp]
 80048a4: 2300         	movs	r3, #0x0
 80048a6: 2201         	movs	r2, #0x1
 80048a8: 2000         	movs	r0, #0x0
 80048aa: f00a feae    	bl	0x800f60a <z_log_msg_runtime_create> @ imm = #0xad5c
 80048ae: 2300         	movs	r3, #0x0
 80048b0: 63bb         	str	r3, [r7, #0x38]
; 		return ret;
 80048b2: 6dfb         	ldr	r3, [r7, #0x5c]
 80048b4: e0e1         	b	0x8004a7a <can_stm32_init+0x3f2> @ imm = #0x1c2
; 	bank_offset = (cfg->can == cfg->master_can) ? 0 : CAN_STM32_NUM_FILTER_BANKS;
 80048b6: 6e3b         	ldr	r3, [r7, #0x60]
 80048b8: 695a         	ldr	r2, [r3, #0x14]
 80048ba: 6e3b         	ldr	r3, [r7, #0x60]
 80048bc: 699b         	ldr	r3, [r3, #0x18]
 80048be: 429a         	cmp	r2, r3
 80048c0: d114         	bne	0x80048ec <can_stm32_init+0x264> @ imm = #0x28
 80048c2: 2300         	movs	r3, #0x0
 80048c4: e013         	b	0x80048ee <can_stm32_init+0x266> @ imm = #0x26
 80048c6: bf00         	nop

080048c8 <$d>:
 80048c8: 84 06 00 20  	.word	0x20000684
 80048cc: 48 00 00 20  	.word	0x20000048
 80048d0: e8 53 01 08  	.word	0x080153e8
 80048d4: a4 45 01 08  	.word	0x080145a4
 80048d8: 04 54 01 08  	.word	0x08015404
 80048dc: 24 54 01 08  	.word	0x08015424
 80048e0: 50 54 01 08  	.word	0x08015450
 80048e4: 70 53 01 08  	.word	0x08015370
 80048e8: 70 54 01 08  	.word	0x08015470

080048ec <$t>:
 80048ec: 230e         	movs	r3, #0xe
 80048ee: 65bb         	str	r3, [r7, #0x58]
; 	cfg->master_can->FMR |= CAN_FMR_FINIT;
 80048f0: 6e3b         	ldr	r3, [r7, #0x60]
 80048f2: 699b         	ldr	r3, [r3, #0x18]
 80048f4: f8d3 2200    	ldr.w	r2, [r3, #0x200]
 80048f8: 6e3b         	ldr	r3, [r7, #0x60]
 80048fa: 699b         	ldr	r3, [r3, #0x18]
 80048fc: f042 0201    	orr	r2, r2, #0x1
 8004900: f8c3 2200    	str.w	r2, [r3, #0x200]
; 	cfg->master_can->FS1R |= ((1U << CONFIG_CAN_MAX_EXT_ID_FILTER) - 1) << bank_offset;
 8004904: 6e3b         	ldr	r3, [r7, #0x60]
 8004906: 699b         	ldr	r3, [r3, #0x18]
 8004908: f8d3 120c    	ldr.w	r1, [r3, #0x20c]
 800490c: 227f         	movs	r2, #0x7f
 800490e: 6dbb         	ldr	r3, [r7, #0x58]
 8004910: 409a         	lsls	r2, r3
 8004912: 6e3b         	ldr	r3, [r7, #0x60]
 8004914: 699b         	ldr	r3, [r3, #0x18]
 8004916: 430a         	orrs	r2, r1
 8004918: f8c3 220c    	str.w	r2, [r3, #0x20c]
; 	cfg->master_can->FMR &= ~CAN_FMR_FINIT;
 800491c: 6e3b         	ldr	r3, [r7, #0x60]
 800491e: 699b         	ldr	r3, [r3, #0x18]
 8004920: f8d3 2200    	ldr.w	r2, [r3, #0x200]
 8004924: 6e3b         	ldr	r3, [r7, #0x60]
 8004926: 699b         	ldr	r3, [r3, #0x18]
 8004928: f022 0201    	bic	r2, r2, #0x1
 800492c: f8c3 2200    	str.w	r2, [r3, #0x200]
; 	can->MCR &= ~CAN_MCR_TTCM & ~CAN_MCR_ABOM & ~CAN_MCR_AWUM &
 8004930: 6e7b         	ldr	r3, [r7, #0x64]
 8004932: 681b         	ldr	r3, [r3]
 8004934: f023 02fc    	bic	r2, r3, #0xfc
 8004938: 6e7b         	ldr	r3, [r7, #0x64]
 800493a: 601a         	str	r2, [r3]
; 	can->MCR |= CAN_MCR_ABOM;
 800493c: 6e7b         	ldr	r3, [r7, #0x64]
 800493e: 681b         	ldr	r3, [r3]
 8004940: f043 0240    	orr	r2, r3, #0x40
 8004944: 6e7b         	ldr	r3, [r7, #0x64]
 8004946: 601a         	str	r2, [r3]
; 	ret = can_calc_timing(dev, &timing, cfg->common.bitrate,
 8004948: 6e3b         	ldr	r3, [r7, #0x60]
 800494a: 68da         	ldr	r2, [r3, #0xc]
; 			      cfg->common.sample_point);
 800494c: 6e3b         	ldr	r3, [r7, #0x60]
 800494e: 8a1b         	ldrh	r3, [r3, #0x10]
; 	ret = can_calc_timing(dev, &timing, cfg->common.bitrate,
 8004950: f107 010c    	add.w	r1, r7, #0xc
 8004954: 6878         	ldr	r0, [r7, #0x4]
 8004956: f00a fdb8    	bl	0x800f4ca <can_calc_timing> @ imm = #0xab70
 800495a: 65f8         	str	r0, [r7, #0x5c]
; 	if (ret == -EINVAL) {
 800495c: 6dfb         	ldr	r3, [r7, #0x5c]
 800495e: f113 0f16    	cmn.w	r3, #0x16
 8004962: d11e         	bne	0x80049a2 <can_stm32_init+0x31a> @ imm = #0x3c
; 		LOG_ERR("Can't find timing for given param");
 8004964: 2303         	movs	r3, #0x3
 8004966: 2b00         	cmp	r3, #0x0
 8004968: d018         	beq	0x800499c <can_stm32_init+0x314> @ imm = #0x30
 800496a: 2301         	movs	r3, #0x1
 800496c: f887 3047    	strb.w	r3, [r7, #0x47]
 8004970: f897 3047    	ldrb.w	r3, [r7, #0x47]
 8004974: f083 0301    	eor	r3, r3, #0x1
 8004978: b2db         	uxtb	r3, r3
 800497a: 2b00         	cmp	r3, #0x0
 800497c: d10e         	bne	0x800499c <can_stm32_init+0x314> @ imm = #0x1c
 800497e: 4b41         	ldr	r3, [pc, #0x104]        @ 0x8004a84 <can_stm32_init+0x3fc>
 8004980: 6819         	ldr	r1, [r3]
 8004982: 4b41         	ldr	r3, [pc, #0x104]        @ 0x8004a88 <can_stm32_init+0x400>
 8004984: 9302         	str	r3, [sp, #0x8]
 8004986: 2300         	movs	r3, #0x0
 8004988: 9301         	str	r3, [sp, #0x4]
 800498a: 2300         	movs	r3, #0x0
 800498c: 9300         	str	r3, [sp]
 800498e: 2300         	movs	r3, #0x0
 8004990: 2201         	movs	r2, #0x1
 8004992: 2000         	movs	r0, #0x0
 8004994: f00a fe39    	bl	0x800f60a <z_log_msg_runtime_create> @ imm = #0xac72
 8004998: 2300         	movs	r3, #0x0
 800499a: 643b         	str	r3, [r7, #0x40]
; 		return -EIO;
 800499c: f06f 0304    	mvn	r3, #0x4
 80049a0: e06b         	b	0x8004a7a <can_stm32_init+0x3f2> @ imm = #0xd6
; 	LOG_DBG("Presc: %d, TS1: %d, TS2: %d",
 80049a2: 2303         	movs	r3, #0x3
 80049a4: 2b03         	cmp	r3, #0x3
 80049a6: d920         	bls	0x80049ea <can_stm32_init+0x362> @ imm = #0x40
 80049a8: 2301         	movs	r3, #0x1
 80049aa: f887 3057    	strb.w	r3, [r7, #0x57]
 80049ae: f897 3057    	ldrb.w	r3, [r7, #0x57]
 80049b2: f083 0301    	eor	r3, r3, #0x1
 80049b6: b2db         	uxtb	r3, r3
 80049b8: 2b00         	cmp	r3, #0x0
 80049ba: d116         	bne	0x80049ea <can_stm32_init+0x362> @ imm = #0x2c
 80049bc: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x8004a84 <can_stm32_init+0x3fc>
 80049be: 6819         	ldr	r1, [r3]
 80049c0: 8abb         	ldrh	r3, [r7, #0x14]
 80049c2: 8a3a         	ldrh	r2, [r7, #0x10]
 80049c4: 8a78         	ldrh	r0, [r7, #0x12]
 80049c6: 9006         	str	r0, [sp, #0x18]
 80049c8: 9205         	str	r2, [sp, #0x14]
 80049ca: 9304         	str	r3, [sp, #0x10]
 80049cc: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x8004a8c <can_stm32_init+0x404>
 80049ce: 9303         	str	r3, [sp, #0xc]
 80049d0: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x8004a90 <can_stm32_init+0x408>
 80049d2: 9302         	str	r3, [sp, #0x8]
 80049d4: 2308         	movs	r3, #0x8
 80049d6: 9301         	str	r3, [sp, #0x4]
 80049d8: 2300         	movs	r3, #0x0
 80049da: 9300         	str	r3, [sp]
 80049dc: 2300         	movs	r3, #0x0
 80049de: 2204         	movs	r2, #0x4
 80049e0: 2000         	movs	r0, #0x0
 80049e2: f00a fe12    	bl	0x800f60a <z_log_msg_runtime_create> @ imm = #0xac24
 80049e6: 2300         	movs	r3, #0x0
 80049e8: 653b         	str	r3, [r7, #0x50]
; 	LOG_DBG("Sample-point err : %d", ret);
 80049ea: 2303         	movs	r3, #0x3
 80049ec: 2b03         	cmp	r3, #0x3
 80049ee: d91c         	bls	0x8004a2a <can_stm32_init+0x3a2> @ imm = #0x38
 80049f0: 2301         	movs	r3, #0x1
 80049f2: f887 304f    	strb.w	r3, [r7, #0x4f]
 80049f6: f897 304f    	ldrb.w	r3, [r7, #0x4f]
 80049fa: f083 0301    	eor	r3, r3, #0x1
 80049fe: b2db         	uxtb	r3, r3
 8004a00: 2b00         	cmp	r3, #0x0
 8004a02: d112         	bne	0x8004a2a <can_stm32_init+0x3a2> @ imm = #0x24
 8004a04: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x8004a84 <can_stm32_init+0x3fc>
 8004a06: 6819         	ldr	r1, [r3]
 8004a08: 6dfb         	ldr	r3, [r7, #0x5c]
 8004a0a: 9304         	str	r3, [sp, #0x10]
 8004a0c: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x8004a8c <can_stm32_init+0x404>
 8004a0e: 9303         	str	r3, [sp, #0xc]
 8004a10: 4b20         	ldr	r3, [pc, #0x80]         @ 0x8004a94 <can_stm32_init+0x40c>
 8004a12: 9302         	str	r3, [sp, #0x8]
 8004a14: 2308         	movs	r3, #0x8
 8004a16: 9301         	str	r3, [sp, #0x4]
 8004a18: 2300         	movs	r3, #0x0
 8004a1a: 9300         	str	r3, [sp]
 8004a1c: 2300         	movs	r3, #0x0
 8004a1e: 2204         	movs	r2, #0x4
 8004a20: 2000         	movs	r0, #0x0
 8004a22: f00a fdf2    	bl	0x800f60a <z_log_msg_runtime_create> @ imm = #0xabe4
 8004a26: 2300         	movs	r3, #0x0
 8004a28: 64bb         	str	r3, [r7, #0x48]
; 	ret = can_set_timing(dev, &timing);
 8004a2a: f107 030c    	add.w	r3, r7, #0xc
 8004a2e: 4619         	mov	r1, r3
 8004a30: 6878         	ldr	r0, [r7, #0x4]
 8004a32: f00a fd5c    	bl	0x800f4ee <can_set_timing> @ imm = #0xaab8
 8004a36: 65f8         	str	r0, [r7, #0x5c]
; 	if (ret) {
 8004a38: 6dfb         	ldr	r3, [r7, #0x5c]
 8004a3a: 2b00         	cmp	r3, #0x0
 8004a3c: d001         	beq	0x8004a42 <can_stm32_init+0x3ba> @ imm = #0x2
; 		return ret;
 8004a3e: 6dfb         	ldr	r3, [r7, #0x5c]
 8004a40: e01b         	b	0x8004a7a <can_stm32_init+0x3f2> @ imm = #0x36
; 	ret = can_stm32_set_mode(dev, CAN_MODE_NORMAL);
 8004a42: 2100         	movs	r1, #0x0
 8004a44: 6878         	ldr	r0, [r7, #0x4]
 8004a46: f7ff fcdd    	bl	0x8004404 <can_stm32_set_mode> @ imm = #-0x646
 8004a4a: 65f8         	str	r0, [r7, #0x5c]
; 	if (ret) {
 8004a4c: 6dfb         	ldr	r3, [r7, #0x5c]
 8004a4e: 2b00         	cmp	r3, #0x0
 8004a50: d001         	beq	0x8004a56 <can_stm32_init+0x3ce> @ imm = #0x2
; 		return ret;
 8004a52: 6dfb         	ldr	r3, [r7, #0x5c]
 8004a54: e011         	b	0x8004a7a <can_stm32_init+0x3f2> @ imm = #0x22
; 	(void)can_stm32_get_state(dev, &data->state, NULL);
 8004a56: 6ebb         	ldr	r3, [r7, #0x68]
 8004a58: 33f4         	adds	r3, #0xf4
 8004a5a: 2200         	movs	r2, #0x0
 8004a5c: 4619         	mov	r1, r3
 8004a5e: 6878         	ldr	r0, [r7, #0x4]
 8004a60: f00a fe4e    	bl	0x800f700 <can_stm32_get_state> @ imm = #0xac9c
; 	cfg->config_irq(can);
 8004a64: 6e3b         	ldr	r3, [r7, #0x60]
 8004a66: 6a5b         	ldr	r3, [r3, #0x24]
 8004a68: 6e78         	ldr	r0, [r7, #0x64]
 8004a6a: 4798         	blx	r3
; 	can->IER |= CAN_IER_TMEIE;
 8004a6c: 6e7b         	ldr	r3, [r7, #0x64]
 8004a6e: 695b         	ldr	r3, [r3, #0x14]
 8004a70: f043 0201    	orr	r2, r3, #0x1
 8004a74: 6e7b         	ldr	r3, [r7, #0x64]
 8004a76: 615a         	str	r2, [r3, #0x14]
; 	return 0;
 8004a78: 2300         	movs	r3, #0x0
; }
 8004a7a: 4618         	mov	r0, r3
 8004a7c: 3778         	adds	r7, #0x78
 8004a7e: 46bd         	mov	sp, r7
 8004a80: bd80         	pop	{r7, pc}
 8004a82: bf00         	nop

08004a84 <$d>:
 8004a84: 48 00 00 20  	.word	0x20000048
 8004a88: 8c 54 01 08  	.word	0x0801548c
 8004a8c: e0 63 01 08  	.word	0x080163e0
 8004a90: b0 54 01 08  	.word	0x080154b0
 8004a94: d0 54 01 08  	.word	0x080154d0

08004a98 <can_stm32_send>:
; {
 8004a98: b5b0         	push	{r4, r5, r7, lr}
 8004a9a: b0a2         	sub	sp, #0x88
 8004a9c: af0a         	add	r7, sp, #0x28
 8004a9e: 60f8         	str	r0, [r7, #0xc]
 8004aa0: 60b9         	str	r1, [r7, #0x8]
 8004aa2: e9c7 2300    	strd	r2, r3, [r7]
; 	const struct can_stm32_config *cfg = dev->config;
 8004aa6: 68fb         	ldr	r3, [r7, #0xc]
 8004aa8: 685b         	ldr	r3, [r3, #0x4]
 8004aaa: 643b         	str	r3, [r7, #0x40]
; 	struct can_stm32_data *data = dev->data;
 8004aac: 68fb         	ldr	r3, [r7, #0xc]
 8004aae: 691b         	ldr	r3, [r3, #0x10]
 8004ab0: 63fb         	str	r3, [r7, #0x3c]
; 	CAN_TypeDef *can = cfg->can;
 8004ab2: 6c3b         	ldr	r3, [r7, #0x40]
 8004ab4: 695b         	ldr	r3, [r3, #0x14]
 8004ab6: 63bb         	str	r3, [r7, #0x38]
; 	uint32_t transmit_status_register = 0;
 8004ab8: 2300         	movs	r3, #0x0
 8004aba: 65bb         	str	r3, [r7, #0x58]
; 	CAN_TxMailBox_TypeDef *mailbox = NULL;
 8004abc: 2300         	movs	r3, #0x0
 8004abe: 64fb         	str	r3, [r7, #0x4c]
; 	struct can_stm32_mailbox *mb = NULL;
 8004ac0: 2300         	movs	r3, #0x0
 8004ac2: 64bb         	str	r3, [r7, #0x48]
; 	LOG_DBG("Sending %d bytes on %s. "
 8004ac4: 2303         	movs	r3, #0x3
 8004ac6: 2b03         	cmp	r3, #0x3
 8004ac8: d939         	bls	0x8004b3e <can_stm32_send+0xa6> @ imm = #0x72
 8004aca: 2301         	movs	r3, #0x1
 8004acc: f887 3047    	strb.w	r3, [r7, #0x47]
 8004ad0: f897 3047    	ldrb.w	r3, [r7, #0x47]
 8004ad4: f083 0301    	eor	r3, r3, #0x1
 8004ad8: b2db         	uxtb	r3, r3
 8004ada: 2b00         	cmp	r3, #0x0
 8004adc: d12f         	bne	0x8004b3e <can_stm32_send+0xa6> @ imm = #0x5e
 8004ade: 4b9c         	ldr	r3, [pc, #0x270]        @ 0x8004d50 <can_stm32_send+0x2b8>
 8004ae0: 681c         	ldr	r4, [r3]
 8004ae2: 68bb         	ldr	r3, [r7, #0x8]
 8004ae4: 791b         	ldrb	r3, [r3, #0x4]
 8004ae6: 461d         	mov	r5, r3
 8004ae8: 68fb         	ldr	r3, [r7, #0xc]
 8004aea: 681b         	ldr	r3, [r3]
 8004aec: 68ba         	ldr	r2, [r7, #0x8]
 8004aee: 6812         	ldr	r2, [r2]
 8004af0: 68b9         	ldr	r1, [r7, #0x8]
 8004af2: 7949         	ldrb	r1, [r1, #0x5]
 8004af4: f001 0101    	and	r1, r1, #0x1
 8004af8: 2900         	cmp	r1, #0x0
 8004afa: d001         	beq	0x8004b00 <can_stm32_send+0x68> @ imm = #0x2
 8004afc: 4995         	ldr	r1, [pc, #0x254]        @ 0x8004d54 <can_stm32_send+0x2bc>
 8004afe: e000         	b	0x8004b02 <can_stm32_send+0x6a> @ imm = #0x0
 8004b00: 4995         	ldr	r1, [pc, #0x254]        @ 0x8004d58 <can_stm32_send+0x2c0>
 8004b02: 68b8         	ldr	r0, [r7, #0x8]
 8004b04: 7940         	ldrb	r0, [r0, #0x5]
 8004b06: f000 0002    	and	r0, r0, #0x2
 8004b0a: 2800         	cmp	r0, #0x0
 8004b0c: d001         	beq	0x8004b12 <can_stm32_send+0x7a> @ imm = #0x2
 8004b0e: 4893         	ldr	r0, [pc, #0x24c]        @ 0x8004d5c <can_stm32_send+0x2c4>
 8004b10: e000         	b	0x8004b14 <can_stm32_send+0x7c> @ imm = #0x0
 8004b12: 4893         	ldr	r0, [pc, #0x24c]        @ 0x8004d60 <can_stm32_send+0x2c8>
 8004b14: 9008         	str	r0, [sp, #0x20]
 8004b16: 9107         	str	r1, [sp, #0x1c]
 8004b18: 9206         	str	r2, [sp, #0x18]
 8004b1a: 9305         	str	r3, [sp, #0x14]
 8004b1c: 9504         	str	r5, [sp, #0x10]
 8004b1e: 4b91         	ldr	r3, [pc, #0x244]        @ 0x8004d64 <can_stm32_send+0x2cc>
 8004b20: 9303         	str	r3, [sp, #0xc]
 8004b22: 4b91         	ldr	r3, [pc, #0x244]        @ 0x8004d68 <can_stm32_send+0x2d0>
 8004b24: 9302         	str	r3, [sp, #0x8]
 8004b26: 2308         	movs	r3, #0x8
 8004b28: 9301         	str	r3, [sp, #0x4]
 8004b2a: 2300         	movs	r3, #0x0
 8004b2c: 9300         	str	r3, [sp]
 8004b2e: 2300         	movs	r3, #0x0
 8004b30: 2204         	movs	r2, #0x4
 8004b32: 4621         	mov	r1, r4
 8004b34: 2000         	movs	r0, #0x0
 8004b36: f00a fd68    	bl	0x800f60a <z_log_msg_runtime_create> @ imm = #0xaad0
 8004b3a: 2300         	movs	r3, #0x0
 8004b3c: 65fb         	str	r3, [r7, #0x5c]
; 	if (frame->dlc > CAN_MAX_DLC) {
 8004b3e: 68bb         	ldr	r3, [r7, #0x8]
 8004b40: 791b         	ldrb	r3, [r3, #0x4]
 8004b42: 2b08         	cmp	r3, #0x8
 8004b44: d922         	bls	0x8004b8c <can_stm32_send+0xf4> @ imm = #0x44
; 		LOG_ERR("DLC of %d exceeds maximum (%d)", frame->dlc, CAN_MAX_DLC);
 8004b46: 2303         	movs	r3, #0x3
 8004b48: 2b00         	cmp	r3, #0x0
 8004b4a: d01c         	beq	0x8004b86 <can_stm32_send+0xee> @ imm = #0x38
 8004b4c: 2301         	movs	r3, #0x1
 8004b4e: 75fb         	strb	r3, [r7, #0x17]
 8004b50: 7dfb         	ldrb	r3, [r7, #0x17]
 8004b52: f083 0301    	eor	r3, r3, #0x1
 8004b56: b2db         	uxtb	r3, r3
 8004b58: 2b00         	cmp	r3, #0x0
 8004b5a: d114         	bne	0x8004b86 <can_stm32_send+0xee> @ imm = #0x28
 8004b5c: 4b7c         	ldr	r3, [pc, #0x1f0]        @ 0x8004d50 <can_stm32_send+0x2b8>
 8004b5e: 6819         	ldr	r1, [r3]
 8004b60: 68bb         	ldr	r3, [r7, #0x8]
 8004b62: 791b         	ldrb	r3, [r3, #0x4]
 8004b64: 461a         	mov	r2, r3
 8004b66: 2308         	movs	r3, #0x8
 8004b68: 9304         	str	r3, [sp, #0x10]
 8004b6a: 9203         	str	r2, [sp, #0xc]
 8004b6c: 4b7f         	ldr	r3, [pc, #0x1fc]        @ 0x8004d6c <can_stm32_send+0x2d4>
 8004b6e: 9302         	str	r3, [sp, #0x8]
 8004b70: 2300         	movs	r3, #0x0
 8004b72: 9301         	str	r3, [sp, #0x4]
 8004b74: 2300         	movs	r3, #0x0
 8004b76: 9300         	str	r3, [sp]
 8004b78: 2300         	movs	r3, #0x0
 8004b7a: 2201         	movs	r2, #0x1
 8004b7c: 2000         	movs	r0, #0x0
 8004b7e: f00a fd44    	bl	0x800f60a <z_log_msg_runtime_create> @ imm = #0xaa88
 8004b82: 2300         	movs	r3, #0x0
 8004b84: 613b         	str	r3, [r7, #0x10]
; 		return -EINVAL;
 8004b86: f06f 0315    	mvn	r3, #0x15
 8004b8a: e174         	b	0x8004e76 <can_stm32_send+0x3de> @ imm = #0x2e8
; 	if ((frame->flags & ~(CAN_FRAME_IDE | CAN_FRAME_RTR)) != 0) {
 8004b8c: 68bb         	ldr	r3, [r7, #0x8]
 8004b8e: 795b         	ldrb	r3, [r3, #0x5]
 8004b90: 2b03         	cmp	r3, #0x3
 8004b92: d91f         	bls	0x8004bd4 <can_stm32_send+0x13c> @ imm = #0x3e
; 		LOG_ERR("unsupported CAN frame flags 0x%02x", frame->flags);
 8004b94: 2303         	movs	r3, #0x3
 8004b96: 2b00         	cmp	r3, #0x0
 8004b98: d019         	beq	0x8004bce <can_stm32_send+0x136> @ imm = #0x32
 8004b9a: 2301         	movs	r3, #0x1
 8004b9c: 77fb         	strb	r3, [r7, #0x1f]
 8004b9e: 7ffb         	ldrb	r3, [r7, #0x1f]
 8004ba0: f083 0301    	eor	r3, r3, #0x1
 8004ba4: b2db         	uxtb	r3, r3
 8004ba6: 2b00         	cmp	r3, #0x0
 8004ba8: d111         	bne	0x8004bce <can_stm32_send+0x136> @ imm = #0x22
 8004baa: 4b69         	ldr	r3, [pc, #0x1a4]        @ 0x8004d50 <can_stm32_send+0x2b8>
 8004bac: 6819         	ldr	r1, [r3]
 8004bae: 68bb         	ldr	r3, [r7, #0x8]
 8004bb0: 795b         	ldrb	r3, [r3, #0x5]
 8004bb2: 9303         	str	r3, [sp, #0xc]
 8004bb4: 4b6e         	ldr	r3, [pc, #0x1b8]        @ 0x8004d70 <can_stm32_send+0x2d8>
 8004bb6: 9302         	str	r3, [sp, #0x8]
 8004bb8: 2300         	movs	r3, #0x0
 8004bba: 9301         	str	r3, [sp, #0x4]
 8004bbc: 2300         	movs	r3, #0x0
 8004bbe: 9300         	str	r3, [sp]
 8004bc0: 2300         	movs	r3, #0x0
 8004bc2: 2201         	movs	r2, #0x1
 8004bc4: 2000         	movs	r0, #0x0
 8004bc6: f00a fd20    	bl	0x800f60a <z_log_msg_runtime_create> @ imm = #0xaa40
 8004bca: 2300         	movs	r3, #0x0
 8004bcc: 61bb         	str	r3, [r7, #0x18]
; 		return -ENOTSUP;
 8004bce: f06f 0385    	mvn	r3, #0x85
 8004bd2: e150         	b	0x8004e76 <can_stm32_send+0x3de> @ imm = #0x2a0
; 	if (!data->common.started) {
 8004bd4: 6bfb         	ldr	r3, [r7, #0x3c]
 8004bd6: 791b         	ldrb	r3, [r3, #0x4]
 8004bd8: f083 0301    	eor	r3, r3, #0x1
 8004bdc: b2db         	uxtb	r3, r3
 8004bde: 2b00         	cmp	r3, #0x0
 8004be0: d002         	beq	0x8004be8 <can_stm32_send+0x150> @ imm = #0x4
; 		return -ENETDOWN;
 8004be2: f06f 0372    	mvn	r3, #0x72
 8004be6: e146         	b	0x8004e76 <can_stm32_send+0x3de> @ imm = #0x28c
; 	if (can->ESR & CAN_ESR_BOFF) {
 8004be8: 6bbb         	ldr	r3, [r7, #0x38]
 8004bea: 699b         	ldr	r3, [r3, #0x18]
 8004bec: f003 0304    	and	r3, r3, #0x4
 8004bf0: 2b00         	cmp	r3, #0x0
 8004bf2: d002         	beq	0x8004bfa <can_stm32_send+0x162> @ imm = #0x4
; 		return -ENETUNREACH;
 8004bf4: f06f 0371    	mvn	r3, #0x71
 8004bf8: e13d         	b	0x8004e76 <can_stm32_send+0x3de> @ imm = #0x27a
; 	k_mutex_lock(&data->inst_mutex, K_FOREVER);
 8004bfa: 6bfb         	ldr	r3, [r7, #0x3c]
 8004bfc: f103 0410    	add.w	r4, r3, #0x10
 8004c00: f04f 30ff    	mov.w	r0, #0xffffffff
 8004c04: f04f 31ff    	mov.w	r1, #0xffffffff
 8004c08: 4602         	mov	r2, r0
 8004c0a: 460b         	mov	r3, r1
 8004c0c: 4620         	mov	r0, r4
 8004c0e: f00a fc15    	bl	0x800f43c <k_mutex_lock> @ imm = #0xa82a
; 	transmit_status_register = can->TSR;
 8004c12: 6bbb         	ldr	r3, [r7, #0x38]
 8004c14: 689b         	ldr	r3, [r3, #0x8]
 8004c16: 65bb         	str	r3, [r7, #0x58]
; 	while (!(transmit_status_register & CAN_TSR_TME)) {
 8004c18: e03f         	b	0x8004c9a <can_stm32_send+0x202> @ imm = #0x7e
; 		k_mutex_unlock(&data->inst_mutex);
 8004c1a: 6bfb         	ldr	r3, [r7, #0x3c]
 8004c1c: 3310         	adds	r3, #0x10
 8004c1e: 4618         	mov	r0, r3
 8004c20: f00a fc1c    	bl	0x800f45c <k_mutex_unlock> @ imm = #0xa838
; 		LOG_DBG("Transmit buffer full");
 8004c24: 2303         	movs	r3, #0x3
 8004c26: 2b03         	cmp	r3, #0x3
 8004c28: d91a         	bls	0x8004c60 <can_stm32_send+0x1c8> @ imm = #0x34
 8004c2a: 2301         	movs	r3, #0x1
 8004c2c: f887 3027    	strb.w	r3, [r7, #0x27]
 8004c30: f897 3027    	ldrb.w	r3, [r7, #0x27]
 8004c34: f083 0301    	eor	r3, r3, #0x1
 8004c38: b2db         	uxtb	r3, r3
 8004c3a: 2b00         	cmp	r3, #0x0
 8004c3c: d110         	bne	0x8004c60 <can_stm32_send+0x1c8> @ imm = #0x20
 8004c3e: 4b44         	ldr	r3, [pc, #0x110]        @ 0x8004d50 <can_stm32_send+0x2b8>
 8004c40: 6819         	ldr	r1, [r3]
 8004c42: 4b48         	ldr	r3, [pc, #0x120]        @ 0x8004d64 <can_stm32_send+0x2cc>
 8004c44: 9303         	str	r3, [sp, #0xc]
 8004c46: 4b4b         	ldr	r3, [pc, #0x12c]        @ 0x8004d74 <can_stm32_send+0x2dc>
 8004c48: 9302         	str	r3, [sp, #0x8]
 8004c4a: 2308         	movs	r3, #0x8
 8004c4c: 9301         	str	r3, [sp, #0x4]
 8004c4e: 2300         	movs	r3, #0x0
 8004c50: 9300         	str	r3, [sp]
 8004c52: 2300         	movs	r3, #0x0
 8004c54: 2204         	movs	r2, #0x4
 8004c56: 2000         	movs	r0, #0x0
 8004c58: f00a fcd7    	bl	0x800f60a <z_log_msg_runtime_create> @ imm = #0xa9ae
 8004c5c: 2300         	movs	r3, #0x0
 8004c5e: 623b         	str	r3, [r7, #0x20]
; 		if (k_sem_take(&data->tx_int_sem, timeout)) {
 8004c60: 6bfb         	ldr	r3, [r7, #0x3c]
 8004c62: f103 0124    	add.w	r1, r3, #0x24
 8004c66: e9d7 2300    	ldrd	r2, r3, [r7]
 8004c6a: 4608         	mov	r0, r1
 8004c6c: f00a fc12    	bl	0x800f494 <k_sem_take>  @ imm = #0xa824
 8004c70: 4603         	mov	r3, r0
 8004c72: 2b00         	cmp	r3, #0x0
 8004c74: d002         	beq	0x8004c7c <can_stm32_send+0x1e4> @ imm = #0x4
; 			return -EAGAIN;
 8004c76: f06f 030a    	mvn	r3, #0xa
 8004c7a: e0fc         	b	0x8004e76 <can_stm32_send+0x3de> @ imm = #0x1f8
; 		k_mutex_lock(&data->inst_mutex, K_FOREVER);
 8004c7c: 6bfb         	ldr	r3, [r7, #0x3c]
 8004c7e: f103 0410    	add.w	r4, r3, #0x10
 8004c82: f04f 30ff    	mov.w	r0, #0xffffffff
 8004c86: f04f 31ff    	mov.w	r1, #0xffffffff
 8004c8a: 4602         	mov	r2, r0
 8004c8c: 460b         	mov	r3, r1
 8004c8e: 4620         	mov	r0, r4
 8004c90: f00a fbd4    	bl	0x800f43c <k_mutex_lock> @ imm = #0xa7a8
; 		transmit_status_register = can->TSR;
 8004c94: 6bbb         	ldr	r3, [r7, #0x38]
 8004c96: 689b         	ldr	r3, [r3, #0x8]
 8004c98: 65bb         	str	r3, [r7, #0x58]
; 	while (!(transmit_status_register & CAN_TSR_TME)) {
 8004c9a: 6dbb         	ldr	r3, [r7, #0x58]
 8004c9c: f003 53e0    	and	r3, r3, #0x1c000000
 8004ca0: 2b00         	cmp	r3, #0x0
 8004ca2: d0ba         	beq	0x8004c1a <can_stm32_send+0x182> @ imm = #-0x8c
; 	if (transmit_status_register & CAN_TSR_TME0) {
 8004ca4: 6dbb         	ldr	r3, [r7, #0x58]
 8004ca6: f003 6380    	and	r3, r3, #0x4000000
 8004caa: 2b00         	cmp	r3, #0x0
 8004cac: d025         	beq	0x8004cfa <can_stm32_send+0x262> @ imm = #0x4a
; 		LOG_DBG("Using TX mailbox 0");
 8004cae: 2303         	movs	r3, #0x3
 8004cb0: 2b03         	cmp	r3, #0x3
 8004cb2: d91a         	bls	0x8004cea <can_stm32_send+0x252> @ imm = #0x34
 8004cb4: 2301         	movs	r3, #0x1
 8004cb6: f887 302f    	strb.w	r3, [r7, #0x2f]
 8004cba: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 8004cbe: f083 0301    	eor	r3, r3, #0x1
 8004cc2: b2db         	uxtb	r3, r3
 8004cc4: 2b00         	cmp	r3, #0x0
 8004cc6: d110         	bne	0x8004cea <can_stm32_send+0x252> @ imm = #0x20
 8004cc8: 4b21         	ldr	r3, [pc, #0x84]         @ 0x8004d50 <can_stm32_send+0x2b8>
 8004cca: 6819         	ldr	r1, [r3]
 8004ccc: 4b25         	ldr	r3, [pc, #0x94]         @ 0x8004d64 <can_stm32_send+0x2cc>
 8004cce: 9303         	str	r3, [sp, #0xc]
 8004cd0: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x8004d78 <can_stm32_send+0x2e0>
 8004cd2: 9302         	str	r3, [sp, #0x8]
 8004cd4: 2308         	movs	r3, #0x8
 8004cd6: 9301         	str	r3, [sp, #0x4]
 8004cd8: 2300         	movs	r3, #0x0
 8004cda: 9300         	str	r3, [sp]
 8004cdc: 2300         	movs	r3, #0x0
 8004cde: 2204         	movs	r2, #0x4
 8004ce0: 2000         	movs	r0, #0x0
 8004ce2: f00a fc92    	bl	0x800f60a <z_log_msg_runtime_create> @ imm = #0xa924
 8004ce6: 2300         	movs	r3, #0x0
 8004ce8: 62bb         	str	r3, [r7, #0x28]
; 		mailbox = &can->sTxMailBox[0];
 8004cea: 6bbb         	ldr	r3, [r7, #0x38]
 8004cec: f503 73c0    	add.w	r3, r3, #0x180
 8004cf0: 64fb         	str	r3, [r7, #0x4c]
; 		mb = &(data->mb0);
 8004cf2: 6bfb         	ldr	r3, [r7, #0x3c]
 8004cf4: 3334         	adds	r3, #0x34
 8004cf6: 64bb         	str	r3, [r7, #0x48]
 8004cf8: e06c         	b	0x8004dd4 <can_stm32_send+0x33c> @ imm = #0xd8
; 	} else if (transmit_status_register & CAN_TSR_TME1) {
 8004cfa: 6dbb         	ldr	r3, [r7, #0x58]
 8004cfc: f003 6300    	and	r3, r3, #0x8000000
 8004d00: 2b00         	cmp	r3, #0x0
 8004d02: d03d         	beq	0x8004d80 <can_stm32_send+0x2e8> @ imm = #0x7a
; 		LOG_DBG("Using TX mailbox 1");
 8004d04: 2303         	movs	r3, #0x3
 8004d06: 2b03         	cmp	r3, #0x3
 8004d08: d91a         	bls	0x8004d40 <can_stm32_send+0x2a8> @ imm = #0x34
 8004d0a: 2301         	movs	r3, #0x1
 8004d0c: f887 3037    	strb.w	r3, [r7, #0x37]
 8004d10: f897 3037    	ldrb.w	r3, [r7, #0x37]
 8004d14: f083 0301    	eor	r3, r3, #0x1
 8004d18: b2db         	uxtb	r3, r3
 8004d1a: 2b00         	cmp	r3, #0x0
 8004d1c: d110         	bne	0x8004d40 <can_stm32_send+0x2a8> @ imm = #0x20
 8004d1e: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8004d50 <can_stm32_send+0x2b8>
 8004d20: 6819         	ldr	r1, [r3]
 8004d22: 4b10         	ldr	r3, [pc, #0x40]         @ 0x8004d64 <can_stm32_send+0x2cc>
 8004d24: 9303         	str	r3, [sp, #0xc]
 8004d26: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8004d7c <can_stm32_send+0x2e4>
 8004d28: 9302         	str	r3, [sp, #0x8]
 8004d2a: 2308         	movs	r3, #0x8
 8004d2c: 9301         	str	r3, [sp, #0x4]
 8004d2e: 2300         	movs	r3, #0x0
 8004d30: 9300         	str	r3, [sp]
 8004d32: 2300         	movs	r3, #0x0
 8004d34: 2204         	movs	r2, #0x4
 8004d36: 2000         	movs	r0, #0x0
 8004d38: f00a fc67    	bl	0x800f60a <z_log_msg_runtime_create> @ imm = #0xa8ce
 8004d3c: 2300         	movs	r3, #0x0
 8004d3e: 633b         	str	r3, [r7, #0x30]
; 		mailbox = &can->sTxMailBox[1];
 8004d40: 6bbb         	ldr	r3, [r7, #0x38]
 8004d42: f503 73c8    	add.w	r3, r3, #0x190
 8004d46: 64fb         	str	r3, [r7, #0x4c]
; 		mb = &data->mb1;
 8004d48: 6bfb         	ldr	r3, [r7, #0x3c]
 8004d4a: 333c         	adds	r3, #0x3c
 8004d4c: 64bb         	str	r3, [r7, #0x48]
 8004d4e: e041         	b	0x8004dd4 <can_stm32_send+0x33c> @ imm = #0x82

08004d50 <$d>:
 8004d50: 48 00 00 20  	.word	0x20000048
 8004d54: ec 54 01 08  	.word	0x080154ec
 8004d58: f8 54 01 08  	.word	0x080154f8
 8004d5c: 04 55 01 08  	.word	0x08015504
 8004d60: 08 55 01 08  	.word	0x08015508
 8004d64: f0 63 01 08  	.word	0x080163f0
 8004d68: 0c 55 01 08  	.word	0x0801550c
 8004d6c: 50 55 01 08  	.word	0x08015550
 8004d70: 70 55 01 08  	.word	0x08015570
 8004d74: 94 55 01 08  	.word	0x08015594
 8004d78: b0 55 01 08  	.word	0x080155b0
 8004d7c: c8 55 01 08  	.word	0x080155c8

08004d80 <$t>:
; 	} else if (transmit_status_register & CAN_TSR_TME2) {
 8004d80: 6dbb         	ldr	r3, [r7, #0x58]
 8004d82: f003 5380    	and	r3, r3, #0x10000000
 8004d86: 2b00         	cmp	r3, #0x0
 8004d88: d024         	beq	0x8004dd4 <can_stm32_send+0x33c> @ imm = #0x48
; 		LOG_DBG("Using TX mailbox 2");
 8004d8a: 2303         	movs	r3, #0x3
 8004d8c: 2b03         	cmp	r3, #0x3
 8004d8e: d91a         	bls	0x8004dc6 <can_stm32_send+0x32e> @ imm = #0x34
 8004d90: 2301         	movs	r3, #0x1
 8004d92: f887 3057    	strb.w	r3, [r7, #0x57]
 8004d96: f897 3057    	ldrb.w	r3, [r7, #0x57]
 8004d9a: f083 0301    	eor	r3, r3, #0x1
 8004d9e: b2db         	uxtb	r3, r3
 8004da0: 2b00         	cmp	r3, #0x0
 8004da2: d110         	bne	0x8004dc6 <can_stm32_send+0x32e> @ imm = #0x20
 8004da4: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x8004e80 <can_stm32_send+0x3e8>
 8004da6: 6819         	ldr	r1, [r3]
 8004da8: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x8004e84 <can_stm32_send+0x3ec>
 8004daa: 9303         	str	r3, [sp, #0xc]
 8004dac: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x8004e88 <can_stm32_send+0x3f0>
 8004dae: 9302         	str	r3, [sp, #0x8]
 8004db0: 2308         	movs	r3, #0x8
 8004db2: 9301         	str	r3, [sp, #0x4]
 8004db4: 2300         	movs	r3, #0x0
 8004db6: 9300         	str	r3, [sp]
 8004db8: 2300         	movs	r3, #0x0
 8004dba: 2204         	movs	r2, #0x4
 8004dbc: 2000         	movs	r0, #0x0
 8004dbe: f00a fc24    	bl	0x800f60a <z_log_msg_runtime_create> @ imm = #0xa848
 8004dc2: 2300         	movs	r3, #0x0
 8004dc4: 653b         	str	r3, [r7, #0x50]
; 		mailbox = &can->sTxMailBox[2];
 8004dc6: 6bbb         	ldr	r3, [r7, #0x38]
 8004dc8: f503 73d0    	add.w	r3, r3, #0x1a0
 8004dcc: 64fb         	str	r3, [r7, #0x4c]
; 		mb = &data->mb2;
 8004dce: 6bfb         	ldr	r3, [r7, #0x3c]
 8004dd0: 3344         	adds	r3, #0x44
 8004dd2: 64bb         	str	r3, [r7, #0x48]
; 	mb->tx_callback = callback;
 8004dd4: 6cbb         	ldr	r3, [r7, #0x48]
 8004dd6: 6f3a         	ldr	r2, [r7, #0x70]
 8004dd8: 601a         	str	r2, [r3]
; 	mb->callback_arg = user_data;
 8004dda: 6cbb         	ldr	r3, [r7, #0x48]
 8004ddc: 6f7a         	ldr	r2, [r7, #0x74]
 8004dde: 605a         	str	r2, [r3, #0x4]
; 	mailbox->TIR &= CAN_TI0R_TXRQ;
 8004de0: 6cfb         	ldr	r3, [r7, #0x4c]
 8004de2: 681b         	ldr	r3, [r3]
 8004de4: f003 0201    	and	r2, r3, #0x1
 8004de8: 6cfb         	ldr	r3, [r7, #0x4c]
 8004dea: 601a         	str	r2, [r3]
; 	if ((frame->flags & CAN_FRAME_IDE) != 0) {
 8004dec: 68bb         	ldr	r3, [r7, #0x8]
 8004dee: 795b         	ldrb	r3, [r3, #0x5]
 8004df0: f003 0301    	and	r3, r3, #0x1
 8004df4: 2b00         	cmp	r3, #0x0
 8004df6: d00a         	beq	0x8004e0e <can_stm32_send+0x376> @ imm = #0x14
; 		mailbox->TIR |= (frame->id << CAN_TI0R_EXID_Pos)
 8004df8: 6cfb         	ldr	r3, [r7, #0x4c]
 8004dfa: 681a         	ldr	r2, [r3]
 8004dfc: 68bb         	ldr	r3, [r7, #0x8]
 8004dfe: 681b         	ldr	r3, [r3]
 8004e00: 00db         	lsls	r3, r3, #0x3
 8004e02: 4313         	orrs	r3, r2
 8004e04: f043 0204    	orr	r2, r3, #0x4
 8004e08: 6cfb         	ldr	r3, [r7, #0x4c]
 8004e0a: 601a         	str	r2, [r3]
 8004e0c: e007         	b	0x8004e1e <can_stm32_send+0x386> @ imm = #0xe
; 		mailbox->TIR |= (frame->id << CAN_TI0R_STID_Pos);
 8004e0e: 6cfb         	ldr	r3, [r7, #0x4c]
 8004e10: 681a         	ldr	r2, [r3]
 8004e12: 68bb         	ldr	r3, [r7, #0x8]
 8004e14: 681b         	ldr	r3, [r3]
 8004e16: 055b         	lsls	r3, r3, #0x15
 8004e18: 431a         	orrs	r2, r3
 8004e1a: 6cfb         	ldr	r3, [r7, #0x4c]
 8004e1c: 601a         	str	r2, [r3]
; 	if ((frame->flags & CAN_FRAME_RTR) != 0) {
 8004e1e: 68bb         	ldr	r3, [r7, #0x8]
 8004e20: 795b         	ldrb	r3, [r3, #0x5]
 8004e22: f003 0302    	and	r3, r3, #0x2
 8004e26: 2b00         	cmp	r3, #0x0
 8004e28: d006         	beq	0x8004e38 <can_stm32_send+0x3a0> @ imm = #0xc
; 		mailbox->TIR |= CAN_TI1R_RTR;
 8004e2a: 6cfb         	ldr	r3, [r7, #0x4c]
 8004e2c: 681b         	ldr	r3, [r3]
 8004e2e: f043 0202    	orr	r2, r3, #0x2
 8004e32: 6cfb         	ldr	r3, [r7, #0x4c]
 8004e34: 601a         	str	r2, [r3]
 8004e36: e007         	b	0x8004e48 <can_stm32_send+0x3b0> @ imm = #0xe
; 		mailbox->TDLR = frame->data_32[0];
 8004e38: 68bb         	ldr	r3, [r7, #0x8]
 8004e3a: 689a         	ldr	r2, [r3, #0x8]
 8004e3c: 6cfb         	ldr	r3, [r7, #0x4c]
 8004e3e: 609a         	str	r2, [r3, #0x8]
; 		mailbox->TDHR = frame->data_32[1];
 8004e40: 68bb         	ldr	r3, [r7, #0x8]
 8004e42: 68da         	ldr	r2, [r3, #0xc]
 8004e44: 6cfb         	ldr	r3, [r7, #0x4c]
 8004e46: 60da         	str	r2, [r3, #0xc]
; 	mailbox->TDTR = (mailbox->TDTR & ~CAN_TDT1R_DLC) |
 8004e48: 6cfb         	ldr	r3, [r7, #0x4c]
 8004e4a: 685b         	ldr	r3, [r3, #0x4]
 8004e4c: f023 020f    	bic	r2, r3, #0xf
; 			((frame->dlc & 0xF) << CAN_TDT1R_DLC_Pos);
 8004e50: 68bb         	ldr	r3, [r7, #0x8]
 8004e52: 791b         	ldrb	r3, [r3, #0x4]
 8004e54: f003 030f    	and	r3, r3, #0xf
; 	mailbox->TDTR = (mailbox->TDTR & ~CAN_TDT1R_DLC) |
 8004e58: 431a         	orrs	r2, r3
 8004e5a: 6cfb         	ldr	r3, [r7, #0x4c]
 8004e5c: 605a         	str	r2, [r3, #0x4]
; 	mailbox->TIR |= CAN_TI0R_TXRQ;
 8004e5e: 6cfb         	ldr	r3, [r7, #0x4c]
 8004e60: 681b         	ldr	r3, [r3]
 8004e62: f043 0201    	orr	r2, r3, #0x1
 8004e66: 6cfb         	ldr	r3, [r7, #0x4c]
 8004e68: 601a         	str	r2, [r3]
; 	k_mutex_unlock(&data->inst_mutex);
 8004e6a: 6bfb         	ldr	r3, [r7, #0x3c]
 8004e6c: 3310         	adds	r3, #0x10
 8004e6e: 4618         	mov	r0, r3
 8004e70: f00a faf4    	bl	0x800f45c <k_mutex_unlock> @ imm = #0xa5e8
; 	return 0;
 8004e74: 2300         	movs	r3, #0x0
; }
 8004e76: 4618         	mov	r0, r3
 8004e78: 3760         	adds	r7, #0x60
 8004e7a: 46bd         	mov	sp, r7
 8004e7c: bdb0         	pop	{r4, r5, r7, pc}
 8004e7e: bf00         	nop

08004e80 <$d>:
 8004e80: 48 00 00 20  	.word	0x20000048
 8004e84: f0 63 01 08  	.word	0x080163f0
 8004e88: e0 55 01 08  	.word	0x080155e0

08004e8c <can_stm32_set_filter>:
; {
 8004e8c: b580         	push	{r7, lr}
 8004e8e: b098         	sub	sp, #0x60
 8004e90: af08         	add	r7, sp, #0x20
 8004e92: 6078         	str	r0, [r7, #0x4]
 8004e94: 6039         	str	r1, [r7]
; 	const struct can_stm32_config *cfg = dev->config;
 8004e96: 687b         	ldr	r3, [r7, #0x4]
 8004e98: 685b         	ldr	r3, [r3, #0x4]
 8004e9a: 623b         	str	r3, [r7, #0x20]
; 	struct can_stm32_data *data = dev->data;
 8004e9c: 687b         	ldr	r3, [r7, #0x4]
 8004e9e: 691b         	ldr	r3, [r3, #0x10]
 8004ea0: 61fb         	str	r3, [r7, #0x1c]
; 	CAN_TypeDef *can = cfg->master_can;
 8004ea2: 6a3b         	ldr	r3, [r7, #0x20]
 8004ea4: 699b         	ldr	r3, [r3, #0x18]
 8004ea6: 61bb         	str	r3, [r7, #0x18]
; 	uint32_t mask = 0U;
 8004ea8: 2300         	movs	r3, #0x0
 8004eaa: 62fb         	str	r3, [r7, #0x2c]
; 	uint32_t id = 0U;
 8004eac: 2300         	movs	r3, #0x0
 8004eae: 633b         	str	r3, [r7, #0x30]
; 	int filter_id = -ENOSPC;
 8004eb0: f06f 031b    	mvn	r3, #0x1b
 8004eb4: 63fb         	str	r3, [r7, #0x3c]
; 	int bank_offset = 0;
 8004eb6: 2300         	movs	r3, #0x0
 8004eb8: 63bb         	str	r3, [r7, #0x38]
; 	if (cfg->can != cfg->master_can) {
 8004eba: 6a3b         	ldr	r3, [r7, #0x20]
 8004ebc: 695a         	ldr	r2, [r3, #0x14]
 8004ebe: 6a3b         	ldr	r3, [r7, #0x20]
 8004ec0: 699b         	ldr	r3, [r3, #0x18]
 8004ec2: 429a         	cmp	r2, r3
 8004ec4: d001         	beq	0x8004eca <can_stm32_set_filter+0x3e> @ imm = #0x2
; 		bank_offset = CAN_STM32_NUM_FILTER_BANKS;
 8004ec6: 230e         	movs	r3, #0xe
 8004ec8: 63bb         	str	r3, [r7, #0x38]
; 	if ((filter->flags & CAN_FILTER_IDE) != 0) {
 8004eca: 683b         	ldr	r3, [r7]
 8004ecc: 7a1b         	ldrb	r3, [r3, #0x8]
 8004ece: f003 0301    	and	r3, r3, #0x1
 8004ed2: 2b00         	cmp	r3, #0x0
 8004ed4: d020         	beq	0x8004f18 <can_stm32_set_filter+0x8c> @ imm = #0x40
; 		for (int i = 0; i < CONFIG_CAN_MAX_EXT_ID_FILTER; i++) {
 8004ed6: 2300         	movs	r3, #0x0
 8004ed8: 62bb         	str	r3, [r7, #0x28]
 8004eda: e019         	b	0x8004f10 <can_stm32_set_filter+0x84> @ imm = #0x32
; 			if (data->rx_cb_ext[i] == NULL) {
 8004edc: 69fa         	ldr	r2, [r7, #0x1c]
 8004ede: 6abb         	ldr	r3, [r7, #0x28]
 8004ee0: 3320         	adds	r3, #0x20
 8004ee2: 009b         	lsls	r3, r3, #0x2
 8004ee4: 4413         	add	r3, r2
 8004ee6: 685b         	ldr	r3, [r3, #0x4]
 8004ee8: 2b00         	cmp	r3, #0x0
 8004eea: d10e         	bne	0x8004f0a <can_stm32_set_filter+0x7e> @ imm = #0x1c
; 				id = can_stm32_filter_to_ext_id(filter);
 8004eec: 6838         	ldr	r0, [r7]
 8004eee: f00a fe2a    	bl	0x800fb46 <can_stm32_filter_to_ext_id> @ imm = #0xac54
 8004ef2: 6338         	str	r0, [r7, #0x30]
; 				mask = can_stm32_filter_to_ext_mask(filter);
 8004ef4: 6838         	ldr	r0, [r7]
 8004ef6: f00a fe07    	bl	0x800fb08 <can_stm32_filter_to_ext_mask> @ imm = #0xac0e
 8004efa: 62f8         	str	r0, [r7, #0x2c]
; 				filter_id = i;
 8004efc: 6abb         	ldr	r3, [r7, #0x28]
 8004efe: 63fb         	str	r3, [r7, #0x3c]
; 				bank_num = bank_offset + i;
 8004f00: 6bba         	ldr	r2, [r7, #0x38]
 8004f02: 6abb         	ldr	r3, [r7, #0x28]
 8004f04: 4413         	add	r3, r2
 8004f06: 637b         	str	r3, [r7, #0x34]
; 				break;
 8004f08: e02b         	b	0x8004f62 <can_stm32_set_filter+0xd6> @ imm = #0x56
; 		for (int i = 0; i < CONFIG_CAN_MAX_EXT_ID_FILTER; i++) {
 8004f0a: 6abb         	ldr	r3, [r7, #0x28]
 8004f0c: 3301         	adds	r3, #0x1
 8004f0e: 62bb         	str	r3, [r7, #0x28]
 8004f10: 6abb         	ldr	r3, [r7, #0x28]
 8004f12: 2b06         	cmp	r3, #0x6
 8004f14: dde2         	ble	0x8004edc <can_stm32_set_filter+0x50> @ imm = #-0x3c
 8004f16: e024         	b	0x8004f62 <can_stm32_set_filter+0xd6> @ imm = #0x48
; 		for (int i = 0; i < CONFIG_CAN_MAX_STD_ID_FILTER; i++) {
 8004f18: 2300         	movs	r3, #0x0
 8004f1a: 627b         	str	r3, [r7, #0x24]
 8004f1c: e01e         	b	0x8004f5c <can_stm32_set_filter+0xd0> @ imm = #0x3c
; 			if (data->rx_cb_std[i] == NULL) {
 8004f1e: 69fa         	ldr	r2, [r7, #0x1c]
 8004f20: 6a7b         	ldr	r3, [r7, #0x24]
 8004f22: 3312         	adds	r3, #0x12
 8004f24: 009b         	lsls	r3, r3, #0x2
 8004f26: 4413         	add	r3, r2
 8004f28: 685b         	ldr	r3, [r3, #0x4]
 8004f2a: 2b00         	cmp	r3, #0x0
 8004f2c: d113         	bne	0x8004f56 <can_stm32_set_filter+0xca> @ imm = #0x26
; 				id = can_stm32_filter_to_std_id(filter);
 8004f2e: 6838         	ldr	r0, [r7]
 8004f30: f00a fdfd    	bl	0x800fb2e <can_stm32_filter_to_std_id> @ imm = #0xabfa
 8004f34: 6338         	str	r0, [r7, #0x30]
; 				mask = can_stm32_filter_to_std_mask(filter);
 8004f36: 6838         	ldr	r0, [r7]
 8004f38: f00a fdd3    	bl	0x800fae2 <can_stm32_filter_to_std_mask> @ imm = #0xaba6
 8004f3c: 62f8         	str	r0, [r7, #0x2c]
; 				filter_id = CONFIG_CAN_MAX_EXT_ID_FILTER + i;
 8004f3e: 6a7b         	ldr	r3, [r7, #0x24]
 8004f40: 3307         	adds	r3, #0x7
 8004f42: 63fb         	str	r3, [r7, #0x3c]
; 				bank_num = bank_offset + CONFIG_CAN_MAX_EXT_ID_FILTER + i / 2;
 8004f44: 6bbb         	ldr	r3, [r7, #0x38]
 8004f46: 1dda         	adds	r2, r3, #0x7
 8004f48: 6a7b         	ldr	r3, [r7, #0x24]
 8004f4a: 0fd9         	lsrs	r1, r3, #0x1f
 8004f4c: 440b         	add	r3, r1
 8004f4e: 105b         	asrs	r3, r3, #0x1
 8004f50: 4413         	add	r3, r2
 8004f52: 637b         	str	r3, [r7, #0x34]
; 				break;
 8004f54: e005         	b	0x8004f62 <can_stm32_set_filter+0xd6> @ imm = #0xa
; 		for (int i = 0; i < CONFIG_CAN_MAX_STD_ID_FILTER; i++) {
 8004f56: 6a7b         	ldr	r3, [r7, #0x24]
 8004f58: 3301         	adds	r3, #0x1
 8004f5a: 627b         	str	r3, [r7, #0x24]
 8004f5c: 6a7b         	ldr	r3, [r7, #0x24]
 8004f5e: 2b0d         	cmp	r3, #0xd
 8004f60: dddd         	ble	0x8004f1e <can_stm32_set_filter+0x92> @ imm = #-0x46
; 	if (filter_id != -ENOSPC) {
 8004f62: 6bfb         	ldr	r3, [r7, #0x3c]
 8004f64: f113 0f1c    	cmn.w	r3, #0x1c
 8004f68: d053         	beq	0x8005012 <can_stm32_set_filter+0x186> @ imm = #0xa6
; 		LOG_DBG("Adding filter_id %d, CAN ID: 0x%x, mask: 0x%x",
 8004f6a: 2303         	movs	r3, #0x3
 8004f6c: 2b03         	cmp	r3, #0x3
 8004f6e: d920         	bls	0x8004fb2 <can_stm32_set_filter+0x126> @ imm = #0x40
 8004f70: 2301         	movs	r3, #0x1
 8004f72: 73fb         	strb	r3, [r7, #0xf]
 8004f74: 7bfb         	ldrb	r3, [r7, #0xf]
 8004f76: f083 0301    	eor	r3, r3, #0x1
 8004f7a: b2db         	uxtb	r3, r3
 8004f7c: 2b00         	cmp	r3, #0x0
 8004f7e: d118         	bne	0x8004fb2 <can_stm32_set_filter+0x126> @ imm = #0x30
 8004f80: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x8005050 <can_stm32_set_filter+0x1c4>
 8004f82: 6819         	ldr	r1, [r3]
 8004f84: 683b         	ldr	r3, [r7]
 8004f86: 681b         	ldr	r3, [r3]
 8004f88: 683a         	ldr	r2, [r7]
 8004f8a: 6852         	ldr	r2, [r2, #0x4]
 8004f8c: 9206         	str	r2, [sp, #0x18]
 8004f8e: 9305         	str	r3, [sp, #0x14]
 8004f90: 6bfb         	ldr	r3, [r7, #0x3c]
 8004f92: 9304         	str	r3, [sp, #0x10]
 8004f94: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x8005054 <can_stm32_set_filter+0x1c8>
 8004f96: 9303         	str	r3, [sp, #0xc]
 8004f98: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x8005058 <can_stm32_set_filter+0x1cc>
 8004f9a: 9302         	str	r3, [sp, #0x8]
 8004f9c: 2308         	movs	r3, #0x8
 8004f9e: 9301         	str	r3, [sp, #0x4]
 8004fa0: 2300         	movs	r3, #0x0
 8004fa2: 9300         	str	r3, [sp]
 8004fa4: 2300         	movs	r3, #0x0
 8004fa6: 2204         	movs	r2, #0x4
 8004fa8: 2000         	movs	r0, #0x0
 8004faa: f00a fb2e    	bl	0x800f60a <z_log_msg_runtime_create> @ imm = #0xa65c
 8004fae: 2300         	movs	r3, #0x0
 8004fb0: 60bb         	str	r3, [r7, #0x8]
; 		can->FMR |= CAN_FMR_FINIT;
 8004fb2: 69bb         	ldr	r3, [r7, #0x18]
 8004fb4: f8d3 3200    	ldr.w	r3, [r3, #0x200]
 8004fb8: f043 0201    	orr	r2, r3, #0x1
 8004fbc: 69bb         	ldr	r3, [r7, #0x18]
 8004fbe: f8c3 2200    	str.w	r2, [r3, #0x200]
; 		can_stm32_set_filter_bank(filter_id, &can->sFilterRegister[bank_num],
 8004fc2: 6b7b         	ldr	r3, [r7, #0x34]
 8004fc4: 3348         	adds	r3, #0x48
 8004fc6: 00db         	lsls	r3, r3, #0x3
 8004fc8: 69ba         	ldr	r2, [r7, #0x18]
 8004fca: 18d1         	adds	r1, r2, r3
; 					  (filter->flags & CAN_FILTER_IDE) != 0,
 8004fcc: 683b         	ldr	r3, [r7]
 8004fce: 7a1b         	ldrb	r3, [r3, #0x8]
 8004fd0: f003 0301    	and	r3, r3, #0x1
; 		can_stm32_set_filter_bank(filter_id, &can->sFilterRegister[bank_num],
 8004fd4: 2b00         	cmp	r3, #0x0
 8004fd6: bf14         	ite	ne
 8004fd8: 2301         	movne	r3, #0x1
 8004fda: 2300         	moveq	r3, #0x0
 8004fdc: b2da         	uxtb	r2, r3
 8004fde: 6afb         	ldr	r3, [r7, #0x2c]
 8004fe0: 9300         	str	r3, [sp]
 8004fe2: 6b3b         	ldr	r3, [r7, #0x30]
 8004fe4: 6bf8         	ldr	r0, [r7, #0x3c]
 8004fe6: f00a fd52    	bl	0x800fa8e <can_stm32_set_filter_bank> @ imm = #0xaaa4
; 		can->FA1R |= 1U << bank_num;
 8004fea: 69bb         	ldr	r3, [r7, #0x18]
 8004fec: f8d3 221c    	ldr.w	r2, [r3, #0x21c]
 8004ff0: 2101         	movs	r1, #0x1
 8004ff2: 6b7b         	ldr	r3, [r7, #0x34]
 8004ff4: fa01 f303    	lsl.w	r3, r1, r3
 8004ff8: 431a         	orrs	r2, r3
 8004ffa: 69bb         	ldr	r3, [r7, #0x18]
 8004ffc: f8c3 221c    	str.w	r2, [r3, #0x21c]
; 		can->FMR &= ~(CAN_FMR_FINIT);
 8005000: 69bb         	ldr	r3, [r7, #0x18]
 8005002: f8d3 3200    	ldr.w	r3, [r3, #0x200]
 8005006: f023 0201    	bic	r2, r3, #0x1
 800500a: 69bb         	ldr	r3, [r7, #0x18]
 800500c: f8c3 2200    	str.w	r2, [r3, #0x200]
 8005010: e019         	b	0x8005046 <can_stm32_set_filter+0x1ba> @ imm = #0x32
; 		LOG_WRN("No free filter left");
 8005012: 2303         	movs	r3, #0x3
 8005014: 2b01         	cmp	r3, #0x1
 8005016: d916         	bls	0x8005046 <can_stm32_set_filter+0x1ba> @ imm = #0x2c
 8005018: 2301         	movs	r3, #0x1
 800501a: 75fb         	strb	r3, [r7, #0x17]
 800501c: 7dfb         	ldrb	r3, [r7, #0x17]
 800501e: f083 0301    	eor	r3, r3, #0x1
 8005022: b2db         	uxtb	r3, r3
 8005024: 2b00         	cmp	r3, #0x0
 8005026: d10e         	bne	0x8005046 <can_stm32_set_filter+0x1ba> @ imm = #0x1c
 8005028: 4b09         	ldr	r3, [pc, #0x24]         @ 0x8005050 <can_stm32_set_filter+0x1c4>
 800502a: 6819         	ldr	r1, [r3]
 800502c: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800505c <can_stm32_set_filter+0x1d0>
 800502e: 9302         	str	r3, [sp, #0x8]
 8005030: 2300         	movs	r3, #0x0
 8005032: 9301         	str	r3, [sp, #0x4]
 8005034: 2300         	movs	r3, #0x0
 8005036: 9300         	str	r3, [sp]
 8005038: 2300         	movs	r3, #0x0
 800503a: 2202         	movs	r2, #0x2
 800503c: 2000         	movs	r0, #0x0
 800503e: f00a fae4    	bl	0x800f60a <z_log_msg_runtime_create> @ imm = #0xa5c8
 8005042: 2300         	movs	r3, #0x0
 8005044: 613b         	str	r3, [r7, #0x10]
; 	return filter_id;
 8005046: 6bfb         	ldr	r3, [r7, #0x3c]
; }
 8005048: 4618         	mov	r0, r3
 800504a: 3740         	adds	r7, #0x40
 800504c: 46bd         	mov	sp, r7
 800504e: bd80         	pop	{r7, pc}

08005050 <$d>:
 8005050: 48 00 00 20  	.word	0x20000048
 8005054: 00 64 01 08  	.word	0x08016400
 8005058: f8 55 01 08  	.word	0x080155f8
 800505c: 2c 56 01 08  	.word	0x0801562c

08005060 <can_stm32_add_rx_filter>:
; {
 8005060: b580         	push	{r7, lr}
 8005062: b08c         	sub	sp, #0x30
 8005064: af04         	add	r7, sp, #0x10
 8005066: 60f8         	str	r0, [r7, #0xc]
 8005068: 60b9         	str	r1, [r7, #0x8]
 800506a: 607a         	str	r2, [r7, #0x4]
 800506c: 603b         	str	r3, [r7]
; 	struct can_stm32_data *data = dev->data;
 800506e: 68fb         	ldr	r3, [r7, #0xc]
 8005070: 691b         	ldr	r3, [r3, #0x10]
 8005072: 61fb         	str	r3, [r7, #0x1c]
; 	if ((filter->flags & ~(CAN_FILTER_IDE)) != 0) {
 8005074: 683b         	ldr	r3, [r7]
 8005076: 7a1b         	ldrb	r3, [r3, #0x8]
 8005078: 2b01         	cmp	r3, #0x1
 800507a: d91f         	bls	0x80050bc <can_stm32_add_rx_filter+0x5c> @ imm = #0x3e
; 		LOG_ERR("unsupported CAN filter flags 0x%02x", filter->flags);
 800507c: 2303         	movs	r3, #0x3
 800507e: 2b00         	cmp	r3, #0x0
 8005080: d019         	beq	0x80050b6 <can_stm32_add_rx_filter+0x56> @ imm = #0x32
 8005082: 2301         	movs	r3, #0x1
 8005084: 75fb         	strb	r3, [r7, #0x17]
 8005086: 7dfb         	ldrb	r3, [r7, #0x17]
 8005088: f083 0301    	eor	r3, r3, #0x1
 800508c: b2db         	uxtb	r3, r3
 800508e: 2b00         	cmp	r3, #0x0
 8005090: d111         	bne	0x80050b6 <can_stm32_add_rx_filter+0x56> @ imm = #0x22
 8005092: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x8005150 <can_stm32_add_rx_filter+0xf0>
 8005094: 6819         	ldr	r1, [r3]
 8005096: 683b         	ldr	r3, [r7]
 8005098: 7a1b         	ldrb	r3, [r3, #0x8]
 800509a: 9303         	str	r3, [sp, #0xc]
 800509c: 4b2d         	ldr	r3, [pc, #0xb4]         @ 0x8005154 <can_stm32_add_rx_filter+0xf4>
 800509e: 9302         	str	r3, [sp, #0x8]
 80050a0: 2300         	movs	r3, #0x0
 80050a2: 9301         	str	r3, [sp, #0x4]
 80050a4: 2300         	movs	r3, #0x0
 80050a6: 9300         	str	r3, [sp]
 80050a8: 2300         	movs	r3, #0x0
 80050aa: 2201         	movs	r2, #0x1
 80050ac: 2000         	movs	r0, #0x0
 80050ae: f00a faac    	bl	0x800f60a <z_log_msg_runtime_create> @ imm = #0xa558
 80050b2: 2300         	movs	r3, #0x0
 80050b4: 613b         	str	r3, [r7, #0x10]
; 		return -ENOTSUP;
 80050b6: f06f 0185    	mvn	r1, #0x85
 80050ba: e044         	b	0x8005146 <can_stm32_add_rx_filter+0xe6> @ imm = #0x88
; 	k_mutex_lock(&filter_mutex, K_FOREVER);
 80050bc: f04f 32ff    	mov.w	r2, #0xffffffff
 80050c0: f04f 33ff    	mov.w	r3, #0xffffffff
 80050c4: 4824         	ldr	r0, [pc, #0x90]         @ 0x8005158 <can_stm32_add_rx_filter+0xf8>
 80050c6: f00a f9b9    	bl	0x800f43c <k_mutex_lock> @ imm = #0xa372
; 	k_mutex_lock(&data->inst_mutex, K_FOREVER);
 80050ca: 69fb         	ldr	r3, [r7, #0x1c]
 80050cc: f103 0110    	add.w	r1, r3, #0x10
 80050d0: f04f 32ff    	mov.w	r2, #0xffffffff
 80050d4: f04f 33ff    	mov.w	r3, #0xffffffff
 80050d8: 4608         	mov	r0, r1
 80050da: f00a f9af    	bl	0x800f43c <k_mutex_lock> @ imm = #0xa35e
; 	filter_id = can_stm32_set_filter(dev, filter);
 80050de: 6839         	ldr	r1, [r7]
 80050e0: 68f8         	ldr	r0, [r7, #0xc]
 80050e2: f7ff fed3    	bl	0x8004e8c <can_stm32_set_filter> @ imm = #-0x25a
 80050e6: 61b8         	str	r0, [r7, #0x18]
; 	if (filter_id >= 0) {
 80050e8: 69bb         	ldr	r3, [r7, #0x18]
 80050ea: 2b00         	cmp	r3, #0x0
 80050ec: db22         	blt	0x8005134 <can_stm32_add_rx_filter+0xd4> @ imm = #0x44
; 		if ((filter->flags & CAN_FILTER_IDE) != 0) {
 80050ee: 683b         	ldr	r3, [r7]
 80050f0: 7a1b         	ldrb	r3, [r3, #0x8]
 80050f2: f003 0301    	and	r3, r3, #0x1
 80050f6: 2b00         	cmp	r3, #0x0
 80050f8: d00d         	beq	0x8005116 <can_stm32_add_rx_filter+0xb6> @ imm = #0x1a
; 			data->rx_cb_ext[filter_id] = cb;
 80050fa: 69fa         	ldr	r2, [r7, #0x1c]
 80050fc: 69bb         	ldr	r3, [r7, #0x18]
 80050fe: 3320         	adds	r3, #0x20
 8005100: 009b         	lsls	r3, r3, #0x2
 8005102: 4413         	add	r3, r2
 8005104: 68ba         	ldr	r2, [r7, #0x8]
 8005106: 605a         	str	r2, [r3, #0x4]
; 			data->cb_arg_ext[filter_id] = cb_arg;
 8005108: 69fb         	ldr	r3, [r7, #0x1c]
 800510a: 69ba         	ldr	r2, [r7, #0x18]
 800510c: 3236         	adds	r2, #0x36
 800510e: 6879         	ldr	r1, [r7, #0x4]
 8005110: f843 1022    	str.w	r1, [r3, r2, lsl #2]
 8005114: e00e         	b	0x8005134 <can_stm32_add_rx_filter+0xd4> @ imm = #0x1c
; 			data->rx_cb_std[filter_id - CONFIG_CAN_MAX_EXT_ID_FILTER] = cb;
 8005116: 69bb         	ldr	r3, [r7, #0x18]
 8005118: 3b07         	subs	r3, #0x7
 800511a: 69fa         	ldr	r2, [r7, #0x1c]
 800511c: 3312         	adds	r3, #0x12
 800511e: 009b         	lsls	r3, r3, #0x2
 8005120: 4413         	add	r3, r2
 8005122: 68ba         	ldr	r2, [r7, #0x8]
 8005124: 605a         	str	r2, [r3, #0x4]
; 			data->cb_arg_std[filter_id - CONFIG_CAN_MAX_EXT_ID_FILTER] = cb_arg;
 8005126: 69bb         	ldr	r3, [r7, #0x18]
 8005128: 1fda         	subs	r2, r3, #0x7
 800512a: 69fb         	ldr	r3, [r7, #0x1c]
 800512c: 3228         	adds	r2, #0x28
 800512e: 6879         	ldr	r1, [r7, #0x4]
 8005130: f843 1022    	str.w	r1, [r3, r2, lsl #2]
; 	k_mutex_unlock(&data->inst_mutex);
 8005134: 69fb         	ldr	r3, [r7, #0x1c]
 8005136: 3310         	adds	r3, #0x10
 8005138: 4618         	mov	r0, r3
 800513a: f00a f98f    	bl	0x800f45c <k_mutex_unlock> @ imm = #0xa31e
; 	k_mutex_unlock(&filter_mutex);
 800513e: 4806         	ldr	r0, [pc, #0x18]         @ 0x8005158 <can_stm32_add_rx_filter+0xf8>
 8005140: f00a f98c    	bl	0x800f45c <k_mutex_unlock> @ imm = #0xa318
; 	return filter_id;
 8005144: 69b9         	ldr	r1, [r7, #0x18]
; }
 8005146: 460b         	mov	r3, r1
 8005148: 4618         	mov	r0, r3
 800514a: 3720         	adds	r7, #0x20
 800514c: 46bd         	mov	sp, r7
 800514e: bd80         	pop	{r7, pc}

08005150 <$d>:
 8005150: 48 00 00 20  	.word	0x20000048
 8005154: 40 56 01 08  	.word	0x08015640
 8005158: 84 06 00 20  	.word	0x20000684

0800515c <can_stm32_remove_rx_filter>:
; {
 800515c: b580         	push	{r7, lr}
 800515e: b096         	sub	sp, #0x58
 8005160: af06         	add	r7, sp, #0x18
 8005162: 6078         	str	r0, [r7, #0x4]
 8005164: 6039         	str	r1, [r7]
; 	const struct can_stm32_config *cfg = dev->config;
 8005166: 687b         	ldr	r3, [r7, #0x4]
 8005168: 685b         	ldr	r3, [r3, #0x4]
 800516a: 62fb         	str	r3, [r7, #0x2c]
; 	struct can_stm32_data *data = dev->data;
 800516c: 687b         	ldr	r3, [r7, #0x4]
 800516e: 691b         	ldr	r3, [r3, #0x10]
 8005170: 62bb         	str	r3, [r7, #0x28]
; 	CAN_TypeDef *can = cfg->master_can;
 8005172: 6afb         	ldr	r3, [r7, #0x2c]
 8005174: 699b         	ldr	r3, [r3, #0x18]
 8005176: 627b         	str	r3, [r7, #0x24]
; 	int bank_offset = 0;
 8005178: 2300         	movs	r3, #0x0
 800517a: 633b         	str	r3, [r7, #0x30]
; 	if (filter_id < 0 || filter_id >= CAN_STM32_MAX_FILTER_ID) {
 800517c: 683b         	ldr	r3, [r7]
 800517e: 2b00         	cmp	r3, #0x0
 8005180: db02         	blt	0x8005188 <can_stm32_remove_rx_filter+0x2c> @ imm = #0x4
 8005182: 683b         	ldr	r3, [r7]
 8005184: 2b22         	cmp	r3, #0x22
 8005186: dd1e         	ble	0x80051c6 <can_stm32_remove_rx_filter+0x6a> @ imm = #0x3c
; 		LOG_ERR("filter ID %d out of bounds", filter_id);
 8005188: 2303         	movs	r3, #0x3
 800518a: 2b00         	cmp	r3, #0x0
 800518c: f000 810a    	beq.w	0x80053a4 <can_stm32_remove_rx_filter+0x248> @ imm = #0x214
 8005190: 2301         	movs	r3, #0x1
 8005192: 73fb         	strb	r3, [r7, #0xf]
 8005194: 7bfb         	ldrb	r3, [r7, #0xf]
 8005196: f083 0301    	eor	r3, r3, #0x1
 800519a: b2db         	uxtb	r3, r3
 800519c: 2b00         	cmp	r3, #0x0
 800519e: f040 8101    	bne.w	0x80053a4 <can_stm32_remove_rx_filter+0x248> @ imm = #0x202
 80051a2: 4b82         	ldr	r3, [pc, #0x208]        @ 0x80053ac <can_stm32_remove_rx_filter+0x250>
 80051a4: 6819         	ldr	r1, [r3]
 80051a6: 683b         	ldr	r3, [r7]
 80051a8: 9303         	str	r3, [sp, #0xc]
 80051aa: 4b81         	ldr	r3, [pc, #0x204]        @ 0x80053b0 <can_stm32_remove_rx_filter+0x254>
 80051ac: 9302         	str	r3, [sp, #0x8]
 80051ae: 2300         	movs	r3, #0x0
 80051b0: 9301         	str	r3, [sp, #0x4]
 80051b2: 2300         	movs	r3, #0x0
 80051b4: 9300         	str	r3, [sp]
 80051b6: 2300         	movs	r3, #0x0
 80051b8: 2201         	movs	r2, #0x1
 80051ba: 2000         	movs	r0, #0x0
 80051bc: f00a fa25    	bl	0x800f60a <z_log_msg_runtime_create> @ imm = #0xa44a
 80051c0: 2300         	movs	r3, #0x0
 80051c2: 60bb         	str	r3, [r7, #0x8]
 80051c4: e0ee         	b	0x80053a4 <can_stm32_remove_rx_filter+0x248> @ imm = #0x1dc
; 	k_mutex_lock(&filter_mutex, K_FOREVER);
 80051c6: f04f 32ff    	mov.w	r2, #0xffffffff
 80051ca: f04f 33ff    	mov.w	r3, #0xffffffff
 80051ce: 4879         	ldr	r0, [pc, #0x1e4]        @ 0x80053b4 <can_stm32_remove_rx_filter+0x258>
 80051d0: f00a f934    	bl	0x800f43c <k_mutex_lock> @ imm = #0xa268
; 	k_mutex_lock(&data->inst_mutex, K_FOREVER);
 80051d4: 6abb         	ldr	r3, [r7, #0x28]
 80051d6: f103 0110    	add.w	r1, r3, #0x10
 80051da: f04f 32ff    	mov.w	r2, #0xffffffff
 80051de: f04f 33ff    	mov.w	r3, #0xffffffff
 80051e2: 4608         	mov	r0, r1
 80051e4: f00a f92a    	bl	0x800f43c <k_mutex_lock> @ imm = #0xa254
; 	if (cfg->can != cfg->master_can) {
 80051e8: 6afb         	ldr	r3, [r7, #0x2c]
 80051ea: 695a         	ldr	r2, [r3, #0x14]
 80051ec: 6afb         	ldr	r3, [r7, #0x2c]
 80051ee: 699b         	ldr	r3, [r3, #0x18]
 80051f0: 429a         	cmp	r2, r3
 80051f2: d001         	beq	0x80051f8 <can_stm32_remove_rx_filter+0x9c> @ imm = #0x2
; 		bank_offset = CAN_STM32_NUM_FILTER_BANKS;
 80051f4: 230e         	movs	r3, #0xe
 80051f6: 633b         	str	r3, [r7, #0x30]
; 	if (filter_id < CONFIG_CAN_MAX_EXT_ID_FILTER) {
 80051f8: 683b         	ldr	r3, [r7]
 80051fa: 2b06         	cmp	r3, #0x6
 80051fc: dc17         	bgt	0x800522e <can_stm32_remove_rx_filter+0xd2> @ imm = #0x2e
; 		ide = true;
 80051fe: 2301         	movs	r3, #0x1
 8005200: f887 3037    	strb.w	r3, [r7, #0x37]
; 		bank_num = bank_offset + filter_id;
 8005204: 6b3a         	ldr	r2, [r7, #0x30]
 8005206: 683b         	ldr	r3, [r7]
 8005208: 4413         	add	r3, r2
 800520a: 63bb         	str	r3, [r7, #0x38]
; 		data->rx_cb_ext[filter_id] = NULL;
 800520c: 6aba         	ldr	r2, [r7, #0x28]
 800520e: 683b         	ldr	r3, [r7]
 8005210: 3320         	adds	r3, #0x20
 8005212: 009b         	lsls	r3, r3, #0x2
 8005214: 4413         	add	r3, r2
 8005216: 2200         	movs	r2, #0x0
 8005218: 605a         	str	r2, [r3, #0x4]
; 		data->cb_arg_ext[filter_id] = NULL;
 800521a: 6abb         	ldr	r3, [r7, #0x28]
 800521c: 683a         	ldr	r2, [r7]
 800521e: 3236         	adds	r2, #0x36
 8005220: 2100         	movs	r1, #0x0
 8005222: f843 1022    	str.w	r1, [r3, r2, lsl #2]
; 		bank_unused = true;
 8005226: 2301         	movs	r3, #0x1
 8005228: f887 303f    	strb.w	r3, [r7, #0x3f]
 800522c: e045         	b	0x80052ba <can_stm32_remove_rx_filter+0x15e> @ imm = #0x8a
; 		int filter_index = filter_id - CONFIG_CAN_MAX_EXT_ID_FILTER;
 800522e: 683b         	ldr	r3, [r7]
 8005230: 3b07         	subs	r3, #0x7
 8005232: 623b         	str	r3, [r7, #0x20]
; 		ide = false;
 8005234: 2300         	movs	r3, #0x0
 8005236: f887 3037    	strb.w	r3, [r7, #0x37]
; 		bank_num = bank_offset + CONFIG_CAN_MAX_EXT_ID_FILTER +
 800523a: 6b3b         	ldr	r3, [r7, #0x30]
 800523c: 1dda         	adds	r2, r3, #0x7
; 			  (filter_id - CONFIG_CAN_MAX_EXT_ID_FILTER) / 2;
 800523e: 683b         	ldr	r3, [r7]
 8005240: 3b07         	subs	r3, #0x7
 8005242: 0fd9         	lsrs	r1, r3, #0x1f
 8005244: 440b         	add	r3, r1
 8005246: 105b         	asrs	r3, r3, #0x1
; 		bank_num = bank_offset + CONFIG_CAN_MAX_EXT_ID_FILTER +
 8005248: 4413         	add	r3, r2
 800524a: 63bb         	str	r3, [r7, #0x38]
; 		data->rx_cb_std[filter_index] = NULL;
 800524c: 6aba         	ldr	r2, [r7, #0x28]
 800524e: 6a3b         	ldr	r3, [r7, #0x20]
 8005250: 3312         	adds	r3, #0x12
 8005252: 009b         	lsls	r3, r3, #0x2
 8005254: 4413         	add	r3, r2
 8005256: 2200         	movs	r2, #0x0
 8005258: 605a         	str	r2, [r3, #0x4]
; 		data->cb_arg_std[filter_index] = NULL;
 800525a: 6abb         	ldr	r3, [r7, #0x28]
 800525c: 6a3a         	ldr	r2, [r7, #0x20]
 800525e: 3228         	adds	r2, #0x28
 8005260: 2100         	movs	r1, #0x0
 8005262: f843 1022    	str.w	r1, [r3, r2, lsl #2]
; 		if (filter_index % 2 == 1) {
 8005266: 6a3b         	ldr	r3, [r7, #0x20]
 8005268: 2b00         	cmp	r3, #0x0
 800526a: f003 0301    	and	r3, r3, #0x1
 800526e: bfb8         	it	lt
 8005270: 425b         	rsblt	r3, r3, #0
 8005272: 2b01         	cmp	r3, #0x1
 8005274: d10d         	bne	0x8005292 <can_stm32_remove_rx_filter+0x136> @ imm = #0x1a
; 			bank_unused = data->rx_cb_std[filter_index - 1] == NULL;
 8005276: 6a3b         	ldr	r3, [r7, #0x20]
 8005278: 3b01         	subs	r3, #0x1
 800527a: 6aba         	ldr	r2, [r7, #0x28]
 800527c: 3312         	adds	r3, #0x12
 800527e: 009b         	lsls	r3, r3, #0x2
 8005280: 4413         	add	r3, r2
 8005282: 685b         	ldr	r3, [r3, #0x4]
 8005284: 2b00         	cmp	r3, #0x0
 8005286: bf0c         	ite	eq
 8005288: 2301         	moveq	r3, #0x1
 800528a: 2300         	movne	r3, #0x0
 800528c: f887 303f    	strb.w	r3, [r7, #0x3f]
 8005290: e013         	b	0x80052ba <can_stm32_remove_rx_filter+0x15e> @ imm = #0x26
; 		} else if (filter_index + 1 < CONFIG_CAN_MAX_STD_ID_FILTER) {
 8005292: 6a3b         	ldr	r3, [r7, #0x20]
 8005294: 2b0c         	cmp	r3, #0xc
 8005296: dc0d         	bgt	0x80052b4 <can_stm32_remove_rx_filter+0x158> @ imm = #0x1a
; 			bank_unused = data->rx_cb_std[filter_index + 1] == NULL;
 8005298: 6a3b         	ldr	r3, [r7, #0x20]
 800529a: 3301         	adds	r3, #0x1
 800529c: 6aba         	ldr	r2, [r7, #0x28]
 800529e: 3312         	adds	r3, #0x12
 80052a0: 009b         	lsls	r3, r3, #0x2
 80052a2: 4413         	add	r3, r2
 80052a4: 685b         	ldr	r3, [r3, #0x4]
 80052a6: 2b00         	cmp	r3, #0x0
 80052a8: bf0c         	ite	eq
 80052aa: 2301         	moveq	r3, #0x1
 80052ac: 2300         	movne	r3, #0x0
 80052ae: f887 303f    	strb.w	r3, [r7, #0x3f]
 80052b2: e002         	b	0x80052ba <can_stm32_remove_rx_filter+0x15e> @ imm = #0x4
; 			bank_unused = true;
 80052b4: 2301         	movs	r3, #0x1
 80052b6: f887 303f    	strb.w	r3, [r7, #0x3f]
; 	LOG_DBG("Removing filter_id %d, ide %d", filter_id, ide);
 80052ba: 2303         	movs	r3, #0x3
 80052bc: 2b03         	cmp	r3, #0x3
 80052be: d91d         	bls	0x80052fc <can_stm32_remove_rx_filter+0x1a0> @ imm = #0x3a
 80052c0: 2301         	movs	r3, #0x1
 80052c2: 77fb         	strb	r3, [r7, #0x1f]
 80052c4: 7ffb         	ldrb	r3, [r7, #0x1f]
 80052c6: f083 0301    	eor	r3, r3, #0x1
 80052ca: b2db         	uxtb	r3, r3
 80052cc: 2b00         	cmp	r3, #0x0
 80052ce: d115         	bne	0x80052fc <can_stm32_remove_rx_filter+0x1a0> @ imm = #0x2a
 80052d0: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x80053ac <can_stm32_remove_rx_filter+0x250>
 80052d2: 6819         	ldr	r1, [r3]
 80052d4: f897 3037    	ldrb.w	r3, [r7, #0x37]
 80052d8: 9305         	str	r3, [sp, #0x14]
 80052da: 683b         	ldr	r3, [r7]
 80052dc: 9304         	str	r3, [sp, #0x10]
 80052de: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x80053b8 <can_stm32_remove_rx_filter+0x25c>
 80052e0: 9303         	str	r3, [sp, #0xc]
 80052e2: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x80053bc <can_stm32_remove_rx_filter+0x260>
 80052e4: 9302         	str	r3, [sp, #0x8]
 80052e6: 2308         	movs	r3, #0x8
 80052e8: 9301         	str	r3, [sp, #0x4]
 80052ea: 2300         	movs	r3, #0x0
 80052ec: 9300         	str	r3, [sp]
 80052ee: 2300         	movs	r3, #0x0
 80052f0: 2204         	movs	r2, #0x4
 80052f2: 2000         	movs	r0, #0x0
 80052f4: f00a f989    	bl	0x800f60a <z_log_msg_runtime_create> @ imm = #0xa312
 80052f8: 2300         	movs	r3, #0x0
 80052fa: 61bb         	str	r3, [r7, #0x18]
; 	can->FMR |= CAN_FMR_FINIT;
 80052fc: 6a7b         	ldr	r3, [r7, #0x24]
 80052fe: f8d3 3200    	ldr.w	r3, [r3, #0x200]
 8005302: f043 0201    	orr	r2, r3, #0x1
 8005306: 6a7b         	ldr	r3, [r7, #0x24]
 8005308: f8c3 2200    	str.w	r2, [r3, #0x200]
; 	can_stm32_set_filter_bank(filter_id, &can->sFilterRegister[bank_num],
 800530c: 6bbb         	ldr	r3, [r7, #0x38]
 800530e: 3348         	adds	r3, #0x48
 8005310: 00db         	lsls	r3, r3, #0x3
 8005312: 6a7a         	ldr	r2, [r7, #0x24]
 8005314: 18d1         	adds	r1, r2, r3
 8005316: f897 2037    	ldrb.w	r2, [r7, #0x37]
 800531a: f04f 33ff    	mov.w	r3, #0xffffffff
 800531e: 9300         	str	r3, [sp]
 8005320: 2300         	movs	r3, #0x0
 8005322: 6838         	ldr	r0, [r7]
 8005324: f00a fbb3    	bl	0x800fa8e <can_stm32_set_filter_bank> @ imm = #0xa766
; 	if (bank_unused) {
 8005328: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 800532c: 2b00         	cmp	r3, #0x0
 800532e: d029         	beq	0x8005384 <can_stm32_remove_rx_filter+0x228> @ imm = #0x52
; 		can->FA1R &= ~(1U << bank_num);
 8005330: 6a7b         	ldr	r3, [r7, #0x24]
 8005332: f8d3 221c    	ldr.w	r2, [r3, #0x21c]
 8005336: 2101         	movs	r1, #0x1
 8005338: 6bbb         	ldr	r3, [r7, #0x38]
 800533a: fa01 f303    	lsl.w	r3, r1, r3
 800533e: 43db         	mvns	r3, r3
 8005340: 401a         	ands	r2, r3
 8005342: 6a7b         	ldr	r3, [r7, #0x24]
 8005344: f8c3 221c    	str.w	r2, [r3, #0x21c]
; 		LOG_DBG("Filter bank %d is unused -> deactivate", bank_num);
 8005348: 2303         	movs	r3, #0x3
 800534a: 2b03         	cmp	r3, #0x3
 800534c: d91a         	bls	0x8005384 <can_stm32_remove_rx_filter+0x228> @ imm = #0x34
 800534e: 2301         	movs	r3, #0x1
 8005350: 75fb         	strb	r3, [r7, #0x17]
 8005352: 7dfb         	ldrb	r3, [r7, #0x17]
 8005354: f083 0301    	eor	r3, r3, #0x1
 8005358: b2db         	uxtb	r3, r3
 800535a: 2b00         	cmp	r3, #0x0
 800535c: d112         	bne	0x8005384 <can_stm32_remove_rx_filter+0x228> @ imm = #0x24
 800535e: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x80053ac <can_stm32_remove_rx_filter+0x250>
 8005360: 6819         	ldr	r1, [r3]
 8005362: 6bbb         	ldr	r3, [r7, #0x38]
 8005364: 9304         	str	r3, [sp, #0x10]
 8005366: 4b14         	ldr	r3, [pc, #0x50]         @ 0x80053b8 <can_stm32_remove_rx_filter+0x25c>
 8005368: 9303         	str	r3, [sp, #0xc]
 800536a: 4b15         	ldr	r3, [pc, #0x54]         @ 0x80053c0 <can_stm32_remove_rx_filter+0x264>
 800536c: 9302         	str	r3, [sp, #0x8]
 800536e: 2308         	movs	r3, #0x8
 8005370: 9301         	str	r3, [sp, #0x4]
 8005372: 2300         	movs	r3, #0x0
 8005374: 9300         	str	r3, [sp]
 8005376: 2300         	movs	r3, #0x0
 8005378: 2204         	movs	r2, #0x4
 800537a: 2000         	movs	r0, #0x0
 800537c: f00a f945    	bl	0x800f60a <z_log_msg_runtime_create> @ imm = #0xa28a
 8005380: 2300         	movs	r3, #0x0
 8005382: 613b         	str	r3, [r7, #0x10]
; 	can->FMR &= ~(CAN_FMR_FINIT);
 8005384: 6a7b         	ldr	r3, [r7, #0x24]
 8005386: f8d3 3200    	ldr.w	r3, [r3, #0x200]
 800538a: f023 0201    	bic	r2, r3, #0x1
 800538e: 6a7b         	ldr	r3, [r7, #0x24]
 8005390: f8c3 2200    	str.w	r2, [r3, #0x200]
; 	k_mutex_unlock(&data->inst_mutex);
 8005394: 6abb         	ldr	r3, [r7, #0x28]
 8005396: 3310         	adds	r3, #0x10
 8005398: 4618         	mov	r0, r3
 800539a: f00a f85f    	bl	0x800f45c <k_mutex_unlock> @ imm = #0xa0be
; 	k_mutex_unlock(&filter_mutex);
 800539e: 4805         	ldr	r0, [pc, #0x14]         @ 0x80053b4 <can_stm32_remove_rx_filter+0x258>
 80053a0: f00a f85c    	bl	0x800f45c <k_mutex_unlock> @ imm = #0xa0b8
; }
 80053a4: 3740         	adds	r7, #0x40
 80053a6: 46bd         	mov	sp, r7
 80053a8: bd80         	pop	{r7, pc}
 80053aa: bf00         	nop

080053ac <$d>:
 80053ac: 48 00 00 20  	.word	0x20000048
 80053b0: 64 56 01 08  	.word	0x08015664
 80053b4: 84 06 00 20  	.word	0x20000684
 80053b8: 18 64 01 08  	.word	0x08016418
 80053bc: 80 56 01 08  	.word	0x08015680
 80053c0: a4 56 01 08  	.word	0x080156a4

080053c4 <LL_RCC_HSE_DisableBypass>:
; {
 80053c4: b480         	push	{r7}
 80053c6: af00         	add	r7, sp, #0x0
;   CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);
 80053c8: 4b04         	ldr	r3, [pc, #0x10]         @ 0x80053dc <LL_RCC_HSE_DisableBypass+0x18>
 80053ca: 681b         	ldr	r3, [r3]
 80053cc: 4a03         	ldr	r2, [pc, #0xc]          @ 0x80053dc <LL_RCC_HSE_DisableBypass+0x18>
 80053ce: f423 2380    	bic	r3, r3, #0x40000
 80053d2: 6013         	str	r3, [r2]
; }
 80053d4: bf00         	nop
 80053d6: 46bd         	mov	sp, r7
 80053d8: bc80         	pop	{r7}
 80053da: 4770         	bx	lr

080053dc <$d>:
 80053dc: 00 38 02 40  	.word	0x40023800

080053e0 <LL_RCC_HSE_Enable>:
; {
 80053e0: b480         	push	{r7}
 80053e2: af00         	add	r7, sp, #0x0
;   SET_BIT(RCC->CR, RCC_CR_HSEON);
 80053e4: 4b04         	ldr	r3, [pc, #0x10]         @ 0x80053f8 <LL_RCC_HSE_Enable+0x18>
 80053e6: 681b         	ldr	r3, [r3]
 80053e8: 4a03         	ldr	r2, [pc, #0xc]          @ 0x80053f8 <LL_RCC_HSE_Enable+0x18>
 80053ea: f443 3380    	orr	r3, r3, #0x10000
 80053ee: 6013         	str	r3, [r2]
; }
 80053f0: bf00         	nop
 80053f2: 46bd         	mov	sp, r7
 80053f4: bc80         	pop	{r7}
 80053f6: 4770         	bx	lr

080053f8 <$d>:
 80053f8: 00 38 02 40  	.word	0x40023800

080053fc <LL_RCC_HSE_IsReady>:
; {
 80053fc: b480         	push	{r7}
 80053fe: af00         	add	r7, sp, #0x0
;   return (READ_BIT(RCC->CR, RCC_CR_HSERDY) == (RCC_CR_HSERDY));
 8005400: 4b06         	ldr	r3, [pc, #0x18]         @ 0x800541c <LL_RCC_HSE_IsReady+0x20>
 8005402: 681b         	ldr	r3, [r3]
 8005404: f403 3300    	and	r3, r3, #0x20000
 8005408: f5b3 3f00    	cmp.w	r3, #0x20000
 800540c: bf0c         	ite	eq
 800540e: 2301         	moveq	r3, #0x1
 8005410: 2300         	movne	r3, #0x0
 8005412: b2db         	uxtb	r3, r3
; }
 8005414: 4618         	mov	r0, r3
 8005416: 46bd         	mov	sp, r7
 8005418: bc80         	pop	{r7}
 800541a: 4770         	bx	lr

0800541c <$d>:
 800541c: 00 38 02 40  	.word	0x40023800

08005420 <LL_RCC_HSI_Enable>:
; {
 8005420: b480         	push	{r7}
 8005422: af00         	add	r7, sp, #0x0
;   SET_BIT(RCC->CR, RCC_CR_HSION);
 8005424: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8005438 <LL_RCC_HSI_Enable+0x18>
 8005426: 681b         	ldr	r3, [r3]
 8005428: 4a03         	ldr	r2, [pc, #0xc]          @ 0x8005438 <LL_RCC_HSI_Enable+0x18>
 800542a: f043 0301    	orr	r3, r3, #0x1
 800542e: 6013         	str	r3, [r2]
; }
 8005430: bf00         	nop
 8005432: 46bd         	mov	sp, r7
 8005434: bc80         	pop	{r7}
 8005436: 4770         	bx	lr

08005438 <$d>:
 8005438: 00 38 02 40  	.word	0x40023800

0800543c <LL_RCC_HSI_IsReady>:
; {
 800543c: b480         	push	{r7}
 800543e: af00         	add	r7, sp, #0x0
;   return (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == (RCC_CR_HSIRDY));
 8005440: 4b06         	ldr	r3, [pc, #0x18]         @ 0x800545c <LL_RCC_HSI_IsReady+0x20>
 8005442: 681b         	ldr	r3, [r3]
 8005444: f003 0302    	and	r3, r3, #0x2
 8005448: 2b02         	cmp	r3, #0x2
 800544a: bf0c         	ite	eq
 800544c: 2301         	moveq	r3, #0x1
 800544e: 2300         	movne	r3, #0x0
 8005450: b2db         	uxtb	r3, r3
; }
 8005452: 4618         	mov	r0, r3
 8005454: 46bd         	mov	sp, r7
 8005456: bc80         	pop	{r7}
 8005458: 4770         	bx	lr
 800545a: bf00         	nop

0800545c <$d>:
 800545c: 00 38 02 40  	.word	0x40023800

08005460 <LL_RCC_LSI_Enable>:
; {
 8005460: b480         	push	{r7}
 8005462: af00         	add	r7, sp, #0x0
;   SET_BIT(RCC->CSR, RCC_CSR_LSION);
 8005464: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8005478 <LL_RCC_LSI_Enable+0x18>
 8005466: 6f5b         	ldr	r3, [r3, #0x74]
 8005468: 4a03         	ldr	r2, [pc, #0xc]          @ 0x8005478 <LL_RCC_LSI_Enable+0x18>
 800546a: f043 0301    	orr	r3, r3, #0x1
 800546e: 6753         	str	r3, [r2, #0x74]
; }
 8005470: bf00         	nop
 8005472: 46bd         	mov	sp, r7
 8005474: bc80         	pop	{r7}
 8005476: 4770         	bx	lr

08005478 <$d>:
 8005478: 00 38 02 40  	.word	0x40023800

0800547c <LL_RCC_LSI_IsReady>:
; {
 800547c: b480         	push	{r7}
 800547e: af00         	add	r7, sp, #0x0
;   return (READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == (RCC_CSR_LSIRDY));
 8005480: 4b06         	ldr	r3, [pc, #0x18]         @ 0x800549c <LL_RCC_LSI_IsReady+0x20>
 8005482: 6f5b         	ldr	r3, [r3, #0x74]
 8005484: f003 0302    	and	r3, r3, #0x2
 8005488: 2b02         	cmp	r3, #0x2
 800548a: bf0c         	ite	eq
 800548c: 2301         	moveq	r3, #0x1
 800548e: 2300         	movne	r3, #0x0
 8005490: b2db         	uxtb	r3, r3
; }
 8005492: 4618         	mov	r0, r3
 8005494: 46bd         	mov	sp, r7
 8005496: bc80         	pop	{r7}
 8005498: 4770         	bx	lr
 800549a: bf00         	nop

0800549c <$d>:
 800549c: 00 38 02 40  	.word	0x40023800

080054a0 <LL_RCC_SetSysClkSource>:
; {
 80054a0: b480         	push	{r7}
 80054a2: b083         	sub	sp, #0xc
 80054a4: af00         	add	r7, sp, #0x0
 80054a6: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, Source);
 80054a8: 4b06         	ldr	r3, [pc, #0x18]         @ 0x80054c4 <LL_RCC_SetSysClkSource+0x24>
 80054aa: 689b         	ldr	r3, [r3, #0x8]
 80054ac: f023 0203    	bic	r2, r3, #0x3
 80054b0: 4904         	ldr	r1, [pc, #0x10]         @ 0x80054c4 <LL_RCC_SetSysClkSource+0x24>
 80054b2: 687b         	ldr	r3, [r7, #0x4]
 80054b4: 4313         	orrs	r3, r2
 80054b6: 608b         	str	r3, [r1, #0x8]
; }
 80054b8: bf00         	nop
 80054ba: 370c         	adds	r7, #0xc
 80054bc: 46bd         	mov	sp, r7
 80054be: bc80         	pop	{r7}
 80054c0: 4770         	bx	lr
 80054c2: bf00         	nop

080054c4 <$d>:
 80054c4: 00 38 02 40  	.word	0x40023800

080054c8 <LL_RCC_GetSysClkSource>:
; {
 80054c8: b480         	push	{r7}
 80054ca: af00         	add	r7, sp, #0x0
;   return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 80054cc: 4b03         	ldr	r3, [pc, #0xc]          @ 0x80054dc <LL_RCC_GetSysClkSource+0x14>
 80054ce: 689b         	ldr	r3, [r3, #0x8]
 80054d0: f003 030c    	and	r3, r3, #0xc
; }
 80054d4: 4618         	mov	r0, r3
 80054d6: 46bd         	mov	sp, r7
 80054d8: bc80         	pop	{r7}
 80054da: 4770         	bx	lr

080054dc <$d>:
 80054dc: 00 38 02 40  	.word	0x40023800

080054e0 <LL_RCC_SetAHBPrescaler>:
; {
 80054e0: b480         	push	{r7}
 80054e2: b083         	sub	sp, #0xc
 80054e4: af00         	add	r7, sp, #0x0
 80054e6: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, Prescaler);
 80054e8: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8005504 <LL_RCC_SetAHBPrescaler+0x24>
 80054ea: 689b         	ldr	r3, [r3, #0x8]
 80054ec: f023 02f0    	bic	r2, r3, #0xf0
 80054f0: 4904         	ldr	r1, [pc, #0x10]         @ 0x8005504 <LL_RCC_SetAHBPrescaler+0x24>
 80054f2: 687b         	ldr	r3, [r7, #0x4]
 80054f4: 4313         	orrs	r3, r2
 80054f6: 608b         	str	r3, [r1, #0x8]
; }
 80054f8: bf00         	nop
 80054fa: 370c         	adds	r7, #0xc
 80054fc: 46bd         	mov	sp, r7
 80054fe: bc80         	pop	{r7}
 8005500: 4770         	bx	lr
 8005502: bf00         	nop

08005504 <$d>:
 8005504: 00 38 02 40  	.word	0x40023800

08005508 <LL_RCC_SetAPB1Prescaler>:
; {
 8005508: b480         	push	{r7}
 800550a: b083         	sub	sp, #0xc
 800550c: af00         	add	r7, sp, #0x0
 800550e: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, Prescaler);
 8005510: 4b06         	ldr	r3, [pc, #0x18]         @ 0x800552c <LL_RCC_SetAPB1Prescaler+0x24>
 8005512: 689b         	ldr	r3, [r3, #0x8]
 8005514: f423 52e0    	bic	r2, r3, #0x1c00
 8005518: 4904         	ldr	r1, [pc, #0x10]         @ 0x800552c <LL_RCC_SetAPB1Prescaler+0x24>
 800551a: 687b         	ldr	r3, [r7, #0x4]
 800551c: 4313         	orrs	r3, r2
 800551e: 608b         	str	r3, [r1, #0x8]
; }
 8005520: bf00         	nop
 8005522: 370c         	adds	r7, #0xc
 8005524: 46bd         	mov	sp, r7
 8005526: bc80         	pop	{r7}
 8005528: 4770         	bx	lr
 800552a: bf00         	nop

0800552c <$d>:
 800552c: 00 38 02 40  	.word	0x40023800

08005530 <LL_RCC_SetAPB2Prescaler>:
; {
 8005530: b480         	push	{r7}
 8005532: b083         	sub	sp, #0xc
 8005534: af00         	add	r7, sp, #0x0
 8005536: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, Prescaler);
 8005538: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8005554 <LL_RCC_SetAPB2Prescaler+0x24>
 800553a: 689b         	ldr	r3, [r3, #0x8]
 800553c: f423 4260    	bic	r2, r3, #0xe000
 8005540: 4904         	ldr	r1, [pc, #0x10]         @ 0x8005554 <LL_RCC_SetAPB2Prescaler+0x24>
 8005542: 687b         	ldr	r3, [r7, #0x4]
 8005544: 4313         	orrs	r3, r2
 8005546: 608b         	str	r3, [r1, #0x8]
; }
 8005548: bf00         	nop
 800554a: 370c         	adds	r7, #0xc
 800554c: 46bd         	mov	sp, r7
 800554e: bc80         	pop	{r7}
 8005550: 4770         	bx	lr
 8005552: bf00         	nop

08005554 <$d>:
 8005554: 00 38 02 40  	.word	0x40023800

08005558 <LL_RCC_GetAHBPrescaler>:
; {
 8005558: b480         	push	{r7}
 800555a: af00         	add	r7, sp, #0x0
;   return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_HPRE));
 800555c: 4b03         	ldr	r3, [pc, #0xc]          @ 0x800556c <LL_RCC_GetAHBPrescaler+0x14>
 800555e: 689b         	ldr	r3, [r3, #0x8]
 8005560: f003 03f0    	and	r3, r3, #0xf0
; }
 8005564: 4618         	mov	r0, r3
 8005566: 46bd         	mov	sp, r7
 8005568: bc80         	pop	{r7}
 800556a: 4770         	bx	lr

0800556c <$d>:
 800556c: 00 38 02 40  	.word	0x40023800

08005570 <LL_RCC_PLL_Enable>:
; {
 8005570: b480         	push	{r7}
 8005572: af00         	add	r7, sp, #0x0
;   SET_BIT(RCC->CR, RCC_CR_PLLON);
 8005574: 4b04         	ldr	r3, [pc, #0x10]         @ 0x8005588 <LL_RCC_PLL_Enable+0x18>
 8005576: 681b         	ldr	r3, [r3]
 8005578: 4a03         	ldr	r2, [pc, #0xc]          @ 0x8005588 <LL_RCC_PLL_Enable+0x18>
 800557a: f043 7380    	orr	r3, r3, #0x1000000
 800557e: 6013         	str	r3, [r2]
; }
 8005580: bf00         	nop
 8005582: 46bd         	mov	sp, r7
 8005584: bc80         	pop	{r7}
 8005586: 4770         	bx	lr

08005588 <$d>:
 8005588: 00 38 02 40  	.word	0x40023800

0800558c <LL_RCC_PLL_Disable>:
; {
 800558c: b480         	push	{r7}
 800558e: af00         	add	r7, sp, #0x0
;   CLEAR_BIT(RCC->CR, RCC_CR_PLLON);
 8005590: 4b04         	ldr	r3, [pc, #0x10]         @ 0x80055a4 <LL_RCC_PLL_Disable+0x18>
 8005592: 681b         	ldr	r3, [r3]
 8005594: 4a03         	ldr	r2, [pc, #0xc]          @ 0x80055a4 <LL_RCC_PLL_Disable+0x18>
 8005596: f023 7380    	bic	r3, r3, #0x1000000
 800559a: 6013         	str	r3, [r2]
; }
 800559c: bf00         	nop
 800559e: 46bd         	mov	sp, r7
 80055a0: bc80         	pop	{r7}
 80055a2: 4770         	bx	lr

080055a4 <$d>:
 80055a4: 00 38 02 40  	.word	0x40023800

080055a8 <LL_RCC_PLL_IsReady>:
; {
 80055a8: b480         	push	{r7}
 80055aa: af00         	add	r7, sp, #0x0
;   return (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == (RCC_CR_PLLRDY));
 80055ac: 4b06         	ldr	r3, [pc, #0x18]         @ 0x80055c8 <LL_RCC_PLL_IsReady+0x20>
 80055ae: 681b         	ldr	r3, [r3]
 80055b0: f003 7300    	and	r3, r3, #0x2000000
 80055b4: f1b3 7f00    	cmp.w	r3, #0x2000000
 80055b8: bf0c         	ite	eq
 80055ba: 2301         	moveq	r3, #0x1
 80055bc: 2300         	movne	r3, #0x0
 80055be: b2db         	uxtb	r3, r3
; }
 80055c0: 4618         	mov	r0, r3
 80055c2: 46bd         	mov	sp, r7
 80055c4: bc80         	pop	{r7}
 80055c6: 4770         	bx	lr

080055c8 <$d>:
 80055c8: 00 38 02 40  	.word	0x40023800

080055cc <enabled_clock>:
; {
 80055cc: b480         	push	{r7}
 80055ce: b085         	sub	sp, #0x14
 80055d0: af00         	add	r7, sp, #0x0
 80055d2: 6078         	str	r0, [r7, #0x4]
; 	int r = 0;
 80055d4: 2300         	movs	r3, #0x0
 80055d6: 60fb         	str	r3, [r7, #0xc]
; 	switch (src_clk) {
 80055d8: 687b         	ldr	r3, [r7, #0x4]
 80055da: 3b01         	subs	r3, #0x1
 80055dc: 2b08         	cmp	r3, #0x8
 80055de: d825         	bhi	0x800562c <enabled_clock+0x60> @ imm = #0x4a
 80055e0: a201         	adr	r2, #4 <enabled_clock+0x19>
 80055e2: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]
 80055e6: bf00         	nop

080055e8 <$d>:
 80055e8: 33 56 00 08  	.word	0x08005633
 80055ec: 15 56 00 08  	.word	0x08005615
 80055f0: 33 56 00 08  	.word	0x08005633
 80055f4: 0d 56 00 08  	.word	0x0800560d
 80055f8: 33 56 00 08  	.word	0x08005633
 80055fc: 33 56 00 08  	.word	0x08005633
 8005600: 33 56 00 08  	.word	0x08005633
 8005604: 1d 56 00 08  	.word	0x0800561d
 8005608: 25 56 00 08  	.word	0x08005625

0800560c <$t>:
; 			r = -ENOTSUP;
 800560c: f06f 0385    	mvn	r3, #0x85
 8005610: 60fb         	str	r3, [r7, #0xc]
; 		break;
 8005612: e00f         	b	0x8005634 <enabled_clock+0x68> @ imm = #0x1e
; 			r = -ENOTSUP;
 8005614: f06f 0385    	mvn	r3, #0x85
 8005618: 60fb         	str	r3, [r7, #0xc]
; 		break;
 800561a: e00b         	b	0x8005634 <enabled_clock+0x68> @ imm = #0x16
; 			r = -ENOTSUP;
 800561c: f06f 0385    	mvn	r3, #0x85
 8005620: 60fb         	str	r3, [r7, #0xc]
; 		break;
 8005622: e007         	b	0x8005634 <enabled_clock+0x68> @ imm = #0xe
; 			r = -ENOTSUP;
 8005624: f06f 0385    	mvn	r3, #0x85
 8005628: 60fb         	str	r3, [r7, #0xc]
; 		break;
 800562a: e003         	b	0x8005634 <enabled_clock+0x68> @ imm = #0x6
; 		return -ENOTSUP;
 800562c: f06f 0385    	mvn	r3, #0x85
 8005630: e001         	b	0x8005636 <enabled_clock+0x6a> @ imm = #0x2
; 		break;
 8005632: bf00         	nop
; 	return r;
 8005634: 68fb         	ldr	r3, [r7, #0xc]
; }
 8005636: 4618         	mov	r0, r3
 8005638: 3714         	adds	r7, #0x14
 800563a: 46bd         	mov	sp, r7
 800563c: bc80         	pop	{r7}
 800563e: 4770         	bx	lr

08005640 <stm32_clock_control_get_subsys_rate>:
; {
 8005640: b580         	push	{r7, lr}
 8005642: b08a         	sub	sp, #0x28
 8005644: af00         	add	r7, sp, #0x0
 8005646: 60f8         	str	r0, [r7, #0xc]
 8005648: 60b9         	str	r1, [r7, #0x8]
 800564a: 607a         	str	r2, [r7, #0x4]
; 	struct stm32_pclken *pclken = (struct stm32_pclken *)(sub_system);
 800564c: 68bb         	ldr	r3, [r7, #0x8]
 800564e: 627b         	str	r3, [r7, #0x24]
; 	uint32_t ahb_clock = SystemCoreClock;
 8005650: 4b78         	ldr	r3, [pc, #0x1e0]        @ 0x8005834 <stm32_clock_control_get_subsys_rate+0x1f4>
 8005652: 681b         	ldr	r3, [r3]
 8005654: 623b         	str	r3, [r7, #0x20]
; 	uint32_t apb1_clock = get_bus_clock(ahb_clock, STM32_APB1_PRESCALER);
 8005656: 2104         	movs	r1, #0x4
 8005658: 6a38         	ldr	r0, [r7, #0x20]
 800565a: f00a faec    	bl	0x800fc36 <get_bus_clock> @ imm = #0xa5d8
 800565e: 61f8         	str	r0, [r7, #0x1c]
; 	uint32_t apb2_clock = get_bus_clock(ahb_clock, STM32_APB2_PRESCALER);
 8005660: 2102         	movs	r1, #0x2
 8005662: 6a38         	ldr	r0, [r7, #0x20]
 8005664: f00a fae7    	bl	0x800fc36 <get_bus_clock> @ imm = #0xa5ce
 8005668: 61b8         	str	r0, [r7, #0x18]
; 	uint32_t ahb3_clock = ahb_clock;
 800566a: 6a3b         	ldr	r3, [r7, #0x20]
 800566c: 617b         	str	r3, [r7, #0x14]
; 	switch (pclken->bus) {
 800566e: 6a7b         	ldr	r3, [r7, #0x24]
 8005670: 681b         	ldr	r3, [r3]
 8005672: 2b44         	cmp	r3, #0x44
 8005674: f200 8092    	bhi.w	0x800579c <stm32_clock_control_get_subsys_rate+0x15c> @ imm = #0x124
 8005678: 2b00         	cmp	r3, #0x0
 800567a: f000 80d2    	beq.w	0x8005822 <stm32_clock_control_get_subsys_rate+0x1e2> @ imm = #0x1a4
 800567e: 3b01         	subs	r3, #0x1
 8005680: 2b43         	cmp	r3, #0x43
 8005682: f200 80ce    	bhi.w	0x8005822 <stm32_clock_control_get_subsys_rate+0x1e2> @ imm = #0x19c
 8005686: a201         	adr	r2, #4 <stm32_clock_control_get_subsys_rate+0x4b>
 8005688: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]

0800568c <$d>:
 800568c: cb 57 00 08  	.word	0x080057cb
 8005690: 01 58 00 08  	.word	0x08005801
 8005694: 09 58 00 08  	.word	0x08005809
 8005698: 13 58 00 08  	.word	0x08005813
 800569c: 1b 58 00 08  	.word	0x0800581b
 80056a0: d5 57 00 08  	.word	0x080057d5
 80056a4: eb 57 00 08  	.word	0x080057eb
 80056a8: 23 58 00 08  	.word	0x08005823
 80056ac: 23 58 00 08  	.word	0x08005823
 80056b0: 23 58 00 08  	.word	0x08005823
 80056b4: 23 58 00 08  	.word	0x08005823
 80056b8: 23 58 00 08  	.word	0x08005823
 80056bc: 23 58 00 08  	.word	0x08005823
 80056c0: 23 58 00 08  	.word	0x08005823
 80056c4: 23 58 00 08  	.word	0x08005823
 80056c8: 23 58 00 08  	.word	0x08005823
 80056cc: 23 58 00 08  	.word	0x08005823
 80056d0: 23 58 00 08  	.word	0x08005823
 80056d4: 23 58 00 08  	.word	0x08005823
 80056d8: 23 58 00 08  	.word	0x08005823
 80056dc: 23 58 00 08  	.word	0x08005823
 80056e0: 23 58 00 08  	.word	0x08005823
 80056e4: 23 58 00 08  	.word	0x08005823
 80056e8: 23 58 00 08  	.word	0x08005823
 80056ec: 23 58 00 08  	.word	0x08005823
 80056f0: 23 58 00 08  	.word	0x08005823
 80056f4: 23 58 00 08  	.word	0x08005823
 80056f8: 23 58 00 08  	.word	0x08005823
 80056fc: 23 58 00 08  	.word	0x08005823
 8005700: 23 58 00 08  	.word	0x08005823
 8005704: 23 58 00 08  	.word	0x08005823
 8005708: 23 58 00 08  	.word	0x08005823
 800570c: 23 58 00 08  	.word	0x08005823
 8005710: 23 58 00 08  	.word	0x08005823
 8005714: 23 58 00 08  	.word	0x08005823
 8005718: 23 58 00 08  	.word	0x08005823
 800571c: 23 58 00 08  	.word	0x08005823
 8005720: 23 58 00 08  	.word	0x08005823
 8005724: 23 58 00 08  	.word	0x08005823
 8005728: 23 58 00 08  	.word	0x08005823
 800572c: 23 58 00 08  	.word	0x08005823
 8005730: 23 58 00 08  	.word	0x08005823
 8005734: 23 58 00 08  	.word	0x08005823
 8005738: 23 58 00 08  	.word	0x08005823
 800573c: 23 58 00 08  	.word	0x08005823
 8005740: 23 58 00 08  	.word	0x08005823
 8005744: 23 58 00 08  	.word	0x08005823
 8005748: a3 57 00 08  	.word	0x080057a3
 800574c: 23 58 00 08  	.word	0x08005823
 8005750: 23 58 00 08  	.word	0x08005823
 8005754: 23 58 00 08  	.word	0x08005823
 8005758: a3 57 00 08  	.word	0x080057a3
 800575c: 23 58 00 08  	.word	0x08005823
 8005760: 23 58 00 08  	.word	0x08005823
 8005764: 23 58 00 08  	.word	0x08005823
 8005768: ab 57 00 08  	.word	0x080057ab
 800576c: 23 58 00 08  	.word	0x08005823
 8005770: 23 58 00 08  	.word	0x08005823
 8005774: 23 58 00 08  	.word	0x08005823
 8005778: 23 58 00 08  	.word	0x08005823
 800577c: 23 58 00 08  	.word	0x08005823
 8005780: 23 58 00 08  	.word	0x08005823
 8005784: 23 58 00 08  	.word	0x08005823
 8005788: b3 57 00 08  	.word	0x080057b3
 800578c: 23 58 00 08  	.word	0x08005823
 8005790: 23 58 00 08  	.word	0x08005823
 8005794: 23 58 00 08  	.word	0x08005823
 8005798: bb 57 00 08  	.word	0x080057bb

0800579c <$t>:
 800579c: 2ba8         	cmp	r3, #0xa8
 800579e: d010         	beq	0x80057c2 <stm32_clock_control_get_subsys_rate+0x182> @ imm = #0x20
 80057a0: e03f         	b	0x8005822 <stm32_clock_control_get_subsys_rate+0x1e2> @ imm = #0x7e
; 		*rate = ahb_clock;
 80057a2: 687b         	ldr	r3, [r7, #0x4]
 80057a4: 6a3a         	ldr	r2, [r7, #0x20]
 80057a6: 601a         	str	r2, [r3]
; 		break;
 80057a8: e03e         	b	0x8005828 <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0x7c
; 		*rate = ahb3_clock;
 80057aa: 687b         	ldr	r3, [r7, #0x4]
 80057ac: 697a         	ldr	r2, [r7, #0x14]
 80057ae: 601a         	str	r2, [r3]
; 		break;
 80057b0: e03a         	b	0x8005828 <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0x74
; 		*rate = apb1_clock;
 80057b2: 687b         	ldr	r3, [r7, #0x4]
 80057b4: 69fa         	ldr	r2, [r7, #0x1c]
 80057b6: 601a         	str	r2, [r3]
; 		break;
 80057b8: e036         	b	0x8005828 <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0x6c
; 		*rate = apb2_clock;
 80057ba: 687b         	ldr	r3, [r7, #0x4]
 80057bc: 69ba         	ldr	r2, [r7, #0x18]
 80057be: 601a         	str	r2, [r3]
; 		break;
 80057c0: e032         	b	0x8005828 <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0x64
; 		*rate = ahb3_clock;
 80057c2: 687b         	ldr	r3, [r7, #0x4]
 80057c4: 697a         	ldr	r2, [r7, #0x14]
 80057c6: 601a         	str	r2, [r3]
; 		break;
 80057c8: e02e         	b	0x8005828 <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0x5c
; 		*rate = SystemCoreClock * STM32_CORE_PRESCALER;
 80057ca: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x8005834 <stm32_clock_control_get_subsys_rate+0x1f4>
 80057cc: 681a         	ldr	r2, [r3]
 80057ce: 687b         	ldr	r3, [r7, #0x4]
 80057d0: 601a         	str	r2, [r3]
; 		break;
 80057d2: e029         	b	0x8005828 <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0x52
; 		*rate = get_pll_div_frequency(get_pllsrc_frequency(),
 80057d4: f000 f8f0    	bl	0x80059b8 <get_pllsrc_frequency> @ imm = #0x1e0
 80057d8: 2302         	movs	r3, #0x2
 80057da: 22a8         	movs	r2, #0xa8
 80057dc: 2106         	movs	r1, #0x6
 80057de: f00a fa14    	bl	0x800fc0a <get_pll_div_frequency> @ imm = #0xa428
 80057e2: 4602         	mov	r2, r0
 80057e4: 687b         	ldr	r3, [r7, #0x4]
 80057e6: 601a         	str	r2, [r3]
; 		break;
 80057e8: e01e         	b	0x8005828 <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0x3c
; 		*rate = get_pll_div_frequency(get_pllsrc_frequency(),
 80057ea: f000 f8e5    	bl	0x80059b8 <get_pllsrc_frequency> @ imm = #0x1ca
 80057ee: 2304         	movs	r3, #0x4
 80057f0: 22a8         	movs	r2, #0xa8
 80057f2: 2106         	movs	r1, #0x6
 80057f4: f00a fa09    	bl	0x800fc0a <get_pll_div_frequency> @ imm = #0xa412
 80057f8: 4602         	mov	r2, r0
 80057fa: 687b         	ldr	r3, [r7, #0x4]
 80057fc: 601a         	str	r2, [r3]
; 		break;
 80057fe: e013         	b	0x8005828 <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0x26
; 		*rate = STM32_LSE_FREQ;
 8005800: 687b         	ldr	r3, [r7, #0x4]
 8005802: 2200         	movs	r2, #0x0
 8005804: 601a         	str	r2, [r3]
; 		break;
 8005806: e00f         	b	0x8005828 <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0x1e
; 		*rate = STM32_LSI_FREQ;
 8005808: 687b         	ldr	r3, [r7, #0x4]
 800580a: f44f 42fa    	mov.w	r2, #0x7d00
 800580e: 601a         	str	r2, [r3]
; 		break;
 8005810: e00a         	b	0x8005828 <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0x14
; 		*rate = STM32_HSI_FREQ;
 8005812: 687b         	ldr	r3, [r7, #0x4]
 8005814: 2200         	movs	r2, #0x0
 8005816: 601a         	str	r2, [r3]
; 		break;
 8005818: e006         	b	0x8005828 <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0xc
; 		*rate = STM32_HSE_FREQ;
 800581a: 687b         	ldr	r3, [r7, #0x4]
 800581c: 4a06         	ldr	r2, [pc, #0x18]         @ 0x8005838 <stm32_clock_control_get_subsys_rate+0x1f8>
 800581e: 601a         	str	r2, [r3]
; 		break;
 8005820: e002         	b	0x8005828 <stm32_clock_control_get_subsys_rate+0x1e8> @ imm = #0x4
; 		return -ENOTSUP;
 8005822: f06f 0385    	mvn	r3, #0x85
 8005826: e000         	b	0x800582a <stm32_clock_control_get_subsys_rate+0x1ea> @ imm = #0x0
; 	return 0;
 8005828: 2300         	movs	r3, #0x0
; }
 800582a: 4618         	mov	r0, r3
 800582c: 3728         	adds	r7, #0x28
 800582e: 46bd         	mov	sp, r7
 8005830: bd80         	pop	{r7, pc}
 8005832: bf00         	nop

08005834 <$d>:
 8005834: f4 00 00 20  	.word	0x200000f4
 8005838: 00 1b b7 00  	.word	0x00b71b00

0800583c <set_up_plls>:
; {
 800583c: b580         	push	{r7, lr}
 800583e: af00         	add	r7, sp, #0x0
; 	if (LL_RCC_GetSysClkSource() == LL_RCC_SYS_CLKSOURCE_STATUS_PLL) {
 8005840: f7ff fe42    	bl	0x80054c8 <LL_RCC_GetSysClkSource> @ imm = #-0x37c
 8005844: 4603         	mov	r3, r0
 8005846: 2b08         	cmp	r3, #0x8
 8005848: d104         	bne	0x8005854 <set_up_plls+0x18> @ imm = #0x8
; 		stm32_clock_switch_to_hsi();
 800584a: f00a fb00    	bl	0x800fe4e <stm32_clock_switch_to_hsi> @ imm = #0xa600
; 		LL_RCC_SetAHBPrescaler(ahb_prescaler(1));
 800584e: 2000         	movs	r0, #0x0
 8005850: f7ff fe46    	bl	0x80054e0 <LL_RCC_SetAHBPrescaler> @ imm = #-0x374
; 	LL_RCC_PLL_Disable();
 8005854: f7ff fe9a    	bl	0x800558c <LL_RCC_PLL_Disable> @ imm = #-0x2cc
; 	MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLP, pllp(STM32_PLL_P_DIVISOR));
 8005858: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8005890 <set_up_plls+0x54>
 800585a: 685b         	ldr	r3, [r3, #0x4]
 800585c: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x8005890 <set_up_plls+0x54>
 800585e: f423 3340    	bic	r3, r3, #0x30000
 8005862: 6053         	str	r3, [r2, #0x4]
; 	MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLQ, pllq(STM32_PLL_Q_DIVISOR));
 8005864: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8005890 <set_up_plls+0x54>
 8005866: 685b         	ldr	r3, [r3, #0x4]
 8005868: f023 6370    	bic	r3, r3, #0xf000000
 800586c: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8005890 <set_up_plls+0x54>
 800586e: f043 6380    	orr	r3, r3, #0x4000000
 8005872: 6053         	str	r3, [r2, #0x4]
; 	config_pll_sysclock();
 8005874: f00a fb2e    	bl	0x800fed4 <config_pll_sysclock> @ imm = #0xa65c
; 	LL_RCC_PLL_Enable();
 8005878: f7ff fe7a    	bl	0x8005570 <LL_RCC_PLL_Enable> @ imm = #-0x30c
; 	while (LL_RCC_PLL_IsReady() != 1U) {
 800587c: bf00         	nop
 800587e: f7ff fe93    	bl	0x80055a8 <LL_RCC_PLL_IsReady> @ imm = #-0x2da
 8005882: 4603         	mov	r3, r0
 8005884: 2b01         	cmp	r3, #0x1
 8005886: d1fa         	bne	0x800587e <set_up_plls+0x42> @ imm = #-0xc
; }
 8005888: bf00         	nop
 800588a: bf00         	nop
 800588c: bd80         	pop	{r7, pc}
 800588e: bf00         	nop

08005890 <$d>:
 8005890: 00 38 02 40  	.word	0x40023800

08005894 <stm32_clock_control_init>:
; {
 8005894: b590         	push	{r4, r7, lr}
 8005896: b085         	sub	sp, #0x14
 8005898: af00         	add	r7, sp, #0x0
 800589a: 6078         	str	r0, [r7, #0x4]
; 	config_enable_default_clocks();
 800589c: f00a fb25    	bl	0x800feea <config_enable_default_clocks> @ imm = #0xa64a
; 	config_regulator_voltage(CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC);
 80058a0: 4823         	ldr	r0, [pc, #0x8c]         @ 0x8005930 <stm32_clock_control_init+0x9c>
 80058a2: f00a fb06    	bl	0x800feb2 <config_regulator_voltage> @ imm = #0xa60c
; 	old_flash_freq = RCC_CALC_FLASH_FREQ(HAL_RCC_GetSysClockFreq(),
 80058a6: f003 f921    	bl	0x8008aec <HAL_RCC_GetSysClockFreq> @ imm = #0x3242
 80058aa: 4604         	mov	r4, r0
 80058ac: f7ff fe54    	bl	0x8005558 <LL_RCC_GetAHBPrescaler> @ imm = #-0x358
 80058b0: 4603         	mov	r3, r0
 80058b2: 091b         	lsrs	r3, r3, #0x4
 80058b4: f003 030f    	and	r3, r3, #0xf
 80058b8: 4a1e         	ldr	r2, [pc, #0x78]         @ 0x8005934 <stm32_clock_control_init+0xa0>
 80058ba: 5cd3         	ldrb	r3, [r2, r3]
 80058bc: fa24 f303    	lsr.w	r3, r4, r3
 80058c0: 60fb         	str	r3, [r7, #0xc]
; 	new_flash_freq = RCC_CALC_FLASH_FREQ(CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC,
 80058c2: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x8005934 <stm32_clock_control_init+0xa0>
 80058c4: 781b         	ldrb	r3, [r3]
 80058c6: 461a         	mov	r2, r3
 80058c8: 4b19         	ldr	r3, [pc, #0x64]         @ 0x8005930 <stm32_clock_control_init+0x9c>
 80058ca: 4113         	asrs	r3, r2
 80058cc: 60bb         	str	r3, [r7, #0x8]
; 	if (old_flash_freq < new_flash_freq) {
 80058ce: 68fa         	ldr	r2, [r7, #0xc]
 80058d0: 68bb         	ldr	r3, [r7, #0x8]
 80058d2: 429a         	cmp	r2, r3
 80058d4: d202         	bhs	0x80058dc <stm32_clock_control_init+0x48> @ imm = #0x4
; 		LL_SetFlashLatency(new_flash_freq);
 80058d6: 68b8         	ldr	r0, [r7, #0x8]
 80058d8: f003 f9fa    	bl	0x8008cd0 <LL_SetFlashLatency> @ imm = #0x33f4
; 	set_up_fixed_clock_sources();
 80058dc: f00a fad2    	bl	0x800fe84 <set_up_fixed_clock_sources> @ imm = #0xa5a4
; 	set_up_plls();
 80058e0: f7ff ffac    	bl	0x800583c <set_up_plls> @ imm = #-0xa8
; 		LL_RCC_SetAHBPrescaler(ahb_prescaler(STM32_CORE_PRESCALER));
 80058e4: 2000         	movs	r0, #0x0
 80058e6: f7ff fdfb    	bl	0x80054e0 <LL_RCC_SetAHBPrescaler> @ imm = #-0x40a
; 	LL_RCC_SetSysClkSource(LL_RCC_SYS_CLKSOURCE_PLL);
 80058ea: 2002         	movs	r0, #0x2
 80058ec: f7ff fdd8    	bl	0x80054a0 <LL_RCC_SetSysClkSource> @ imm = #-0x450
; 	while (LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_PLL) {
 80058f0: bf00         	nop
 80058f2: f7ff fde9    	bl	0x80054c8 <LL_RCC_GetSysClkSource> @ imm = #-0x42e
 80058f6: 4603         	mov	r3, r0
 80058f8: 2b08         	cmp	r3, #0x8
 80058fa: d1fa         	bne	0x80058f2 <stm32_clock_control_init+0x5e> @ imm = #-0xc
; 	if (old_flash_freq >= new_flash_freq) {
 80058fc: 68fa         	ldr	r2, [r7, #0xc]
 80058fe: 68bb         	ldr	r3, [r7, #0x8]
 8005900: 429a         	cmp	r2, r3
 8005902: d302         	blo	0x800590a <stm32_clock_control_init+0x76> @ imm = #0x4
; 		LL_SetFlashLatency(new_flash_freq);
 8005904: 68b8         	ldr	r0, [r7, #0x8]
 8005906: f003 f9e3    	bl	0x8008cd0 <LL_SetFlashLatency> @ imm = #0x33c6
; 	SystemCoreClock = CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC;
 800590a: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8005938 <stm32_clock_control_init+0xa4>
 800590c: 4a08         	ldr	r2, [pc, #0x20]         @ 0x8005930 <stm32_clock_control_init+0x9c>
 800590e: 601a         	str	r2, [r3]
; 	LL_RCC_SetAPB1Prescaler(apb1_prescaler(STM32_APB1_PRESCALER));
 8005910: f44f 50a0    	mov.w	r0, #0x1400
 8005914: f7ff fdf8    	bl	0x8005508 <LL_RCC_SetAPB1Prescaler> @ imm = #-0x410
; 	LL_RCC_SetAPB2Prescaler(apb2_prescaler(STM32_APB2_PRESCALER));
 8005918: f44f 4000    	mov.w	r0, #0x8000
 800591c: f7ff fe08    	bl	0x8005530 <LL_RCC_SetAPB2Prescaler> @ imm = #-0x3f0
; 	stm32_clock_control_mco_init();
 8005920: f00a f96d    	bl	0x800fbfe <stm32_clock_control_mco_init> @ imm = #0xa2da
; 	return 0;
 8005924: 2300         	movs	r3, #0x0
; }
 8005926: 4618         	mov	r0, r3
 8005928: 3714         	adds	r7, #0x14
 800592a: 46bd         	mov	sp, r7
 800592c: bd90         	pop	{r4, r7, pc}
 800592e: bf00         	nop

08005930 <$d>:
 8005930: 00 7a 03 0a  	.word	0x0a037a00
 8005934: 88 67 01 08  	.word	0x08016788
 8005938: f4 00 00 20  	.word	0x200000f4

0800593c <LL_APB1_GRP1_EnableClock>:
; {
 800593c: b480         	push	{r7}
 800593e: b085         	sub	sp, #0x14
 8005940: af00         	add	r7, sp, #0x0
 8005942: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(RCC->APB1ENR, Periphs);
 8005944: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8005968 <LL_APB1_GRP1_EnableClock+0x2c>
 8005946: 6c1a         	ldr	r2, [r3, #0x40]
 8005948: 4907         	ldr	r1, [pc, #0x1c]         @ 0x8005968 <LL_APB1_GRP1_EnableClock+0x2c>
 800594a: 687b         	ldr	r3, [r7, #0x4]
 800594c: 4313         	orrs	r3, r2
 800594e: 640b         	str	r3, [r1, #0x40]
;   tmpreg = READ_BIT(RCC->APB1ENR, Periphs);
 8005950: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8005968 <LL_APB1_GRP1_EnableClock+0x2c>
 8005952: 6c1a         	ldr	r2, [r3, #0x40]
 8005954: 687b         	ldr	r3, [r7, #0x4]
 8005956: 4013         	ands	r3, r2
 8005958: 60fb         	str	r3, [r7, #0xc]
;   (void)tmpreg;
 800595a: 68fb         	ldr	r3, [r7, #0xc]
; }
 800595c: bf00         	nop
 800595e: 3714         	adds	r7, #0x14
 8005960: 46bd         	mov	sp, r7
 8005962: bc80         	pop	{r7}
 8005964: 4770         	bx	lr
 8005966: bf00         	nop

08005968 <$d>:
 8005968: 00 38 02 40  	.word	0x40023800

0800596c <LL_RCC_PLL_ConfigDomain_SYS>:
; {
 800596c: b480         	push	{r7}
 800596e: b085         	sub	sp, #0x14
 8005970: af00         	add	r7, sp, #0x0
 8005972: 60f8         	str	r0, [r7, #0xc]
 8005974: 60b9         	str	r1, [r7, #0x8]
 8005976: 607a         	str	r2, [r7, #0x4]
 8005978: 603b         	str	r3, [r7]
;   MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC | RCC_PLLCFGR_PLLM | RCC_PLLCFGR_PLLN,
 800597a: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x80059b0 <LL_RCC_PLL_ConfigDomain_SYS+0x44>
 800597c: 685a         	ldr	r2, [r3, #0x4]
 800597e: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x80059b4 <LL_RCC_PLL_ConfigDomain_SYS+0x48>
 8005980: 4013         	ands	r3, r2
 8005982: 68f9         	ldr	r1, [r7, #0xc]
 8005984: 68ba         	ldr	r2, [r7, #0x8]
 8005986: 4311         	orrs	r1, r2
 8005988: 687a         	ldr	r2, [r7, #0x4]
 800598a: 0192         	lsls	r2, r2, #0x6
 800598c: 430a         	orrs	r2, r1
 800598e: 4908         	ldr	r1, [pc, #0x20]         @ 0x80059b0 <LL_RCC_PLL_ConfigDomain_SYS+0x44>
 8005990: 4313         	orrs	r3, r2
 8005992: 604b         	str	r3, [r1, #0x4]
;   MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLP, PLLP_R);
 8005994: 4b06         	ldr	r3, [pc, #0x18]         @ 0x80059b0 <LL_RCC_PLL_ConfigDomain_SYS+0x44>
 8005996: 685b         	ldr	r3, [r3, #0x4]
 8005998: f423 3240    	bic	r2, r3, #0x30000
 800599c: 4904         	ldr	r1, [pc, #0x10]         @ 0x80059b0 <LL_RCC_PLL_ConfigDomain_SYS+0x44>
 800599e: 683b         	ldr	r3, [r7]
 80059a0: 4313         	orrs	r3, r2
 80059a2: 604b         	str	r3, [r1, #0x4]
; }
 80059a4: bf00         	nop
 80059a6: 3714         	adds	r7, #0x14
 80059a8: 46bd         	mov	sp, r7
 80059aa: bc80         	pop	{r7}
 80059ac: 4770         	bx	lr
 80059ae: bf00         	nop

080059b0 <$d>:
 80059b0: 00 38 02 40  	.word	0x40023800
 80059b4: 00 80 bf ff  	.word	0xffbf8000

080059b8 <get_pllsrc_frequency>:
; {
 80059b8: b480         	push	{r7}
 80059ba: af00         	add	r7, sp, #0x0
; 		return STM32_HSE_FREQ;
 80059bc: 4b02         	ldr	r3, [pc, #0x8]          @ 0x80059c8 <get_pllsrc_frequency+0x10>
; }
 80059be: 4618         	mov	r0, r3
 80059c0: 46bd         	mov	sp, r7
 80059c2: bc80         	pop	{r7}
 80059c4: 4770         	bx	lr
 80059c6: bf00         	nop

080059c8 <$d>:
 80059c8: 00 1b b7 00  	.word	0x00b71b00

080059cc <console_out>:
; {
 80059cc: b580         	push	{r7, lr}
 80059ce: b082         	sub	sp, #0x8
 80059d0: af00         	add	r7, sp, #0x0
 80059d2: 6078         	str	r0, [r7, #0x4]
; 	if (pm_device_runtime_get(uart_console_dev) < 0) {
 80059d4: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8005a20 <console_out+0x54>
 80059d6: 4618         	mov	r0, r3
 80059d8: f00a fabd    	bl	0x800ff56 <pm_device_runtime_get> @ imm = #0xa57a
 80059dc: 4603         	mov	r3, r0
 80059de: 2b00         	cmp	r3, #0x0
 80059e0: da01         	bge	0x80059e6 <console_out+0x1a> @ imm = #0x2
; 		return c;
 80059e2: 6879         	ldr	r1, [r7, #0x4]
 80059e4: e017         	b	0x8005a16 <console_out+0x4a> @ imm = #0x2e
; 	if ('\n' == c) {
 80059e6: 687b         	ldr	r3, [r7, #0x4]
 80059e8: 2b0a         	cmp	r3, #0xa
 80059ea: d104         	bne	0x80059f6 <console_out+0x2a> @ imm = #0x8
; 		uart_poll_out(uart_console_dev, '\r');
 80059ec: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8005a20 <console_out+0x54>
 80059ee: 210d         	movs	r1, #0xd
 80059f0: 4618         	mov	r0, r3
 80059f2: f00a faa1    	bl	0x800ff38 <uart_poll_out> @ imm = #0xa542
; 	uart_poll_out(uart_console_dev, c);
 80059f6: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x8005a20 <console_out+0x54>
 80059f8: 687b         	ldr	r3, [r7, #0x4]
 80059fa: b2db         	uxtb	r3, r3
 80059fc: 4619         	mov	r1, r3
 80059fe: 4610         	mov	r0, r2
 8005a00: f00a fa9a    	bl	0x800ff38 <uart_poll_out> @ imm = #0xa534
; 	(void)pm_device_runtime_put_async(uart_console_dev, K_MSEC(1));
 8005a04: 4906         	ldr	r1, [pc, #0x18]         @ 0x8005a20 <console_out+0x54>
 8005a06: f04f 020a    	mov.w	r2, #0xa
 8005a0a: f04f 0300    	mov.w	r3, #0x0
 8005a0e: 4608         	mov	r0, r1
 8005a10: f00a faab    	bl	0x800ff6a <pm_device_runtime_put_async> @ imm = #0xa556
; 	return c;
 8005a14: 6879         	ldr	r1, [r7, #0x4]
; }
 8005a16: 460b         	mov	r3, r1
 8005a18: 4618         	mov	r0, r3
 8005a1a: 3708         	adds	r7, #0x8
 8005a1c: 46bd         	mov	sp, r7
 8005a1e: bd80         	pop	{r7, pc}

08005a20 <$d>:
 8005a20: 94 46 01 08  	.word	0x08014694

08005a24 <uart_console_hook_install>:
; {
 8005a24: b580         	push	{r7, lr}
 8005a26: af00         	add	r7, sp, #0x0
; 	__stdout_hook_install(console_out);
 8005a28: 4803         	ldr	r0, [pc, #0xc]          @ 0x8005a38 <uart_console_hook_install+0x14>
 8005a2a: f7fd fcc1    	bl	0x80033b0 <__stdout_hook_install> @ imm = #-0x267e
; 	__printk_hook_install(console_out);
 8005a2e: 4802         	ldr	r0, [pc, #0x8]          @ 0x8005a38 <uart_console_hook_install+0x14>
 8005a30: f7fb fc54    	bl	0x80012dc <__printk_hook_install> @ imm = #-0x4758
; }
 8005a34: bf00         	nop
 8005a36: bd80         	pop	{r7, pc}

08005a38 <$d>:
 8005a38: cd 59 00 08  	.word	0x080059cd

08005a3c <uart_console_init>:
; {
 8005a3c: b580         	push	{r7, lr}
 8005a3e: af00         	add	r7, sp, #0x0
; 	if (!device_is_ready(uart_console_dev)) {
 8005a40: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8005a64 <uart_console_init+0x28>
 8005a42: 4618         	mov	r0, r3
 8005a44: f00a fa59    	bl	0x800fefa <device_is_ready> @ imm = #0xa4b2
 8005a48: 4603         	mov	r3, r0
 8005a4a: f083 0301    	eor	r3, r3, #0x1
 8005a4e: b2db         	uxtb	r3, r3
 8005a50: 2b00         	cmp	r3, #0x0
 8005a52: d002         	beq	0x8005a5a <uart_console_init+0x1e> @ imm = #0x4
; 		return -ENODEV;
 8005a54: f06f 0312    	mvn	r3, #0x12
 8005a58: e002         	b	0x8005a60 <uart_console_init+0x24> @ imm = #0x4
; 	uart_console_hook_install();
 8005a5a: f7ff ffe3    	bl	0x8005a24 <uart_console_hook_install> @ imm = #-0x3a
; 	return 0;
 8005a5e: 2300         	movs	r3, #0x0
; }
 8005a60: 4618         	mov	r0, r3
 8005a62: bd80         	pop	{r7, pc}

08005a64 <$d>:
 8005a64: 94 46 01 08  	.word	0x08014694

08005a68 <gpio_stm32_clock_request>:
; {
 8005a68: b580         	push	{r7, lr}
 8005a6a: b086         	sub	sp, #0x18
 8005a6c: af00         	add	r7, sp, #0x0
 8005a6e: 6078         	str	r0, [r7, #0x4]
 8005a70: 460b         	mov	r3, r1
 8005a72: 70fb         	strb	r3, [r7, #0x3]
; 	const struct gpio_stm32_config *cfg = dev->config;
 8005a74: 687b         	ldr	r3, [r7, #0x4]
 8005a76: 685b         	ldr	r3, [r3, #0x4]
 8005a78: 613b         	str	r3, [r7, #0x10]
; 	const struct device *const clk = DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE);
 8005a7a: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8005aac <gpio_stm32_clock_request+0x44>
 8005a7c: 60fb         	str	r3, [r7, #0xc]
; 	if (on) {
 8005a7e: 78fb         	ldrb	r3, [r7, #0x3]
 8005a80: 2b00         	cmp	r3, #0x0
 8005a82: d007         	beq	0x8005a94 <gpio_stm32_clock_request+0x2c> @ imm = #0xe
; 					(clock_control_subsys_t)&cfg->pclken);
 8005a84: 693b         	ldr	r3, [r7, #0x10]
 8005a86: 330c         	adds	r3, #0xc
; 		ret = clock_control_on(clk,
 8005a88: 4619         	mov	r1, r3
 8005a8a: 68f8         	ldr	r0, [r7, #0xc]
 8005a8c: f00a fcf3    	bl	0x8010476 <clock_control_on> @ imm = #0xa9e6
 8005a90: 6178         	str	r0, [r7, #0x14]
 8005a92: e006         	b	0x8005aa2 <gpio_stm32_clock_request+0x3a> @ imm = #0xc
; 					(clock_control_subsys_t)&cfg->pclken);
 8005a94: 693b         	ldr	r3, [r7, #0x10]
 8005a96: 330c         	adds	r3, #0xc
; 		ret = clock_control_off(clk,
 8005a98: 4619         	mov	r1, r3
 8005a9a: 68f8         	ldr	r0, [r7, #0xc]
 8005a9c: f00a fcfd    	bl	0x801049a <clock_control_off> @ imm = #0xa9fa
 8005aa0: 6178         	str	r0, [r7, #0x14]
; 	return ret;
 8005aa2: 697b         	ldr	r3, [r7, #0x14]
; }
 8005aa4: 4618         	mov	r0, r3
 8005aa6: 3718         	adds	r7, #0x18
 8005aa8: 46bd         	mov	sp, r7
 8005aaa: bd80         	pop	{r7, pc}

08005aac <$d>:
 8005aac: a4 45 01 08  	.word	0x080145a4

08005ab0 <gpio_stm32_pin_interrupt_configure>:
; {
 8005ab0: b580         	push	{r7, lr}
 8005ab2: b08a         	sub	sp, #0x28
 8005ab4: af00         	add	r7, sp, #0x0
 8005ab6: 60f8         	str	r0, [r7, #0xc]
 8005ab8: 607a         	str	r2, [r7, #0x4]
 8005aba: 603b         	str	r3, [r7]
 8005abc: 460b         	mov	r3, r1
 8005abe: 72fb         	strb	r3, [r7, #0xb]
; 	const struct gpio_stm32_config *cfg = dev->config;
 8005ac0: 68fb         	ldr	r3, [r7, #0xc]
 8005ac2: 685b         	ldr	r3, [r3, #0x4]
 8005ac4: 61fb         	str	r3, [r7, #0x1c]
; 	struct gpio_stm32_data *data = dev->data;
 8005ac6: 68fb         	ldr	r3, [r7, #0xc]
 8005ac8: 691b         	ldr	r3, [r3, #0x10]
 8005aca: 61bb         	str	r3, [r7, #0x18]
; 	const stm32_gpio_irq_line_t irq_line = stm32_gpio_intc_get_pin_irq_line(cfg->port, pin);
 8005acc: 69fb         	ldr	r3, [r7, #0x1c]
 8005ace: 689b         	ldr	r3, [r3, #0x8]
 8005ad0: 461a         	mov	r2, r3
 8005ad2: 7afb         	ldrb	r3, [r7, #0xb]
 8005ad4: 4619         	mov	r1, r3
 8005ad6: 4610         	mov	r0, r2
 8005ad8: f009 fb01    	bl	0x800f0de <stm32_gpio_intc_get_pin_irq_line> @ imm = #0x9602
 8005adc: 6178         	str	r0, [r7, #0x14]
; 	uint32_t irq_trigger = 0;
 8005ade: 2300         	movs	r3, #0x0
 8005ae0: 627b         	str	r3, [r7, #0x24]
; 	int err = 0;
 8005ae2: 2300         	movs	r3, #0x0
 8005ae4: 623b         	str	r3, [r7, #0x20]
; 	if (mode == GPIO_INT_MODE_DISABLED) {
 8005ae6: 687b         	ldr	r3, [r7, #0x4]
 8005ae8: f5b3 1f00    	cmp.w	r3, #0x200000
 8005aec: d108         	bne	0x8005b00 <gpio_stm32_pin_interrupt_configure+0x50> @ imm = #0x10
; 		gpio_stm32_disable_pin_irqs(cfg->port, pin);
 8005aee: 69fb         	ldr	r3, [r7, #0x1c]
 8005af0: 689b         	ldr	r3, [r3, #0x8]
 8005af2: 461a         	mov	r2, r3
 8005af4: 7afb         	ldrb	r3, [r7, #0xb]
 8005af6: 4619         	mov	r1, r3
 8005af8: 4610         	mov	r0, r2
 8005afa: f00a fe3e    	bl	0x801077a <gpio_stm32_disable_pin_irqs> @ imm = #0xac7c
; 		goto exit;
 8005afe: e040         	b	0x8005b82 <gpio_stm32_pin_interrupt_configure+0xd2> @ imm = #0x80
; 	if (mode == GPIO_INT_MODE_LEVEL) {
 8005b00: 687b         	ldr	r3, [r7, #0x4]
 8005b02: f5b3 0f80    	cmp.w	r3, #0x400000
 8005b06: d103         	bne	0x8005b10 <gpio_stm32_pin_interrupt_configure+0x60> @ imm = #0x6
; 			err = -ENOTSUP;
 8005b08: f06f 0385    	mvn	r3, #0x85
 8005b0c: 623b         	str	r3, [r7, #0x20]
; 			goto exit;
 8005b0e: e038         	b	0x8005b82 <gpio_stm32_pin_interrupt_configure+0xd2> @ imm = #0x70
; 		switch (trig) {
 8005b10: 683b         	ldr	r3, [r7]
 8005b12: f1b3 6fc0    	cmp.w	r3, #0x6000000
 8005b16: d012         	beq	0x8005b3e <gpio_stm32_pin_interrupt_configure+0x8e> @ imm = #0x24
 8005b18: 683b         	ldr	r3, [r7]
 8005b1a: f1b3 6fc0    	cmp.w	r3, #0x6000000
 8005b1e: d811         	bhi	0x8005b44 <gpio_stm32_pin_interrupt_configure+0x94> @ imm = #0x22
 8005b20: 683b         	ldr	r3, [r7]
 8005b22: f1b3 7f00    	cmp.w	r3, #0x2000000
 8005b26: d004         	beq	0x8005b32 <gpio_stm32_pin_interrupt_configure+0x82> @ imm = #0x8
 8005b28: 683b         	ldr	r3, [r7]
 8005b2a: f1b3 6f80    	cmp.w	r3, #0x4000000
 8005b2e: d003         	beq	0x8005b38 <gpio_stm32_pin_interrupt_configure+0x88> @ imm = #0x6
 8005b30: e008         	b	0x8005b44 <gpio_stm32_pin_interrupt_configure+0x94> @ imm = #0x10
; 			irq_trigger = STM32_GPIO_IRQ_TRIG_FALLING;
 8005b32: 2302         	movs	r3, #0x2
 8005b34: 627b         	str	r3, [r7, #0x24]
; 			break;
 8005b36: e009         	b	0x8005b4c <gpio_stm32_pin_interrupt_configure+0x9c> @ imm = #0x12
; 			irq_trigger = STM32_GPIO_IRQ_TRIG_RISING;
 8005b38: 2301         	movs	r3, #0x1
 8005b3a: 627b         	str	r3, [r7, #0x24]
; 			break;
 8005b3c: e006         	b	0x8005b4c <gpio_stm32_pin_interrupt_configure+0x9c> @ imm = #0xc
; 			irq_trigger = STM32_GPIO_IRQ_TRIG_BOTH;
 8005b3e: 2303         	movs	r3, #0x3
 8005b40: 627b         	str	r3, [r7, #0x24]
; 			break;
 8005b42: e003         	b	0x8005b4c <gpio_stm32_pin_interrupt_configure+0x9c> @ imm = #0x6
; 			err = -EINVAL;
 8005b44: f06f 0315    	mvn	r3, #0x15
 8005b48: 623b         	str	r3, [r7, #0x20]
; 			goto exit;
 8005b4a: e01a         	b	0x8005b82 <gpio_stm32_pin_interrupt_configure+0xd2> @ imm = #0x34
; 	if (stm32_gpio_intc_set_irq_callback(irq_line, gpio_stm32_isr, data) != 0) {
 8005b4c: 69ba         	ldr	r2, [r7, #0x18]
 8005b4e: 490f         	ldr	r1, [pc, #0x3c]         @ 0x8005b8c <gpio_stm32_pin_interrupt_configure+0xdc>
 8005b50: 6978         	ldr	r0, [r7, #0x14]
 8005b52: f7fd feb3    	bl	0x80038bc <stm32_gpio_intc_set_irq_callback> @ imm = #-0x229a
 8005b56: 4603         	mov	r3, r0
 8005b58: 2b00         	cmp	r3, #0x0
 8005b5a: d003         	beq	0x8005b64 <gpio_stm32_pin_interrupt_configure+0xb4> @ imm = #0x6
; 		err = -EBUSY;
 8005b5c: f06f 030f    	mvn	r3, #0xf
 8005b60: 623b         	str	r3, [r7, #0x20]
; 		goto exit;
 8005b62: e00e         	b	0x8005b82 <gpio_stm32_pin_interrupt_configure+0xd2> @ imm = #0x1c
; 	stm32_exti_set_line_src_port(pin, cfg->port);
 8005b64: 69fb         	ldr	r3, [r7, #0x1c]
 8005b66: 689b         	ldr	r3, [r3, #0x8]
 8005b68: 461a         	mov	r2, r3
 8005b6a: 7afb         	ldrb	r3, [r7, #0xb]
 8005b6c: 4611         	mov	r1, r2
 8005b6e: 4618         	mov	r0, r3
 8005b70: f009 facf    	bl	0x800f112 <stm32_exti_set_line_src_port> @ imm = #0x959e
; 	stm32_gpio_intc_select_line_trigger(irq_line, irq_trigger);
 8005b74: 6a79         	ldr	r1, [r7, #0x24]
 8005b76: 6978         	ldr	r0, [r7, #0x14]
 8005b78: f7fd fe64    	bl	0x8003844 <stm32_gpio_intc_select_line_trigger> @ imm = #-0x2338
; 	stm32_gpio_intc_enable_line(irq_line);
 8005b7c: 6978         	ldr	r0, [r7, #0x14]
 8005b7e: f7fd fe45    	bl	0x800380c <stm32_gpio_intc_enable_line> @ imm = #-0x2376
; 	return err;
 8005b82: 6a3b         	ldr	r3, [r7, #0x20]
; }
 8005b84: 4618         	mov	r0, r3
 8005b86: 3728         	adds	r7, #0x28
 8005b88: 46bd         	mov	sp, r7
 8005b8a: bd80         	pop	{r7, pc}

08005b8c <$d>:
 8005b8c: 3f 06 01 08  	.word	0x0801063f

08005b90 <gpio_stm32_init>:
; {
 8005b90: b580         	push	{r7, lr}
 8005b92: b084         	sub	sp, #0x10
 8005b94: af00         	add	r7, sp, #0x0
 8005b96: 6078         	str	r0, [r7, #0x4]
; 	struct gpio_stm32_data *data = dev->data;
 8005b98: 687b         	ldr	r3, [r7, #0x4]
 8005b9a: 691b         	ldr	r3, [r3, #0x10]
 8005b9c: 60fb         	str	r3, [r7, #0xc]
; 	data->dev = dev;
 8005b9e: 68fb         	ldr	r3, [r7, #0xc]
 8005ba0: 687a         	ldr	r2, [r7, #0x4]
 8005ba2: 605a         	str	r2, [r3, #0x4]
; 	if (!device_is_ready(DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE))) {
 8005ba4: 480e         	ldr	r0, [pc, #0x38]         @ 0x8005be0 <gpio_stm32_init+0x50>
 8005ba6: f00a fae4    	bl	0x8010172 <device_is_ready> @ imm = #0xa5c8
 8005baa: 4603         	mov	r3, r0
 8005bac: f083 0301    	eor	r3, r3, #0x1
 8005bb0: b2db         	uxtb	r3, r3
 8005bb2: 2b00         	cmp	r3, #0x0
 8005bb4: d002         	beq	0x8005bbc <gpio_stm32_init+0x2c> @ imm = #0x4
; 		return -ENODEV;
 8005bb6: f06f 0312    	mvn	r3, #0x12
 8005bba: e00d         	b	0x8005bd8 <gpio_stm32_init+0x48> @ imm = #0x1a
; 	ret = gpio_stm32_clock_request(dev, !IS_ENABLED(CONFIG_PM_DEVICE_RUNTIME));
 8005bbc: 2101         	movs	r1, #0x1
 8005bbe: 6878         	ldr	r0, [r7, #0x4]
 8005bc0: f7ff ff52    	bl	0x8005a68 <gpio_stm32_clock_request> @ imm = #-0x15c
 8005bc4: 60b8         	str	r0, [r7, #0x8]
; 	if (ret < 0) {
 8005bc6: 68bb         	ldr	r3, [r7, #0x8]
 8005bc8: 2b00         	cmp	r3, #0x0
 8005bca: da01         	bge	0x8005bd0 <gpio_stm32_init+0x40> @ imm = #0x2
; 		return ret;
 8005bcc: 68bb         	ldr	r3, [r7, #0x8]
 8005bce: e003         	b	0x8005bd8 <gpio_stm32_init+0x48> @ imm = #0x6
; 	(void)pm_device_runtime_enable(dev);
 8005bd0: 6878         	ldr	r0, [r7, #0x4]
 8005bd2: f00a fc74    	bl	0x80104be <pm_device_runtime_enable> @ imm = #0xa8e8
; 	return 0;
 8005bd6: 2300         	movs	r3, #0x0
; }
 8005bd8: 4618         	mov	r0, r3
 8005bda: 3710         	adds	r7, #0x10
 8005bdc: 46bd         	mov	sp, r7
 8005bde: bd80         	pop	{r7, pc}

08005be0 <$d>:
 8005be0: a4 45 01 08  	.word	0x080145a4

08005be4 <stm32_pin_configure>:
; {
 8005be4: b580         	push	{r7, lr}
 8005be6: b086         	sub	sp, #0x18
 8005be8: af00         	add	r7, sp, #0x0
 8005bea: 60f8         	str	r0, [r7, #0xc]
 8005bec: 60b9         	str	r1, [r7, #0x8]
 8005bee: 607a         	str	r2, [r7, #0x4]
; 	if (STM32_PORT(pin) >= gpio_ports_cnt) {
 8005bf0: 68fb         	ldr	r3, [r7, #0xc]
 8005bf2: 091b         	lsrs	r3, r3, #0x4
 8005bf4: 2210         	movs	r2, #0x10
 8005bf6: 4293         	cmp	r3, r2
 8005bf8: d302         	blo	0x8005c00 <stm32_pin_configure+0x1c> @ imm = #0x4
; 		return -EINVAL;
 8005bfa: f06f 0315    	mvn	r3, #0x15
 8005bfe: e01f         	b	0x8005c40 <stm32_pin_configure+0x5c> @ imm = #0x3e
; 	port_device = gpio_ports[STM32_PORT(pin)];
 8005c00: 68fb         	ldr	r3, [r7, #0xc]
 8005c02: 091b         	lsrs	r3, r3, #0x4
 8005c04: 4a10         	ldr	r2, [pc, #0x40]         @ 0x8005c48 <stm32_pin_configure+0x64>
 8005c06: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 8005c0a: 617b         	str	r3, [r7, #0x14]
; 	if ((port_device == NULL) || (!device_is_ready(port_device))) {
 8005c0c: 697b         	ldr	r3, [r7, #0x14]
 8005c0e: 2b00         	cmp	r3, #0x0
 8005c10: d008         	beq	0x8005c24 <stm32_pin_configure+0x40> @ imm = #0x10
 8005c12: 6978         	ldr	r0, [r7, #0x14]
 8005c14: f00a ffc0    	bl	0x8010b98 <device_is_ready> @ imm = #0xaf80
 8005c18: 4603         	mov	r3, r0
 8005c1a: f083 0301    	eor	r3, r3, #0x1
 8005c1e: b2db         	uxtb	r3, r3
 8005c20: 2b00         	cmp	r3, #0x0
 8005c22: d002         	beq	0x8005c2a <stm32_pin_configure+0x46> @ imm = #0x4
; 		return -ENODEV;
 8005c24: f06f 0312    	mvn	r3, #0x12
 8005c28: e00a         	b	0x8005c40 <stm32_pin_configure+0x5c> @ imm = #0x14
; 	return gpio_stm32_configure(port_device, STM32_PIN(pin), pin_cgf, pin_func);
 8005c2a: 68fb         	ldr	r3, [r7, #0xc]
 8005c2c: b2db         	uxtb	r3, r3
 8005c2e: f003 030f    	and	r3, r3, #0xf
 8005c32: b2d9         	uxtb	r1, r3
 8005c34: 687b         	ldr	r3, [r7, #0x4]
 8005c36: 68ba         	ldr	r2, [r7, #0x8]
 8005c38: 6978         	ldr	r0, [r7, #0x14]
 8005c3a: f00a fea2    	bl	0x8010982 <gpio_stm32_configure> @ imm = #0xad44
 8005c3e: 4603         	mov	r3, r0
; }
 8005c40: 4618         	mov	r0, r3
 8005c42: 3718         	adds	r7, #0x18
 8005c44: 46bd         	mov	sp, r7
 8005c46: bd80         	pop	{r7, pc}

08005c48 <$d>:
 8005c48: 0c 65 01 08  	.word	0x0801650c

08005c4c <LL_USART_SetBaudRate>:
; {
 8005c4c: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 8005c50: b0c0         	sub	sp, #0x100
 8005c52: af00         	add	r7, sp, #0x0
 8005c54: f8c7 00fc    	str.w	r0, [r7, #0xfc]
 8005c58: f8c7 10f8    	str.w	r1, [r7, #0xf8]
 8005c5c: f8c7 20f4    	str.w	r2, [r7, #0xf4]
 8005c60: f8c7 30f0    	str.w	r3, [r7, #0xf0]
;   if (OverSampling == LL_USART_OVERSAMPLING_8)
 8005c64: f8d7 30f4    	ldr.w	r3, [r7, #0xf4]
 8005c68: f5b3 4f00    	cmp.w	r3, #0x8000
 8005c6c: f040 810e    	bne.w	0x8005e8c <LL_USART_SetBaudRate+0x240> @ imm = #0x21c
;     USARTx->BRR = (uint16_t)(__LL_USART_DIV_SAMPLING8(PeriphClk, BaudRate));
 8005c70: f8d7 30f8    	ldr.w	r3, [r7, #0xf8]
 8005c74: 2200         	movs	r2, #0x0
 8005c76: f8c7 30e8    	str.w	r3, [r7, #0xe8]
 8005c7a: f8c7 20ec    	str.w	r2, [r7, #0xec]
 8005c7e: e9d7 453a    	ldrd	r4, r5, [r7, #232]
 8005c82: 4622         	mov	r2, r4
 8005c84: 462b         	mov	r3, r5
 8005c86: 1891         	adds	r1, r2, r2
 8005c88: 6639         	str	r1, [r7, #0x60]
 8005c8a: 415b         	adcs	r3, r3
 8005c8c: 667b         	str	r3, [r7, #0x64]
 8005c8e: e9d7 2318    	ldrd	r2, r3, [r7, #96]
 8005c92: 4620         	mov	r0, r4
 8005c94: 4629         	mov	r1, r5
 8005c96: 4604         	mov	r4, r0
 8005c98: eb12 0804    	adds.w	r8, r2, r4
 8005c9c: 460c         	mov	r4, r1
 8005c9e: eb43 0904    	adc.w	r9, r3, r4
 8005ca2: f04f 0200    	mov.w	r2, #0x0
 8005ca6: f04f 0300    	mov.w	r3, #0x0
 8005caa: ea4f 03c9    	lsl.w	r3, r9, #0x3
 8005cae: ea43 7358    	orr.w	r3, r3, r8, lsr #29
 8005cb2: ea4f 02c8    	lsl.w	r2, r8, #0x3
 8005cb6: 4690         	mov	r8, r2
 8005cb8: 4699         	mov	r9, r3
 8005cba: 4603         	mov	r3, r0
 8005cbc: eb18 0303    	adds.w	r3, r8, r3
 8005cc0: f8c7 30e0    	str.w	r3, [r7, #0xe0]
 8005cc4: 460b         	mov	r3, r1
 8005cc6: eb49 0303    	adc.w	r3, r9, r3
 8005cca: f8c7 30e4    	str.w	r3, [r7, #0xe4]
 8005cce: f8d7 30f0    	ldr.w	r3, [r7, #0xf0]
 8005cd2: 2200         	movs	r2, #0x0
 8005cd4: 469a         	mov	r10, r3
 8005cd6: 4693         	mov	r11, r2
 8005cd8: eb1a 030a    	adds.w	r3, r10, r10
 8005cdc: 65bb         	str	r3, [r7, #0x58]
 8005cde: eb4b 030b    	adc.w	r3, r11, r11
 8005ce2: 65fb         	str	r3, [r7, #0x5c]
 8005ce4: e9d7 2316    	ldrd	r2, r3, [r7, #88]
 8005ce8: e9d7 0138    	ldrd	r0, r1, [r7, #224]
 8005cec: f7fa fd46    	bl	0x800077c <__aeabi_uldivmod> @ imm = #-0x5574
 8005cf0: 4602         	mov	r2, r0
 8005cf2: 460b         	mov	r3, r1
 8005cf4: 4b64         	ldr	r3, [pc, #0x190]        @ 0x8005e88 <LL_USART_SetBaudRate+0x23c>
 8005cf6: fba3 2302    	umull	r2, r3, r3, r2
 8005cfa: 095b         	lsrs	r3, r3, #0x5
 8005cfc: b29b         	uxth	r3, r3
 8005cfe: 011b         	lsls	r3, r3, #0x4
 8005d00: b29c         	uxth	r4, r3
 8005d02: f8d7 30f8    	ldr.w	r3, [r7, #0xf8]
 8005d06: 2200         	movs	r2, #0x0
 8005d08: f8c7 30d8    	str.w	r3, [r7, #0xd8]
 8005d0c: f8c7 20dc    	str.w	r2, [r7, #0xdc]
 8005d10: e9d7 8936    	ldrd	r8, r9, [r7, #216]
 8005d14: 4642         	mov	r2, r8
 8005d16: 464b         	mov	r3, r9
 8005d18: 1891         	adds	r1, r2, r2
 8005d1a: 6539         	str	r1, [r7, #0x50]
 8005d1c: 415b         	adcs	r3, r3
 8005d1e: 657b         	str	r3, [r7, #0x54]
 8005d20: e9d7 2314    	ldrd	r2, r3, [r7, #80]
 8005d24: 4641         	mov	r1, r8
 8005d26: 1851         	adds	r1, r2, r1
 8005d28: 64b9         	str	r1, [r7, #0x48]
 8005d2a: 4649         	mov	r1, r9
 8005d2c: 414b         	adcs	r3, r1
 8005d2e: 64fb         	str	r3, [r7, #0x4c]
 8005d30: f04f 0200    	mov.w	r2, #0x0
 8005d34: f04f 0300    	mov.w	r3, #0x0
 8005d38: e9d7 ab12    	ldrd	r10, r11, [r7, #72]
 8005d3c: 4659         	mov	r1, r11
 8005d3e: 00cb         	lsls	r3, r1, #0x3
 8005d40: 4655         	mov	r5, r10
 8005d42: ea43 7355    	orr.w	r3, r3, r5, lsr #29
 8005d46: 4651         	mov	r1, r10
 8005d48: 00ca         	lsls	r2, r1, #0x3
 8005d4a: 4610         	mov	r0, r2
 8005d4c: 4619         	mov	r1, r3
 8005d4e: 4603         	mov	r3, r0
 8005d50: 4642         	mov	r2, r8
 8005d52: 189b         	adds	r3, r3, r2
 8005d54: f8c7 30d0    	str.w	r3, [r7, #0xd0]
 8005d58: 464b         	mov	r3, r9
 8005d5a: 460a         	mov	r2, r1
 8005d5c: eb42 0303    	adc.w	r3, r2, r3
 8005d60: f8c7 30d4    	str.w	r3, [r7, #0xd4]
 8005d64: f8d7 30f0    	ldr.w	r3, [r7, #0xf0]
 8005d68: 2200         	movs	r2, #0x0
 8005d6a: f8c7 30c8    	str.w	r3, [r7, #0xc8]
 8005d6e: f8c7 20cc    	str.w	r2, [r7, #0xcc]
 8005d72: e9d7 1232    	ldrd	r1, r2, [r7, #200]
 8005d76: 460b         	mov	r3, r1
 8005d78: 18db         	adds	r3, r3, r3
 8005d7a: 643b         	str	r3, [r7, #0x40]
 8005d7c: 4613         	mov	r3, r2
 8005d7e: eb42 0303    	adc.w	r3, r2, r3
 8005d82: 647b         	str	r3, [r7, #0x44]
 8005d84: e9d7 2310    	ldrd	r2, r3, [r7, #64]
 8005d88: e9d7 0134    	ldrd	r0, r1, [r7, #208]
 8005d8c: f7fa fcf6    	bl	0x800077c <__aeabi_uldivmod> @ imm = #-0x5614
 8005d90: 4602         	mov	r2, r0
 8005d92: 460b         	mov	r3, r1
 8005d94: 4611         	mov	r1, r2
 8005d96: 4b3c         	ldr	r3, [pc, #0xf0]         @ 0x8005e88 <LL_USART_SetBaudRate+0x23c>
 8005d98: fba3 2301    	umull	r2, r3, r3, r1
 8005d9c: 095b         	lsrs	r3, r3, #0x5
 8005d9e: 2264         	movs	r2, #0x64
 8005da0: fb02 f303    	mul	r3, r2, r3
 8005da4: 1acb         	subs	r3, r1, r3
 8005da6: 00db         	lsls	r3, r3, #0x3
 8005da8: f103 0232    	add.w	r2, r3, #0x32
 8005dac: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x8005e88 <LL_USART_SetBaudRate+0x23c>
 8005dae: fba3 2302    	umull	r2, r3, r3, r2
 8005db2: 095b         	lsrs	r3, r3, #0x5
 8005db4: b29b         	uxth	r3, r3
 8005db6: 005b         	lsls	r3, r3, #0x1
 8005db8: b29b         	uxth	r3, r3
 8005dba: f403 73f8    	and	r3, r3, #0x1f0
 8005dbe: b29b         	uxth	r3, r3
 8005dc0: 4423         	add	r3, r4
 8005dc2: b29c         	uxth	r4, r3
 8005dc4: f8d7 30f8    	ldr.w	r3, [r7, #0xf8]
 8005dc8: 2200         	movs	r2, #0x0
 8005dca: f8c7 30c0    	str.w	r3, [r7, #0xc0]
 8005dce: f8c7 20c4    	str.w	r2, [r7, #0xc4]
 8005dd2: e9d7 8930    	ldrd	r8, r9, [r7, #192]
 8005dd6: 4642         	mov	r2, r8
 8005dd8: 464b         	mov	r3, r9
 8005dda: 1891         	adds	r1, r2, r2
 8005ddc: 63b9         	str	r1, [r7, #0x38]
 8005dde: 415b         	adcs	r3, r3
 8005de0: 63fb         	str	r3, [r7, #0x3c]
 8005de2: e9d7 230e    	ldrd	r2, r3, [r7, #56]
 8005de6: 4641         	mov	r1, r8
 8005de8: 1851         	adds	r1, r2, r1
 8005dea: 6339         	str	r1, [r7, #0x30]
 8005dec: 4649         	mov	r1, r9
 8005dee: 414b         	adcs	r3, r1
 8005df0: 637b         	str	r3, [r7, #0x34]
 8005df2: f04f 0200    	mov.w	r2, #0x0
 8005df6: f04f 0300    	mov.w	r3, #0x0
 8005dfa: e9d7 ab0c    	ldrd	r10, r11, [r7, #48]
 8005dfe: 4659         	mov	r1, r11
 8005e00: 00cb         	lsls	r3, r1, #0x3
 8005e02: 4655         	mov	r5, r10
 8005e04: ea43 7355    	orr.w	r3, r3, r5, lsr #29
 8005e08: 4651         	mov	r1, r10
 8005e0a: 00ca         	lsls	r2, r1, #0x3
 8005e0c: 4610         	mov	r0, r2
 8005e0e: 4619         	mov	r1, r3
 8005e10: 4603         	mov	r3, r0
 8005e12: 4642         	mov	r2, r8
 8005e14: 189b         	adds	r3, r3, r2
 8005e16: f8c7 30b8    	str.w	r3, [r7, #0xb8]
 8005e1a: 464b         	mov	r3, r9
 8005e1c: 460a         	mov	r2, r1
 8005e1e: eb42 0303    	adc.w	r3, r2, r3
 8005e22: f8c7 30bc    	str.w	r3, [r7, #0xbc]
 8005e26: f8d7 30f0    	ldr.w	r3, [r7, #0xf0]
 8005e2a: 2200         	movs	r2, #0x0
 8005e2c: f8c7 30b0    	str.w	r3, [r7, #0xb0]
 8005e30: f8c7 20b4    	str.w	r2, [r7, #0xb4]
 8005e34: e9d7 122c    	ldrd	r1, r2, [r7, #176]
 8005e38: 460b         	mov	r3, r1
 8005e3a: 18db         	adds	r3, r3, r3
 8005e3c: 62bb         	str	r3, [r7, #0x28]
 8005e3e: 4613         	mov	r3, r2
 8005e40: eb42 0303    	adc.w	r3, r2, r3
 8005e44: 62fb         	str	r3, [r7, #0x2c]
 8005e46: e9d7 230a    	ldrd	r2, r3, [r7, #40]
 8005e4a: e9d7 012e    	ldrd	r0, r1, [r7, #184]
 8005e4e: f7fa fc95    	bl	0x800077c <__aeabi_uldivmod> @ imm = #-0x56d6
 8005e52: 4602         	mov	r2, r0
 8005e54: 460b         	mov	r3, r1
 8005e56: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8005e88 <LL_USART_SetBaudRate+0x23c>
 8005e58: fba3 1302    	umull	r1, r3, r3, r2
 8005e5c: 095b         	lsrs	r3, r3, #0x5
 8005e5e: 2164         	movs	r1, #0x64
 8005e60: fb01 f303    	mul	r3, r1, r3
 8005e64: 1ad3         	subs	r3, r2, r3
 8005e66: 00db         	lsls	r3, r3, #0x3
 8005e68: 3332         	adds	r3, #0x32
 8005e6a: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8005e88 <LL_USART_SetBaudRate+0x23c>
 8005e6c: fba2 2303    	umull	r2, r3, r2, r3
 8005e70: 095b         	lsrs	r3, r3, #0x5
 8005e72: b29b         	uxth	r3, r3
 8005e74: f003 0307    	and	r3, r3, #0x7
 8005e78: b29b         	uxth	r3, r3
 8005e7a: 4423         	add	r3, r4
 8005e7c: b29b         	uxth	r3, r3
 8005e7e: 461a         	mov	r2, r3
 8005e80: f8d7 30fc    	ldr.w	r3, [r7, #0xfc]
 8005e84: 609a         	str	r2, [r3, #0x8]
; }
 8005e86: e10c         	b	0x80060a2 <LL_USART_SetBaudRate+0x456> @ imm = #0x218

08005e88 <$d>:
 8005e88: 1f 85 eb 51  	.word	0x51eb851f

08005e8c <$t>:
;     USARTx->BRR = (uint16_t)(__LL_USART_DIV_SAMPLING16(PeriphClk, BaudRate));
 8005e8c: f8d7 30f8    	ldr.w	r3, [r7, #0xf8]
 8005e90: 2200         	movs	r2, #0x0
 8005e92: f8c7 30a8    	str.w	r3, [r7, #0xa8]
 8005e96: f8c7 20ac    	str.w	r2, [r7, #0xac]
 8005e9a: e9d7 892a    	ldrd	r8, r9, [r7, #168]
 8005e9e: 4642         	mov	r2, r8
 8005ea0: 464b         	mov	r3, r9
 8005ea2: 1891         	adds	r1, r2, r2
 8005ea4: 6239         	str	r1, [r7, #0x20]
 8005ea6: 415b         	adcs	r3, r3
 8005ea8: 627b         	str	r3, [r7, #0x24]
 8005eaa: e9d7 2308    	ldrd	r2, r3, [r7, #32]
 8005eae: 4641         	mov	r1, r8
 8005eb0: 1854         	adds	r4, r2, r1
 8005eb2: 46cc         	mov	r12, r9
 8005eb4: eb43 050c    	adc.w	r5, r3, r12
 8005eb8: f04f 0200    	mov.w	r2, #0x0
 8005ebc: f04f 0300    	mov.w	r3, #0x0
 8005ec0: 00eb         	lsls	r3, r5, #0x3
 8005ec2: ea43 7354    	orr.w	r3, r3, r4, lsr #29
 8005ec6: 00e2         	lsls	r2, r4, #0x3
 8005ec8: 4614         	mov	r4, r2
 8005eca: 461d         	mov	r5, r3
 8005ecc: 4640         	mov	r0, r8
 8005ece: 4649         	mov	r1, r9
 8005ed0: 4603         	mov	r3, r0
 8005ed2: 18e3         	adds	r3, r4, r3
 8005ed4: f8c7 30a0    	str.w	r3, [r7, #0xa0]
 8005ed8: 460b         	mov	r3, r1
 8005eda: eb45 0303    	adc.w	r3, r5, r3
 8005ede: f8c7 30a4    	str.w	r3, [r7, #0xa4]
 8005ee2: f8d7 30f0    	ldr.w	r3, [r7, #0xf0]
 8005ee6: 2200         	movs	r2, #0x0
 8005ee8: f8c7 3098    	str.w	r3, [r7, #0x98]
 8005eec: f8c7 209c    	str.w	r2, [r7, #0x9c]
 8005ef0: f04f 0200    	mov.w	r2, #0x0
 8005ef4: f04f 0300    	mov.w	r3, #0x0
 8005ef8: e9d7 4526    	ldrd	r4, r5, [r7, #152]
 8005efc: 4629         	mov	r1, r5
 8005efe: 008b         	lsls	r3, r1, #0x2
 8005f00: 4620         	mov	r0, r4
 8005f02: 4629         	mov	r1, r5
 8005f04: 4604         	mov	r4, r0
 8005f06: ea43 7394    	orr.w	r3, r3, r4, lsr #30
 8005f0a: 4601         	mov	r1, r0
 8005f0c: 008a         	lsls	r2, r1, #0x2
 8005f0e: e9d7 0128    	ldrd	r0, r1, [r7, #160]
 8005f12: f7fa fc33    	bl	0x800077c <__aeabi_uldivmod> @ imm = #-0x579a
 8005f16: 4602         	mov	r2, r0
 8005f18: 460b         	mov	r3, r1
 8005f1a: 4b65         	ldr	r3, [pc, #0x194]        @ 0x80060b0 <LL_USART_SetBaudRate+0x464>
 8005f1c: fba3 2302    	umull	r2, r3, r3, r2
 8005f20: 095b         	lsrs	r3, r3, #0x5
 8005f22: b29b         	uxth	r3, r3
 8005f24: 011b         	lsls	r3, r3, #0x4
 8005f26: b29c         	uxth	r4, r3
 8005f28: f8d7 30f8    	ldr.w	r3, [r7, #0xf8]
 8005f2c: 2200         	movs	r2, #0x0
 8005f2e: f8c7 3090    	str.w	r3, [r7, #0x90]
 8005f32: f8c7 2094    	str.w	r2, [r7, #0x94]
 8005f36: e9d7 8924    	ldrd	r8, r9, [r7, #144]
 8005f3a: 4642         	mov	r2, r8
 8005f3c: 464b         	mov	r3, r9
 8005f3e: 1891         	adds	r1, r2, r2
 8005f40: 61b9         	str	r1, [r7, #0x18]
 8005f42: 415b         	adcs	r3, r3
 8005f44: 61fb         	str	r3, [r7, #0x1c]
 8005f46: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 8005f4a: 4641         	mov	r1, r8
 8005f4c: 1851         	adds	r1, r2, r1
 8005f4e: 6139         	str	r1, [r7, #0x10]
 8005f50: 4649         	mov	r1, r9
 8005f52: 414b         	adcs	r3, r1
 8005f54: 617b         	str	r3, [r7, #0x14]
 8005f56: f04f 0200    	mov.w	r2, #0x0
 8005f5a: f04f 0300    	mov.w	r3, #0x0
 8005f5e: e9d7 ab04    	ldrd	r10, r11, [r7, #16]
 8005f62: 4659         	mov	r1, r11
 8005f64: 00cb         	lsls	r3, r1, #0x3
 8005f66: 4655         	mov	r5, r10
 8005f68: ea43 7355    	orr.w	r3, r3, r5, lsr #29
 8005f6c: 4651         	mov	r1, r10
 8005f6e: 00ca         	lsls	r2, r1, #0x3
 8005f70: 4610         	mov	r0, r2
 8005f72: 4619         	mov	r1, r3
 8005f74: 4603         	mov	r3, r0
 8005f76: 4642         	mov	r2, r8
 8005f78: 189b         	adds	r3, r3, r2
 8005f7a: f8c7 3088    	str.w	r3, [r7, #0x88]
 8005f7e: 464b         	mov	r3, r9
 8005f80: 460a         	mov	r2, r1
 8005f82: eb42 0303    	adc.w	r3, r2, r3
 8005f86: f8c7 308c    	str.w	r3, [r7, #0x8c]
 8005f8a: f8d7 30f0    	ldr.w	r3, [r7, #0xf0]
 8005f8e: 2200         	movs	r2, #0x0
 8005f90: f8c7 3080    	str.w	r3, [r7, #0x80]
 8005f94: f8c7 2084    	str.w	r2, [r7, #0x84]
 8005f98: f04f 0200    	mov.w	r2, #0x0
 8005f9c: f04f 0300    	mov.w	r3, #0x0
 8005fa0: e9d7 8920    	ldrd	r8, r9, [r7, #128]
 8005fa4: 4649         	mov	r1, r9
 8005fa6: 008b         	lsls	r3, r1, #0x2
 8005fa8: 4645         	mov	r5, r8
 8005faa: ea43 7395    	orr.w	r3, r3, r5, lsr #30
 8005fae: 4641         	mov	r1, r8
 8005fb0: 008a         	lsls	r2, r1, #0x2
 8005fb2: e9d7 0122    	ldrd	r0, r1, [r7, #136]
 8005fb6: f7fa fbe1    	bl	0x800077c <__aeabi_uldivmod> @ imm = #-0x583e
 8005fba: 4602         	mov	r2, r0
 8005fbc: 460b         	mov	r3, r1
 8005fbe: 4611         	mov	r1, r2
 8005fc0: 4b3b         	ldr	r3, [pc, #0xec]         @ 0x80060b0 <LL_USART_SetBaudRate+0x464>
 8005fc2: fba3 2301    	umull	r2, r3, r3, r1
 8005fc6: 095b         	lsrs	r3, r3, #0x5
 8005fc8: 2264         	movs	r2, #0x64
 8005fca: fb02 f303    	mul	r3, r2, r3
 8005fce: 1acb         	subs	r3, r1, r3
 8005fd0: 011b         	lsls	r3, r3, #0x4
 8005fd2: 3332         	adds	r3, #0x32
 8005fd4: 4a36         	ldr	r2, [pc, #0xd8]         @ 0x80060b0 <LL_USART_SetBaudRate+0x464>
 8005fd6: fba2 2303    	umull	r2, r3, r2, r3
 8005fda: 095b         	lsrs	r3, r3, #0x5
 8005fdc: b29b         	uxth	r3, r3
 8005fde: f003 03f0    	and	r3, r3, #0xf0
 8005fe2: b29b         	uxth	r3, r3
 8005fe4: 4423         	add	r3, r4
 8005fe6: b29c         	uxth	r4, r3
 8005fe8: f8d7 30f8    	ldr.w	r3, [r7, #0xf8]
 8005fec: 2200         	movs	r2, #0x0
 8005fee: 67bb         	str	r3, [r7, #0x78]
 8005ff0: 67fa         	str	r2, [r7, #0x7c]
 8005ff2: e9d7 891e    	ldrd	r8, r9, [r7, #120]
 8005ff6: 4642         	mov	r2, r8
 8005ff8: 464b         	mov	r3, r9
 8005ffa: 1891         	adds	r1, r2, r2
 8005ffc: 60b9         	str	r1, [r7, #0x8]
 8005ffe: 415b         	adcs	r3, r3
 8006000: 60fb         	str	r3, [r7, #0xc]
 8006002: e9d7 2302    	ldrd	r2, r3, [r7, #8]
 8006006: 4641         	mov	r1, r8
 8006008: 1851         	adds	r1, r2, r1
 800600a: 6039         	str	r1, [r7]
 800600c: 4649         	mov	r1, r9
 800600e: 414b         	adcs	r3, r1
 8006010: 607b         	str	r3, [r7, #0x4]
 8006012: f04f 0200    	mov.w	r2, #0x0
 8006016: f04f 0300    	mov.w	r3, #0x0
 800601a: e9d7 ab00    	ldrd	r10, r11, [r7]
 800601e: 4659         	mov	r1, r11
 8006020: 00cb         	lsls	r3, r1, #0x3
 8006022: 4655         	mov	r5, r10
 8006024: ea43 7355    	orr.w	r3, r3, r5, lsr #29
 8006028: 4651         	mov	r1, r10
 800602a: 00ca         	lsls	r2, r1, #0x3
 800602c: 4610         	mov	r0, r2
 800602e: 4619         	mov	r1, r3
 8006030: 4603         	mov	r3, r0
 8006032: 4642         	mov	r2, r8
 8006034: 189b         	adds	r3, r3, r2
 8006036: 673b         	str	r3, [r7, #0x70]
 8006038: 464b         	mov	r3, r9
 800603a: 460a         	mov	r2, r1
 800603c: eb42 0303    	adc.w	r3, r2, r3
 8006040: 677b         	str	r3, [r7, #0x74]
 8006042: f8d7 30f0    	ldr.w	r3, [r7, #0xf0]
 8006046: 2200         	movs	r2, #0x0
 8006048: 66bb         	str	r3, [r7, #0x68]
 800604a: 66fa         	str	r2, [r7, #0x6c]
 800604c: f04f 0200    	mov.w	r2, #0x0
 8006050: f04f 0300    	mov.w	r3, #0x0
 8006054: e9d7 891a    	ldrd	r8, r9, [r7, #104]
 8006058: 4649         	mov	r1, r9
 800605a: 008b         	lsls	r3, r1, #0x2
 800605c: 4645         	mov	r5, r8
 800605e: ea43 7395    	orr.w	r3, r3, r5, lsr #30
 8006062: 4641         	mov	r1, r8
 8006064: 008a         	lsls	r2, r1, #0x2
 8006066: e9d7 011c    	ldrd	r0, r1, [r7, #112]
 800606a: f7fa fb87    	bl	0x800077c <__aeabi_uldivmod> @ imm = #-0x58f2
 800606e: 4602         	mov	r2, r0
 8006070: 460b         	mov	r3, r1
 8006072: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x80060b0 <LL_USART_SetBaudRate+0x464>
 8006074: fba3 1302    	umull	r1, r3, r3, r2
 8006078: 095b         	lsrs	r3, r3, #0x5
 800607a: 2164         	movs	r1, #0x64
 800607c: fb01 f303    	mul	r3, r1, r3
 8006080: 1ad3         	subs	r3, r2, r3
 8006082: 011b         	lsls	r3, r3, #0x4
 8006084: 3332         	adds	r3, #0x32
 8006086: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x80060b0 <LL_USART_SetBaudRate+0x464>
 8006088: fba2 2303    	umull	r2, r3, r2, r3
 800608c: 095b         	lsrs	r3, r3, #0x5
 800608e: b29b         	uxth	r3, r3
 8006090: f003 030f    	and	r3, r3, #0xf
 8006094: b29b         	uxth	r3, r3
 8006096: 4423         	add	r3, r4
 8006098: b29b         	uxth	r3, r3
 800609a: 461a         	mov	r2, r3
 800609c: f8d7 30fc    	ldr.w	r3, [r7, #0xfc]
 80060a0: 609a         	str	r2, [r3, #0x8]
; }
 80060a2: bf00         	nop
 80060a4: f507 7780    	add.w	r7, r7, #0x100
 80060a8: 46bd         	mov	sp, r7
 80060aa: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}
 80060ae: bf00         	nop

080060b0 <$d>:
 80060b0: 1f 85 eb 51  	.word	0x51eb851f

080060b4 <uart_stm32_set_baudrate>:
; {
 80060b4: b580         	push	{r7, lr}
 80060b6: b08c         	sub	sp, #0x30
 80060b8: af04         	add	r7, sp, #0x10
 80060ba: 6078         	str	r0, [r7, #0x4]
 80060bc: 6039         	str	r1, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 80060be: 687b         	ldr	r3, [r7, #0x4]
 80060c0: 685b         	ldr	r3, [r3, #0x4]
 80060c2: 61bb         	str	r3, [r7, #0x18]
; 	USART_TypeDef *usart = config->usart;
 80060c4: 69bb         	ldr	r3, [r7, #0x18]
 80060c6: 681b         	ldr	r3, [r3]
 80060c8: 617b         	str	r3, [r7, #0x14]
; 	struct uart_stm32_data *data = dev->data;
 80060ca: 687b         	ldr	r3, [r7, #0x4]
 80060cc: 691b         	ldr	r3, [r3, #0x10]
 80060ce: 61fb         	str	r3, [r7, #0x1c]
; 		if (clock_control_get_rate(data->clock,
 80060d0: 69fb         	ldr	r3, [r7, #0x1c]
 80060d2: 6818         	ldr	r0, [r3]
; 					   (clock_control_subsys_t)&config->pclken[0],
 80060d4: 69bb         	ldr	r3, [r7, #0x18]
 80060d6: 68db         	ldr	r3, [r3, #0xc]
; 		if (clock_control_get_rate(data->clock,
 80060d8: f107 0208    	add.w	r2, r7, #0x8
 80060dc: 4619         	mov	r1, r3
 80060de: f00a fe74    	bl	0x8010dca <clock_control_get_rate> @ imm = #0xace8
 80060e2: 4603         	mov	r3, r0
 80060e4: 2b00         	cmp	r3, #0x0
 80060e6: da1a         	bge	0x800611e <uart_stm32_set_baudrate+0x6a> @ imm = #0x34
; 			LOG_ERR("Failed call clock_control_get_rate(pclken[0])");
 80060e8: 2303         	movs	r3, #0x3
 80060ea: 2b00         	cmp	r3, #0x0
 80060ec: d021         	beq	0x8006132 <uart_stm32_set_baudrate+0x7e> @ imm = #0x42
 80060ee: 2301         	movs	r3, #0x1
 80060f0: 74fb         	strb	r3, [r7, #0x13]
 80060f2: 7cfb         	ldrb	r3, [r7, #0x13]
 80060f4: f083 0301    	eor	r3, r3, #0x1
 80060f8: b2db         	uxtb	r3, r3
 80060fa: 2b00         	cmp	r3, #0x0
 80060fc: d119         	bne	0x8006132 <uart_stm32_set_baudrate+0x7e> @ imm = #0x32
 80060fe: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x8006138 <uart_stm32_set_baudrate+0x84>
 8006100: 6819         	ldr	r1, [r3]
 8006102: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800613c <uart_stm32_set_baudrate+0x88>
 8006104: 9302         	str	r3, [sp, #0x8]
 8006106: 2300         	movs	r3, #0x0
 8006108: 9301         	str	r3, [sp, #0x4]
 800610a: 2300         	movs	r3, #0x0
 800610c: 9300         	str	r3, [sp]
 800610e: 2300         	movs	r3, #0x0
 8006110: 2201         	movs	r2, #0x1
 8006112: 2000         	movs	r0, #0x0
 8006114: f00b f8c5    	bl	0x80112a2 <z_log_msg_runtime_create> @ imm = #0xb18a
 8006118: 2300         	movs	r3, #0x0
 800611a: 60fb         	str	r3, [r7, #0xc]
; 			return;
 800611c: e009         	b	0x8006132 <uart_stm32_set_baudrate+0x7e> @ imm = #0x12
; 		LL_USART_SetOverSampling(usart,
 800611e: 2100         	movs	r1, #0x0
 8006120: 6978         	ldr	r0, [r7, #0x14]
 8006122: f00a ff57    	bl	0x8010fd4 <LL_USART_SetOverSampling> @ imm = #0xaeae
; 		LL_USART_SetBaudRate(usart,
 8006126: 68b9         	ldr	r1, [r7, #0x8]
 8006128: 683b         	ldr	r3, [r7]
 800612a: 2200         	movs	r2, #0x0
 800612c: 6978         	ldr	r0, [r7, #0x14]
 800612e: f7ff fd8d    	bl	0x8005c4c <LL_USART_SetBaudRate> @ imm = #-0x4e6
; }
 8006132: 3720         	adds	r7, #0x20
 8006134: 46bd         	mov	sp, r7
 8006136: bd80         	pop	{r7, pc}

08006138 <$d>:
 8006138: 4c 00 00 20  	.word	0x2000004c
 800613c: b8 57 01 08  	.word	0x080157b8

08006140 <uart_stm32_configure>:
; {
 8006140: b580         	push	{r7, lr}
 8006142: b08a         	sub	sp, #0x28
 8006144: af00         	add	r7, sp, #0x0
 8006146: 6078         	str	r0, [r7, #0x4]
 8006148: 6039         	str	r1, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 800614a: 687b         	ldr	r3, [r7, #0x4]
 800614c: 685b         	ldr	r3, [r3, #0x4]
 800614e: 627b         	str	r3, [r7, #0x24]
; 	USART_TypeDef *usart = config->usart;
 8006150: 6a7b         	ldr	r3, [r7, #0x24]
 8006152: 681b         	ldr	r3, [r3]
 8006154: 623b         	str	r3, [r7, #0x20]
; 	struct uart_stm32_data *data = dev->data;
 8006156: 687b         	ldr	r3, [r7, #0x4]
 8006158: 691b         	ldr	r3, [r3, #0x10]
 800615a: 61fb         	str	r3, [r7, #0x1c]
; 	struct uart_config *uart_cfg = data->uart_cfg;
 800615c: 69fb         	ldr	r3, [r7, #0x1c]
 800615e: 685b         	ldr	r3, [r3, #0x4]
 8006160: 61bb         	str	r3, [r7, #0x18]
; 	const uint32_t parity = uart_stm32_cfg2ll_parity(cfg->parity);
 8006162: 683b         	ldr	r3, [r7]
 8006164: 791b         	ldrb	r3, [r3, #0x4]
 8006166: 4618         	mov	r0, r3
 8006168: f00b f945    	bl	0x80113f6 <uart_stm32_cfg2ll_parity> @ imm = #0xb28a
 800616c: 6178         	str	r0, [r7, #0x14]
; 	const uint32_t stopbits = uart_stm32_cfg2ll_stopbits(config, cfg->stop_bits);
 800616e: 683b         	ldr	r3, [r7]
 8006170: 795b         	ldrb	r3, [r3, #0x5]
 8006172: 4619         	mov	r1, r3
 8006174: 6a78         	ldr	r0, [r7, #0x24]
 8006176: f00b f96b    	bl	0x8011450 <uart_stm32_cfg2ll_stopbits> @ imm = #0xb2d6
 800617a: 6138         	str	r0, [r7, #0x10]
; 	const uint32_t databits = uart_stm32_cfg2ll_databits(cfg->data_bits,
 800617c: 683b         	ldr	r3, [r7]
 800617e: 799a         	ldrb	r2, [r3, #0x6]
; 							     cfg->parity);
 8006180: 683b         	ldr	r3, [r7]
 8006182: 791b         	ldrb	r3, [r3, #0x4]
; 	const uint32_t databits = uart_stm32_cfg2ll_databits(cfg->data_bits,
 8006184: 4619         	mov	r1, r3
 8006186: 4610         	mov	r0, r2
 8006188: f00b f9a0    	bl	0x80114cc <uart_stm32_cfg2ll_databits> @ imm = #0xb340
 800618c: 60f8         	str	r0, [r7, #0xc]
; 	if ((cfg->parity == UART_CFG_PARITY_MARK) ||
 800618e: 683b         	ldr	r3, [r7]
 8006190: 791b         	ldrb	r3, [r3, #0x4]
 8006192: 2b03         	cmp	r3, #0x3
 8006194: d003         	beq	0x800619e <uart_stm32_configure+0x5e> @ imm = #0x6
; 	    (cfg->parity == UART_CFG_PARITY_SPACE)) {
 8006196: 683b         	ldr	r3, [r7]
 8006198: 791b         	ldrb	r3, [r3, #0x4]
; 	if ((cfg->parity == UART_CFG_PARITY_MARK) ||
 800619a: 2b04         	cmp	r3, #0x4
 800619c: d102         	bne	0x80061a4 <uart_stm32_configure+0x64> @ imm = #0x4
; 		return -ENOTSUP;
 800619e: f06f 0385    	mvn	r3, #0x85
 80061a2: e04f         	b	0x8006244 <uart_stm32_configure+0x104> @ imm = #0x9e
; 	if ((cfg->parity != UART_CFG_PARITY_NONE) &&
 80061a4: 683b         	ldr	r3, [r7]
 80061a6: 791b         	ldrb	r3, [r3, #0x4]
 80061a8: 2b00         	cmp	r3, #0x0
 80061aa: d006         	beq	0x80061ba <uart_stm32_configure+0x7a> @ imm = #0xc
; 	    (cfg->data_bits == UART_CFG_DATA_BITS_9)) {
 80061ac: 683b         	ldr	r3, [r7]
 80061ae: 799b         	ldrb	r3, [r3, #0x6]
; 	if ((cfg->parity != UART_CFG_PARITY_NONE) &&
 80061b0: 2b04         	cmp	r3, #0x4
 80061b2: d102         	bne	0x80061ba <uart_stm32_configure+0x7a> @ imm = #0x4
; 		return -ENOTSUP;
 80061b4: f06f 0385    	mvn	r3, #0x85
 80061b8: e044         	b	0x8006244 <uart_stm32_configure+0x104> @ imm = #0x88
; 	if (uart_stm32_ll2cfg_stopbits(stopbits) != cfg->stop_bits) {
 80061ba: 6938         	ldr	r0, [r7, #0x10]
 80061bc: f00b f967    	bl	0x801148e <uart_stm32_ll2cfg_stopbits> @ imm = #0xb2ce
 80061c0: 4603         	mov	r3, r0
 80061c2: 461a         	mov	r2, r3
 80061c4: 683b         	ldr	r3, [r7]
 80061c6: 795b         	ldrb	r3, [r3, #0x5]
 80061c8: 429a         	cmp	r2, r3
 80061ca: d002         	beq	0x80061d2 <uart_stm32_configure+0x92> @ imm = #0x4
; 		return -ENOTSUP;
 80061cc: f06f 0385    	mvn	r3, #0x85
 80061d0: e038         	b	0x8006244 <uart_stm32_configure+0x104> @ imm = #0x70
; 	if (uart_stm32_ll2cfg_databits(databits, parity) != cfg->data_bits) {
 80061d2: 6979         	ldr	r1, [r7, #0x14]
 80061d4: 68f8         	ldr	r0, [r7, #0xc]
 80061d6: f00b f993    	bl	0x8011500 <uart_stm32_ll2cfg_databits> @ imm = #0xb326
 80061da: 4603         	mov	r3, r0
 80061dc: 461a         	mov	r2, r3
 80061de: 683b         	ldr	r3, [r7]
 80061e0: 799b         	ldrb	r3, [r3, #0x6]
 80061e2: 429a         	cmp	r2, r3
 80061e4: d002         	beq	0x80061ec <uart_stm32_configure+0xac> @ imm = #0x4
; 		return -ENOTSUP;
 80061e6: f06f 0385    	mvn	r3, #0x85
 80061ea: e02b         	b	0x8006244 <uart_stm32_configure+0x104> @ imm = #0x56
; 	if (!(cfg->flow_ctrl == UART_CFG_FLOW_CTRL_NONE
 80061ec: 683b         	ldr	r3, [r7]
 80061ee: 79db         	ldrb	r3, [r3, #0x7]
 80061f0: 2b00         	cmp	r3, #0x0
 80061f2: d016         	beq	0x8006222 <uart_stm32_configure+0xe2> @ imm = #0x2c
; 		|| (cfg->flow_ctrl == UART_CFG_FLOW_CTRL_RTS_CTS &&
 80061f4: 683b         	ldr	r3, [r7]
 80061f6: 79db         	ldrb	r3, [r3, #0x7]
; 	if (!(cfg->flow_ctrl == UART_CFG_FLOW_CTRL_NONE
 80061f8: 2b01         	cmp	r3, #0x1
 80061fa: d10f         	bne	0x800621c <uart_stm32_configure+0xdc> @ imm = #0x1e
; 		|| (cfg->flow_ctrl == UART_CFG_FLOW_CTRL_RTS_CTS &&
 80061fc: 6a3b         	ldr	r3, [r7, #0x20]
 80061fe: 4a13         	ldr	r2, [pc, #0x4c]         @ 0x800624c <uart_stm32_configure+0x10c>
 8006200: 4293         	cmp	r3, r2
 8006202: d00e         	beq	0x8006222 <uart_stm32_configure+0xe2> @ imm = #0x1c
; 			IS_UART_HWFLOW_INSTANCE(usart))
 8006204: 6a3b         	ldr	r3, [r7, #0x20]
 8006206: 4a12         	ldr	r2, [pc, #0x48]         @ 0x8006250 <uart_stm32_configure+0x110>
 8006208: 4293         	cmp	r3, r2
 800620a: d00a         	beq	0x8006222 <uart_stm32_configure+0xe2> @ imm = #0x14
 800620c: 6a3b         	ldr	r3, [r7, #0x20]
 800620e: 4a11         	ldr	r2, [pc, #0x44]         @ 0x8006254 <uart_stm32_configure+0x114>
 8006210: 4293         	cmp	r3, r2
 8006212: d006         	beq	0x8006222 <uart_stm32_configure+0xe2> @ imm = #0xc
 8006214: 6a3b         	ldr	r3, [r7, #0x20]
 8006216: 4a10         	ldr	r2, [pc, #0x40]         @ 0x8006258 <uart_stm32_configure+0x118>
 8006218: 4293         	cmp	r3, r2
 800621a: d002         	beq	0x8006222 <uart_stm32_configure+0xe2> @ imm = #0x4
; 		return -ENOTSUP;
 800621c: f06f 0385    	mvn	r3, #0x85
 8006220: e010         	b	0x8006244 <uart_stm32_configure+0x104> @ imm = #0x20
; 	LL_USART_Disable(usart);
 8006222: 6a38         	ldr	r0, [r7, #0x20]
 8006224: f00a fe64    	bl	0x8010ef0 <LL_USART_Disable> @ imm = #0xacc8
; 	uart_stm32_parameters_set(dev, cfg);
 8006228: 6839         	ldr	r1, [r7]
 800622a: 6878         	ldr	r0, [r7, #0x4]
 800622c: f00b f9a9    	bl	0x8011582 <uart_stm32_parameters_set> @ imm = #0xb352
; 	LL_USART_Enable(usart);
 8006230: 6a38         	ldr	r0, [r7, #0x20]
 8006232: f00a fe4e    	bl	0x8010ed2 <LL_USART_Enable> @ imm = #0xac9c
; 	*uart_cfg = *cfg;
 8006236: 69bb         	ldr	r3, [r7, #0x18]
 8006238: 683a         	ldr	r2, [r7]
 800623a: e892 0003    	ldm.w	r2, {r0, r1}
 800623e: e883 0003    	stm.w	r3, {r0, r1}
; 	return 0;
 8006242: 2300         	movs	r3, #0x0
; };
 8006244: 4618         	mov	r0, r3
 8006246: 3728         	adds	r7, #0x28
 8006248: 46bd         	mov	sp, r7
 800624a: bd80         	pop	{r7, pc}

0800624c <$d>:
 800624c: 00 10 01 40  	.word	0x40011000
 8006250: 00 44 00 40  	.word	0x40004400
 8006254: 00 48 00 40  	.word	0x40004800
 8006258: 00 14 01 40  	.word	0x40011400

0800625c <uart_stm32_poll_in>:
; {
 800625c: b580         	push	{r7, lr}
 800625e: b082         	sub	sp, #0x8
 8006260: af00         	add	r7, sp, #0x0
 8006262: 6078         	str	r0, [r7, #0x4]
 8006264: 6039         	str	r1, [r7]
; 	return uart_stm32_poll_in_visitor(dev, (void *)c, poll_in_u8);
 8006266: 4a05         	ldr	r2, [pc, #0x14]         @ 0x800627c <uart_stm32_poll_in+0x20>
 8006268: 6839         	ldr	r1, [r7]
 800626a: 6878         	ldr	r0, [r7, #0x4]
 800626c: f00b fa4e    	bl	0x801170c <uart_stm32_poll_in_visitor> @ imm = #0xb49c
 8006270: 4603         	mov	r3, r0
; }
 8006272: 4618         	mov	r0, r3
 8006274: 3708         	adds	r7, #0x8
 8006276: 46bd         	mov	sp, r7
 8006278: bd80         	pop	{r7, pc}
 800627a: bf00         	nop

0800627c <$d>:
 800627c: f3 17 01 08  	.word	0x080117f3

08006280 <uart_stm32_poll_out>:
; {
 8006280: b580         	push	{r7, lr}
 8006282: b082         	sub	sp, #0x8
 8006284: af00         	add	r7, sp, #0x0
 8006286: 6078         	str	r0, [r7, #0x4]
 8006288: 460b         	mov	r3, r1
 800628a: 70fb         	strb	r3, [r7, #0x3]
; 	uart_stm32_poll_out_visitor(dev, c, poll_out_u8);
 800628c: 78fb         	ldrb	r3, [r7, #0x3]
 800628e: b29b         	uxth	r3, r3
 8006290: 4a04         	ldr	r2, [pc, #0x10]         @ 0x80062a4 <uart_stm32_poll_out+0x24>
 8006292: 4619         	mov	r1, r3
 8006294: 6878         	ldr	r0, [r7, #0x4]
 8006296: f00b fa60    	bl	0x801175a <uart_stm32_poll_out_visitor> @ imm = #0xb4c0
; }
 800629a: bf00         	nop
 800629c: 3708         	adds	r7, #0x8
 800629e: 46bd         	mov	sp, r7
 80062a0: bd80         	pop	{r7, pc}
 80062a2: bf00         	nop

080062a4 <$d>:
 80062a4: 13 18 01 08  	.word	0x08011813

080062a8 <__uart_stm32_get_clock>:
; {
 80062a8: b480         	push	{r7}
 80062aa: b085         	sub	sp, #0x14
 80062ac: af00         	add	r7, sp, #0x0
 80062ae: 6078         	str	r0, [r7, #0x4]
; 	struct uart_stm32_data *data = dev->data;
 80062b0: 687b         	ldr	r3, [r7, #0x4]
 80062b2: 691b         	ldr	r3, [r3, #0x10]
 80062b4: 60fb         	str	r3, [r7, #0xc]
; 	const struct device *const clk = DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE);
 80062b6: 4b05         	ldr	r3, [pc, #0x14]         @ 0x80062cc <__uart_stm32_get_clock+0x24>
 80062b8: 60bb         	str	r3, [r7, #0x8]
; 	data->clock = clk;
 80062ba: 68fb         	ldr	r3, [r7, #0xc]
 80062bc: 68ba         	ldr	r2, [r7, #0x8]
 80062be: 601a         	str	r2, [r3]
; }
 80062c0: bf00         	nop
 80062c2: 3714         	adds	r7, #0x14
 80062c4: 46bd         	mov	sp, r7
 80062c6: bc80         	pop	{r7}
 80062c8: 4770         	bx	lr
 80062ca: bf00         	nop

080062cc <$d>:
 80062cc: a4 45 01 08  	.word	0x080145a4

080062d0 <uart_stm32_clocks_enable>:
; {
 80062d0: b580         	push	{r7, lr}
 80062d2: b08e         	sub	sp, #0x38
 80062d4: af04         	add	r7, sp, #0x10
 80062d6: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 80062d8: 687b         	ldr	r3, [r7, #0x4]
 80062da: 685b         	ldr	r3, [r3, #0x4]
 80062dc: 623b         	str	r3, [r7, #0x20]
; 	struct uart_stm32_data *data = dev->data;
 80062de: 687b         	ldr	r3, [r7, #0x4]
 80062e0: 691b         	ldr	r3, [r3, #0x10]
 80062e2: 627b         	str	r3, [r7, #0x24]
; 	__uart_stm32_get_clock(dev);
 80062e4: 6878         	ldr	r0, [r7, #0x4]
 80062e6: f7ff ffdf    	bl	0x80062a8 <__uart_stm32_get_clock> @ imm = #-0x42
; 	if (!device_is_ready(data->clock)) {
 80062ea: 6a7b         	ldr	r3, [r7, #0x24]
 80062ec: 681b         	ldr	r3, [r3]
 80062ee: 4618         	mov	r0, r3
 80062f0: f00a fd4d    	bl	0x8010d8e <device_is_ready> @ imm = #0xaa9a
 80062f4: 4603         	mov	r3, r0
 80062f6: f083 0301    	eor	r3, r3, #0x1
 80062fa: b2db         	uxtb	r3, r3
 80062fc: 2b00         	cmp	r3, #0x0
 80062fe: d01c         	beq	0x800633a <uart_stm32_clocks_enable+0x6a> @ imm = #0x38
; 		LOG_ERR("clock control device not ready");
 8006300: 2303         	movs	r3, #0x3
 8006302: 2b00         	cmp	r3, #0x0
 8006304: d016         	beq	0x8006334 <uart_stm32_clocks_enable+0x64> @ imm = #0x2c
 8006306: 2301         	movs	r3, #0x1
 8006308: 74fb         	strb	r3, [r7, #0x13]
 800630a: 7cfb         	ldrb	r3, [r7, #0x13]
 800630c: f083 0301    	eor	r3, r3, #0x1
 8006310: b2db         	uxtb	r3, r3
 8006312: 2b00         	cmp	r3, #0x0
 8006314: d10e         	bne	0x8006334 <uart_stm32_clocks_enable+0x64> @ imm = #0x1c
 8006316: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x8006394 <uart_stm32_clocks_enable+0xc4>
 8006318: 6819         	ldr	r1, [r3]
 800631a: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x8006398 <uart_stm32_clocks_enable+0xc8>
 800631c: 9302         	str	r3, [sp, #0x8]
 800631e: 2300         	movs	r3, #0x0
 8006320: 9301         	str	r3, [sp, #0x4]
 8006322: 2300         	movs	r3, #0x0
 8006324: 9300         	str	r3, [sp]
 8006326: 2300         	movs	r3, #0x0
 8006328: 2201         	movs	r2, #0x1
 800632a: 2000         	movs	r0, #0x0
 800632c: f00a ffb9    	bl	0x80112a2 <z_log_msg_runtime_create> @ imm = #0xaf72
 8006330: 2300         	movs	r3, #0x0
 8006332: 60fb         	str	r3, [r7, #0xc]
; 		return -ENODEV;
 8006334: f06f 0312    	mvn	r3, #0x12
 8006338: e028         	b	0x800638c <uart_stm32_clocks_enable+0xbc> @ imm = #0x50
; 	err = clock_control_on(data->clock, (clock_control_subsys_t)&config->pclken[0]);
 800633a: 6a7b         	ldr	r3, [r7, #0x24]
 800633c: 681a         	ldr	r2, [r3]
 800633e: 6a3b         	ldr	r3, [r7, #0x20]
 8006340: 68db         	ldr	r3, [r3, #0xc]
 8006342: 4619         	mov	r1, r3
 8006344: 4610         	mov	r0, r2
 8006346: f00a fd2e    	bl	0x8010da6 <clock_control_on> @ imm = #0xaa5c
 800634a: 61f8         	str	r0, [r7, #0x1c]
; 	if (err != 0) {
 800634c: 69fb         	ldr	r3, [r7, #0x1c]
 800634e: 2b00         	cmp	r3, #0x0
 8006350: d01b         	beq	0x800638a <uart_stm32_clocks_enable+0xba> @ imm = #0x36
; 		LOG_ERR("Could not enable (LP)UART clock");
 8006352: 2303         	movs	r3, #0x3
 8006354: 2b00         	cmp	r3, #0x0
 8006356: d016         	beq	0x8006386 <uart_stm32_clocks_enable+0xb6> @ imm = #0x2c
 8006358: 2301         	movs	r3, #0x1
 800635a: 76fb         	strb	r3, [r7, #0x1b]
 800635c: 7efb         	ldrb	r3, [r7, #0x1b]
 800635e: f083 0301    	eor	r3, r3, #0x1
 8006362: b2db         	uxtb	r3, r3
 8006364: 2b00         	cmp	r3, #0x0
 8006366: d10e         	bne	0x8006386 <uart_stm32_clocks_enable+0xb6> @ imm = #0x1c
 8006368: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8006394 <uart_stm32_clocks_enable+0xc4>
 800636a: 6819         	ldr	r1, [r3]
 800636c: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800639c <uart_stm32_clocks_enable+0xcc>
 800636e: 9302         	str	r3, [sp, #0x8]
 8006370: 2300         	movs	r3, #0x0
 8006372: 9301         	str	r3, [sp, #0x4]
 8006374: 2300         	movs	r3, #0x0
 8006376: 9300         	str	r3, [sp]
 8006378: 2300         	movs	r3, #0x0
 800637a: 2201         	movs	r2, #0x1
 800637c: 2000         	movs	r0, #0x0
 800637e: f00a ff90    	bl	0x80112a2 <z_log_msg_runtime_create> @ imm = #0xaf20
 8006382: 2300         	movs	r3, #0x0
 8006384: 617b         	str	r3, [r7, #0x14]
; 		return err;
 8006386: 69fb         	ldr	r3, [r7, #0x1c]
 8006388: e000         	b	0x800638c <uart_stm32_clocks_enable+0xbc> @ imm = #0x0
; 	return 0;
 800638a: 2300         	movs	r3, #0x0
; }
 800638c: 4618         	mov	r0, r3
 800638e: 3728         	adds	r7, #0x28
 8006390: 46bd         	mov	sp, r7
 8006392: bd80         	pop	{r7, pc}

08006394 <$d>:
 8006394: 4c 00 00 20  	.word	0x2000004c
 8006398: e8 57 01 08  	.word	0x080157e8
 800639c: 08 58 01 08  	.word	0x08015808

080063a0 <uart_stm32_registers_configure>:
; {
 80063a0: b580         	push	{r7, lr}
 80063a2: b08c         	sub	sp, #0x30
 80063a4: af04         	add	r7, sp, #0x10
 80063a6: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 80063a8: 687b         	ldr	r3, [r7, #0x4]
 80063aa: 685b         	ldr	r3, [r3, #0x4]
 80063ac: 61fb         	str	r3, [r7, #0x1c]
; 	USART_TypeDef *usart = config->usart;
 80063ae: 69fb         	ldr	r3, [r7, #0x1c]
 80063b0: 681b         	ldr	r3, [r3]
 80063b2: 61bb         	str	r3, [r7, #0x18]
; 	struct uart_stm32_data *data = dev->data;
 80063b4: 687b         	ldr	r3, [r7, #0x4]
 80063b6: 691b         	ldr	r3, [r3, #0x10]
 80063b8: 617b         	str	r3, [r7, #0x14]
; 	struct uart_config *uart_cfg = data->uart_cfg;
 80063ba: 697b         	ldr	r3, [r7, #0x14]
 80063bc: 685b         	ldr	r3, [r3, #0x4]
 80063be: 613b         	str	r3, [r7, #0x10]
; 	LL_USART_Disable(usart);
 80063c0: 69b8         	ldr	r0, [r7, #0x18]
 80063c2: f00a fd95    	bl	0x8010ef0 <LL_USART_Disable> @ imm = #0xab2a
; 	if (!device_is_ready(config->reset.dev)) {
 80063c6: 69fb         	ldr	r3, [r7, #0x1c]
 80063c8: 685b         	ldr	r3, [r3, #0x4]
 80063ca: 4618         	mov	r0, r3
 80063cc: f00a fcdf    	bl	0x8010d8e <device_is_ready> @ imm = #0xa9be
 80063d0: 4603         	mov	r3, r0
 80063d2: f083 0301    	eor	r3, r3, #0x1
 80063d6: b2db         	uxtb	r3, r3
 80063d8: 2b00         	cmp	r3, #0x0
 80063da: d01c         	beq	0x8006416 <uart_stm32_registers_configure+0x76> @ imm = #0x38
; 		LOG_ERR("reset controller not ready");
 80063dc: 2303         	movs	r3, #0x3
 80063de: 2b00         	cmp	r3, #0x0
 80063e0: d016         	beq	0x8006410 <uart_stm32_registers_configure+0x70> @ imm = #0x2c
 80063e2: 2301         	movs	r3, #0x1
 80063e4: 73fb         	strb	r3, [r7, #0xf]
 80063e6: 7bfb         	ldrb	r3, [r7, #0xf]
 80063e8: f083 0301    	eor	r3, r3, #0x1
 80063ec: b2db         	uxtb	r3, r3
 80063ee: 2b00         	cmp	r3, #0x0
 80063f0: d10e         	bne	0x8006410 <uart_stm32_registers_configure+0x70> @ imm = #0x1c
 80063f2: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x8006450 <uart_stm32_registers_configure+0xb0>
 80063f4: 6819         	ldr	r1, [r3]
 80063f6: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x8006454 <uart_stm32_registers_configure+0xb4>
 80063f8: 9302         	str	r3, [sp, #0x8]
 80063fa: 2300         	movs	r3, #0x0
 80063fc: 9301         	str	r3, [sp, #0x4]
 80063fe: 2300         	movs	r3, #0x0
 8006400: 9300         	str	r3, [sp]
 8006402: 2300         	movs	r3, #0x0
 8006404: 2201         	movs	r2, #0x1
 8006406: 2000         	movs	r0, #0x0
 8006408: f00a ff4b    	bl	0x80112a2 <z_log_msg_runtime_create> @ imm = #0xae96
 800640c: 2300         	movs	r3, #0x0
 800640e: 60bb         	str	r3, [r7, #0x8]
; 		return -ENODEV;
 8006410: f06f 0312    	mvn	r3, #0x12
 8006414: e017         	b	0x8006446 <uart_stm32_registers_configure+0xa6> @ imm = #0x2e
; 	(void)reset_line_toggle_dt(&config->reset);
 8006416: 69fb         	ldr	r3, [r7, #0x1c]
 8006418: 3304         	adds	r3, #0x4
 800641a: 4618         	mov	r0, r3
 800641c: f00a fd3a    	bl	0x8010e94 <reset_line_toggle_dt> @ imm = #0xaa74
; 	LL_USART_SetTransferDirection(usart, LL_USART_DIRECTION_TX_RX);
 8006420: 210c         	movs	r1, #0xc
 8006422: 69b8         	ldr	r0, [r7, #0x18]
 8006424: f00a fd73    	bl	0x8010f0e <LL_USART_SetTransferDirection> @ imm = #0xaae6
; 	uart_stm32_parameters_set(dev, uart_cfg);
 8006428: 6939         	ldr	r1, [r7, #0x10]
 800642a: 6878         	ldr	r0, [r7, #0x4]
 800642c: f00b f8a9    	bl	0x8011582 <uart_stm32_parameters_set> @ imm = #0xb152
; 	if (config->single_wire) {
 8006430: 69fb         	ldr	r3, [r7, #0x1c]
 8006432: 7d1b         	ldrb	r3, [r3, #0x14]
 8006434: 2b00         	cmp	r3, #0x0
 8006436: d002         	beq	0x800643e <uart_stm32_registers_configure+0x9e> @ imm = #0x4
; 		LL_USART_EnableHalfDuplex(usart);
 8006438: 69b8         	ldr	r0, [r7, #0x18]
 800643a: f00a fe39    	bl	0x80110b0 <LL_USART_EnableHalfDuplex> @ imm = #0xac72
; 	LL_USART_Enable(usart);
 800643e: 69b8         	ldr	r0, [r7, #0x18]
 8006440: f00a fd47    	bl	0x8010ed2 <LL_USART_Enable> @ imm = #0xaa8e
; 	return 0;
 8006444: 2300         	movs	r3, #0x0
; }
 8006446: 4618         	mov	r0, r3
 8006448: 3720         	adds	r7, #0x20
 800644a: 46bd         	mov	sp, r7
 800644c: bd80         	pop	{r7, pc}
 800644e: bf00         	nop

08006450 <$d>:
 8006450: 4c 00 00 20  	.word	0x2000004c
 8006454: 28 58 01 08  	.word	0x08015828

08006458 <spi_context_cs_configure_all>:
; {
 8006458: b580         	push	{r7, lr}
 800645a: b08c         	sub	sp, #0x30
 800645c: af06         	add	r7, sp, #0x18
 800645e: 6078         	str	r0, [r7, #0x4]
; 	for (cs_gpio = ctx->cs_gpios; cs_gpio < &ctx->cs_gpios[ctx->num_cs_gpios]; cs_gpio++) {
 8006460: 687b         	ldr	r3, [r7, #0x4]
 8006462: 689b         	ldr	r3, [r3, #0x8]
 8006464: 617b         	str	r3, [r7, #0x14]
 8006466: e03c         	b	0x80064e2 <spi_context_cs_configure_all+0x8a> @ imm = #0x78
; 		if (!device_is_ready(cs_gpio->port)) {
 8006468: 697b         	ldr	r3, [r7, #0x14]
 800646a: 681b         	ldr	r3, [r3]
 800646c: 4618         	mov	r0, r3
 800646e: f00b fa75    	bl	0x801195c <device_is_ready> @ imm = #0xb4ea
 8006472: 4603         	mov	r3, r0
 8006474: f083 0301    	eor	r3, r3, #0x1
 8006478: b2db         	uxtb	r3, r3
 800647a: 2b00         	cmp	r3, #0x0
 800647c: d023         	beq	0x80064c6 <spi_context_cs_configure_all+0x6e> @ imm = #0x46
; 			LOG_ERR("CS GPIO port %s pin %d is not ready",
 800647e: 2303         	movs	r3, #0x3
 8006480: 2b00         	cmp	r3, #0x0
 8006482: d01d         	beq	0x80064c0 <spi_context_cs_configure_all+0x68> @ imm = #0x3a
 8006484: 2301         	movs	r3, #0x1
 8006486: 73fb         	strb	r3, [r7, #0xf]
 8006488: 7bfb         	ldrb	r3, [r7, #0xf]
 800648a: f083 0301    	eor	r3, r3, #0x1
 800648e: b2db         	uxtb	r3, r3
 8006490: 2b00         	cmp	r3, #0x0
 8006492: d115         	bne	0x80064c0 <spi_context_cs_configure_all+0x68> @ imm = #0x2a
 8006494: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x8006500 <spi_context_cs_configure_all+0xa8>
 8006496: 6819         	ldr	r1, [r3]
 8006498: 697b         	ldr	r3, [r7, #0x14]
 800649a: 681b         	ldr	r3, [r3]
 800649c: 681b         	ldr	r3, [r3]
 800649e: 697a         	ldr	r2, [r7, #0x14]
 80064a0: 7912         	ldrb	r2, [r2, #0x4]
 80064a2: 9204         	str	r2, [sp, #0x10]
 80064a4: 9303         	str	r3, [sp, #0xc]
 80064a6: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x8006504 <spi_context_cs_configure_all+0xac>
 80064a8: 9302         	str	r3, [sp, #0x8]
 80064aa: 2300         	movs	r3, #0x0
 80064ac: 9301         	str	r3, [sp, #0x4]
 80064ae: 2300         	movs	r3, #0x0
 80064b0: 9300         	str	r3, [sp]
 80064b2: 2300         	movs	r3, #0x0
 80064b4: 2201         	movs	r2, #0x1
 80064b6: 2000         	movs	r0, #0x0
 80064b8: f00b fa5c    	bl	0x8011974 <z_log_msg_runtime_create> @ imm = #0xb4b8
 80064bc: 2300         	movs	r3, #0x0
 80064be: 60bb         	str	r3, [r7, #0x8]
; 			return -ENODEV;
 80064c0: f06f 0312    	mvn	r3, #0x12
 80064c4: e017         	b	0x80064f6 <spi_context_cs_configure_all+0x9e> @ imm = #0x2e
; 		ret = gpio_pin_configure_dt(cs_gpio, GPIO_OUTPUT_INACTIVE);
 80064c6: f44f 11b0    	mov.w	r1, #0x160000
 80064ca: 6978         	ldr	r0, [r7, #0x14]
 80064cc: f00b fcb7    	bl	0x8011e3e <gpio_pin_configure_dt> @ imm = #0xb96e
 80064d0: 6138         	str	r0, [r7, #0x10]
; 		if (ret < 0) {
 80064d2: 693b         	ldr	r3, [r7, #0x10]
 80064d4: 2b00         	cmp	r3, #0x0
 80064d6: da01         	bge	0x80064dc <spi_context_cs_configure_all+0x84> @ imm = #0x2
; 			return ret;
 80064d8: 693b         	ldr	r3, [r7, #0x10]
 80064da: e00c         	b	0x80064f6 <spi_context_cs_configure_all+0x9e> @ imm = #0x18
; 	for (cs_gpio = ctx->cs_gpios; cs_gpio < &ctx->cs_gpios[ctx->num_cs_gpios]; cs_gpio++) {
 80064dc: 697b         	ldr	r3, [r7, #0x14]
 80064de: 3308         	adds	r3, #0x8
 80064e0: 617b         	str	r3, [r7, #0x14]
 80064e2: 687b         	ldr	r3, [r7, #0x4]
 80064e4: 689a         	ldr	r2, [r3, #0x8]
 80064e6: 687b         	ldr	r3, [r7, #0x4]
 80064e8: 68db         	ldr	r3, [r3, #0xc]
 80064ea: 00db         	lsls	r3, r3, #0x3
 80064ec: 4413         	add	r3, r2
 80064ee: 697a         	ldr	r2, [r7, #0x14]
 80064f0: 429a         	cmp	r2, r3
 80064f2: d3b9         	blo	0x8006468 <spi_context_cs_configure_all+0x10> @ imm = #-0x8e
; 	return 0;
 80064f4: 2300         	movs	r3, #0x0
; }
 80064f6: 4618         	mov	r0, r3
 80064f8: 3718         	adds	r7, #0x18
 80064fa: 46bd         	mov	sp, r7
 80064fc: bd80         	pop	{r7, pc}
 80064fe: bf00         	nop

08006500 <$d>:
 8006500: 70 00 00 20  	.word	0x20000070
 8006504: 74 58 01 08  	.word	0x08015874

08006508 <spi_context_buffers_setup>:
; {
 8006508: b5f0         	push	{r4, r5, r6, r7, lr}
 800650a: b097         	sub	sp, #0x5c
 800650c: af0c         	add	r7, sp, #0x30
 800650e: 6178         	str	r0, [r7, #0x14]
 8006510: 6139         	str	r1, [r7, #0x10]
 8006512: 60fa         	str	r2, [r7, #0xc]
 8006514: 72fb         	strb	r3, [r7, #0xb]
; 	LOG_DBG("tx_bufs %p - rx_bufs %p - %u", tx_bufs, rx_bufs, dfs);
 8006516: 2303         	movs	r3, #0x3
 8006518: 2b03         	cmp	r3, #0x3
 800651a: d920         	bls	0x800655e <spi_context_buffers_setup+0x56> @ imm = #0x40
 800651c: 2301         	movs	r3, #0x1
 800651e: f887 3023    	strb.w	r3, [r7, #0x23]
 8006522: f897 3023    	ldrb.w	r3, [r7, #0x23]
 8006526: f083 0301    	eor	r3, r3, #0x1
 800652a: b2db         	uxtb	r3, r3
 800652c: 2b00         	cmp	r3, #0x0
 800652e: d116         	bne	0x800655e <spi_context_buffers_setup+0x56> @ imm = #0x2c
 8006530: 4b4e         	ldr	r3, [pc, #0x138]        @ 0x800666c <spi_context_buffers_setup+0x164>
 8006532: 6819         	ldr	r1, [r3]
 8006534: 7afb         	ldrb	r3, [r7, #0xb]
 8006536: 9306         	str	r3, [sp, #0x18]
 8006538: 68fb         	ldr	r3, [r7, #0xc]
 800653a: 9305         	str	r3, [sp, #0x14]
 800653c: 693b         	ldr	r3, [r7, #0x10]
 800653e: 9304         	str	r3, [sp, #0x10]
 8006540: 4b4b         	ldr	r3, [pc, #0x12c]        @ 0x8006670 <spi_context_buffers_setup+0x168>
 8006542: 9303         	str	r3, [sp, #0xc]
 8006544: 4b4b         	ldr	r3, [pc, #0x12c]        @ 0x8006674 <spi_context_buffers_setup+0x16c>
 8006546: 9302         	str	r3, [sp, #0x8]
 8006548: 2308         	movs	r3, #0x8
 800654a: 9301         	str	r3, [sp, #0x4]
 800654c: 2300         	movs	r3, #0x0
 800654e: 9300         	str	r3, [sp]
 8006550: 2300         	movs	r3, #0x0
 8006552: 2204         	movs	r2, #0x4
 8006554: 2000         	movs	r0, #0x0
 8006556: f00b fa0d    	bl	0x8011974 <z_log_msg_runtime_create> @ imm = #0xb41a
 800655a: 2300         	movs	r3, #0x0
 800655c: 627b         	str	r3, [r7, #0x24]
; 	ctx->current_tx = tx_bufs ? tx_bufs->buffers : NULL;
 800655e: 693b         	ldr	r3, [r7, #0x10]
 8006560: 2b00         	cmp	r3, #0x0
 8006562: d002         	beq	0x800656a <spi_context_buffers_setup+0x62> @ imm = #0x4
 8006564: 693b         	ldr	r3, [r7, #0x10]
 8006566: 681b         	ldr	r3, [r3]
 8006568: e000         	b	0x800656c <spi_context_buffers_setup+0x64> @ imm = #0x0
 800656a: 2300         	movs	r3, #0x0
 800656c: 697a         	ldr	r2, [r7, #0x14]
 800656e: 6353         	str	r3, [r2, #0x34]
; 	ctx->tx_count = ctx->current_tx ? tx_bufs->count : 0;
 8006570: 697b         	ldr	r3, [r7, #0x14]
 8006572: 6b5b         	ldr	r3, [r3, #0x34]
 8006574: 2b00         	cmp	r3, #0x0
 8006576: d002         	beq	0x800657e <spi_context_buffers_setup+0x76> @ imm = #0x4
 8006578: 693b         	ldr	r3, [r7, #0x10]
 800657a: 685b         	ldr	r3, [r3, #0x4]
 800657c: e000         	b	0x8006580 <spi_context_buffers_setup+0x78> @ imm = #0x0
 800657e: 2300         	movs	r3, #0x0
 8006580: 697a         	ldr	r2, [r7, #0x14]
 8006582: 6393         	str	r3, [r2, #0x38]
; 		spi_context_get_next_buf(&ctx->current_tx, &ctx->tx_count,
 8006584: 697b         	ldr	r3, [r7, #0x14]
 8006586: f103 0034    	add.w	r0, r3, #0x34
 800658a: 697b         	ldr	r3, [r7, #0x14]
 800658c: f103 0138    	add.w	r1, r3, #0x38
 8006590: 697b         	ldr	r3, [r7, #0x14]
 8006592: f103 0248    	add.w	r2, r3, #0x48
 8006596: 7afb         	ldrb	r3, [r7, #0xb]
 8006598: f00b fe57    	bl	0x801224a <spi_context_get_next_buf> @ imm = #0xbcae
 800659c: 4602         	mov	r2, r0
; 	ctx->tx_buf = (const uint8_t *)
 800659e: 697b         	ldr	r3, [r7, #0x14]
 80065a0: 645a         	str	r2, [r3, #0x44]
; 	ctx->current_rx = rx_bufs ? rx_bufs->buffers : NULL;
 80065a2: 68fb         	ldr	r3, [r7, #0xc]
 80065a4: 2b00         	cmp	r3, #0x0
 80065a6: d002         	beq	0x80065ae <spi_context_buffers_setup+0xa6> @ imm = #0x4
 80065a8: 68fb         	ldr	r3, [r7, #0xc]
 80065aa: 681b         	ldr	r3, [r3]
 80065ac: e000         	b	0x80065b0 <spi_context_buffers_setup+0xa8> @ imm = #0x0
 80065ae: 2300         	movs	r3, #0x0
 80065b0: 697a         	ldr	r2, [r7, #0x14]
 80065b2: 63d3         	str	r3, [r2, #0x3c]
; 	ctx->rx_count = ctx->current_rx ? rx_bufs->count : 0;
 80065b4: 697b         	ldr	r3, [r7, #0x14]
 80065b6: 6bdb         	ldr	r3, [r3, #0x3c]
 80065b8: 2b00         	cmp	r3, #0x0
 80065ba: d002         	beq	0x80065c2 <spi_context_buffers_setup+0xba> @ imm = #0x4
 80065bc: 68fb         	ldr	r3, [r7, #0xc]
 80065be: 685b         	ldr	r3, [r3, #0x4]
 80065c0: e000         	b	0x80065c4 <spi_context_buffers_setup+0xbc> @ imm = #0x0
 80065c2: 2300         	movs	r3, #0x0
 80065c4: 697a         	ldr	r2, [r7, #0x14]
 80065c6: 6413         	str	r3, [r2, #0x40]
; 		spi_context_get_next_buf(&ctx->current_rx, &ctx->rx_count,
 80065c8: 697b         	ldr	r3, [r7, #0x14]
 80065ca: f103 003c    	add.w	r0, r3, #0x3c
 80065ce: 697b         	ldr	r3, [r7, #0x14]
 80065d0: f103 0140    	add.w	r1, r3, #0x40
 80065d4: 697b         	ldr	r3, [r7, #0x14]
 80065d6: f103 0250    	add.w	r2, r3, #0x50
 80065da: 7afb         	ldrb	r3, [r7, #0xb]
 80065dc: f00b fe35    	bl	0x801224a <spi_context_get_next_buf> @ imm = #0xbc6a
 80065e0: 4602         	mov	r2, r0
; 	ctx->rx_buf = (uint8_t *)
 80065e2: 697b         	ldr	r3, [r7, #0x14]
 80065e4: 64da         	str	r2, [r3, #0x4c]
; 	ctx->sync_status = 0;
 80065e6: 697b         	ldr	r3, [r7, #0x14]
 80065e8: 2200         	movs	r2, #0x0
 80065ea: 631a         	str	r2, [r3, #0x30]
; 	LOG_DBG("current_tx %p (%zu), current_rx %p (%zu),"
 80065ec: 2303         	movs	r3, #0x3
 80065ee: 2b03         	cmp	r3, #0x3
 80065f0: d938         	bls	0x8006664 <spi_context_buffers_setup+0x15c> @ imm = #0x70
 80065f2: 2301         	movs	r3, #0x1
 80065f4: f887 3022    	strb.w	r3, [r7, #0x22]
 80065f8: f897 3022    	ldrb.w	r3, [r7, #0x22]
 80065fc: f083 0301    	eor	r3, r3, #0x1
 8006600: b2db         	uxtb	r3, r3
 8006602: 2b00         	cmp	r3, #0x0
 8006604: d12e         	bne	0x8006664 <spi_context_buffers_setup+0x15c> @ imm = #0x5c
 8006606: 4b19         	ldr	r3, [pc, #0x64]         @ 0x800666c <spi_context_buffers_setup+0x164>
 8006608: 681b         	ldr	r3, [r3]
 800660a: 607b         	str	r3, [r7, #0x4]
 800660c: 697b         	ldr	r3, [r7, #0x14]
 800660e: 6b5b         	ldr	r3, [r3, #0x34]
 8006610: 697a         	ldr	r2, [r7, #0x14]
 8006612: 6b92         	ldr	r2, [r2, #0x38]
 8006614: 6979         	ldr	r1, [r7, #0x14]
 8006616: 6bc9         	ldr	r1, [r1, #0x3c]
 8006618: 6978         	ldr	r0, [r7, #0x14]
 800661a: 6c00         	ldr	r0, [r0, #0x40]
 800661c: 697c         	ldr	r4, [r7, #0x14]
 800661e: 6c64         	ldr	r4, [r4, #0x44]
 8006620: 697d         	ldr	r5, [r7, #0x14]
 8006622: 6cad         	ldr	r5, [r5, #0x48]
 8006624: 697e         	ldr	r6, [r7, #0x14]
 8006626: 6cf6         	ldr	r6, [r6, #0x4c]
 8006628: f8d7 c014    	ldr.w	r12, [r7, #0x14]
 800662c: f8dc c050    	ldr.w	r12, [r12, #0x50]
 8006630: f8cd c02c    	str.w	r12, [sp, #0x2c]
 8006634: 960a         	str	r6, [sp, #0x28]
 8006636: 9509         	str	r5, [sp, #0x24]
 8006638: 9408         	str	r4, [sp, #0x20]
 800663a: 9007         	str	r0, [sp, #0x1c]
 800663c: 9106         	str	r1, [sp, #0x18]
 800663e: 9205         	str	r2, [sp, #0x14]
 8006640: 9304         	str	r3, [sp, #0x10]
 8006642: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8006670 <spi_context_buffers_setup+0x168>
 8006644: 9303         	str	r3, [sp, #0xc]
 8006646: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8006678 <spi_context_buffers_setup+0x170>
 8006648: 9302         	str	r3, [sp, #0x8]
 800664a: 2308         	movs	r3, #0x8
 800664c: 9301         	str	r3, [sp, #0x4]
 800664e: 2300         	movs	r3, #0x0
 8006650: 9300         	str	r3, [sp]
 8006652: 2300         	movs	r3, #0x0
 8006654: 2204         	movs	r2, #0x4
 8006656: 6879         	ldr	r1, [r7, #0x4]
 8006658: 2000         	movs	r0, #0x0
 800665a: f00b f98b    	bl	0x8011974 <z_log_msg_runtime_create> @ imm = #0xb316
 800665e: 2300         	movs	r3, #0x0
 8006660: 61fb         	str	r3, [r7, #0x1c]
; }
 8006662: bf00         	nop
 8006664: bf00         	nop
 8006666: 372c         	adds	r7, #0x2c
 8006668: 46bd         	mov	sp, r7
 800666a: bdf0         	pop	{r4, r5, r6, r7, pc}

0800666c <$d>:
 800666c: 70 00 00 20  	.word	0x20000070
 8006670: c0 66 01 08  	.word	0x080166c0
 8006674: 98 58 01 08  	.word	0x08015898
 8006678: bc 58 01 08  	.word	0x080158bc

0800667c <spi_stm32_send_next_frame>:
; {
 800667c: b580         	push	{r7, lr}
 800667e: b09c         	sub	sp, #0x70
 8006680: af06         	add	r7, sp, #0x18
 8006682: 6078         	str	r0, [r7, #0x4]
 8006684: 6039         	str	r1, [r7]
; 	const uint8_t frame_size = SPI_WORD_SIZE_GET(data->ctx.config->operation);
 8006686: 683b         	ldr	r3, [r7]
 8006688: 681b         	ldr	r3, [r3]
 800668a: 889b         	ldrh	r3, [r3, #0x4]
 800668c: 095b         	lsrs	r3, r3, #0x5
 800668e: b2db         	uxtb	r3, r3
 8006690: f003 033f    	and	r3, r3, #0x3f
 8006694: f887 3053    	strb.w	r3, [r7, #0x53]
; 	uint32_t tx_frame = SPI_STM32_TX_NOP;
 8006698: 2300         	movs	r3, #0x0
 800669a: 657b         	str	r3, [r7, #0x54]
; 	if (frame_size == 8) {
 800669c: f897 3053    	ldrb.w	r3, [r7, #0x53]
 80066a0: 2b08         	cmp	r3, #0x8
 80066a2: f040 80a8    	bne.w	0x80067f6 <spi_stm32_send_next_frame+0x17a> @ imm = #0x150
; 		if (spi_context_tx_buf_on(&data->ctx)) {
 80066a6: 683b         	ldr	r3, [r7]
 80066a8: 647b         	str	r3, [r7, #0x44]
; 	return !!(ctx->tx_buf && ctx->tx_len);
 80066aa: 6c7b         	ldr	r3, [r7, #0x44]
 80066ac: 6c5b         	ldr	r3, [r3, #0x44]
 80066ae: 2b00         	cmp	r3, #0x0
 80066b0: d005         	beq	0x80066be <spi_stm32_send_next_frame+0x42> @ imm = #0xa
 80066b2: 6c7b         	ldr	r3, [r7, #0x44]
 80066b4: 6c9b         	ldr	r3, [r3, #0x48]
 80066b6: 2b00         	cmp	r3, #0x0
 80066b8: d001         	beq	0x80066be <spi_stm32_send_next_frame+0x42> @ imm = #0x2
 80066ba: 2301         	movs	r3, #0x1
 80066bc: e000         	b	0x80066c0 <spi_stm32_send_next_frame+0x44> @ imm = #0x0
 80066be: 2300         	movs	r3, #0x0
 80066c0: f003 0301    	and	r3, r3, #0x1
 80066c4: b2db         	uxtb	r3, r3
; 		if (spi_context_tx_buf_on(&data->ctx)) {
 80066c6: 2b00         	cmp	r3, #0x0
 80066c8: d005         	beq	0x80066d6 <spi_stm32_send_next_frame+0x5a> @ imm = #0xa
; 			tx_frame = UNALIGNED_GET((uint8_t *)(data->ctx.tx_buf));
 80066ca: 683b         	ldr	r3, [r7]
 80066cc: 6c5b         	ldr	r3, [r3, #0x44]
 80066ce: 64bb         	str	r3, [r7, #0x48]
 80066d0: 6cbb         	ldr	r3, [r7, #0x48]
 80066d2: 781b         	ldrb	r3, [r3]
 80066d4: 657b         	str	r3, [r7, #0x54]
; 		LL_SPI_TransmitData8(spi, tx_frame);
 80066d6: 6d7b         	ldr	r3, [r7, #0x54]
 80066d8: b2db         	uxtb	r3, r3
 80066da: 4619         	mov	r1, r3
 80066dc: 6878         	ldr	r0, [r7, #0x4]
 80066de: f00b fb41    	bl	0x8011d64 <LL_SPI_TransmitData8> @ imm = #0xb682
; 		spi_context_update_tx(&data->ctx, 1, 1);
 80066e2: 683b         	ldr	r3, [r7]
 80066e4: 643b         	str	r3, [r7, #0x40]
 80066e6: 2301         	movs	r3, #0x1
 80066e8: f887 303f    	strb.w	r3, [r7, #0x3f]
 80066ec: 2301         	movs	r3, #0x1
 80066ee: 63bb         	str	r3, [r7, #0x38]
; 	if (!ctx->tx_len) {
 80066f0: 6c3b         	ldr	r3, [r7, #0x40]
 80066f2: 6c9b         	ldr	r3, [r3, #0x48]
 80066f4: 2b00         	cmp	r3, #0x0
 80066f6: f000 811d    	beq.w	0x8006934 <spi_stm32_send_next_frame+0x2b8> @ imm = #0x23a
; 	if (len > ctx->tx_len) {
 80066fa: 6c3b         	ldr	r3, [r7, #0x40]
 80066fc: 6c9b         	ldr	r3, [r3, #0x48]
 80066fe: 6bba         	ldr	r2, [r7, #0x38]
 8006700: 429a         	cmp	r2, r3
 8006702: d91d         	bls	0x8006740 <spi_stm32_send_next_frame+0xc4> @ imm = #0x3a
; 		LOG_ERR("Update exceeds current buffer");
 8006704: 2303         	movs	r3, #0x3
 8006706: 2b00         	cmp	r3, #0x0
 8006708: d019         	beq	0x800673e <spi_stm32_send_next_frame+0xc2> @ imm = #0x32
 800670a: 2301         	movs	r3, #0x1
 800670c: f887 3037    	strb.w	r3, [r7, #0x37]
 8006710: f897 3037    	ldrb.w	r3, [r7, #0x37]
 8006714: f083 0301    	eor	r3, r3, #0x1
 8006718: b2db         	uxtb	r3, r3
 800671a: 2b00         	cmp	r3, #0x0
 800671c: d10f         	bne	0x800673e <spi_stm32_send_next_frame+0xc2> @ imm = #0x1e
 800671e: 4b89         	ldr	r3, [pc, #0x224]        @ 0x8006944 <spi_stm32_send_next_frame+0x2c8>
 8006720: 6819         	ldr	r1, [r3]
 8006722: 4b89         	ldr	r3, [pc, #0x224]        @ 0x8006948 <spi_stm32_send_next_frame+0x2cc>
 8006724: 9302         	str	r3, [sp, #0x8]
 8006726: 2300         	movs	r3, #0x0
 8006728: 9301         	str	r3, [sp, #0x4]
 800672a: 2300         	movs	r3, #0x0
 800672c: 9300         	str	r3, [sp]
 800672e: 2300         	movs	r3, #0x0
 8006730: 2201         	movs	r2, #0x1
 8006732: 2000         	movs	r0, #0x0
 8006734: f00b f91e    	bl	0x8011974 <z_log_msg_runtime_create> @ imm = #0xb23c
 8006738: 2300         	movs	r3, #0x0
 800673a: 633b         	str	r3, [r7, #0x30]
; 		return;
 800673c: e0fd         	b	0x800693a <spi_stm32_send_next_frame+0x2be> @ imm = #0x1fa
 800673e: e0fc         	b	0x800693a <spi_stm32_send_next_frame+0x2be> @ imm = #0x1f8
; 	ctx->tx_len -= len;
 8006740: 6c3b         	ldr	r3, [r7, #0x40]
 8006742: 6c9a         	ldr	r2, [r3, #0x48]
 8006744: 6bbb         	ldr	r3, [r7, #0x38]
 8006746: 1ad2         	subs	r2, r2, r3
 8006748: 6c3b         	ldr	r3, [r7, #0x40]
 800674a: 649a         	str	r2, [r3, #0x48]
; 	if (!ctx->tx_len) {
 800674c: 6c3b         	ldr	r3, [r7, #0x40]
 800674e: 6c9b         	ldr	r3, [r3, #0x48]
 8006750: 2b00         	cmp	r3, #0x0
 8006752: d11b         	bne	0x800678c <spi_stm32_send_next_frame+0x110> @ imm = #0x36
; 		++ctx->current_tx;
 8006754: 6c3b         	ldr	r3, [r7, #0x40]
 8006756: 6b5b         	ldr	r3, [r3, #0x34]
 8006758: f103 0208    	add.w	r2, r3, #0x8
 800675c: 6c3b         	ldr	r3, [r7, #0x40]
 800675e: 635a         	str	r2, [r3, #0x34]
; 		--ctx->tx_count;
 8006760: 6c3b         	ldr	r3, [r7, #0x40]
 8006762: 6b9b         	ldr	r3, [r3, #0x38]
 8006764: 1e5a         	subs	r2, r3, #0x1
 8006766: 6c3b         	ldr	r3, [r7, #0x40]
 8006768: 639a         	str	r2, [r3, #0x38]
; 			spi_context_get_next_buf(&ctx->current_tx,
 800676a: 6c3b         	ldr	r3, [r7, #0x40]
 800676c: f103 0034    	add.w	r0, r3, #0x34
 8006770: 6c3b         	ldr	r3, [r7, #0x40]
 8006772: f103 0138    	add.w	r1, r3, #0x38
 8006776: 6c3b         	ldr	r3, [r7, #0x40]
 8006778: f103 0248    	add.w	r2, r3, #0x48
 800677c: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 8006780: f00b fd63    	bl	0x801224a <spi_context_get_next_buf> @ imm = #0xbac6
 8006784: 4602         	mov	r2, r0
; 		ctx->tx_buf = (const uint8_t *)
 8006786: 6c3b         	ldr	r3, [r7, #0x40]
 8006788: 645a         	str	r2, [r3, #0x44]
 800678a: e00d         	b	0x80067a8 <spi_stm32_send_next_frame+0x12c> @ imm = #0x1a
; 	} else if (ctx->tx_buf) {
 800678c: 6c3b         	ldr	r3, [r7, #0x40]
 800678e: 6c5b         	ldr	r3, [r3, #0x44]
 8006790: 2b00         	cmp	r3, #0x0
 8006792: d009         	beq	0x80067a8 <spi_stm32_send_next_frame+0x12c> @ imm = #0x12
; 		ctx->tx_buf += dfs * len;
 8006794: 6c3b         	ldr	r3, [r7, #0x40]
 8006796: 6c5a         	ldr	r2, [r3, #0x44]
 8006798: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 800679c: 6bb9         	ldr	r1, [r7, #0x38]
 800679e: fb01 f303    	mul	r3, r1, r3
 80067a2: 441a         	add	r2, r3
 80067a4: 6c3b         	ldr	r3, [r7, #0x40]
 80067a6: 645a         	str	r2, [r3, #0x44]
; 	LOG_DBG("tx buf/len %p/%zu", (void *)ctx->tx_buf, ctx->tx_len);
 80067a8: 2303         	movs	r3, #0x3
 80067aa: 2b03         	cmp	r3, #0x3
 80067ac: f240 80c5    	bls.w	0x800693a <spi_stm32_send_next_frame+0x2be> @ imm = #0x18a
 80067b0: 2301         	movs	r3, #0x1
 80067b2: f887 302f    	strb.w	r3, [r7, #0x2f]
 80067b6: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 80067ba: f083 0301    	eor	r3, r3, #0x1
 80067be: b2db         	uxtb	r3, r3
 80067c0: 2b00         	cmp	r3, #0x0
 80067c2: f040 80ba    	bne.w	0x800693a <spi_stm32_send_next_frame+0x2be> @ imm = #0x174
 80067c6: 4b5f         	ldr	r3, [pc, #0x17c]        @ 0x8006944 <spi_stm32_send_next_frame+0x2c8>
 80067c8: 6819         	ldr	r1, [r3]
 80067ca: 6c3b         	ldr	r3, [r7, #0x40]
 80067cc: 6c5b         	ldr	r3, [r3, #0x44]
 80067ce: 6c3a         	ldr	r2, [r7, #0x40]
 80067d0: 6c92         	ldr	r2, [r2, #0x48]
 80067d2: 9205         	str	r2, [sp, #0x14]
 80067d4: 9304         	str	r3, [sp, #0x10]
 80067d6: 4b5d         	ldr	r3, [pc, #0x174]        @ 0x800694c <spi_stm32_send_next_frame+0x2d0>
 80067d8: 9303         	str	r3, [sp, #0xc]
 80067da: 4b5d         	ldr	r3, [pc, #0x174]        @ 0x8006950 <spi_stm32_send_next_frame+0x2d4>
 80067dc: 9302         	str	r3, [sp, #0x8]
 80067de: 2308         	movs	r3, #0x8
 80067e0: 9301         	str	r3, [sp, #0x4]
 80067e2: 2300         	movs	r3, #0x0
 80067e4: 9300         	str	r3, [sp]
 80067e6: 2300         	movs	r3, #0x0
 80067e8: 2204         	movs	r2, #0x4
 80067ea: 2000         	movs	r0, #0x0
 80067ec: f00b f8c2    	bl	0x8011974 <z_log_msg_runtime_create> @ imm = #0xb184
 80067f0: 2300         	movs	r3, #0x0
 80067f2: 62bb         	str	r3, [r7, #0x28]
; }
 80067f4: e0a1         	b	0x800693a <spi_stm32_send_next_frame+0x2be> @ imm = #0x142
; 		if (spi_context_tx_buf_on(&data->ctx)) {
 80067f6: 683b         	ldr	r3, [r7]
 80067f8: 627b         	str	r3, [r7, #0x24]
; 	return !!(ctx->tx_buf && ctx->tx_len);
 80067fa: 6a7b         	ldr	r3, [r7, #0x24]
 80067fc: 6c5b         	ldr	r3, [r3, #0x44]
 80067fe: 2b00         	cmp	r3, #0x0
 8006800: d005         	beq	0x800680e <spi_stm32_send_next_frame+0x192> @ imm = #0xa
 8006802: 6a7b         	ldr	r3, [r7, #0x24]
 8006804: 6c9b         	ldr	r3, [r3, #0x48]
 8006806: 2b00         	cmp	r3, #0x0
 8006808: d001         	beq	0x800680e <spi_stm32_send_next_frame+0x192> @ imm = #0x2
 800680a: 2301         	movs	r3, #0x1
 800680c: e000         	b	0x8006810 <spi_stm32_send_next_frame+0x194> @ imm = #0x0
 800680e: 2300         	movs	r3, #0x0
 8006810: f003 0301    	and	r3, r3, #0x1
 8006814: b2db         	uxtb	r3, r3
; 		if (spi_context_tx_buf_on(&data->ctx)) {
 8006816: 2b00         	cmp	r3, #0x0
 8006818: d006         	beq	0x8006828 <spi_stm32_send_next_frame+0x1ac> @ imm = #0xc
; 			tx_frame = UNALIGNED_GET((uint16_t *)(data->ctx.tx_buf));
 800681a: 683b         	ldr	r3, [r7]
 800681c: 6c5b         	ldr	r3, [r3, #0x44]
 800681e: 64fb         	str	r3, [r7, #0x4c]
 8006820: 6cfb         	ldr	r3, [r7, #0x4c]
 8006822: 881b         	ldrh	r3, [r3]
 8006824: b29b         	uxth	r3, r3
 8006826: 657b         	str	r3, [r7, #0x54]
; 		LL_SPI_TransmitData16(spi, tx_frame);
 8006828: 6d7b         	ldr	r3, [r7, #0x54]
 800682a: b29b         	uxth	r3, r3
 800682c: 4619         	mov	r1, r3
 800682e: 6878         	ldr	r0, [r7, #0x4]
 8006830: f00b faa9    	bl	0x8011d86 <LL_SPI_TransmitData16> @ imm = #0xb552
; 		spi_context_update_tx(&data->ctx, 2, 1);
 8006834: 683b         	ldr	r3, [r7]
 8006836: 623b         	str	r3, [r7, #0x20]
 8006838: 2302         	movs	r3, #0x2
 800683a: 77fb         	strb	r3, [r7, #0x1f]
 800683c: 2301         	movs	r3, #0x1
 800683e: 61bb         	str	r3, [r7, #0x18]
; 	if (!ctx->tx_len) {
 8006840: 6a3b         	ldr	r3, [r7, #0x20]
 8006842: 6c9b         	ldr	r3, [r3, #0x48]
 8006844: 2b00         	cmp	r3, #0x0
 8006846: d077         	beq	0x8006938 <spi_stm32_send_next_frame+0x2bc> @ imm = #0xee
; 	if (len > ctx->tx_len) {
 8006848: 6a3b         	ldr	r3, [r7, #0x20]
 800684a: 6c9b         	ldr	r3, [r3, #0x48]
 800684c: 69ba         	ldr	r2, [r7, #0x18]
 800684e: 429a         	cmp	r2, r3
 8006850: d91b         	bls	0x800688a <spi_stm32_send_next_frame+0x20e> @ imm = #0x36
; 		LOG_ERR("Update exceeds current buffer");
 8006852: 2303         	movs	r3, #0x3
 8006854: 2b00         	cmp	r3, #0x0
 8006856: d017         	beq	0x8006888 <spi_stm32_send_next_frame+0x20c> @ imm = #0x2e
 8006858: 2301         	movs	r3, #0x1
 800685a: 75fb         	strb	r3, [r7, #0x17]
 800685c: 7dfb         	ldrb	r3, [r7, #0x17]
 800685e: f083 0301    	eor	r3, r3, #0x1
 8006862: b2db         	uxtb	r3, r3
 8006864: 2b00         	cmp	r3, #0x0
 8006866: d10f         	bne	0x8006888 <spi_stm32_send_next_frame+0x20c> @ imm = #0x1e
 8006868: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x8006944 <spi_stm32_send_next_frame+0x2c8>
 800686a: 6819         	ldr	r1, [r3]
 800686c: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x8006948 <spi_stm32_send_next_frame+0x2cc>
 800686e: 9302         	str	r3, [sp, #0x8]
 8006870: 2300         	movs	r3, #0x0
 8006872: 9301         	str	r3, [sp, #0x4]
 8006874: 2300         	movs	r3, #0x0
 8006876: 9300         	str	r3, [sp]
 8006878: 2300         	movs	r3, #0x0
 800687a: 2201         	movs	r2, #0x1
 800687c: 2000         	movs	r0, #0x0
 800687e: f00b f879    	bl	0x8011974 <z_log_msg_runtime_create> @ imm = #0xb0f2
 8006882: 2300         	movs	r3, #0x0
 8006884: 613b         	str	r3, [r7, #0x10]
; 		return;
 8006886: e058         	b	0x800693a <spi_stm32_send_next_frame+0x2be> @ imm = #0xb0
 8006888: e057         	b	0x800693a <spi_stm32_send_next_frame+0x2be> @ imm = #0xae
; 	ctx->tx_len -= len;
 800688a: 6a3b         	ldr	r3, [r7, #0x20]
 800688c: 6c9a         	ldr	r2, [r3, #0x48]
 800688e: 69bb         	ldr	r3, [r7, #0x18]
 8006890: 1ad2         	subs	r2, r2, r3
 8006892: 6a3b         	ldr	r3, [r7, #0x20]
 8006894: 649a         	str	r2, [r3, #0x48]
; 	if (!ctx->tx_len) {
 8006896: 6a3b         	ldr	r3, [r7, #0x20]
 8006898: 6c9b         	ldr	r3, [r3, #0x48]
 800689a: 2b00         	cmp	r3, #0x0
 800689c: d11a         	bne	0x80068d4 <spi_stm32_send_next_frame+0x258> @ imm = #0x34
; 		++ctx->current_tx;
 800689e: 6a3b         	ldr	r3, [r7, #0x20]
 80068a0: 6b5b         	ldr	r3, [r3, #0x34]
 80068a2: f103 0208    	add.w	r2, r3, #0x8
 80068a6: 6a3b         	ldr	r3, [r7, #0x20]
 80068a8: 635a         	str	r2, [r3, #0x34]
; 		--ctx->tx_count;
 80068aa: 6a3b         	ldr	r3, [r7, #0x20]
 80068ac: 6b9b         	ldr	r3, [r3, #0x38]
 80068ae: 1e5a         	subs	r2, r3, #0x1
 80068b0: 6a3b         	ldr	r3, [r7, #0x20]
 80068b2: 639a         	str	r2, [r3, #0x38]
; 			spi_context_get_next_buf(&ctx->current_tx,
 80068b4: 6a3b         	ldr	r3, [r7, #0x20]
 80068b6: f103 0034    	add.w	r0, r3, #0x34
 80068ba: 6a3b         	ldr	r3, [r7, #0x20]
 80068bc: f103 0138    	add.w	r1, r3, #0x38
 80068c0: 6a3b         	ldr	r3, [r7, #0x20]
 80068c2: f103 0248    	add.w	r2, r3, #0x48
 80068c6: 7ffb         	ldrb	r3, [r7, #0x1f]
 80068c8: f00b fcbf    	bl	0x801224a <spi_context_get_next_buf> @ imm = #0xb97e
 80068cc: 4602         	mov	r2, r0
; 		ctx->tx_buf = (const uint8_t *)
 80068ce: 6a3b         	ldr	r3, [r7, #0x20]
 80068d0: 645a         	str	r2, [r3, #0x44]
 80068d2: e00c         	b	0x80068ee <spi_stm32_send_next_frame+0x272> @ imm = #0x18
; 	} else if (ctx->tx_buf) {
 80068d4: 6a3b         	ldr	r3, [r7, #0x20]
 80068d6: 6c5b         	ldr	r3, [r3, #0x44]
 80068d8: 2b00         	cmp	r3, #0x0
 80068da: d008         	beq	0x80068ee <spi_stm32_send_next_frame+0x272> @ imm = #0x10
; 		ctx->tx_buf += dfs * len;
 80068dc: 6a3b         	ldr	r3, [r7, #0x20]
 80068de: 6c5a         	ldr	r2, [r3, #0x44]
 80068e0: 7ffb         	ldrb	r3, [r7, #0x1f]
 80068e2: 69b9         	ldr	r1, [r7, #0x18]
 80068e4: fb01 f303    	mul	r3, r1, r3
 80068e8: 441a         	add	r2, r3
 80068ea: 6a3b         	ldr	r3, [r7, #0x20]
 80068ec: 645a         	str	r2, [r3, #0x44]
; 	LOG_DBG("tx buf/len %p/%zu", (void *)ctx->tx_buf, ctx->tx_len);
 80068ee: 2303         	movs	r3, #0x3
 80068f0: 2b03         	cmp	r3, #0x3
 80068f2: d922         	bls	0x800693a <spi_stm32_send_next_frame+0x2be> @ imm = #0x44
 80068f4: 2301         	movs	r3, #0x1
 80068f6: 73fb         	strb	r3, [r7, #0xf]
 80068f8: 7bfb         	ldrb	r3, [r7, #0xf]
 80068fa: f083 0301    	eor	r3, r3, #0x1
 80068fe: b2db         	uxtb	r3, r3
 8006900: 2b00         	cmp	r3, #0x0
 8006902: d11a         	bne	0x800693a <spi_stm32_send_next_frame+0x2be> @ imm = #0x34
 8006904: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x8006944 <spi_stm32_send_next_frame+0x2c8>
 8006906: 6819         	ldr	r1, [r3]
 8006908: 6a3b         	ldr	r3, [r7, #0x20]
 800690a: 6c5b         	ldr	r3, [r3, #0x44]
 800690c: 6a3a         	ldr	r2, [r7, #0x20]
 800690e: 6c92         	ldr	r2, [r2, #0x48]
 8006910: 9205         	str	r2, [sp, #0x14]
 8006912: 9304         	str	r3, [sp, #0x10]
 8006914: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800694c <spi_stm32_send_next_frame+0x2d0>
 8006916: 9303         	str	r3, [sp, #0xc]
 8006918: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8006950 <spi_stm32_send_next_frame+0x2d4>
 800691a: 9302         	str	r3, [sp, #0x8]
 800691c: 2308         	movs	r3, #0x8
 800691e: 9301         	str	r3, [sp, #0x4]
 8006920: 2300         	movs	r3, #0x0
 8006922: 9300         	str	r3, [sp]
 8006924: 2300         	movs	r3, #0x0
 8006926: 2204         	movs	r2, #0x4
 8006928: 2000         	movs	r0, #0x0
 800692a: f00b f823    	bl	0x8011974 <z_log_msg_runtime_create> @ imm = #0xb046
 800692e: 2300         	movs	r3, #0x0
 8006930: 60bb         	str	r3, [r7, #0x8]
; }
 8006932: e002         	b	0x800693a <spi_stm32_send_next_frame+0x2be> @ imm = #0x4
; 		return;
 8006934: bf00         	nop
 8006936: e000         	b	0x800693a <spi_stm32_send_next_frame+0x2be> @ imm = #0x0
 8006938: bf00         	nop
; }
 800693a: bf00         	nop
 800693c: 3758         	adds	r7, #0x58
 800693e: 46bd         	mov	sp, r7
 8006940: bd80         	pop	{r7, pc}
 8006942: bf00         	nop

08006944 <$d>:
 8006944: 70 00 00 20  	.word	0x20000070
 8006948: 10 59 01 08  	.word	0x08015910
 800694c: 68 66 01 08  	.word	0x08016668
 8006950: 30 59 01 08  	.word	0x08015930

08006954 <spi_stm32_read_next_frame>:
; {
 8006954: b580         	push	{r7, lr}
 8006956: b09c         	sub	sp, #0x70
 8006958: af06         	add	r7, sp, #0x18
 800695a: 6078         	str	r0, [r7, #0x4]
 800695c: 6039         	str	r1, [r7]
; 	const uint8_t frame_size = SPI_WORD_SIZE_GET(data->ctx.config->operation);
 800695e: 683b         	ldr	r3, [r7]
 8006960: 681b         	ldr	r3, [r3]
 8006962: 889b         	ldrh	r3, [r3, #0x4]
 8006964: 095b         	lsrs	r3, r3, #0x5
 8006966: b2db         	uxtb	r3, r3
 8006968: f003 033f    	and	r3, r3, #0x3f
 800696c: f887 3057    	strb.w	r3, [r7, #0x57]
; 	uint32_t rx_frame = 0;
 8006970: 2300         	movs	r3, #0x0
 8006972: 653b         	str	r3, [r7, #0x50]
; 	if (frame_size == 8) {
 8006974: f897 3057    	ldrb.w	r3, [r7, #0x57]
 8006978: 2b08         	cmp	r3, #0x8
 800697a: f040 80a8    	bne.w	0x8006ace <spi_stm32_read_next_frame+0x17a> @ imm = #0x150
; 		rx_frame = LL_SPI_ReceiveData8(spi);
 800697e: 6878         	ldr	r0, [r7, #0x4]
 8006980: f00b f9d7    	bl	0x8011d32 <LL_SPI_ReceiveData8> @ imm = #0xb3ae
 8006984: 4603         	mov	r3, r0
 8006986: 653b         	str	r3, [r7, #0x50]
; 		if (spi_context_rx_buf_on(&data->ctx)) {
 8006988: 683b         	ldr	r3, [r7]
 800698a: 647b         	str	r3, [r7, #0x44]
; 	return !!(ctx->rx_buf && ctx->rx_len);
 800698c: 6c7b         	ldr	r3, [r7, #0x44]
 800698e: 6cdb         	ldr	r3, [r3, #0x4c]
 8006990: 2b00         	cmp	r3, #0x0
 8006992: d005         	beq	0x80069a0 <spi_stm32_read_next_frame+0x4c> @ imm = #0xa
 8006994: 6c7b         	ldr	r3, [r7, #0x44]
 8006996: 6d1b         	ldr	r3, [r3, #0x50]
 8006998: 2b00         	cmp	r3, #0x0
 800699a: d001         	beq	0x80069a0 <spi_stm32_read_next_frame+0x4c> @ imm = #0x2
 800699c: 2301         	movs	r3, #0x1
 800699e: e000         	b	0x80069a2 <spi_stm32_read_next_frame+0x4e> @ imm = #0x0
 80069a0: 2300         	movs	r3, #0x0
 80069a2: f003 0301    	and	r3, r3, #0x1
 80069a6: b2db         	uxtb	r3, r3
; 		if (spi_context_rx_buf_on(&data->ctx)) {
 80069a8: 2b00         	cmp	r3, #0x0
 80069aa: d006         	beq	0x80069ba <spi_stm32_read_next_frame+0x66> @ imm = #0xc
; 			UNALIGNED_PUT(rx_frame, (uint8_t *)data->ctx.rx_buf);
 80069ac: 683b         	ldr	r3, [r7]
 80069ae: 6cdb         	ldr	r3, [r3, #0x4c]
 80069b0: 64bb         	str	r3, [r7, #0x48]
 80069b2: 6d3b         	ldr	r3, [r7, #0x50]
 80069b4: b2da         	uxtb	r2, r3
 80069b6: 6cbb         	ldr	r3, [r7, #0x48]
 80069b8: 701a         	strb	r2, [r3]
; 		spi_context_update_rx(&data->ctx, 1, 1);
 80069ba: 683b         	ldr	r3, [r7]
 80069bc: 643b         	str	r3, [r7, #0x40]
 80069be: 2301         	movs	r3, #0x1
 80069c0: f887 303f    	strb.w	r3, [r7, #0x3f]
 80069c4: 2301         	movs	r3, #0x1
 80069c6: 63bb         	str	r3, [r7, #0x38]
; 	if (!ctx->rx_len) {
 80069c8: 6c3b         	ldr	r3, [r7, #0x40]
 80069ca: 6d1b         	ldr	r3, [r3, #0x50]
 80069cc: 2b00         	cmp	r3, #0x0
 80069ce: f000 811c    	beq.w	0x8006c0a <spi_stm32_read_next_frame+0x2b6> @ imm = #0x238
; 	if (len > ctx->rx_len) {
 80069d2: 6c3b         	ldr	r3, [r7, #0x40]
 80069d4: 6d1b         	ldr	r3, [r3, #0x50]
 80069d6: 6bba         	ldr	r2, [r7, #0x38]
 80069d8: 429a         	cmp	r2, r3
 80069da: d91d         	bls	0x8006a18 <spi_stm32_read_next_frame+0xc4> @ imm = #0x3a
; 		LOG_ERR("Update exceeds current buffer");
 80069dc: 2303         	movs	r3, #0x3
 80069de: 2b00         	cmp	r3, #0x0
 80069e0: d019         	beq	0x8006a16 <spi_stm32_read_next_frame+0xc2> @ imm = #0x32
 80069e2: 2301         	movs	r3, #0x1
 80069e4: f887 3037    	strb.w	r3, [r7, #0x37]
 80069e8: f897 3037    	ldrb.w	r3, [r7, #0x37]
 80069ec: f083 0301    	eor	r3, r3, #0x1
 80069f0: b2db         	uxtb	r3, r3
 80069f2: 2b00         	cmp	r3, #0x0
 80069f4: d10f         	bne	0x8006a16 <spi_stm32_read_next_frame+0xc2> @ imm = #0x1e
 80069f6: 4b88         	ldr	r3, [pc, #0x220]        @ 0x8006c18 <spi_stm32_read_next_frame+0x2c4>
 80069f8: 6819         	ldr	r1, [r3]
 80069fa: 4b88         	ldr	r3, [pc, #0x220]        @ 0x8006c1c <spi_stm32_read_next_frame+0x2c8>
 80069fc: 9302         	str	r3, [sp, #0x8]
 80069fe: 2300         	movs	r3, #0x0
 8006a00: 9301         	str	r3, [sp, #0x4]
 8006a02: 2300         	movs	r3, #0x0
 8006a04: 9300         	str	r3, [sp]
 8006a06: 2300         	movs	r3, #0x0
 8006a08: 2201         	movs	r2, #0x1
 8006a0a: 2000         	movs	r0, #0x0
 8006a0c: f00a ffb2    	bl	0x8011974 <z_log_msg_runtime_create> @ imm = #0xaf64
 8006a10: 2300         	movs	r3, #0x0
 8006a12: 633b         	str	r3, [r7, #0x30]
; 		return;
 8006a14: e0fc         	b	0x8006c10 <spi_stm32_read_next_frame+0x2bc> @ imm = #0x1f8
 8006a16: e0fb         	b	0x8006c10 <spi_stm32_read_next_frame+0x2bc> @ imm = #0x1f6
; 	ctx->rx_len -= len;
 8006a18: 6c3b         	ldr	r3, [r7, #0x40]
 8006a1a: 6d1a         	ldr	r2, [r3, #0x50]
 8006a1c: 6bbb         	ldr	r3, [r7, #0x38]
 8006a1e: 1ad2         	subs	r2, r2, r3
 8006a20: 6c3b         	ldr	r3, [r7, #0x40]
 8006a22: 651a         	str	r2, [r3, #0x50]
; 	if (!ctx->rx_len) {
 8006a24: 6c3b         	ldr	r3, [r7, #0x40]
 8006a26: 6d1b         	ldr	r3, [r3, #0x50]
 8006a28: 2b00         	cmp	r3, #0x0
 8006a2a: d11b         	bne	0x8006a64 <spi_stm32_read_next_frame+0x110> @ imm = #0x36
; 		++ctx->current_rx;
 8006a2c: 6c3b         	ldr	r3, [r7, #0x40]
 8006a2e: 6bdb         	ldr	r3, [r3, #0x3c]
 8006a30: f103 0208    	add.w	r2, r3, #0x8
 8006a34: 6c3b         	ldr	r3, [r7, #0x40]
 8006a36: 63da         	str	r2, [r3, #0x3c]
; 		--ctx->rx_count;
 8006a38: 6c3b         	ldr	r3, [r7, #0x40]
 8006a3a: 6c1b         	ldr	r3, [r3, #0x40]
 8006a3c: 1e5a         	subs	r2, r3, #0x1
 8006a3e: 6c3b         	ldr	r3, [r7, #0x40]
 8006a40: 641a         	str	r2, [r3, #0x40]
; 			spi_context_get_next_buf(&ctx->current_rx,
 8006a42: 6c3b         	ldr	r3, [r7, #0x40]
 8006a44: f103 003c    	add.w	r0, r3, #0x3c
 8006a48: 6c3b         	ldr	r3, [r7, #0x40]
 8006a4a: f103 0140    	add.w	r1, r3, #0x40
 8006a4e: 6c3b         	ldr	r3, [r7, #0x40]
 8006a50: f103 0250    	add.w	r2, r3, #0x50
 8006a54: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 8006a58: f00b fbf7    	bl	0x801224a <spi_context_get_next_buf> @ imm = #0xb7ee
 8006a5c: 4602         	mov	r2, r0
; 		ctx->rx_buf = (uint8_t *)
 8006a5e: 6c3b         	ldr	r3, [r7, #0x40]
 8006a60: 64da         	str	r2, [r3, #0x4c]
 8006a62: e00d         	b	0x8006a80 <spi_stm32_read_next_frame+0x12c> @ imm = #0x1a
; 	} else if (ctx->rx_buf) {
 8006a64: 6c3b         	ldr	r3, [r7, #0x40]
 8006a66: 6cdb         	ldr	r3, [r3, #0x4c]
 8006a68: 2b00         	cmp	r3, #0x0
 8006a6a: d009         	beq	0x8006a80 <spi_stm32_read_next_frame+0x12c> @ imm = #0x12
; 		ctx->rx_buf += dfs * len;
 8006a6c: 6c3b         	ldr	r3, [r7, #0x40]
 8006a6e: 6cda         	ldr	r2, [r3, #0x4c]
 8006a70: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 8006a74: 6bb9         	ldr	r1, [r7, #0x38]
 8006a76: fb01 f303    	mul	r3, r1, r3
 8006a7a: 441a         	add	r2, r3
 8006a7c: 6c3b         	ldr	r3, [r7, #0x40]
 8006a7e: 64da         	str	r2, [r3, #0x4c]
; 	LOG_DBG("rx buf/len %p/%zu", (void *)ctx->rx_buf, ctx->rx_len);
 8006a80: 2303         	movs	r3, #0x3
 8006a82: 2b03         	cmp	r3, #0x3
 8006a84: f240 80c4    	bls.w	0x8006c10 <spi_stm32_read_next_frame+0x2bc> @ imm = #0x188
 8006a88: 2301         	movs	r3, #0x1
 8006a8a: f887 302f    	strb.w	r3, [r7, #0x2f]
 8006a8e: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 8006a92: f083 0301    	eor	r3, r3, #0x1
 8006a96: b2db         	uxtb	r3, r3
 8006a98: 2b00         	cmp	r3, #0x0
 8006a9a: f040 80b9    	bne.w	0x8006c10 <spi_stm32_read_next_frame+0x2bc> @ imm = #0x172
 8006a9e: 4b5e         	ldr	r3, [pc, #0x178]        @ 0x8006c18 <spi_stm32_read_next_frame+0x2c4>
 8006aa0: 6819         	ldr	r1, [r3]
 8006aa2: 6c3b         	ldr	r3, [r7, #0x40]
 8006aa4: 6cdb         	ldr	r3, [r3, #0x4c]
 8006aa6: 6c3a         	ldr	r2, [r7, #0x40]
 8006aa8: 6d12         	ldr	r2, [r2, #0x50]
 8006aaa: 9205         	str	r2, [sp, #0x14]
 8006aac: 9304         	str	r3, [sp, #0x10]
 8006aae: 4b5c         	ldr	r3, [pc, #0x170]        @ 0x8006c20 <spi_stm32_read_next_frame+0x2cc>
 8006ab0: 9303         	str	r3, [sp, #0xc]
 8006ab2: 4b5c         	ldr	r3, [pc, #0x170]        @ 0x8006c24 <spi_stm32_read_next_frame+0x2d0>
 8006ab4: 9302         	str	r3, [sp, #0x8]
 8006ab6: 2308         	movs	r3, #0x8
 8006ab8: 9301         	str	r3, [sp, #0x4]
 8006aba: 2300         	movs	r3, #0x0
 8006abc: 9300         	str	r3, [sp]
 8006abe: 2300         	movs	r3, #0x0
 8006ac0: 2204         	movs	r2, #0x4
 8006ac2: 2000         	movs	r0, #0x0
 8006ac4: f00a ff56    	bl	0x8011974 <z_log_msg_runtime_create> @ imm = #0xaeac
 8006ac8: 2300         	movs	r3, #0x0
 8006aca: 62bb         	str	r3, [r7, #0x28]
; }
 8006acc: e0a0         	b	0x8006c10 <spi_stm32_read_next_frame+0x2bc> @ imm = #0x140
; 		rx_frame = LL_SPI_ReceiveData16(spi);
 8006ace: 6878         	ldr	r0, [r7, #0x4]
 8006ad0: f00b f93c    	bl	0x8011d4c <LL_SPI_ReceiveData16> @ imm = #0xb278
 8006ad4: 4603         	mov	r3, r0
 8006ad6: 653b         	str	r3, [r7, #0x50]
; 		if (spi_context_rx_buf_on(&data->ctx)) {
 8006ad8: 683b         	ldr	r3, [r7]
 8006ada: 627b         	str	r3, [r7, #0x24]
; 	return !!(ctx->rx_buf && ctx->rx_len);
 8006adc: 6a7b         	ldr	r3, [r7, #0x24]
 8006ade: 6cdb         	ldr	r3, [r3, #0x4c]
 8006ae0: 2b00         	cmp	r3, #0x0
 8006ae2: d005         	beq	0x8006af0 <spi_stm32_read_next_frame+0x19c> @ imm = #0xa
 8006ae4: 6a7b         	ldr	r3, [r7, #0x24]
 8006ae6: 6d1b         	ldr	r3, [r3, #0x50]
 8006ae8: 2b00         	cmp	r3, #0x0
 8006aea: d001         	beq	0x8006af0 <spi_stm32_read_next_frame+0x19c> @ imm = #0x2
 8006aec: 2301         	movs	r3, #0x1
 8006aee: e000         	b	0x8006af2 <spi_stm32_read_next_frame+0x19e> @ imm = #0x0
 8006af0: 2300         	movs	r3, #0x0
 8006af2: f003 0301    	and	r3, r3, #0x1
 8006af6: b2db         	uxtb	r3, r3
; 		if (spi_context_rx_buf_on(&data->ctx)) {
 8006af8: 2b00         	cmp	r3, #0x0
 8006afa: d006         	beq	0x8006b0a <spi_stm32_read_next_frame+0x1b6> @ imm = #0xc
; 			UNALIGNED_PUT(rx_frame, (uint16_t *)data->ctx.rx_buf);
 8006afc: 683b         	ldr	r3, [r7]
 8006afe: 6cdb         	ldr	r3, [r3, #0x4c]
 8006b00: 64fb         	str	r3, [r7, #0x4c]
 8006b02: 6d3b         	ldr	r3, [r7, #0x50]
 8006b04: b29a         	uxth	r2, r3
 8006b06: 6cfb         	ldr	r3, [r7, #0x4c]
 8006b08: 801a         	strh	r2, [r3]
; 		spi_context_update_rx(&data->ctx, 2, 1);
 8006b0a: 683b         	ldr	r3, [r7]
 8006b0c: 623b         	str	r3, [r7, #0x20]
 8006b0e: 2302         	movs	r3, #0x2
 8006b10: 77fb         	strb	r3, [r7, #0x1f]
 8006b12: 2301         	movs	r3, #0x1
 8006b14: 61bb         	str	r3, [r7, #0x18]
; 	if (!ctx->rx_len) {
 8006b16: 6a3b         	ldr	r3, [r7, #0x20]
 8006b18: 6d1b         	ldr	r3, [r3, #0x50]
 8006b1a: 2b00         	cmp	r3, #0x0
 8006b1c: d077         	beq	0x8006c0e <spi_stm32_read_next_frame+0x2ba> @ imm = #0xee
; 	if (len > ctx->rx_len) {
 8006b1e: 6a3b         	ldr	r3, [r7, #0x20]
 8006b20: 6d1b         	ldr	r3, [r3, #0x50]
 8006b22: 69ba         	ldr	r2, [r7, #0x18]
 8006b24: 429a         	cmp	r2, r3
 8006b26: d91b         	bls	0x8006b60 <spi_stm32_read_next_frame+0x20c> @ imm = #0x36
; 		LOG_ERR("Update exceeds current buffer");
 8006b28: 2303         	movs	r3, #0x3
 8006b2a: 2b00         	cmp	r3, #0x0
 8006b2c: d017         	beq	0x8006b5e <spi_stm32_read_next_frame+0x20a> @ imm = #0x2e
 8006b2e: 2301         	movs	r3, #0x1
 8006b30: 75fb         	strb	r3, [r7, #0x17]
 8006b32: 7dfb         	ldrb	r3, [r7, #0x17]
 8006b34: f083 0301    	eor	r3, r3, #0x1
 8006b38: b2db         	uxtb	r3, r3
 8006b3a: 2b00         	cmp	r3, #0x0
 8006b3c: d10f         	bne	0x8006b5e <spi_stm32_read_next_frame+0x20a> @ imm = #0x1e
 8006b3e: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x8006c18 <spi_stm32_read_next_frame+0x2c4>
 8006b40: 6819         	ldr	r1, [r3]
 8006b42: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x8006c1c <spi_stm32_read_next_frame+0x2c8>
 8006b44: 9302         	str	r3, [sp, #0x8]
 8006b46: 2300         	movs	r3, #0x0
 8006b48: 9301         	str	r3, [sp, #0x4]
 8006b4a: 2300         	movs	r3, #0x0
 8006b4c: 9300         	str	r3, [sp]
 8006b4e: 2300         	movs	r3, #0x0
 8006b50: 2201         	movs	r2, #0x1
 8006b52: 2000         	movs	r0, #0x0
 8006b54: f00a ff0e    	bl	0x8011974 <z_log_msg_runtime_create> @ imm = #0xae1c
 8006b58: 2300         	movs	r3, #0x0
 8006b5a: 613b         	str	r3, [r7, #0x10]
; 		return;
 8006b5c: e058         	b	0x8006c10 <spi_stm32_read_next_frame+0x2bc> @ imm = #0xb0
 8006b5e: e057         	b	0x8006c10 <spi_stm32_read_next_frame+0x2bc> @ imm = #0xae
; 	ctx->rx_len -= len;
 8006b60: 6a3b         	ldr	r3, [r7, #0x20]
 8006b62: 6d1a         	ldr	r2, [r3, #0x50]
 8006b64: 69bb         	ldr	r3, [r7, #0x18]
 8006b66: 1ad2         	subs	r2, r2, r3
 8006b68: 6a3b         	ldr	r3, [r7, #0x20]
 8006b6a: 651a         	str	r2, [r3, #0x50]
; 	if (!ctx->rx_len) {
 8006b6c: 6a3b         	ldr	r3, [r7, #0x20]
 8006b6e: 6d1b         	ldr	r3, [r3, #0x50]
 8006b70: 2b00         	cmp	r3, #0x0
 8006b72: d11a         	bne	0x8006baa <spi_stm32_read_next_frame+0x256> @ imm = #0x34
; 		++ctx->current_rx;
 8006b74: 6a3b         	ldr	r3, [r7, #0x20]
 8006b76: 6bdb         	ldr	r3, [r3, #0x3c]
 8006b78: f103 0208    	add.w	r2, r3, #0x8
 8006b7c: 6a3b         	ldr	r3, [r7, #0x20]
 8006b7e: 63da         	str	r2, [r3, #0x3c]
; 		--ctx->rx_count;
 8006b80: 6a3b         	ldr	r3, [r7, #0x20]
 8006b82: 6c1b         	ldr	r3, [r3, #0x40]
 8006b84: 1e5a         	subs	r2, r3, #0x1
 8006b86: 6a3b         	ldr	r3, [r7, #0x20]
 8006b88: 641a         	str	r2, [r3, #0x40]
; 			spi_context_get_next_buf(&ctx->current_rx,
 8006b8a: 6a3b         	ldr	r3, [r7, #0x20]
 8006b8c: f103 003c    	add.w	r0, r3, #0x3c
 8006b90: 6a3b         	ldr	r3, [r7, #0x20]
 8006b92: f103 0140    	add.w	r1, r3, #0x40
 8006b96: 6a3b         	ldr	r3, [r7, #0x20]
 8006b98: f103 0250    	add.w	r2, r3, #0x50
 8006b9c: 7ffb         	ldrb	r3, [r7, #0x1f]
 8006b9e: f00b fb54    	bl	0x801224a <spi_context_get_next_buf> @ imm = #0xb6a8
 8006ba2: 4602         	mov	r2, r0
; 		ctx->rx_buf = (uint8_t *)
 8006ba4: 6a3b         	ldr	r3, [r7, #0x20]
 8006ba6: 64da         	str	r2, [r3, #0x4c]
 8006ba8: e00c         	b	0x8006bc4 <spi_stm32_read_next_frame+0x270> @ imm = #0x18
; 	} else if (ctx->rx_buf) {
 8006baa: 6a3b         	ldr	r3, [r7, #0x20]
 8006bac: 6cdb         	ldr	r3, [r3, #0x4c]
 8006bae: 2b00         	cmp	r3, #0x0
 8006bb0: d008         	beq	0x8006bc4 <spi_stm32_read_next_frame+0x270> @ imm = #0x10
; 		ctx->rx_buf += dfs * len;
 8006bb2: 6a3b         	ldr	r3, [r7, #0x20]
 8006bb4: 6cda         	ldr	r2, [r3, #0x4c]
 8006bb6: 7ffb         	ldrb	r3, [r7, #0x1f]
 8006bb8: 69b9         	ldr	r1, [r7, #0x18]
 8006bba: fb01 f303    	mul	r3, r1, r3
 8006bbe: 441a         	add	r2, r3
 8006bc0: 6a3b         	ldr	r3, [r7, #0x20]
 8006bc2: 64da         	str	r2, [r3, #0x4c]
; 	LOG_DBG("rx buf/len %p/%zu", (void *)ctx->rx_buf, ctx->rx_len);
 8006bc4: 2303         	movs	r3, #0x3
 8006bc6: 2b03         	cmp	r3, #0x3
 8006bc8: d922         	bls	0x8006c10 <spi_stm32_read_next_frame+0x2bc> @ imm = #0x44
 8006bca: 2301         	movs	r3, #0x1
 8006bcc: 73fb         	strb	r3, [r7, #0xf]
 8006bce: 7bfb         	ldrb	r3, [r7, #0xf]
 8006bd0: f083 0301    	eor	r3, r3, #0x1
 8006bd4: b2db         	uxtb	r3, r3
 8006bd6: 2b00         	cmp	r3, #0x0
 8006bd8: d11a         	bne	0x8006c10 <spi_stm32_read_next_frame+0x2bc> @ imm = #0x34
 8006bda: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x8006c18 <spi_stm32_read_next_frame+0x2c4>
 8006bdc: 6819         	ldr	r1, [r3]
 8006bde: 6a3b         	ldr	r3, [r7, #0x20]
 8006be0: 6cdb         	ldr	r3, [r3, #0x4c]
 8006be2: 6a3a         	ldr	r2, [r7, #0x20]
 8006be4: 6d12         	ldr	r2, [r2, #0x50]
 8006be6: 9205         	str	r2, [sp, #0x14]
 8006be8: 9304         	str	r3, [sp, #0x10]
 8006bea: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8006c20 <spi_stm32_read_next_frame+0x2cc>
 8006bec: 9303         	str	r3, [sp, #0xc]
 8006bee: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8006c24 <spi_stm32_read_next_frame+0x2d0>
 8006bf0: 9302         	str	r3, [sp, #0x8]
 8006bf2: 2308         	movs	r3, #0x8
 8006bf4: 9301         	str	r3, [sp, #0x4]
 8006bf6: 2300         	movs	r3, #0x0
 8006bf8: 9300         	str	r3, [sp]
 8006bfa: 2300         	movs	r3, #0x0
 8006bfc: 2204         	movs	r2, #0x4
 8006bfe: 2000         	movs	r0, #0x0
 8006c00: f00a feb8    	bl	0x8011974 <z_log_msg_runtime_create> @ imm = #0xad70
 8006c04: 2300         	movs	r3, #0x0
 8006c06: 60bb         	str	r3, [r7, #0x8]
; }
 8006c08: e002         	b	0x8006c10 <spi_stm32_read_next_frame+0x2bc> @ imm = #0x4
; 		return;
 8006c0a: bf00         	nop
 8006c0c: e000         	b	0x8006c10 <spi_stm32_read_next_frame+0x2bc> @ imm = #0x0
 8006c0e: bf00         	nop
; }
 8006c10: bf00         	nop
 8006c12: 3758         	adds	r7, #0x58
 8006c14: 46bd         	mov	sp, r7
 8006c16: bd80         	pop	{r7, pc}

08006c18 <$d>:
 8006c18: 70 00 00 20  	.word	0x20000070
 8006c1c: 10 59 01 08  	.word	0x08015910
 8006c20: 80 66 01 08  	.word	0x08016680
 8006c24: 48 59 01 08  	.word	0x08015948

08006c28 <spi_stm32_get_err>:
; {
 8006c28: b580         	push	{r7, lr}
 8006c2a: b08c         	sub	sp, #0x30
 8006c2c: af06         	add	r7, sp, #0x18
 8006c2e: 6078         	str	r0, [r7, #0x4]
; 	uint32_t sr = LL_SPI_ReadReg(spi, SR);
 8006c30: 687b         	ldr	r3, [r7, #0x4]
 8006c32: 689b         	ldr	r3, [r3, #0x8]
 8006c34: 617b         	str	r3, [r7, #0x14]
; 	if (sr & SPI_STM32_ERR_MSK) {
 8006c36: 697b         	ldr	r3, [r7, #0x14]
 8006c38: f403 73b8    	and	r3, r3, #0x170
 8006c3c: 2b00         	cmp	r3, #0x0
 8006c3e: d02b         	beq	0x8006c98 <spi_stm32_get_err+0x70> @ imm = #0x56
; 		LOG_ERR("%s: err=%d", __func__,
 8006c40: 2303         	movs	r3, #0x3
 8006c42: 2b00         	cmp	r3, #0x0
 8006c44: d01c         	beq	0x8006c80 <spi_stm32_get_err+0x58> @ imm = #0x38
 8006c46: 2301         	movs	r3, #0x1
 8006c48: 74fb         	strb	r3, [r7, #0x13]
 8006c4a: 7cfb         	ldrb	r3, [r7, #0x13]
 8006c4c: f083 0301    	eor	r3, r3, #0x1
 8006c50: b2db         	uxtb	r3, r3
 8006c52: 2b00         	cmp	r3, #0x0
 8006c54: d114         	bne	0x8006c80 <spi_stm32_get_err+0x58> @ imm = #0x28
 8006c56: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x8006ca4 <spi_stm32_get_err+0x7c>
 8006c58: 6819         	ldr	r1, [r3]
 8006c5a: 697b         	ldr	r3, [r7, #0x14]
 8006c5c: f403 73b8    	and	r3, r3, #0x170
 8006c60: 9304         	str	r3, [sp, #0x10]
 8006c62: 4b11         	ldr	r3, [pc, #0x44]         @ 0x8006ca8 <spi_stm32_get_err+0x80>
 8006c64: 9303         	str	r3, [sp, #0xc]
 8006c66: 4b11         	ldr	r3, [pc, #0x44]         @ 0x8006cac <spi_stm32_get_err+0x84>
 8006c68: 9302         	str	r3, [sp, #0x8]
 8006c6a: 2300         	movs	r3, #0x0
 8006c6c: 9301         	str	r3, [sp, #0x4]
 8006c6e: 2300         	movs	r3, #0x0
 8006c70: 9300         	str	r3, [sp]
 8006c72: 2300         	movs	r3, #0x0
 8006c74: 2201         	movs	r2, #0x1
 8006c76: 2000         	movs	r0, #0x0
 8006c78: f00a fe7c    	bl	0x8011974 <z_log_msg_runtime_create> @ imm = #0xacf8
 8006c7c: 2300         	movs	r3, #0x0
 8006c7e: 60fb         	str	r3, [r7, #0xc]
; 		if (LL_SPI_IsActiveFlag_OVR(spi)) {
 8006c80: 6878         	ldr	r0, [r7, #0x4]
 8006c82: f00a ffff    	bl	0x8011c84 <LL_SPI_IsActiveFlag_OVR> @ imm = #0xaffe
 8006c86: 4603         	mov	r3, r0
 8006c88: 2b00         	cmp	r3, #0x0
 8006c8a: d002         	beq	0x8006c92 <spi_stm32_get_err+0x6a> @ imm = #0x4
; 			LL_SPI_ClearFlag_OVR(spi);
 8006c8c: 6878         	ldr	r0, [r7, #0x4]
 8006c8e: f00b f830    	bl	0x8011cf2 <LL_SPI_ClearFlag_OVR> @ imm = #0xb060
; 		return -EIO;
 8006c92: f06f 0304    	mvn	r3, #0x4
 8006c96: e000         	b	0x8006c9a <spi_stm32_get_err+0x72> @ imm = #0x0
; 	return 0;
 8006c98: 2300         	movs	r3, #0x0
; }
 8006c9a: 4618         	mov	r0, r3
 8006c9c: 3718         	adds	r7, #0x18
 8006c9e: 46bd         	mov	sp, r7
 8006ca0: bd80         	pop	{r7, pc}
 8006ca2: bf00         	nop

08006ca4 <$d>:
 8006ca4: 70 00 00 20  	.word	0x20000070
 8006ca8: 98 66 01 08  	.word	0x08016698
 8006cac: 60 59 01 08  	.word	0x08015960

08006cb0 <spi_stm32_shift_s>:
; {
 8006cb0: b580         	push	{r7, lr}
 8006cb2: b0ac         	sub	sp, #0xb0
 8006cb4: af06         	add	r7, sp, #0x18
 8006cb6: 6078         	str	r0, [r7, #0x4]
 8006cb8: 6039         	str	r1, [r7]
; 	if (ll_func_tx_is_not_full(spi) && spi_context_tx_on(&data->ctx)) {
 8006cba: 6878         	ldr	r0, [r7, #0x4]
 8006cbc: f00b faf7    	bl	0x80122ae <ll_func_tx_is_not_full> @ imm = #0xb5ee
 8006cc0: 4603         	mov	r3, r0
 8006cc2: 2b00         	cmp	r3, #0x0
 8006cc4: f000 814a    	beq.w	0x8006f5c <spi_stm32_shift_s+0x2ac> @ imm = #0x294
 8006cc8: 683b         	ldr	r3, [r7]
 8006cca: 67fb         	str	r3, [r7, #0x7c]
; 	return !!(ctx->tx_len);
 8006ccc: 6ffb         	ldr	r3, [r7, #0x7c]
 8006cce: 6c9b         	ldr	r3, [r3, #0x48]
 8006cd0: 2b00         	cmp	r3, #0x0
 8006cd2: bf14         	ite	ne
 8006cd4: 2301         	movne	r3, #0x1
 8006cd6: 2300         	moveq	r3, #0x0
 8006cd8: b2db         	uxtb	r3, r3
; 	if (ll_func_tx_is_not_full(spi) && spi_context_tx_on(&data->ctx)) {
 8006cda: 2b00         	cmp	r3, #0x0
 8006cdc: f000 813e    	beq.w	0x8006f5c <spi_stm32_shift_s+0x2ac> @ imm = #0x27c
; 		if (SPI_WORD_SIZE_GET(data->ctx.config->operation) == 8) {
 8006ce0: 683b         	ldr	r3, [r7]
 8006ce2: 681b         	ldr	r3, [r3]
 8006ce4: 889b         	ldrh	r3, [r3, #0x4]
 8006ce6: 095b         	lsrs	r3, r3, #0x5
 8006ce8: f003 033f    	and	r3, r3, #0x3f
 8006cec: 2b08         	cmp	r3, #0x8
 8006cee: f040 809a    	bne.w	0x8006e26 <spi_stm32_shift_s+0x176> @ imm = #0x134
; 			tx_frame = UNALIGNED_GET((uint8_t *)(data->ctx.tx_buf));
 8006cf2: 683b         	ldr	r3, [r7]
 8006cf4: 6c5b         	ldr	r3, [r3, #0x44]
 8006cf6: f8c7 308c    	str.w	r3, [r7, #0x8c]
 8006cfa: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 8006cfe: 781b         	ldrb	r3, [r3]
 8006d00: f8a7 3092    	strh.w	r3, [r7, #0x92]
; 			LL_SPI_TransmitData8(spi, tx_frame);
 8006d04: f8b7 3092    	ldrh.w	r3, [r7, #0x92]
 8006d08: b2db         	uxtb	r3, r3
 8006d0a: 4619         	mov	r1, r3
 8006d0c: 6878         	ldr	r0, [r7, #0x4]
 8006d0e: f00b f829    	bl	0x8011d64 <LL_SPI_TransmitData8> @ imm = #0xb052
; 			spi_context_update_tx(&data->ctx, 1, 1);
 8006d12: 683b         	ldr	r3, [r7]
 8006d14: 67bb         	str	r3, [r7, #0x78]
 8006d16: 2301         	movs	r3, #0x1
 8006d18: f887 3077    	strb.w	r3, [r7, #0x77]
 8006d1c: 2301         	movs	r3, #0x1
 8006d1e: 673b         	str	r3, [r7, #0x70]
; 	if (!ctx->tx_len) {
 8006d20: 6fbb         	ldr	r3, [r7, #0x78]
 8006d22: 6c9b         	ldr	r3, [r3, #0x48]
 8006d24: 2b00         	cmp	r3, #0x0
 8006d26: f000 8115    	beq.w	0x8006f54 <spi_stm32_shift_s+0x2a4> @ imm = #0x22a
; 	if (len > ctx->tx_len) {
 8006d2a: 6fbb         	ldr	r3, [r7, #0x78]
 8006d2c: 6c9b         	ldr	r3, [r3, #0x48]
 8006d2e: 6f3a         	ldr	r2, [r7, #0x70]
 8006d30: 429a         	cmp	r2, r3
 8006d32: d91d         	bls	0x8006d70 <spi_stm32_shift_s+0xc0> @ imm = #0x3a
; 		LOG_ERR("Update exceeds current buffer");
 8006d34: 2303         	movs	r3, #0x3
 8006d36: 2b00         	cmp	r3, #0x0
 8006d38: d019         	beq	0x8006d6e <spi_stm32_shift_s+0xbe> @ imm = #0x32
 8006d3a: 2301         	movs	r3, #0x1
 8006d3c: f887 306f    	strb.w	r3, [r7, #0x6f]
 8006d40: f897 306f    	ldrb.w	r3, [r7, #0x6f]
 8006d44: f083 0301    	eor	r3, r3, #0x1
 8006d48: b2db         	uxtb	r3, r3
 8006d4a: 2b00         	cmp	r3, #0x0
 8006d4c: d10f         	bne	0x8006d6e <spi_stm32_shift_s+0xbe> @ imm = #0x1e
 8006d4e: 4b8e         	ldr	r3, [pc, #0x238]        @ 0x8006f88 <spi_stm32_shift_s+0x2d8>
 8006d50: 6819         	ldr	r1, [r3]
 8006d52: 4b8e         	ldr	r3, [pc, #0x238]        @ 0x8006f8c <spi_stm32_shift_s+0x2dc>
 8006d54: 9302         	str	r3, [sp, #0x8]
 8006d56: 2300         	movs	r3, #0x0
 8006d58: 9301         	str	r3, [sp, #0x4]
 8006d5a: 2300         	movs	r3, #0x0
 8006d5c: 9300         	str	r3, [sp]
 8006d5e: 2300         	movs	r3, #0x0
 8006d60: 2201         	movs	r2, #0x1
 8006d62: 2000         	movs	r0, #0x0
 8006d64: f00a fe06    	bl	0x8011974 <z_log_msg_runtime_create> @ imm = #0xac0c
 8006d68: 2300         	movs	r3, #0x0
 8006d6a: 66bb         	str	r3, [r7, #0x68]
; 		return;
 8006d6c: e0f5         	b	0x8006f5a <spi_stm32_shift_s+0x2aa> @ imm = #0x1ea
 8006d6e: e0f4         	b	0x8006f5a <spi_stm32_shift_s+0x2aa> @ imm = #0x1e8
; 	ctx->tx_len -= len;
 8006d70: 6fbb         	ldr	r3, [r7, #0x78]
 8006d72: 6c9a         	ldr	r2, [r3, #0x48]
 8006d74: 6f3b         	ldr	r3, [r7, #0x70]
 8006d76: 1ad2         	subs	r2, r2, r3
 8006d78: 6fbb         	ldr	r3, [r7, #0x78]
 8006d7a: 649a         	str	r2, [r3, #0x48]
; 	if (!ctx->tx_len) {
 8006d7c: 6fbb         	ldr	r3, [r7, #0x78]
 8006d7e: 6c9b         	ldr	r3, [r3, #0x48]
 8006d80: 2b00         	cmp	r3, #0x0
 8006d82: d11b         	bne	0x8006dbc <spi_stm32_shift_s+0x10c> @ imm = #0x36
; 		++ctx->current_tx;
 8006d84: 6fbb         	ldr	r3, [r7, #0x78]
 8006d86: 6b5b         	ldr	r3, [r3, #0x34]
 8006d88: f103 0208    	add.w	r2, r3, #0x8
 8006d8c: 6fbb         	ldr	r3, [r7, #0x78]
 8006d8e: 635a         	str	r2, [r3, #0x34]
; 		--ctx->tx_count;
 8006d90: 6fbb         	ldr	r3, [r7, #0x78]
 8006d92: 6b9b         	ldr	r3, [r3, #0x38]
 8006d94: 1e5a         	subs	r2, r3, #0x1
 8006d96: 6fbb         	ldr	r3, [r7, #0x78]
 8006d98: 639a         	str	r2, [r3, #0x38]
; 			spi_context_get_next_buf(&ctx->current_tx,
 8006d9a: 6fbb         	ldr	r3, [r7, #0x78]
 8006d9c: f103 0034    	add.w	r0, r3, #0x34
 8006da0: 6fbb         	ldr	r3, [r7, #0x78]
 8006da2: f103 0138    	add.w	r1, r3, #0x38
 8006da6: 6fbb         	ldr	r3, [r7, #0x78]
 8006da8: f103 0248    	add.w	r2, r3, #0x48
 8006dac: f897 3077    	ldrb.w	r3, [r7, #0x77]
 8006db0: f00b fa4b    	bl	0x801224a <spi_context_get_next_buf> @ imm = #0xb496
 8006db4: 4602         	mov	r2, r0
; 		ctx->tx_buf = (const uint8_t *)
 8006db6: 6fbb         	ldr	r3, [r7, #0x78]
 8006db8: 645a         	str	r2, [r3, #0x44]
 8006dba: e00d         	b	0x8006dd8 <spi_stm32_shift_s+0x128> @ imm = #0x1a
; 	} else if (ctx->tx_buf) {
 8006dbc: 6fbb         	ldr	r3, [r7, #0x78]
 8006dbe: 6c5b         	ldr	r3, [r3, #0x44]
 8006dc0: 2b00         	cmp	r3, #0x0
 8006dc2: d009         	beq	0x8006dd8 <spi_stm32_shift_s+0x128> @ imm = #0x12
; 		ctx->tx_buf += dfs * len;
 8006dc4: 6fbb         	ldr	r3, [r7, #0x78]
 8006dc6: 6c5a         	ldr	r2, [r3, #0x44]
 8006dc8: f897 3077    	ldrb.w	r3, [r7, #0x77]
 8006dcc: 6f39         	ldr	r1, [r7, #0x70]
 8006dce: fb01 f303    	mul	r3, r1, r3
 8006dd2: 441a         	add	r2, r3
 8006dd4: 6fbb         	ldr	r3, [r7, #0x78]
 8006dd6: 645a         	str	r2, [r3, #0x44]
; 	LOG_DBG("tx buf/len %p/%zu", (void *)ctx->tx_buf, ctx->tx_len);
 8006dd8: 2303         	movs	r3, #0x3
 8006dda: 2b03         	cmp	r3, #0x3
 8006ddc: f240 80bd    	bls.w	0x8006f5a <spi_stm32_shift_s+0x2aa> @ imm = #0x17a
 8006de0: 2301         	movs	r3, #0x1
 8006de2: f887 3067    	strb.w	r3, [r7, #0x67]
 8006de6: f897 3067    	ldrb.w	r3, [r7, #0x67]
 8006dea: f083 0301    	eor	r3, r3, #0x1
 8006dee: b2db         	uxtb	r3, r3
 8006df0: 2b00         	cmp	r3, #0x0
 8006df2: f040 80b2    	bne.w	0x8006f5a <spi_stm32_shift_s+0x2aa> @ imm = #0x164
 8006df6: 4b64         	ldr	r3, [pc, #0x190]        @ 0x8006f88 <spi_stm32_shift_s+0x2d8>
 8006df8: 6819         	ldr	r1, [r3]
 8006dfa: 6fbb         	ldr	r3, [r7, #0x78]
 8006dfc: 6c5b         	ldr	r3, [r3, #0x44]
 8006dfe: 6fba         	ldr	r2, [r7, #0x78]
 8006e00: 6c92         	ldr	r2, [r2, #0x48]
 8006e02: 9205         	str	r2, [sp, #0x14]
 8006e04: 9304         	str	r3, [sp, #0x10]
 8006e06: 4b62         	ldr	r3, [pc, #0x188]        @ 0x8006f90 <spi_stm32_shift_s+0x2e0>
 8006e08: 9303         	str	r3, [sp, #0xc]
 8006e0a: 4b62         	ldr	r3, [pc, #0x188]        @ 0x8006f94 <spi_stm32_shift_s+0x2e4>
 8006e0c: 9302         	str	r3, [sp, #0x8]
 8006e0e: 2308         	movs	r3, #0x8
 8006e10: 9301         	str	r3, [sp, #0x4]
 8006e12: 2300         	movs	r3, #0x0
 8006e14: 9300         	str	r3, [sp]
 8006e16: 2300         	movs	r3, #0x0
 8006e18: 2204         	movs	r2, #0x4
 8006e1a: 2000         	movs	r0, #0x0
 8006e1c: f00a fdaa    	bl	0x8011974 <z_log_msg_runtime_create> @ imm = #0xab54
 8006e20: 2300         	movs	r3, #0x0
 8006e22: 663b         	str	r3, [r7, #0x60]
; 	if (ll_func_tx_is_not_full(spi) && spi_context_tx_on(&data->ctx)) {
 8006e24: e09d         	b	0x8006f62 <spi_stm32_shift_s+0x2b2> @ imm = #0x13a
; 			tx_frame = UNALIGNED_GET((uint16_t *)(data->ctx.tx_buf));
 8006e26: 683b         	ldr	r3, [r7]
 8006e28: 6c5b         	ldr	r3, [r3, #0x44]
 8006e2a: f8c7 3094    	str.w	r3, [r7, #0x94]
 8006e2e: f8d7 3094    	ldr.w	r3, [r7, #0x94]
 8006e32: 881b         	ldrh	r3, [r3]
 8006e34: b29b         	uxth	r3, r3
 8006e36: f8a7 3092    	strh.w	r3, [r7, #0x92]
; 			LL_SPI_TransmitData16(spi, tx_frame);
 8006e3a: f8b7 3092    	ldrh.w	r3, [r7, #0x92]
 8006e3e: 4619         	mov	r1, r3
 8006e40: 6878         	ldr	r0, [r7, #0x4]
 8006e42: f00a ffa0    	bl	0x8011d86 <LL_SPI_TransmitData16> @ imm = #0xaf40
; 			spi_context_update_tx(&data->ctx, 2, 1);
 8006e46: 683b         	ldr	r3, [r7]
 8006e48: 65fb         	str	r3, [r7, #0x5c]
 8006e4a: 2302         	movs	r3, #0x2
 8006e4c: f887 305b    	strb.w	r3, [r7, #0x5b]
 8006e50: 2301         	movs	r3, #0x1
 8006e52: 657b         	str	r3, [r7, #0x54]
; 	if (!ctx->tx_len) {
 8006e54: 6dfb         	ldr	r3, [r7, #0x5c]
 8006e56: 6c9b         	ldr	r3, [r3, #0x48]
 8006e58: 2b00         	cmp	r3, #0x0
 8006e5a: d07d         	beq	0x8006f58 <spi_stm32_shift_s+0x2a8> @ imm = #0xfa
; 	if (len > ctx->tx_len) {
 8006e5c: 6dfb         	ldr	r3, [r7, #0x5c]
 8006e5e: 6c9b         	ldr	r3, [r3, #0x48]
 8006e60: 6d7a         	ldr	r2, [r7, #0x54]
 8006e62: 429a         	cmp	r2, r3
 8006e64: d91d         	bls	0x8006ea2 <spi_stm32_shift_s+0x1f2> @ imm = #0x3a
; 		LOG_ERR("Update exceeds current buffer");
 8006e66: 2303         	movs	r3, #0x3
 8006e68: 2b00         	cmp	r3, #0x0
 8006e6a: d019         	beq	0x8006ea0 <spi_stm32_shift_s+0x1f0> @ imm = #0x32
 8006e6c: 2301         	movs	r3, #0x1
 8006e6e: f887 3053    	strb.w	r3, [r7, #0x53]
 8006e72: f897 3053    	ldrb.w	r3, [r7, #0x53]
 8006e76: f083 0301    	eor	r3, r3, #0x1
 8006e7a: b2db         	uxtb	r3, r3
 8006e7c: 2b00         	cmp	r3, #0x0
 8006e7e: d10f         	bne	0x8006ea0 <spi_stm32_shift_s+0x1f0> @ imm = #0x1e
 8006e80: 4b41         	ldr	r3, [pc, #0x104]        @ 0x8006f88 <spi_stm32_shift_s+0x2d8>
 8006e82: 6819         	ldr	r1, [r3]
 8006e84: 4b41         	ldr	r3, [pc, #0x104]        @ 0x8006f8c <spi_stm32_shift_s+0x2dc>
 8006e86: 9302         	str	r3, [sp, #0x8]
 8006e88: 2300         	movs	r3, #0x0
 8006e8a: 9301         	str	r3, [sp, #0x4]
 8006e8c: 2300         	movs	r3, #0x0
 8006e8e: 9300         	str	r3, [sp]
 8006e90: 2300         	movs	r3, #0x0
 8006e92: 2201         	movs	r2, #0x1
 8006e94: 2000         	movs	r0, #0x0
 8006e96: f00a fd6d    	bl	0x8011974 <z_log_msg_runtime_create> @ imm = #0xaada
 8006e9a: 2300         	movs	r3, #0x0
 8006e9c: 64fb         	str	r3, [r7, #0x4c]
; 		return;
 8006e9e: e05c         	b	0x8006f5a <spi_stm32_shift_s+0x2aa> @ imm = #0xb8
 8006ea0: e05b         	b	0x8006f5a <spi_stm32_shift_s+0x2aa> @ imm = #0xb6
; 	ctx->tx_len -= len;
 8006ea2: 6dfb         	ldr	r3, [r7, #0x5c]
 8006ea4: 6c9a         	ldr	r2, [r3, #0x48]
 8006ea6: 6d7b         	ldr	r3, [r7, #0x54]
 8006ea8: 1ad2         	subs	r2, r2, r3
 8006eaa: 6dfb         	ldr	r3, [r7, #0x5c]
 8006eac: 649a         	str	r2, [r3, #0x48]
; 	if (!ctx->tx_len) {
 8006eae: 6dfb         	ldr	r3, [r7, #0x5c]
 8006eb0: 6c9b         	ldr	r3, [r3, #0x48]
 8006eb2: 2b00         	cmp	r3, #0x0
 8006eb4: d11b         	bne	0x8006eee <spi_stm32_shift_s+0x23e> @ imm = #0x36
; 		++ctx->current_tx;
 8006eb6: 6dfb         	ldr	r3, [r7, #0x5c]
 8006eb8: 6b5b         	ldr	r3, [r3, #0x34]
 8006eba: f103 0208    	add.w	r2, r3, #0x8
 8006ebe: 6dfb         	ldr	r3, [r7, #0x5c]
 8006ec0: 635a         	str	r2, [r3, #0x34]
; 		--ctx->tx_count;
 8006ec2: 6dfb         	ldr	r3, [r7, #0x5c]
 8006ec4: 6b9b         	ldr	r3, [r3, #0x38]
 8006ec6: 1e5a         	subs	r2, r3, #0x1
 8006ec8: 6dfb         	ldr	r3, [r7, #0x5c]
 8006eca: 639a         	str	r2, [r3, #0x38]
; 			spi_context_get_next_buf(&ctx->current_tx,
 8006ecc: 6dfb         	ldr	r3, [r7, #0x5c]
 8006ece: f103 0034    	add.w	r0, r3, #0x34
 8006ed2: 6dfb         	ldr	r3, [r7, #0x5c]
 8006ed4: f103 0138    	add.w	r1, r3, #0x38
 8006ed8: 6dfb         	ldr	r3, [r7, #0x5c]
 8006eda: f103 0248    	add.w	r2, r3, #0x48
 8006ede: f897 305b    	ldrb.w	r3, [r7, #0x5b]
 8006ee2: f00b f9b2    	bl	0x801224a <spi_context_get_next_buf> @ imm = #0xb364
 8006ee6: 4602         	mov	r2, r0
; 		ctx->tx_buf = (const uint8_t *)
 8006ee8: 6dfb         	ldr	r3, [r7, #0x5c]
 8006eea: 645a         	str	r2, [r3, #0x44]
 8006eec: e00d         	b	0x8006f0a <spi_stm32_shift_s+0x25a> @ imm = #0x1a
; 	} else if (ctx->tx_buf) {
 8006eee: 6dfb         	ldr	r3, [r7, #0x5c]
 8006ef0: 6c5b         	ldr	r3, [r3, #0x44]
 8006ef2: 2b00         	cmp	r3, #0x0
 8006ef4: d009         	beq	0x8006f0a <spi_stm32_shift_s+0x25a> @ imm = #0x12
; 		ctx->tx_buf += dfs * len;
 8006ef6: 6dfb         	ldr	r3, [r7, #0x5c]
 8006ef8: 6c5a         	ldr	r2, [r3, #0x44]
 8006efa: f897 305b    	ldrb.w	r3, [r7, #0x5b]
 8006efe: 6d79         	ldr	r1, [r7, #0x54]
 8006f00: fb01 f303    	mul	r3, r1, r3
 8006f04: 441a         	add	r2, r3
 8006f06: 6dfb         	ldr	r3, [r7, #0x5c]
 8006f08: 645a         	str	r2, [r3, #0x44]
; 	LOG_DBG("tx buf/len %p/%zu", (void *)ctx->tx_buf, ctx->tx_len);
 8006f0a: 2303         	movs	r3, #0x3
 8006f0c: 2b03         	cmp	r3, #0x3
 8006f0e: d924         	bls	0x8006f5a <spi_stm32_shift_s+0x2aa> @ imm = #0x48
 8006f10: 2301         	movs	r3, #0x1
 8006f12: f887 304b    	strb.w	r3, [r7, #0x4b]
 8006f16: f897 304b    	ldrb.w	r3, [r7, #0x4b]
 8006f1a: f083 0301    	eor	r3, r3, #0x1
 8006f1e: b2db         	uxtb	r3, r3
 8006f20: 2b00         	cmp	r3, #0x0
 8006f22: d11a         	bne	0x8006f5a <spi_stm32_shift_s+0x2aa> @ imm = #0x34
 8006f24: 4b18         	ldr	r3, [pc, #0x60]         @ 0x8006f88 <spi_stm32_shift_s+0x2d8>
 8006f26: 6819         	ldr	r1, [r3]
 8006f28: 6dfb         	ldr	r3, [r7, #0x5c]
 8006f2a: 6c5b         	ldr	r3, [r3, #0x44]
 8006f2c: 6dfa         	ldr	r2, [r7, #0x5c]
 8006f2e: 6c92         	ldr	r2, [r2, #0x48]
 8006f30: 9205         	str	r2, [sp, #0x14]
 8006f32: 9304         	str	r3, [sp, #0x10]
 8006f34: 4b16         	ldr	r3, [pc, #0x58]         @ 0x8006f90 <spi_stm32_shift_s+0x2e0>
 8006f36: 9303         	str	r3, [sp, #0xc]
 8006f38: 4b16         	ldr	r3, [pc, #0x58]         @ 0x8006f94 <spi_stm32_shift_s+0x2e4>
 8006f3a: 9302         	str	r3, [sp, #0x8]
 8006f3c: 2308         	movs	r3, #0x8
 8006f3e: 9301         	str	r3, [sp, #0x4]
 8006f40: 2300         	movs	r3, #0x0
 8006f42: 9300         	str	r3, [sp]
 8006f44: 2300         	movs	r3, #0x0
 8006f46: 2204         	movs	r2, #0x4
 8006f48: 2000         	movs	r0, #0x0
 8006f4a: f00a fd13    	bl	0x8011974 <z_log_msg_runtime_create> @ imm = #0xaa26
 8006f4e: 2300         	movs	r3, #0x0
 8006f50: 647b         	str	r3, [r7, #0x44]
; 	if (ll_func_tx_is_not_full(spi) && spi_context_tx_on(&data->ctx)) {
 8006f52: e006         	b	0x8006f62 <spi_stm32_shift_s+0x2b2> @ imm = #0xc
; 		return;
 8006f54: bf00         	nop
 8006f56: e004         	b	0x8006f62 <spi_stm32_shift_s+0x2b2> @ imm = #0x8
 8006f58: bf00         	nop
; 	if (ll_func_tx_is_not_full(spi) && spi_context_tx_on(&data->ctx)) {
 8006f5a: e002         	b	0x8006f62 <spi_stm32_shift_s+0x2b2> @ imm = #0x4
; 		ll_func_disable_int_tx_empty(spi);
 8006f5c: 6878         	ldr	r0, [r7, #0x4]
 8006f5e: f00b f9be    	bl	0x80122de <ll_func_disable_int_tx_empty> @ imm = #0xb37c
; 	if (ll_func_rx_is_not_empty(spi) &&
 8006f62: 6878         	ldr	r0, [r7, #0x4]
 8006f64: f00b f9af    	bl	0x80122c6 <ll_func_rx_is_not_empty> @ imm = #0xb35e
 8006f68: 4603         	mov	r3, r0
 8006f6a: 2b00         	cmp	r3, #0x0
 8006f6c: f000 8150    	beq.w	0x8007210 <spi_stm32_shift_s+0x560> @ imm = #0x2a0
; 	    spi_context_rx_buf_on(&data->ctx)) {
 8006f70: 683b         	ldr	r3, [r7]
 8006f72: 643b         	str	r3, [r7, #0x40]
; 	return !!(ctx->rx_buf && ctx->rx_len);
 8006f74: 6c3b         	ldr	r3, [r7, #0x40]
 8006f76: 6cdb         	ldr	r3, [r3, #0x4c]
 8006f78: 2b00         	cmp	r3, #0x0
 8006f7a: d00d         	beq	0x8006f98 <spi_stm32_shift_s+0x2e8> @ imm = #0x1a
 8006f7c: 6c3b         	ldr	r3, [r7, #0x40]
 8006f7e: 6d1b         	ldr	r3, [r3, #0x50]
 8006f80: 2b00         	cmp	r3, #0x0
 8006f82: d009         	beq	0x8006f98 <spi_stm32_shift_s+0x2e8> @ imm = #0x12
 8006f84: 2301         	movs	r3, #0x1
 8006f86: e008         	b	0x8006f9a <spi_stm32_shift_s+0x2ea> @ imm = #0x10

08006f88 <$d>:
 8006f88: 70 00 00 20  	.word	0x20000070
 8006f8c: 10 59 01 08  	.word	0x08015910
 8006f90: 68 66 01 08  	.word	0x08016668
 8006f94: 30 59 01 08  	.word	0x08015930

08006f98 <$t>:
 8006f98: 2300         	movs	r3, #0x0
 8006f9a: f003 0301    	and	r3, r3, #0x1
 8006f9e: b2db         	uxtb	r3, r3
; 	if (ll_func_rx_is_not_empty(spi) &&
 8006fa0: 2b00         	cmp	r3, #0x0
 8006fa2: f000 8135    	beq.w	0x8007210 <spi_stm32_shift_s+0x560> @ imm = #0x26a
; 		if (SPI_WORD_SIZE_GET(data->ctx.config->operation) == 8) {
 8006fa6: 683b         	ldr	r3, [r7]
 8006fa8: 681b         	ldr	r3, [r3]
 8006faa: 889b         	ldrh	r3, [r3, #0x4]
 8006fac: 095b         	lsrs	r3, r3, #0x5
 8006fae: f003 033f    	and	r3, r3, #0x3f
 8006fb2: 2b08         	cmp	r3, #0x8
 8006fb4: f040 809a    	bne.w	0x80070ec <spi_stm32_shift_s+0x43c> @ imm = #0x134
; 			rx_frame = LL_SPI_ReceiveData8(spi);
 8006fb8: 6878         	ldr	r0, [r7, #0x4]
 8006fba: f00a feba    	bl	0x8011d32 <LL_SPI_ReceiveData8> @ imm = #0xad74
 8006fbe: 4603         	mov	r3, r0
 8006fc0: f8a7 308a    	strh.w	r3, [r7, #0x8a]
; 			UNALIGNED_PUT(rx_frame, (uint8_t *)data->ctx.rx_buf);
 8006fc4: 683b         	ldr	r3, [r7]
 8006fc6: 6cdb         	ldr	r3, [r3, #0x4c]
 8006fc8: f8c7 3080    	str.w	r3, [r7, #0x80]
 8006fcc: f8b7 308a    	ldrh.w	r3, [r7, #0x8a]
 8006fd0: b2da         	uxtb	r2, r3
 8006fd2: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 8006fd6: 701a         	strb	r2, [r3]
; 			spi_context_update_rx(&data->ctx, 1, 1);
 8006fd8: 683b         	ldr	r3, [r7]
 8006fda: 63fb         	str	r3, [r7, #0x3c]
 8006fdc: 2301         	movs	r3, #0x1
 8006fde: f887 303b    	strb.w	r3, [r7, #0x3b]
 8006fe2: 2301         	movs	r3, #0x1
 8006fe4: 637b         	str	r3, [r7, #0x34]
; 	if (!ctx->rx_len) {
 8006fe6: 6bfb         	ldr	r3, [r7, #0x3c]
 8006fe8: 6d1b         	ldr	r3, [r3, #0x50]
 8006fea: 2b00         	cmp	r3, #0x0
 8006fec: f000 810d    	beq.w	0x800720a <spi_stm32_shift_s+0x55a> @ imm = #0x21a
; 	if (len > ctx->rx_len) {
 8006ff0: 6bfb         	ldr	r3, [r7, #0x3c]
 8006ff2: 6d1b         	ldr	r3, [r3, #0x50]
 8006ff4: 6b7a         	ldr	r2, [r7, #0x34]
 8006ff6: 429a         	cmp	r2, r3
 8006ff8: d91d         	bls	0x8007036 <spi_stm32_shift_s+0x386> @ imm = #0x3a
; 		LOG_ERR("Update exceeds current buffer");
 8006ffa: 2303         	movs	r3, #0x3
 8006ffc: 2b00         	cmp	r3, #0x0
 8006ffe: d019         	beq	0x8007034 <spi_stm32_shift_s+0x384> @ imm = #0x32
 8007000: 2301         	movs	r3, #0x1
 8007002: f887 3033    	strb.w	r3, [r7, #0x33]
 8007006: f897 3033    	ldrb.w	r3, [r7, #0x33]
 800700a: f083 0301    	eor	r3, r3, #0x1
 800700e: b2db         	uxtb	r3, r3
 8007010: 2b00         	cmp	r3, #0x0
 8007012: d10f         	bne	0x8007034 <spi_stm32_shift_s+0x384> @ imm = #0x1e
 8007014: 4b80         	ldr	r3, [pc, #0x200]        @ 0x8007218 <spi_stm32_shift_s+0x568>
 8007016: 6819         	ldr	r1, [r3]
 8007018: 4b80         	ldr	r3, [pc, #0x200]        @ 0x800721c <spi_stm32_shift_s+0x56c>
 800701a: 9302         	str	r3, [sp, #0x8]
 800701c: 2300         	movs	r3, #0x0
 800701e: 9301         	str	r3, [sp, #0x4]
 8007020: 2300         	movs	r3, #0x0
 8007022: 9300         	str	r3, [sp]
 8007024: 2300         	movs	r3, #0x0
 8007026: 2201         	movs	r2, #0x1
 8007028: 2000         	movs	r0, #0x0
 800702a: f00a fca3    	bl	0x8011974 <z_log_msg_runtime_create> @ imm = #0xa946
 800702e: 2300         	movs	r3, #0x0
 8007030: 62fb         	str	r3, [r7, #0x2c]
; 		return;
 8007032: e0ed         	b	0x8007210 <spi_stm32_shift_s+0x560> @ imm = #0x1da
 8007034: e0ec         	b	0x8007210 <spi_stm32_shift_s+0x560> @ imm = #0x1d8
; 	ctx->rx_len -= len;
 8007036: 6bfb         	ldr	r3, [r7, #0x3c]
 8007038: 6d1a         	ldr	r2, [r3, #0x50]
 800703a: 6b7b         	ldr	r3, [r7, #0x34]
 800703c: 1ad2         	subs	r2, r2, r3
 800703e: 6bfb         	ldr	r3, [r7, #0x3c]
 8007040: 651a         	str	r2, [r3, #0x50]
; 	if (!ctx->rx_len) {
 8007042: 6bfb         	ldr	r3, [r7, #0x3c]
 8007044: 6d1b         	ldr	r3, [r3, #0x50]
 8007046: 2b00         	cmp	r3, #0x0
 8007048: d11b         	bne	0x8007082 <spi_stm32_shift_s+0x3d2> @ imm = #0x36
; 		++ctx->current_rx;
 800704a: 6bfb         	ldr	r3, [r7, #0x3c]
 800704c: 6bdb         	ldr	r3, [r3, #0x3c]
 800704e: f103 0208    	add.w	r2, r3, #0x8
 8007052: 6bfb         	ldr	r3, [r7, #0x3c]
 8007054: 63da         	str	r2, [r3, #0x3c]
; 		--ctx->rx_count;
 8007056: 6bfb         	ldr	r3, [r7, #0x3c]
 8007058: 6c1b         	ldr	r3, [r3, #0x40]
 800705a: 1e5a         	subs	r2, r3, #0x1
 800705c: 6bfb         	ldr	r3, [r7, #0x3c]
 800705e: 641a         	str	r2, [r3, #0x40]
; 			spi_context_get_next_buf(&ctx->current_rx,
 8007060: 6bfb         	ldr	r3, [r7, #0x3c]
 8007062: f103 003c    	add.w	r0, r3, #0x3c
 8007066: 6bfb         	ldr	r3, [r7, #0x3c]
 8007068: f103 0140    	add.w	r1, r3, #0x40
 800706c: 6bfb         	ldr	r3, [r7, #0x3c]
 800706e: f103 0250    	add.w	r2, r3, #0x50
 8007072: f897 303b    	ldrb.w	r3, [r7, #0x3b]
 8007076: f00b f8e8    	bl	0x801224a <spi_context_get_next_buf> @ imm = #0xb1d0
 800707a: 4602         	mov	r2, r0
; 		ctx->rx_buf = (uint8_t *)
 800707c: 6bfb         	ldr	r3, [r7, #0x3c]
 800707e: 64da         	str	r2, [r3, #0x4c]
 8007080: e00d         	b	0x800709e <spi_stm32_shift_s+0x3ee> @ imm = #0x1a
; 	} else if (ctx->rx_buf) {
 8007082: 6bfb         	ldr	r3, [r7, #0x3c]
 8007084: 6cdb         	ldr	r3, [r3, #0x4c]
 8007086: 2b00         	cmp	r3, #0x0
 8007088: d009         	beq	0x800709e <spi_stm32_shift_s+0x3ee> @ imm = #0x12
; 		ctx->rx_buf += dfs * len;
 800708a: 6bfb         	ldr	r3, [r7, #0x3c]
 800708c: 6cda         	ldr	r2, [r3, #0x4c]
 800708e: f897 303b    	ldrb.w	r3, [r7, #0x3b]
 8007092: 6b79         	ldr	r1, [r7, #0x34]
 8007094: fb01 f303    	mul	r3, r1, r3
 8007098: 441a         	add	r2, r3
 800709a: 6bfb         	ldr	r3, [r7, #0x3c]
 800709c: 64da         	str	r2, [r3, #0x4c]
; 	LOG_DBG("rx buf/len %p/%zu", (void *)ctx->rx_buf, ctx->rx_len);
 800709e: 2303         	movs	r3, #0x3
 80070a0: 2b03         	cmp	r3, #0x3
 80070a2: f240 80b5    	bls.w	0x8007210 <spi_stm32_shift_s+0x560> @ imm = #0x16a
 80070a6: 2301         	movs	r3, #0x1
 80070a8: f887 302b    	strb.w	r3, [r7, #0x2b]
 80070ac: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 80070b0: f083 0301    	eor	r3, r3, #0x1
 80070b4: b2db         	uxtb	r3, r3
 80070b6: 2b00         	cmp	r3, #0x0
 80070b8: f040 80aa    	bne.w	0x8007210 <spi_stm32_shift_s+0x560> @ imm = #0x154
 80070bc: 4b56         	ldr	r3, [pc, #0x158]        @ 0x8007218 <spi_stm32_shift_s+0x568>
 80070be: 6819         	ldr	r1, [r3]
 80070c0: 6bfb         	ldr	r3, [r7, #0x3c]
 80070c2: 6cdb         	ldr	r3, [r3, #0x4c]
 80070c4: 6bfa         	ldr	r2, [r7, #0x3c]
 80070c6: 6d12         	ldr	r2, [r2, #0x50]
 80070c8: 9205         	str	r2, [sp, #0x14]
 80070ca: 9304         	str	r3, [sp, #0x10]
 80070cc: 4b54         	ldr	r3, [pc, #0x150]        @ 0x8007220 <spi_stm32_shift_s+0x570>
 80070ce: 9303         	str	r3, [sp, #0xc]
 80070d0: 4b54         	ldr	r3, [pc, #0x150]        @ 0x8007224 <spi_stm32_shift_s+0x574>
 80070d2: 9302         	str	r3, [sp, #0x8]
 80070d4: 2308         	movs	r3, #0x8
 80070d6: 9301         	str	r3, [sp, #0x4]
 80070d8: 2300         	movs	r3, #0x0
 80070da: 9300         	str	r3, [sp]
 80070dc: 2300         	movs	r3, #0x0
 80070de: 2204         	movs	r2, #0x4
 80070e0: 2000         	movs	r0, #0x0
 80070e2: f00a fc47    	bl	0x8011974 <z_log_msg_runtime_create> @ imm = #0xa88e
 80070e6: 2300         	movs	r3, #0x0
 80070e8: 627b         	str	r3, [r7, #0x24]
; }
 80070ea: e091         	b	0x8007210 <spi_stm32_shift_s+0x560> @ imm = #0x122
; 			rx_frame = LL_SPI_ReceiveData16(spi);
 80070ec: 6878         	ldr	r0, [r7, #0x4]
 80070ee: f00a fe2d    	bl	0x8011d4c <LL_SPI_ReceiveData16> @ imm = #0xac5a
 80070f2: 4603         	mov	r3, r0
 80070f4: f8a7 308a    	strh.w	r3, [r7, #0x8a]
; 			UNALIGNED_PUT(rx_frame, (uint16_t *)data->ctx.rx_buf);
 80070f8: 683b         	ldr	r3, [r7]
 80070fa: 6cdb         	ldr	r3, [r3, #0x4c]
 80070fc: f8c7 3084    	str.w	r3, [r7, #0x84]
 8007100: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 8007104: f8b7 208a    	ldrh.w	r2, [r7, #0x8a]
 8007108: 801a         	strh	r2, [r3]
; 			spi_context_update_rx(&data->ctx, 2, 1);
 800710a: 683b         	ldr	r3, [r7]
 800710c: 623b         	str	r3, [r7, #0x20]
 800710e: 2302         	movs	r3, #0x2
 8007110: 77fb         	strb	r3, [r7, #0x1f]
 8007112: 2301         	movs	r3, #0x1
 8007114: 61bb         	str	r3, [r7, #0x18]
; 	if (!ctx->rx_len) {
 8007116: 6a3b         	ldr	r3, [r7, #0x20]
 8007118: 6d1b         	ldr	r3, [r3, #0x50]
 800711a: 2b00         	cmp	r3, #0x0
 800711c: d077         	beq	0x800720e <spi_stm32_shift_s+0x55e> @ imm = #0xee
; 	if (len > ctx->rx_len) {
 800711e: 6a3b         	ldr	r3, [r7, #0x20]
 8007120: 6d1b         	ldr	r3, [r3, #0x50]
 8007122: 69ba         	ldr	r2, [r7, #0x18]
 8007124: 429a         	cmp	r2, r3
 8007126: d91b         	bls	0x8007160 <spi_stm32_shift_s+0x4b0> @ imm = #0x36
; 		LOG_ERR("Update exceeds current buffer");
 8007128: 2303         	movs	r3, #0x3
 800712a: 2b00         	cmp	r3, #0x0
 800712c: d017         	beq	0x800715e <spi_stm32_shift_s+0x4ae> @ imm = #0x2e
 800712e: 2301         	movs	r3, #0x1
 8007130: 75fb         	strb	r3, [r7, #0x17]
 8007132: 7dfb         	ldrb	r3, [r7, #0x17]
 8007134: f083 0301    	eor	r3, r3, #0x1
 8007138: b2db         	uxtb	r3, r3
 800713a: 2b00         	cmp	r3, #0x0
 800713c: d10f         	bne	0x800715e <spi_stm32_shift_s+0x4ae> @ imm = #0x1e
 800713e: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x8007218 <spi_stm32_shift_s+0x568>
 8007140: 6819         	ldr	r1, [r3]
 8007142: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x800721c <spi_stm32_shift_s+0x56c>
 8007144: 9302         	str	r3, [sp, #0x8]
 8007146: 2300         	movs	r3, #0x0
 8007148: 9301         	str	r3, [sp, #0x4]
 800714a: 2300         	movs	r3, #0x0
 800714c: 9300         	str	r3, [sp]
 800714e: 2300         	movs	r3, #0x0
 8007150: 2201         	movs	r2, #0x1
 8007152: 2000         	movs	r0, #0x0
 8007154: f00a fc0e    	bl	0x8011974 <z_log_msg_runtime_create> @ imm = #0xa81c
 8007158: 2300         	movs	r3, #0x0
 800715a: 613b         	str	r3, [r7, #0x10]
; 		return;
 800715c: e058         	b	0x8007210 <spi_stm32_shift_s+0x560> @ imm = #0xb0
 800715e: e057         	b	0x8007210 <spi_stm32_shift_s+0x560> @ imm = #0xae
; 	ctx->rx_len -= len;
 8007160: 6a3b         	ldr	r3, [r7, #0x20]
 8007162: 6d1a         	ldr	r2, [r3, #0x50]
 8007164: 69bb         	ldr	r3, [r7, #0x18]
 8007166: 1ad2         	subs	r2, r2, r3
 8007168: 6a3b         	ldr	r3, [r7, #0x20]
 800716a: 651a         	str	r2, [r3, #0x50]
; 	if (!ctx->rx_len) {
 800716c: 6a3b         	ldr	r3, [r7, #0x20]
 800716e: 6d1b         	ldr	r3, [r3, #0x50]
 8007170: 2b00         	cmp	r3, #0x0
 8007172: d11a         	bne	0x80071aa <spi_stm32_shift_s+0x4fa> @ imm = #0x34
; 		++ctx->current_rx;
 8007174: 6a3b         	ldr	r3, [r7, #0x20]
 8007176: 6bdb         	ldr	r3, [r3, #0x3c]
 8007178: f103 0208    	add.w	r2, r3, #0x8
 800717c: 6a3b         	ldr	r3, [r7, #0x20]
 800717e: 63da         	str	r2, [r3, #0x3c]
; 		--ctx->rx_count;
 8007180: 6a3b         	ldr	r3, [r7, #0x20]
 8007182: 6c1b         	ldr	r3, [r3, #0x40]
 8007184: 1e5a         	subs	r2, r3, #0x1
 8007186: 6a3b         	ldr	r3, [r7, #0x20]
 8007188: 641a         	str	r2, [r3, #0x40]
; 			spi_context_get_next_buf(&ctx->current_rx,
 800718a: 6a3b         	ldr	r3, [r7, #0x20]
 800718c: f103 003c    	add.w	r0, r3, #0x3c
 8007190: 6a3b         	ldr	r3, [r7, #0x20]
 8007192: f103 0140    	add.w	r1, r3, #0x40
 8007196: 6a3b         	ldr	r3, [r7, #0x20]
 8007198: f103 0250    	add.w	r2, r3, #0x50
 800719c: 7ffb         	ldrb	r3, [r7, #0x1f]
 800719e: f00b f854    	bl	0x801224a <spi_context_get_next_buf> @ imm = #0xb0a8
 80071a2: 4602         	mov	r2, r0
; 		ctx->rx_buf = (uint8_t *)
 80071a4: 6a3b         	ldr	r3, [r7, #0x20]
 80071a6: 64da         	str	r2, [r3, #0x4c]
 80071a8: e00c         	b	0x80071c4 <spi_stm32_shift_s+0x514> @ imm = #0x18
; 	} else if (ctx->rx_buf) {
 80071aa: 6a3b         	ldr	r3, [r7, #0x20]
 80071ac: 6cdb         	ldr	r3, [r3, #0x4c]
 80071ae: 2b00         	cmp	r3, #0x0
 80071b0: d008         	beq	0x80071c4 <spi_stm32_shift_s+0x514> @ imm = #0x10
; 		ctx->rx_buf += dfs * len;
 80071b2: 6a3b         	ldr	r3, [r7, #0x20]
 80071b4: 6cda         	ldr	r2, [r3, #0x4c]
 80071b6: 7ffb         	ldrb	r3, [r7, #0x1f]
 80071b8: 69b9         	ldr	r1, [r7, #0x18]
 80071ba: fb01 f303    	mul	r3, r1, r3
 80071be: 441a         	add	r2, r3
 80071c0: 6a3b         	ldr	r3, [r7, #0x20]
 80071c2: 64da         	str	r2, [r3, #0x4c]
; 	LOG_DBG("rx buf/len %p/%zu", (void *)ctx->rx_buf, ctx->rx_len);
 80071c4: 2303         	movs	r3, #0x3
 80071c6: 2b03         	cmp	r3, #0x3
 80071c8: d922         	bls	0x8007210 <spi_stm32_shift_s+0x560> @ imm = #0x44
 80071ca: 2301         	movs	r3, #0x1
 80071cc: 73fb         	strb	r3, [r7, #0xf]
 80071ce: 7bfb         	ldrb	r3, [r7, #0xf]
 80071d0: f083 0301    	eor	r3, r3, #0x1
 80071d4: b2db         	uxtb	r3, r3
 80071d6: 2b00         	cmp	r3, #0x0
 80071d8: d11a         	bne	0x8007210 <spi_stm32_shift_s+0x560> @ imm = #0x34
 80071da: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x8007218 <spi_stm32_shift_s+0x568>
 80071dc: 6819         	ldr	r1, [r3]
 80071de: 6a3b         	ldr	r3, [r7, #0x20]
 80071e0: 6cdb         	ldr	r3, [r3, #0x4c]
 80071e2: 6a3a         	ldr	r2, [r7, #0x20]
 80071e4: 6d12         	ldr	r2, [r2, #0x50]
 80071e6: 9205         	str	r2, [sp, #0x14]
 80071e8: 9304         	str	r3, [sp, #0x10]
 80071ea: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8007220 <spi_stm32_shift_s+0x570>
 80071ec: 9303         	str	r3, [sp, #0xc]
 80071ee: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8007224 <spi_stm32_shift_s+0x574>
 80071f0: 9302         	str	r3, [sp, #0x8]
 80071f2: 2308         	movs	r3, #0x8
 80071f4: 9301         	str	r3, [sp, #0x4]
 80071f6: 2300         	movs	r3, #0x0
 80071f8: 9300         	str	r3, [sp]
 80071fa: 2300         	movs	r3, #0x0
 80071fc: 2204         	movs	r2, #0x4
 80071fe: 2000         	movs	r0, #0x0
 8007200: f00a fbb8    	bl	0x8011974 <z_log_msg_runtime_create> @ imm = #0xa770
 8007204: 2300         	movs	r3, #0x0
 8007206: 60bb         	str	r3, [r7, #0x8]
; }
 8007208: e002         	b	0x8007210 <spi_stm32_shift_s+0x560> @ imm = #0x4
; 		return;
 800720a: bf00         	nop
 800720c: e000         	b	0x8007210 <spi_stm32_shift_s+0x560> @ imm = #0x0
 800720e: bf00         	nop
; }
 8007210: bf00         	nop
 8007212: 3798         	adds	r7, #0x98
 8007214: 46bd         	mov	sp, r7
 8007216: bd80         	pop	{r7, pc}

08007218 <$d>:
 8007218: 70 00 00 20  	.word	0x20000070
 800721c: 10 59 01 08  	.word	0x08015910
 8007220: 80 66 01 08  	.word	0x08016680
 8007224: 48 59 01 08  	.word	0x08015948

08007228 <spi_stm32_configure>:
; {
 8007228: b5f0         	push	{r4, r5, r6, r7, lr}
 800722a: b0a3         	sub	sp, #0x8c
 800722c: af0c         	add	r7, sp, #0x30
 800722e: 6078         	str	r0, [r7, #0x4]
 8007230: 6039         	str	r1, [r7]
; 	const struct spi_stm32_config *cfg = dev->config;
 8007232: 687b         	ldr	r3, [r7, #0x4]
 8007234: 685b         	ldr	r3, [r3, #0x4]
 8007236: 63bb         	str	r3, [r7, #0x38]
; 	struct spi_stm32_data *data = dev->data;
 8007238: 687b         	ldr	r3, [r7, #0x4]
 800723a: 691b         	ldr	r3, [r3, #0x10]
 800723c: 637b         	str	r3, [r7, #0x34]
; 	const uint32_t scaler[] = {
 800723e: 4b8d         	ldr	r3, [pc, #0x234]        @ 0x8007474 <spi_stm32_configure+0x24c>
 8007240: f107 0410    	add.w	r4, r7, #0x10
 8007244: 461d         	mov	r5, r3
 8007246: cd0f         	ldm	r5!, {r0, r1, r2, r3}
 8007248: c40f         	stm	r4!, {r0, r1, r2, r3}
 800724a: e895 000f    	ldm.w	r5, {r0, r1, r2, r3}
 800724e: e884 000f    	stm.w	r4, {r0, r1, r2, r3}
; 	SPI_TypeDef *spi = cfg->spi;
 8007252: 6bbb         	ldr	r3, [r7, #0x38]
 8007254: 681b         	ldr	r3, [r3]
 8007256: 633b         	str	r3, [r7, #0x30]
; 	if (spi_context_configured(&data->ctx, config)) {
 8007258: 6b7b         	ldr	r3, [r7, #0x34]
 800725a: 6839         	ldr	r1, [r7]
 800725c: 4618         	mov	r0, r3
 800725e: f00a ff2d    	bl	0x80120bc <spi_context_configured> @ imm = #0xae5a
 8007262: 4603         	mov	r3, r0
 8007264: 2b00         	cmp	r3, #0x0
 8007266: d001         	beq	0x800726c <spi_stm32_configure+0x44> @ imm = #0x2
; 		return 0;
 8007268: 2300         	movs	r3, #0x0
 800726a: e156         	b	0x800751a <spi_stm32_configure+0x2f2> @ imm = #0x2ac
; 	if ((SPI_WORD_SIZE_GET(config->operation) != 8)
 800726c: 683b         	ldr	r3, [r7]
 800726e: 889b         	ldrh	r3, [r3, #0x4]
 8007270: 095b         	lsrs	r3, r3, #0x5
 8007272: f003 033f    	and	r3, r3, #0x3f
 8007276: 2b08         	cmp	r3, #0x8
 8007278: d009         	beq	0x800728e <spi_stm32_configure+0x66> @ imm = #0x12
; 	    && (SPI_WORD_SIZE_GET(config->operation) != 16)) {
 800727a: 683b         	ldr	r3, [r7]
 800727c: 889b         	ldrh	r3, [r3, #0x4]
 800727e: 095b         	lsrs	r3, r3, #0x5
 8007280: f003 033f    	and	r3, r3, #0x3f
 8007284: 2b10         	cmp	r3, #0x10
 8007286: d002         	beq	0x800728e <spi_stm32_configure+0x66> @ imm = #0x4
; 		return -ENOTSUP;
 8007288: f06f 0385    	mvn	r3, #0x85
 800728c: e145         	b	0x800751a <spi_stm32_configure+0x2f2> @ imm = #0x28a
; 	if ((config->operation & SPI_FRAME_FORMAT_TI) == SPI_FRAME_FORMAT_TI) {
 800728e: 683b         	ldr	r3, [r7]
 8007290: 889b         	ldrh	r3, [r3, #0x4]
 8007292: b21b         	sxth	r3, r3
 8007294: 2b00         	cmp	r3, #0x0
 8007296: da04         	bge	0x80072a2 <spi_stm32_configure+0x7a> @ imm = #0x8
; 		LL_SPI_SetStandard(spi, LL_SPI_PROTOCOL_TI);
 8007298: 2110         	movs	r1, #0x10
 800729a: 6b38         	ldr	r0, [r7, #0x30]
 800729c: f00a fc14    	bl	0x8011ac8 <LL_SPI_SetStandard> @ imm = #0xa828
 80072a0: e003         	b	0x80072aa <spi_stm32_configure+0x82> @ imm = #0x6
; 		LL_SPI_SetStandard(spi, LL_SPI_PROTOCOL_MOTOROLA);
 80072a2: 2100         	movs	r1, #0x0
 80072a4: 6b38         	ldr	r0, [r7, #0x30]
 80072a6: f00a fc0f    	bl	0x8011ac8 <LL_SPI_SetStandard> @ imm = #0xa81e
; 					   (clock_control_subsys_t) &cfg->pclken[0], &clock) < 0) {
 80072aa: 6bbb         	ldr	r3, [r7, #0x38]
 80072ac: 68db         	ldr	r3, [r3, #0xc]
; 		if (clock_control_get_rate(DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE),
 80072ae: f107 020c    	add.w	r2, r7, #0xc
 80072b2: 4619         	mov	r1, r3
 80072b4: 4870         	ldr	r0, [pc, #0x1c0]        @ 0x8007478 <spi_stm32_configure+0x250>
 80072b6: f00a fee6    	bl	0x8012086 <clock_control_get_rate> @ imm = #0xadcc
 80072ba: 4603         	mov	r3, r0
 80072bc: 2b00         	cmp	r3, #0x0
 80072be: da1e         	bge	0x80072fe <spi_stm32_configure+0xd6> @ imm = #0x3c
; 			LOG_ERR("Failed call clock_control_get_rate(pclk[0])");
 80072c0: 2303         	movs	r3, #0x3
 80072c2: 2b00         	cmp	r3, #0x0
 80072c4: d018         	beq	0x80072f8 <spi_stm32_configure+0xd0> @ imm = #0x30
 80072c6: 2301         	movs	r3, #0x1
 80072c8: f887 3053    	strb.w	r3, [r7, #0x53]
 80072cc: f897 3053    	ldrb.w	r3, [r7, #0x53]
 80072d0: f083 0301    	eor	r3, r3, #0x1
 80072d4: b2db         	uxtb	r3, r3
 80072d6: 2b00         	cmp	r3, #0x0
 80072d8: d10e         	bne	0x80072f8 <spi_stm32_configure+0xd0> @ imm = #0x1c
 80072da: 4b68         	ldr	r3, [pc, #0x1a0]        @ 0x800747c <spi_stm32_configure+0x254>
 80072dc: 6819         	ldr	r1, [r3]
 80072de: 4b68         	ldr	r3, [pc, #0x1a0]        @ 0x8007480 <spi_stm32_configure+0x258>
 80072e0: 9302         	str	r3, [sp, #0x8]
 80072e2: 2300         	movs	r3, #0x0
 80072e4: 9301         	str	r3, [sp, #0x4]
 80072e6: 2300         	movs	r3, #0x0
 80072e8: 9300         	str	r3, [sp]
 80072ea: 2300         	movs	r3, #0x0
 80072ec: 2201         	movs	r2, #0x1
 80072ee: 2000         	movs	r0, #0x0
 80072f0: f00a fb40    	bl	0x8011974 <z_log_msg_runtime_create> @ imm = #0xa680
 80072f4: 2300         	movs	r3, #0x0
 80072f6: 657b         	str	r3, [r7, #0x54]
; 			return -EIO;
 80072f8: f06f 0304    	mvn	r3, #0x4
 80072fc: e10d         	b	0x800751a <spi_stm32_configure+0x2f2> @ imm = #0x21a
; 	for (br = 1 ; br <= ARRAY_SIZE(scaler) ; ++br) {
 80072fe: 2301         	movs	r3, #0x1
 8007300: 643b         	str	r3, [r7, #0x40]
 8007302: e00c         	b	0x800731e <spi_stm32_configure+0xf6> @ imm = #0x18
; 		uint32_t clk = clock >> br;
 8007304: 68fa         	ldr	r2, [r7, #0xc]
 8007306: 6c3b         	ldr	r3, [r7, #0x40]
 8007308: fa22 f303    	lsr.w	r3, r2, r3
 800730c: 63fb         	str	r3, [r7, #0x3c]
; 		if (clk <= config->frequency) {
 800730e: 683b         	ldr	r3, [r7]
 8007310: 681b         	ldr	r3, [r3]
 8007312: 6bfa         	ldr	r2, [r7, #0x3c]
 8007314: 429a         	cmp	r2, r3
 8007316: d906         	bls	0x8007326 <spi_stm32_configure+0xfe> @ imm = #0xc
; 	for (br = 1 ; br <= ARRAY_SIZE(scaler) ; ++br) {
 8007318: 6c3b         	ldr	r3, [r7, #0x40]
 800731a: 3301         	adds	r3, #0x1
 800731c: 643b         	str	r3, [r7, #0x40]
 800731e: 6c3b         	ldr	r3, [r7, #0x40]
 8007320: 2b08         	cmp	r3, #0x8
 8007322: d9ef         	bls	0x8007304 <spi_stm32_configure+0xdc> @ imm = #-0x22
 8007324: e000         	b	0x8007328 <spi_stm32_configure+0x100> @ imm = #0x0
; 			break;
 8007326: bf00         	nop
; 	if (br > ARRAY_SIZE(scaler)) {
 8007328: 6c3b         	ldr	r3, [r7, #0x40]
 800732a: 2b08         	cmp	r3, #0x8
 800732c: d928         	bls	0x8007380 <spi_stm32_configure+0x158> @ imm = #0x50
; 		LOG_ERR("Unsupported frequency %uHz, max %uHz, min %uHz",
 800732e: 2303         	movs	r3, #0x3
 8007330: 2b00         	cmp	r3, #0x0
 8007332: d022         	beq	0x800737a <spi_stm32_configure+0x152> @ imm = #0x44
 8007334: 2301         	movs	r3, #0x1
 8007336: f887 304b    	strb.w	r3, [r7, #0x4b]
 800733a: f897 304b    	ldrb.w	r3, [r7, #0x4b]
 800733e: f083 0301    	eor	r3, r3, #0x1
 8007342: b2db         	uxtb	r3, r3
 8007344: 2b00         	cmp	r3, #0x0
 8007346: d118         	bne	0x800737a <spi_stm32_configure+0x152> @ imm = #0x30
 8007348: 4b4c         	ldr	r3, [pc, #0x130]        @ 0x800747c <spi_stm32_configure+0x254>
 800734a: 6818         	ldr	r0, [r3]
 800734c: 683b         	ldr	r3, [r7]
 800734e: 681b         	ldr	r3, [r3]
 8007350: 68fa         	ldr	r2, [r7, #0xc]
 8007352: 0852         	lsrs	r2, r2, #0x1
 8007354: 68f9         	ldr	r1, [r7, #0xc]
 8007356: 0a09         	lsrs	r1, r1, #0x8
 8007358: 9105         	str	r1, [sp, #0x14]
 800735a: 9204         	str	r2, [sp, #0x10]
 800735c: 9303         	str	r3, [sp, #0xc]
 800735e: 4b49         	ldr	r3, [pc, #0x124]        @ 0x8007484 <spi_stm32_configure+0x25c>
 8007360: 9302         	str	r3, [sp, #0x8]
 8007362: 2300         	movs	r3, #0x0
 8007364: 9301         	str	r3, [sp, #0x4]
 8007366: 2300         	movs	r3, #0x0
 8007368: 9300         	str	r3, [sp]
 800736a: 2300         	movs	r3, #0x0
 800736c: 2201         	movs	r2, #0x1
 800736e: 4601         	mov	r1, r0
 8007370: 2000         	movs	r0, #0x0
 8007372: f00a faff    	bl	0x8011974 <z_log_msg_runtime_create> @ imm = #0xa5fe
 8007376: 2300         	movs	r3, #0x0
 8007378: 647b         	str	r3, [r7, #0x44]
; 		return -EINVAL;
 800737a: f06f 0315    	mvn	r3, #0x15
 800737e: e0cc         	b	0x800751a <spi_stm32_configure+0x2f2> @ imm = #0x198
; 	LL_SPI_Disable(spi);
 8007380: 6b38         	ldr	r0, [r7, #0x30]
 8007382: f00a fb61    	bl	0x8011a48 <LL_SPI_Disable> @ imm = #0xa6c2
; 	LL_SPI_SetBaudRatePrescaler(spi, scaler[br - 1]);
 8007386: 6c3b         	ldr	r3, [r7, #0x40]
 8007388: 3b01         	subs	r3, #0x1
 800738a: 009b         	lsls	r3, r3, #0x2
 800738c: 3358         	adds	r3, #0x58
 800738e: 443b         	add	r3, r7
 8007390: f853 3c48    	ldr	r3, [r3, #-72]
 8007394: 4619         	mov	r1, r3
 8007396: 6b38         	ldr	r0, [r7, #0x30]
 8007398: f00a fbcc    	bl	0x8011b34 <LL_SPI_SetBaudRatePrescaler> @ imm = #0xa798
; 	if (SPI_MODE_GET(config->operation) & SPI_MODE_CPOL) {
 800739c: 683b         	ldr	r3, [r7]
 800739e: 889b         	ldrh	r3, [r3, #0x4]
 80073a0: f003 0302    	and	r3, r3, #0x2
 80073a4: 2b00         	cmp	r3, #0x0
 80073a6: d004         	beq	0x80073b2 <spi_stm32_configure+0x18a> @ imm = #0x8
; 		LL_SPI_SetClockPolarity(spi, LL_SPI_POLARITY_HIGH);
 80073a8: 2102         	movs	r1, #0x2
 80073aa: 6b38         	ldr	r0, [r7, #0x30]
 80073ac: f00a fbb0    	bl	0x8011b10 <LL_SPI_SetClockPolarity> @ imm = #0xa760
 80073b0: e003         	b	0x80073ba <spi_stm32_configure+0x192> @ imm = #0x6
; 		LL_SPI_SetClockPolarity(spi, LL_SPI_POLARITY_LOW);
 80073b2: 2100         	movs	r1, #0x0
 80073b4: 6b38         	ldr	r0, [r7, #0x30]
 80073b6: f00a fbab    	bl	0x8011b10 <LL_SPI_SetClockPolarity> @ imm = #0xa756
; 	if (SPI_MODE_GET(config->operation) & SPI_MODE_CPHA) {
 80073ba: 683b         	ldr	r3, [r7]
 80073bc: 889b         	ldrh	r3, [r3, #0x4]
 80073be: f003 0304    	and	r3, r3, #0x4
 80073c2: 2b00         	cmp	r3, #0x0
 80073c4: d004         	beq	0x80073d0 <spi_stm32_configure+0x1a8> @ imm = #0x8
; 		LL_SPI_SetClockPhase(spi, LL_SPI_PHASE_2EDGE);
 80073c6: 2101         	movs	r1, #0x1
 80073c8: 6b38         	ldr	r0, [r7, #0x30]
 80073ca: f00a fb8f    	bl	0x8011aec <LL_SPI_SetClockPhase> @ imm = #0xa71e
 80073ce: e003         	b	0x80073d8 <spi_stm32_configure+0x1b0> @ imm = #0x6
; 		LL_SPI_SetClockPhase(spi, LL_SPI_PHASE_1EDGE);
 80073d0: 2100         	movs	r1, #0x0
 80073d2: 6b38         	ldr	r0, [r7, #0x30]
 80073d4: f00a fb8a    	bl	0x8011aec <LL_SPI_SetClockPhase> @ imm = #0xa714
; 	LL_SPI_SetTransferDirection(spi, LL_SPI_FULL_DUPLEX);
 80073d8: 2100         	movs	r1, #0x0
 80073da: 6b38         	ldr	r0, [r7, #0x30]
 80073dc: f00a fbce    	bl	0x8011b7c <LL_SPI_SetTransferDirection> @ imm = #0xa79c
; 	if (config->operation & SPI_TRANSFER_LSB) {
 80073e0: 683b         	ldr	r3, [r7]
 80073e2: 889b         	ldrh	r3, [r3, #0x4]
 80073e4: f003 0310    	and	r3, r3, #0x10
 80073e8: 2b00         	cmp	r3, #0x0
 80073ea: d004         	beq	0x80073f6 <spi_stm32_configure+0x1ce> @ imm = #0x8
; 		LL_SPI_SetTransferBitOrder(spi, LL_SPI_LSB_FIRST);
 80073ec: 2180         	movs	r1, #0x80
 80073ee: 6b38         	ldr	r0, [r7, #0x30]
 80073f0: f00a fbb2    	bl	0x8011b58 <LL_SPI_SetTransferBitOrder> @ imm = #0xa764
 80073f4: e003         	b	0x80073fe <spi_stm32_configure+0x1d6> @ imm = #0x6
; 		LL_SPI_SetTransferBitOrder(spi, LL_SPI_MSB_FIRST);
 80073f6: 2100         	movs	r1, #0x0
 80073f8: 6b38         	ldr	r0, [r7, #0x30]
 80073fa: f00a fbad    	bl	0x8011b58 <LL_SPI_SetTransferBitOrder> @ imm = #0xa75a
; 	LL_SPI_DisableCRC(spi);
 80073fe: 6b38         	ldr	r0, [r7, #0x30]
 8007400: f00a fbe0    	bl	0x8011bc4 <LL_SPI_DisableCRC> @ imm = #0xa7c0
; 	if (spi_cs_is_gpio(config) || !IS_ENABLED(CONFIG_SPI_STM32_USE_HW_SS)) {
 8007404: 6838         	ldr	r0, [r7]
 8007406: f00a fde1    	bl	0x8011fcc <spi_cs_is_gpio> @ imm = #0xabc2
 800740a: 4603         	mov	r3, r0
 800740c: 2b00         	cmp	r3, #0x0
 800740e: d005         	beq	0x800741c <spi_stm32_configure+0x1f4> @ imm = #0xa
; 		LL_SPI_SetNSSMode(spi, LL_SPI_NSS_SOFT);
 8007410: f44f 7100    	mov.w	r1, #0x200
 8007414: 6b38         	ldr	r0, [r7, #0x30]
 8007416: f00a fbe4    	bl	0x8011be2 <LL_SPI_SetNSSMode> @ imm = #0xa7c8
 800741a: e00f         	b	0x800743c <spi_stm32_configure+0x214> @ imm = #0x1e
; 		if (config->operation & SPI_OP_MODE_SLAVE) {
 800741c: 683b         	ldr	r3, [r7]
 800741e: 889b         	ldrh	r3, [r3, #0x4]
 8007420: f003 0301    	and	r3, r3, #0x1
 8007424: 2b00         	cmp	r3, #0x0
 8007426: d004         	beq	0x8007432 <spi_stm32_configure+0x20a> @ imm = #0x8
; 			LL_SPI_SetNSSMode(spi, LL_SPI_NSS_HARD_INPUT);
 8007428: 2100         	movs	r1, #0x0
 800742a: 6b38         	ldr	r0, [r7, #0x30]
 800742c: f00a fbd9    	bl	0x8011be2 <LL_SPI_SetNSSMode> @ imm = #0xa7b2
 8007430: e004         	b	0x800743c <spi_stm32_configure+0x214> @ imm = #0x8
; 			LL_SPI_SetNSSMode(spi, LL_SPI_NSS_HARD_OUTPUT);
 8007432: f44f 2180    	mov.w	r1, #0x40000
 8007436: 6b38         	ldr	r0, [r7, #0x30]
 8007438: f00a fbd3    	bl	0x8011be2 <LL_SPI_SetNSSMode> @ imm = #0xa7a6
; 	if (config->operation & SPI_OP_MODE_SLAVE) {
 800743c: 683b         	ldr	r3, [r7]
 800743e: 889b         	ldrh	r3, [r3, #0x4]
 8007440: f003 0301    	and	r3, r3, #0x1
 8007444: 2b00         	cmp	r3, #0x0
 8007446: d004         	beq	0x8007452 <spi_stm32_configure+0x22a> @ imm = #0x8
; 		LL_SPI_SetMode(spi, LL_SPI_MODE_SLAVE);
 8007448: 2100         	movs	r1, #0x0
 800744a: 6b38         	ldr	r0, [r7, #0x30]
 800744c: f00a fb1d    	bl	0x8011a8a <LL_SPI_SetMode> @ imm = #0xa63a
 8007450: e004         	b	0x800745c <spi_stm32_configure+0x234> @ imm = #0x8
; 		LL_SPI_SetMode(spi, LL_SPI_MODE_MASTER);
 8007452: f44f 7182    	mov.w	r1, #0x104
 8007456: 6b38         	ldr	r0, [r7, #0x30]
 8007458: f00a fb17    	bl	0x8011a8a <LL_SPI_SetMode> @ imm = #0xa62e
; 	if (SPI_WORD_SIZE_GET(config->operation) ==  8) {
 800745c: 683b         	ldr	r3, [r7]
 800745e: 889b         	ldrh	r3, [r3, #0x4]
 8007460: 095b         	lsrs	r3, r3, #0x5
 8007462: f003 033f    	and	r3, r3, #0x3f
 8007466: 2b08         	cmp	r3, #0x8
 8007468: d10e         	bne	0x8007488 <spi_stm32_configure+0x260> @ imm = #0x1c
; 		LL_SPI_SetDataWidth(spi, LL_SPI_DATAWIDTH_8BIT);
 800746a: 2100         	movs	r1, #0x0
 800746c: 6b38         	ldr	r0, [r7, #0x30]
 800746e: f00a fb97    	bl	0x8011ba0 <LL_SPI_SetDataWidth> @ imm = #0xa72e
 8007472: e00e         	b	0x8007492 <spi_stm32_configure+0x26a> @ imm = #0x1c

08007474 <$d>:
 8007474: 10 5a 01 08  	.word	0x08015a10
 8007478: a4 45 01 08  	.word	0x080145a4
 800747c: 70 00 00 20  	.word	0x20000070
 8007480: 6c 59 01 08  	.word	0x0801596c
 8007484: 98 59 01 08  	.word	0x08015998

08007488 <$t>:
; 		LL_SPI_SetDataWidth(spi, LL_SPI_DATAWIDTH_16BIT);
 8007488: f44f 6100    	mov.w	r1, #0x800
 800748c: 6b38         	ldr	r0, [r7, #0x30]
 800748e: f00a fb87    	bl	0x8011ba0 <LL_SPI_SetDataWidth> @ imm = #0xa70e
; 	data->ctx.config = config;
 8007492: 6b7b         	ldr	r3, [r7, #0x34]
 8007494: 683a         	ldr	r2, [r7]
 8007496: 601a         	str	r2, [r3]
; 	LOG_DBG("Installed config %p: freq %uHz (div = %u),"
 8007498: 2303         	movs	r3, #0x3
 800749a: 2b03         	cmp	r3, #0x3
 800749c: d93c         	bls	0x8007518 <spi_stm32_configure+0x2f0> @ imm = #0x78
 800749e: 2301         	movs	r3, #0x1
 80074a0: f887 3052    	strb.w	r3, [r7, #0x52]
 80074a4: f897 3052    	ldrb.w	r3, [r7, #0x52]
 80074a8: f083 0301    	eor	r3, r3, #0x1
 80074ac: b2db         	uxtb	r3, r3
 80074ae: 2b00         	cmp	r3, #0x0
 80074b0: d132         	bne	0x8007518 <spi_stm32_configure+0x2f0> @ imm = #0x64
 80074b2: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x8007524 <spi_stm32_configure+0x2fc>
 80074b4: 681e         	ldr	r6, [r3]
 80074b6: 68fa         	ldr	r2, [r7, #0xc]
 80074b8: 6c3b         	ldr	r3, [r7, #0x40]
 80074ba: fa22 f303    	lsr.w	r3, r2, r3
 80074be: 2101         	movs	r1, #0x1
 80074c0: 6c3a         	ldr	r2, [r7, #0x40]
 80074c2: fa01 f202    	lsl.w	r2, r1, r2
 80074c6: 6839         	ldr	r1, [r7]
 80074c8: 8889         	ldrh	r1, [r1, #0x4]
 80074ca: 0849         	lsrs	r1, r1, #0x1
 80074cc: f001 0101    	and	r1, r1, #0x1
 80074d0: 6838         	ldr	r0, [r7]
 80074d2: 8880         	ldrh	r0, [r0, #0x4]
 80074d4: 0880         	lsrs	r0, r0, #0x2
 80074d6: f000 0001    	and	r0, r0, #0x1
 80074da: 683c         	ldr	r4, [r7]
 80074dc: 88a4         	ldrh	r4, [r4, #0x4]
 80074de: 08e4         	lsrs	r4, r4, #0x3
 80074e0: f004 0401    	and	r4, r4, #0x1
 80074e4: 683d         	ldr	r5, [r7]
 80074e6: 88ed         	ldrh	r5, [r5, #0x6]
 80074e8: 950a         	str	r5, [sp, #0x28]
 80074ea: 9409         	str	r4, [sp, #0x24]
 80074ec: 9008         	str	r0, [sp, #0x20]
 80074ee: 9107         	str	r1, [sp, #0x1c]
 80074f0: 9206         	str	r2, [sp, #0x18]
 80074f2: 9305         	str	r3, [sp, #0x14]
 80074f4: 683b         	ldr	r3, [r7]
 80074f6: 9304         	str	r3, [sp, #0x10]
 80074f8: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8007528 <spi_stm32_configure+0x300>
 80074fa: 9303         	str	r3, [sp, #0xc]
 80074fc: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800752c <spi_stm32_configure+0x304>
 80074fe: 9302         	str	r3, [sp, #0x8]
 8007500: 2308         	movs	r3, #0x8
 8007502: 9301         	str	r3, [sp, #0x4]
 8007504: 2300         	movs	r3, #0x0
 8007506: 9300         	str	r3, [sp]
 8007508: 2300         	movs	r3, #0x0
 800750a: 2204         	movs	r2, #0x4
 800750c: 4631         	mov	r1, r6
 800750e: 2000         	movs	r0, #0x0
 8007510: f00a fa30    	bl	0x8011974 <z_log_msg_runtime_create> @ imm = #0xa460
 8007514: 2300         	movs	r3, #0x0
 8007516: 64fb         	str	r3, [r7, #0x4c]
; 	return 0;
 8007518: 2300         	movs	r3, #0x0
; }
 800751a: 4618         	mov	r0, r3
 800751c: 375c         	adds	r7, #0x5c
 800751e: 46bd         	mov	sp, r7
 8007520: bdf0         	pop	{r4, r5, r6, r7, pc}
 8007522: bf00         	nop

08007524 <$d>:
 8007524: 70 00 00 20  	.word	0x20000070
 8007528: ac 66 01 08  	.word	0x080166ac
 800752c: c8 59 01 08  	.word	0x080159c8

08007530 <spi_stm32_init>:
; {
 8007530: b580         	push	{r7, lr}
 8007532: b090         	sub	sp, #0x40
 8007534: af04         	add	r7, sp, #0x10
 8007536: 6078         	str	r0, [r7, #0x4]
; 	struct spi_stm32_data *data __attribute__((unused)) = dev->data;
 8007538: 687b         	ldr	r3, [r7, #0x4]
 800753a: 691b         	ldr	r3, [r3, #0x10]
 800753c: 627b         	str	r3, [r7, #0x24]
; 	const struct spi_stm32_config *cfg = dev->config;
 800753e: 687b         	ldr	r3, [r7, #0x4]
 8007540: 685b         	ldr	r3, [r3, #0x4]
 8007542: 62bb         	str	r3, [r7, #0x28]
; 	if (!device_is_ready(DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE))) {
 8007544: 484a         	ldr	r0, [pc, #0x128]        @ 0x8007670 <spi_stm32_init+0x140>
 8007546: f00a fa09    	bl	0x801195c <device_is_ready> @ imm = #0xa412
 800754a: 4603         	mov	r3, r0
 800754c: f083 0301    	eor	r3, r3, #0x1
 8007550: b2db         	uxtb	r3, r3
 8007552: 2b00         	cmp	r3, #0x0
 8007554: d01c         	beq	0x8007590 <spi_stm32_init+0x60> @ imm = #0x38
; 		LOG_ERR("clock control device not ready");
 8007556: 2303         	movs	r3, #0x3
 8007558: 2b00         	cmp	r3, #0x0
 800755a: d016         	beq	0x800758a <spi_stm32_init+0x5a> @ imm = #0x2c
 800755c: 2301         	movs	r3, #0x1
 800755e: 74fb         	strb	r3, [r7, #0x13]
 8007560: 7cfb         	ldrb	r3, [r7, #0x13]
 8007562: f083 0301    	eor	r3, r3, #0x1
 8007566: b2db         	uxtb	r3, r3
 8007568: 2b00         	cmp	r3, #0x0
 800756a: d10e         	bne	0x800758a <spi_stm32_init+0x5a> @ imm = #0x1c
 800756c: 4b41         	ldr	r3, [pc, #0x104]        @ 0x8007674 <spi_stm32_init+0x144>
 800756e: 6819         	ldr	r1, [r3]
 8007570: 4b41         	ldr	r3, [pc, #0x104]        @ 0x8007678 <spi_stm32_init+0x148>
 8007572: 9302         	str	r3, [sp, #0x8]
 8007574: 2300         	movs	r3, #0x0
 8007576: 9301         	str	r3, [sp, #0x4]
 8007578: 2300         	movs	r3, #0x0
 800757a: 9300         	str	r3, [sp]
 800757c: 2300         	movs	r3, #0x0
 800757e: 2201         	movs	r2, #0x1
 8007580: 2000         	movs	r0, #0x0
 8007582: f00a f9f7    	bl	0x8011974 <z_log_msg_runtime_create> @ imm = #0xa3ee
 8007586: 2300         	movs	r3, #0x0
 8007588: 60fb         	str	r3, [r7, #0xc]
; 		return -ENODEV;
 800758a: f06f 0312    	mvn	r3, #0x12
 800758e: e06a         	b	0x8007666 <spi_stm32_init+0x136> @ imm = #0xd4
; 			       (clock_control_subsys_t) &cfg->pclken[0]);
 8007590: 6abb         	ldr	r3, [r7, #0x28]
 8007592: 68db         	ldr	r3, [r3, #0xc]
; 	err = clock_control_on(DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE),
 8007594: 4619         	mov	r1, r3
 8007596: 4836         	ldr	r0, [pc, #0xd8]         @ 0x8007670 <spi_stm32_init+0x140>
 8007598: f00a fd63    	bl	0x8012062 <clock_control_on> @ imm = #0xaac6
 800759c: 62f8         	str	r0, [r7, #0x2c]
; 	if (err < 0) {
 800759e: 6afb         	ldr	r3, [r7, #0x2c]
 80075a0: 2b00         	cmp	r3, #0x0
 80075a2: da1b         	bge	0x80075dc <spi_stm32_init+0xac> @ imm = #0x36
; 		LOG_ERR("Could not enable SPI clock");
 80075a4: 2303         	movs	r3, #0x3
 80075a6: 2b00         	cmp	r3, #0x0
 80075a8: d016         	beq	0x80075d8 <spi_stm32_init+0xa8> @ imm = #0x2c
 80075aa: 2301         	movs	r3, #0x1
 80075ac: 76fb         	strb	r3, [r7, #0x1b]
 80075ae: 7efb         	ldrb	r3, [r7, #0x1b]
 80075b0: f083 0301    	eor	r3, r3, #0x1
 80075b4: b2db         	uxtb	r3, r3
 80075b6: 2b00         	cmp	r3, #0x0
 80075b8: d10e         	bne	0x80075d8 <spi_stm32_init+0xa8> @ imm = #0x1c
 80075ba: 4b2e         	ldr	r3, [pc, #0xb8]         @ 0x8007674 <spi_stm32_init+0x144>
 80075bc: 6819         	ldr	r1, [r3]
 80075be: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x800767c <spi_stm32_init+0x14c>
 80075c0: 9302         	str	r3, [sp, #0x8]
 80075c2: 2300         	movs	r3, #0x0
 80075c4: 9301         	str	r3, [sp, #0x4]
 80075c6: 2300         	movs	r3, #0x0
 80075c8: 9300         	str	r3, [sp]
 80075ca: 2300         	movs	r3, #0x0
 80075cc: 2201         	movs	r2, #0x1
 80075ce: 2000         	movs	r0, #0x0
 80075d0: f00a f9d0    	bl	0x8011974 <z_log_msg_runtime_create> @ imm = #0xa3a0
 80075d4: 2300         	movs	r3, #0x0
 80075d6: 617b         	str	r3, [r7, #0x14]
; 		return err;
 80075d8: 6afb         	ldr	r3, [r7, #0x2c]
 80075da: e044         	b	0x8007666 <spi_stm32_init+0x136> @ imm = #0x88
; 	if (!spi_stm32_is_subghzspi(dev)) {
 80075dc: 6878         	ldr	r0, [r7, #0x4]
 80075de: f00b f83b    	bl	0x8012658 <spi_stm32_is_subghzspi> @ imm = #0xb076
 80075e2: 4603         	mov	r3, r0
 80075e4: f083 0301    	eor	r3, r3, #0x1
 80075e8: b2db         	uxtb	r3, r3
 80075ea: 2b00         	cmp	r3, #0x0
 80075ec: d029         	beq	0x8007642 <spi_stm32_init+0x112> @ imm = #0x52
; 		err = pinctrl_apply_state(cfg->pcfg, PINCTRL_STATE_DEFAULT);
 80075ee: 6abb         	ldr	r3, [r7, #0x28]
 80075f0: 685b         	ldr	r3, [r3, #0x4]
 80075f2: 2100         	movs	r1, #0x0
 80075f4: 4618         	mov	r0, r3
 80075f6: f00a fd0d    	bl	0x8012014 <pinctrl_apply_state> @ imm = #0xaa1a
 80075fa: 62f8         	str	r0, [r7, #0x2c]
; 		if (err < 0) {
 80075fc: 6afb         	ldr	r3, [r7, #0x2c]
 80075fe: 2b00         	cmp	r3, #0x0
 8007600: da1f         	bge	0x8007642 <spi_stm32_init+0x112> @ imm = #0x3e
; 			LOG_ERR("SPI pinctrl setup failed (%d)", err);
 8007602: 2303         	movs	r3, #0x3
 8007604: 2b00         	cmp	r3, #0x0
 8007606: d01a         	beq	0x800763e <spi_stm32_init+0x10e> @ imm = #0x34
 8007608: 2301         	movs	r3, #0x1
 800760a: f887 3023    	strb.w	r3, [r7, #0x23]
 800760e: f897 3023    	ldrb.w	r3, [r7, #0x23]
 8007612: f083 0301    	eor	r3, r3, #0x1
 8007616: b2db         	uxtb	r3, r3
 8007618: 2b00         	cmp	r3, #0x0
 800761a: d110         	bne	0x800763e <spi_stm32_init+0x10e> @ imm = #0x20
 800761c: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8007674 <spi_stm32_init+0x144>
 800761e: 6819         	ldr	r1, [r3]
 8007620: 6afb         	ldr	r3, [r7, #0x2c]
 8007622: 9303         	str	r3, [sp, #0xc]
 8007624: 4b16         	ldr	r3, [pc, #0x58]         @ 0x8007680 <spi_stm32_init+0x150>
 8007626: 9302         	str	r3, [sp, #0x8]
 8007628: 2300         	movs	r3, #0x0
 800762a: 9301         	str	r3, [sp, #0x4]
 800762c: 2300         	movs	r3, #0x0
 800762e: 9300         	str	r3, [sp]
 8007630: 2300         	movs	r3, #0x0
 8007632: 2201         	movs	r2, #0x1
 8007634: 2000         	movs	r0, #0x0
 8007636: f00a f99d    	bl	0x8011974 <z_log_msg_runtime_create> @ imm = #0xa33a
 800763a: 2300         	movs	r3, #0x0
 800763c: 61fb         	str	r3, [r7, #0x1c]
; 			return err;
 800763e: 6afb         	ldr	r3, [r7, #0x2c]
 8007640: e011         	b	0x8007666 <spi_stm32_init+0x136> @ imm = #0x22
; 	err = spi_context_cs_configure_all(&data->ctx);
 8007642: 6a7b         	ldr	r3, [r7, #0x24]
 8007644: 4618         	mov	r0, r3
 8007646: f7fe ff07    	bl	0x8006458 <spi_context_cs_configure_all> @ imm = #-0x11f2
 800764a: 62f8         	str	r0, [r7, #0x2c]
; 	if (err < 0) {
 800764c: 6afb         	ldr	r3, [r7, #0x2c]
 800764e: 2b00         	cmp	r3, #0x0
 8007650: da01         	bge	0x8007656 <spi_stm32_init+0x126> @ imm = #0x2
; 		return err;
 8007652: 6afb         	ldr	r3, [r7, #0x2c]
 8007654: e007         	b	0x8007666 <spi_stm32_init+0x136> @ imm = #0xe
; 	spi_context_unlock_unconditionally(&data->ctx);
 8007656: 6a7b         	ldr	r3, [r7, #0x24]
 8007658: 4618         	mov	r0, r3
 800765a: f00a fdd9    	bl	0x8012210 <spi_context_unlock_unconditionally> @ imm = #0xabb2
; 	return pm_device_runtime_enable(dev);
 800765e: 6878         	ldr	r0, [r7, #0x4]
 8007660: f00a fcf5    	bl	0x801204e <pm_device_runtime_enable> @ imm = #0xa9ea
 8007664: 4603         	mov	r3, r0
; }
 8007666: 4618         	mov	r0, r3
 8007668: 3730         	adds	r7, #0x30
 800766a: 46bd         	mov	sp, r7
 800766c: bd80         	pop	{r7, pc}
 800766e: bf00         	nop

08007670 <$d>:
 8007670: a4 45 01 08  	.word	0x080145a4
 8007674: 70 00 00 20  	.word	0x20000070
 8007678: 30 5a 01 08  	.word	0x08015a30
 800767c: 50 5a 01 08  	.word	0x08015a50
 8007680: 6c 5a 01 08  	.word	0x08015a6c

08007684 <__NVIC_SetPriority>:
; {
 8007684: b480         	push	{r7}
 8007686: b083         	sub	sp, #0xc
 8007688: af00         	add	r7, sp, #0x0
 800768a: 4603         	mov	r3, r0
 800768c: 6039         	str	r1, [r7]
 800768e: 71fb         	strb	r3, [r7, #0x7]
;   if ((int32_t)(IRQn) >= 0)
 8007690: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 8007694: 2b00         	cmp	r3, #0x0
 8007696: db0a         	blt	0x80076ae <__NVIC_SetPriority+0x2a> @ imm = #0x14
;     NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8007698: 683b         	ldr	r3, [r7]
 800769a: b2da         	uxtb	r2, r3
 800769c: 490c         	ldr	r1, [pc, #0x30]         @ 0x80076d0 <__NVIC_SetPriority+0x4c>
 800769e: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 80076a2: 0112         	lsls	r2, r2, #0x4
 80076a4: b2d2         	uxtb	r2, r2
 80076a6: 440b         	add	r3, r1
 80076a8: f883 2300    	strb.w	r2, [r3, #0x300]
; }
 80076ac: e00a         	b	0x80076c4 <__NVIC_SetPriority+0x40> @ imm = #0x14
;     SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80076ae: 683b         	ldr	r3, [r7]
 80076b0: b2da         	uxtb	r2, r3
 80076b2: 4908         	ldr	r1, [pc, #0x20]         @ 0x80076d4 <__NVIC_SetPriority+0x50>
 80076b4: 79fb         	ldrb	r3, [r7, #0x7]
 80076b6: f003 030f    	and	r3, r3, #0xf
 80076ba: 3b04         	subs	r3, #0x4
 80076bc: 0112         	lsls	r2, r2, #0x4
 80076be: b2d2         	uxtb	r2, r2
 80076c0: 440b         	add	r3, r1
 80076c2: 761a         	strb	r2, [r3, #0x18]
; }
 80076c4: bf00         	nop
 80076c6: 370c         	adds	r7, #0xc
 80076c8: 46bd         	mov	sp, r7
 80076ca: bc80         	pop	{r7}
 80076cc: 4770         	bx	lr
 80076ce: bf00         	nop

080076d0 <$d>:
 80076d0: 00 e1 00 e0  	.word	0xe000e100
 80076d4: 00 ed 00 e0  	.word	0xe000ed00

080076d8 <elapsed>:
; {
 80076d8: b480         	push	{r7}
 80076da: b085         	sub	sp, #0x14
 80076dc: af00         	add	r7, sp, #0x0
; 	uint32_t val1 = SysTick->VAL;	/* A */
 80076de: 4b19         	ldr	r3, [pc, #0x64]         @ 0x8007744 <elapsed+0x6c>
 80076e0: 689b         	ldr	r3, [r3, #0x8]
 80076e2: 60fb         	str	r3, [r7, #0xc]
; 	uint32_t ctrl = SysTick->CTRL;	/* B */
 80076e4: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x8007744 <elapsed+0x6c>
 80076e6: 681b         	ldr	r3, [r3]
 80076e8: 607b         	str	r3, [r7, #0x4]
; 	uint32_t val2 = SysTick->VAL;	/* C */
 80076ea: 4b16         	ldr	r3, [pc, #0x58]         @ 0x8007744 <elapsed+0x6c>
 80076ec: 689b         	ldr	r3, [r3, #0x8]
 80076ee: 60bb         	str	r3, [r7, #0x8]
; 	if (val1 == 0) {
 80076f0: 68fb         	ldr	r3, [r7, #0xc]
 80076f2: 2b00         	cmp	r3, #0x0
 80076f4: d102         	bne	0x80076fc <elapsed+0x24> @ imm = #0x4
; 		val1 = last_load;
 80076f6: 4b14         	ldr	r3, [pc, #0x50]         @ 0x8007748 <elapsed+0x70>
 80076f8: 681b         	ldr	r3, [r3]
 80076fa: 60fb         	str	r3, [r7, #0xc]
; 	if (val2 == 0) {
 80076fc: 68bb         	ldr	r3, [r7, #0x8]
 80076fe: 2b00         	cmp	r3, #0x0
 8007700: d102         	bne	0x8007708 <elapsed+0x30> @ imm = #0x4
; 		val2 = last_load;
 8007702: 4b11         	ldr	r3, [pc, #0x44]         @ 0x8007748 <elapsed+0x70>
 8007704: 681b         	ldr	r3, [r3]
 8007706: 60bb         	str	r3, [r7, #0x8]
; 	if ((ctrl & SysTick_CTRL_COUNTFLAG_Msk)
 8007708: 687b         	ldr	r3, [r7, #0x4]
 800770a: f403 3380    	and	r3, r3, #0x10000
 800770e: 2b00         	cmp	r3, #0x0
 8007710: d103         	bne	0x800771a <elapsed+0x42> @ imm = #0x6
; 	    || (val1 < val2)) {
 8007712: 68fa         	ldr	r2, [r7, #0xc]
 8007714: 68bb         	ldr	r3, [r7, #0x8]
 8007716: 429a         	cmp	r2, r3
 8007718: d208         	bhs	0x800772c <elapsed+0x54> @ imm = #0x10
; 		overflow_cyc += last_load;
 800771a: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x800774c <elapsed+0x74>
 800771c: 681a         	ldr	r2, [r3]
 800771e: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8007748 <elapsed+0x70>
 8007720: 681b         	ldr	r3, [r3]
 8007722: 4413         	add	r3, r2
 8007724: 4a09         	ldr	r2, [pc, #0x24]         @ 0x800774c <elapsed+0x74>
 8007726: 6013         	str	r3, [r2]
; 		(void)SysTick->CTRL;
 8007728: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8007744 <elapsed+0x6c>
 800772a: 681b         	ldr	r3, [r3]
; 	return (last_load - val2) + overflow_cyc;
 800772c: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8007748 <elapsed+0x70>
 800772e: 681a         	ldr	r2, [r3]
 8007730: 68bb         	ldr	r3, [r7, #0x8]
 8007732: 1ad2         	subs	r2, r2, r3
 8007734: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800774c <elapsed+0x74>
 8007736: 681b         	ldr	r3, [r3]
 8007738: 4413         	add	r3, r2
; }
 800773a: 4618         	mov	r0, r3
 800773c: 3714         	adds	r7, #0x14
 800773e: 46bd         	mov	sp, r7
 8007740: bc80         	pop	{r7}
 8007742: 4770         	bx	lr

08007744 <$d>:
 8007744: 10 e0 00 e0  	.word	0xe000e010
 8007748: 3c 09 00 20  	.word	0x2000093c
 800774c: 40 09 00 20  	.word	0x20000940

08007750 <sys_clock_isr>:
; {
 8007750: 4668         	mov	r0, sp
 8007752: f020 0107    	bic	r1, r0, #0x7
 8007756: 468d         	mov	sp, r1
 8007758: e92d 4fb1    	push.w	{r0, r4, r5, r7, r8, r9, r10, r11, lr}
 800775c: b085         	sub	sp, #0x14
 800775e: af00         	add	r7, sp, #0x0
; 	elapsed();
 8007760: f7ff ffba    	bl	0x80076d8 <elapsed>     @ imm = #-0x8c
; 	cycle_count += overflow_cyc;
 8007764: 4b22         	ldr	r3, [pc, #0x88]         @ 0x80077f0 <sys_clock_isr+0xa0>
 8007766: 681b         	ldr	r3, [r3]
 8007768: 2200         	movs	r2, #0x0
 800776a: 4698         	mov	r8, r3
 800776c: 4691         	mov	r9, r2
 800776e: 4b21         	ldr	r3, [pc, #0x84]         @ 0x80077f4 <sys_clock_isr+0xa4>
 8007770: e9d3 2300    	ldrd	r2, r3, [r3]
 8007774: eb18 0102    	adds.w	r1, r8, r2
 8007778: 6039         	str	r1, [r7]
 800777a: eb49 0303    	adc.w	r3, r9, r3
 800777e: 607b         	str	r3, [r7, #0x4]
 8007780: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x80077f4 <sys_clock_isr+0xa4>
 8007782: e9d7 1200    	ldrd	r1, r2, [r7]
 8007786: e9c3 1200    	strd	r1, r2, [r3]
; 	overflow_cyc = 0;
 800778a: 4b19         	ldr	r3, [pc, #0x64]         @ 0x80077f0 <sys_clock_isr+0xa0>
 800778c: 2200         	movs	r2, #0x0
 800778e: 601a         	str	r2, [r3]
; 		dcycles = cycle_count - announced_cycles;
 8007790: 4b18         	ldr	r3, [pc, #0x60]         @ 0x80077f4 <sys_clock_isr+0xa4>
 8007792: e9d3 2300    	ldrd	r2, r3, [r3]
 8007796: 4611         	mov	r1, r2
 8007798: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x80077f8 <sys_clock_isr+0xa8>
 800779a: e9d3 2300    	ldrd	r2, r3, [r3]
 800779e: 4613         	mov	r3, r2
 80077a0: 1acb         	subs	r3, r1, r3
 80077a2: 60fb         	str	r3, [r7, #0xc]
; 		dticks = dcycles / CYC_PER_TICK;
 80077a4: 68fb         	ldr	r3, [r7, #0xc]
 80077a6: 4a15         	ldr	r2, [pc, #0x54]         @ 0x80077fc <sys_clock_isr+0xac>
 80077a8: fba2 2303    	umull	r2, r3, r2, r3
 80077ac: 0b9b         	lsrs	r3, r3, #0xe
 80077ae: 60bb         	str	r3, [r7, #0x8]
; 		announced_cycles += dticks * CYC_PER_TICK;
 80077b0: 68bb         	ldr	r3, [r7, #0x8]
 80077b2: f244 12a0    	movw	r2, #0x41a0
 80077b6: fb02 f303    	mul	r3, r2, r3
 80077ba: 2200         	movs	r2, #0x0
 80077bc: 461c         	mov	r4, r3
 80077be: 4615         	mov	r5, r2
 80077c0: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x80077f8 <sys_clock_isr+0xa8>
 80077c2: e9d3 2300    	ldrd	r2, r3, [r3]
 80077c6: eb14 0a02    	adds.w	r10, r4, r2
 80077ca: eb45 0b03    	adc.w	r11, r5, r3
 80077ce: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x80077f8 <sys_clock_isr+0xa8>
 80077d0: e9c3 ab00    	strd	r10, r11, [r3]
; 		sys_clock_announce(dticks);
 80077d4: 68bb         	ldr	r3, [r7, #0x8]
 80077d6: 4618         	mov	r0, r3
 80077d8: f004 fd72    	bl	0x800c2c0 <sys_clock_announce> @ imm = #0x4ae4
; 	z_arm_int_exit();
 80077dc: f7fa fd34    	bl	0x8002248 <z_arm_int_exit> @ imm = #-0x5598
; }
 80077e0: bf00         	nop
 80077e2: 3714         	adds	r7, #0x14
 80077e4: 46bd         	mov	sp, r7
 80077e6: e8bd 4fb1    	pop.w	{r0, r4, r5, r7, r8, r9, r10, r11, lr}
 80077ea: 4685         	mov	sp, r0
 80077ec: 4770         	bx	lr
 80077ee: bf00         	nop

080077f0 <$d>:
 80077f0: 40 09 00 20  	.word	0x20000940
 80077f4: e0 01 00 20  	.word	0x200001e0
 80077f8: e8 01 00 20  	.word	0x200001e8
 80077fc: 2d 34 a9 f9  	.word	0xf9a9342d

08007800 <sys_clock_set_timeout>:
; {
 8007800: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 8007804: b09a         	sub	sp, #0x68
 8007806: af00         	add	r7, sp, #0x0
 8007808: 61f8         	str	r0, [r7, #0x1c]
 800780a: 460b         	mov	r3, r1
 800780c: 76fb         	strb	r3, [r7, #0x1b]
; 	if (IS_ENABLED(CONFIG_TICKLESS_KERNEL) && idle && ticks == K_TICKS_FOREVER) {
 800780e: 7efb         	ldrb	r3, [r7, #0x1b]
 8007810: 2b00         	cmp	r3, #0x0
 8007812: d00e         	beq	0x8007832 <sys_clock_set_timeout+0x32> @ imm = #0x1c
 8007814: 69fb         	ldr	r3, [r7, #0x1c]
 8007816: f1b3 3fff    	cmp.w	r3, #0xffffffff
 800781a: d10a         	bne	0x8007832 <sys_clock_set_timeout+0x32> @ imm = #0x14
; 		SysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk;
 800781c: 4b72         	ldr	r3, [pc, #0x1c8]        @ 0x80079e8 <sys_clock_set_timeout+0x1e8>
 800781e: 681b         	ldr	r3, [r3]
 8007820: 4a71         	ldr	r2, [pc, #0x1c4]        @ 0x80079e8 <sys_clock_set_timeout+0x1e8>
 8007822: f023 0301    	bic	r3, r3, #0x1
 8007826: 6013         	str	r3, [r2]
; 		last_load = TIMER_STOPPED;
 8007828: 4b70         	ldr	r3, [pc, #0x1c0]        @ 0x80079ec <sys_clock_set_timeout+0x1ec>
 800782a: f04f 427f    	mov.w	r2, #0xff000000
 800782e: 601a         	str	r2, [r3]
 8007830: e0d6         	b	0x80079e0 <sys_clock_set_timeout+0x1e0> @ imm = #0x1ac
; 	uint32_t last_load_ = last_load;
 8007832: 4b6e         	ldr	r3, [pc, #0x1b8]        @ 0x80079ec <sys_clock_set_timeout+0x1ec>
 8007834: 681b         	ldr	r3, [r3]
 8007836: 667b         	str	r3, [r7, #0x64]
; 	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
 8007838: 69fb         	ldr	r3, [r7, #0x1c]
 800783a: f1b3 3fff    	cmp.w	r3, #0xffffffff
 800783e: d001         	beq	0x8007844 <sys_clock_set_timeout+0x44> @ imm = #0x2
 8007840: 69fb         	ldr	r3, [r7, #0x1c]
 8007842: e001         	b	0x8007848 <sys_clock_set_timeout+0x48> @ imm = #0x2
 8007844: f240 33e5    	movw	r3, #0x3e5
 8007848: 61fb         	str	r3, [r7, #0x1c]
; 	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
 800784a: 69fb         	ldr	r3, [r7, #0x1c]
 800784c: 2b01         	cmp	r3, #0x1
 800784e: dd07         	ble	0x8007860 <sys_clock_set_timeout+0x60> @ imm = #0xe
 8007850: 69fb         	ldr	r3, [r7, #0x1c]
 8007852: f240 32e6    	movw	r2, #0x3e6
 8007856: 4293         	cmp	r3, r2
 8007858: bfa8         	it	ge
 800785a: 4613         	movge	r3, r2
 800785c: 3b01         	subs	r3, #0x1
 800785e: e000         	b	0x8007862 <sys_clock_set_timeout+0x62> @ imm = #0x0
 8007860: 2300         	movs	r3, #0x0
 8007862: 61fb         	str	r3, [r7, #0x1c]
 8007864: 4b62         	ldr	r3, [pc, #0x188]        @ 0x80079f0 <sys_clock_set_timeout+0x1f0>
 8007866: 64fb         	str	r3, [r7, #0x4c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8007868: f3ef 8311    	mrs	r3, basepri
 800786c: 64bb         	str	r3, [r7, #0x48]
;   return(result);
 800786e: 6cbb         	ldr	r3, [r7, #0x48]
; 	key = __get_BASEPRI();
 8007870: 647b         	str	r3, [r7, #0x44]
 8007872: 2310         	movs	r3, #0x10
 8007874: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8007876: 6c3b         	ldr	r3, [r7, #0x40]
 8007878: f383 8812    	msr	basepri_max, r3
; }
 800787c: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800787e: f3bf 8f6f    	isb	sy
; }
 8007882: bf00         	nop
; 	return key;
 8007884: 6c7b         	ldr	r3, [r7, #0x44]
; 	k.key = arch_irq_lock();
 8007886: 623b         	str	r3, [r7, #0x20]
 8007888: 6cfb         	ldr	r3, [r7, #0x4c]
 800788a: 63fb         	str	r3, [r7, #0x3c]
; }
 800788c: bf00         	nop
 800788e: 6cfb         	ldr	r3, [r7, #0x4c]
 8007890: 63bb         	str	r3, [r7, #0x38]
; }
 8007892: bf00         	nop
; 	return k;
 8007894: 6a3b         	ldr	r3, [r7, #0x20]
 8007896: 62bb         	str	r3, [r7, #0x28]
; 	uint32_t pending = elapsed();
 8007898: f7ff ff1e    	bl	0x80076d8 <elapsed>     @ imm = #-0x1c4
 800789c: 6638         	str	r0, [r7, #0x60]
; 	val1 = SysTick->VAL;
 800789e: 4b52         	ldr	r3, [pc, #0x148]        @ 0x80079e8 <sys_clock_set_timeout+0x1e8>
 80078a0: 689b         	ldr	r3, [r3, #0x8]
 80078a2: 65fb         	str	r3, [r7, #0x5c]
; 	cycle_count += pending;
 80078a4: 6e3b         	ldr	r3, [r7, #0x60]
 80078a6: 2200         	movs	r2, #0x0
 80078a8: 469a         	mov	r10, r3
 80078aa: 4693         	mov	r11, r2
 80078ac: 4b51         	ldr	r3, [pc, #0x144]        @ 0x80079f4 <sys_clock_set_timeout+0x1f4>
 80078ae: e9d3 2300    	ldrd	r2, r3, [r3]
 80078b2: eb1a 0102    	adds.w	r1, r10, r2
 80078b6: 6139         	str	r1, [r7, #0x10]
 80078b8: eb4b 0303    	adc.w	r3, r11, r3
 80078bc: 617b         	str	r3, [r7, #0x14]
 80078be: 4b4d         	ldr	r3, [pc, #0x134]        @ 0x80079f4 <sys_clock_set_timeout+0x1f4>
 80078c0: e9d7 1204    	ldrd	r1, r2, [r7, #16]
 80078c4: e9c3 1200    	strd	r1, r2, [r3]
; 	overflow_cyc = 0U;
 80078c8: 4b4b         	ldr	r3, [pc, #0x12c]        @ 0x80079f8 <sys_clock_set_timeout+0x1f8>
 80078ca: 2200         	movs	r2, #0x0
 80078cc: 601a         	str	r2, [r3]
; 	uint32_t unannounced = cycle_count - announced_cycles;
 80078ce: 4b49         	ldr	r3, [pc, #0x124]        @ 0x80079f4 <sys_clock_set_timeout+0x1f4>
 80078d0: e9d3 2300    	ldrd	r2, r3, [r3]
 80078d4: 4611         	mov	r1, r2
 80078d6: 4b49         	ldr	r3, [pc, #0x124]        @ 0x80079fc <sys_clock_set_timeout+0x1fc>
 80078d8: e9d3 2300    	ldrd	r2, r3, [r3]
 80078dc: 4613         	mov	r3, r2
 80078de: 1acb         	subs	r3, r1, r3
 80078e0: 65bb         	str	r3, [r7, #0x58]
; 	if ((int32_t)unannounced < 0) {
 80078e2: 6dbb         	ldr	r3, [r7, #0x58]
 80078e4: 2b00         	cmp	r3, #0x0
 80078e6: da04         	bge	0x80078f2 <sys_clock_set_timeout+0xf2> @ imm = #0x8
; 		last_load = MIN_DELAY;
 80078e8: 4b40         	ldr	r3, [pc, #0x100]        @ 0x80079ec <sys_clock_set_timeout+0x1ec>
 80078ea: f240 421a    	movw	r2, #0x41a
 80078ee: 601a         	str	r2, [r3]
 80078f0: e02c         	b	0x800794c <sys_clock_set_timeout+0x14c> @ imm = #0x58
; 		delay = ticks * CYC_PER_TICK;
 80078f2: 69fb         	ldr	r3, [r7, #0x1c]
 80078f4: f244 12a0    	movw	r2, #0x41a0
 80078f8: fb02 f303    	mul	r3, r2, r3
 80078fc: 657b         	str	r3, [r7, #0x54]
; 		delay += unannounced;
 80078fe: 6d7a         	ldr	r2, [r7, #0x54]
 8007900: 6dbb         	ldr	r3, [r7, #0x58]
 8007902: 4413         	add	r3, r2
 8007904: 657b         	str	r3, [r7, #0x54]
; 		delay = DIV_ROUND_UP(delay, CYC_PER_TICK) * CYC_PER_TICK;
 8007906: 6d7b         	ldr	r3, [r7, #0x54]
 8007908: f503 4383    	add.w	r3, r3, #0x4180
 800790c: 331f         	adds	r3, #0x1f
 800790e: 4a3c         	ldr	r2, [pc, #0xf0]         @ 0x8007a00 <sys_clock_set_timeout+0x200>
 8007910: fba2 2303    	umull	r2, r3, r2, r3
 8007914: 0b9b         	lsrs	r3, r3, #0xe
 8007916: f244 12a0    	movw	r2, #0x41a0
 800791a: fb02 f303    	mul	r3, r2, r3
 800791e: 657b         	str	r3, [r7, #0x54]
; 		delay -= unannounced;
 8007920: 6d7a         	ldr	r2, [r7, #0x54]
 8007922: 6dbb         	ldr	r3, [r7, #0x58]
 8007924: 1ad3         	subs	r3, r2, r3
 8007926: 657b         	str	r3, [r7, #0x54]
; 		delay = MAX(delay, MIN_DELAY);
 8007928: 6d7b         	ldr	r3, [r7, #0x54]
 800792a: f240 421a    	movw	r2, #0x41a
 800792e: 4293         	cmp	r3, r2
 8007930: bf38         	it	lo
 8007932: 4613         	movlo	r3, r2
 8007934: 657b         	str	r3, [r7, #0x54]
; 		if (delay > MAX_CYCLES) {
 8007936: 6d7b         	ldr	r3, [r7, #0x54]
 8007938: 4a32         	ldr	r2, [pc, #0xc8]         @ 0x8007a04 <sys_clock_set_timeout+0x204>
 800793a: 4293         	cmp	r3, r2
 800793c: d903         	bls	0x8007946 <sys_clock_set_timeout+0x146> @ imm = #0x6
; 			last_load = MAX_CYCLES;
 800793e: 4b2b         	ldr	r3, [pc, #0xac]         @ 0x80079ec <sys_clock_set_timeout+0x1ec>
 8007940: 4a30         	ldr	r2, [pc, #0xc0]         @ 0x8007a04 <sys_clock_set_timeout+0x204>
 8007942: 601a         	str	r2, [r3]
 8007944: e002         	b	0x800794c <sys_clock_set_timeout+0x14c> @ imm = #0x4
; 			last_load = delay;
 8007946: 4a29         	ldr	r2, [pc, #0xa4]         @ 0x80079ec <sys_clock_set_timeout+0x1ec>
 8007948: 6d7b         	ldr	r3, [r7, #0x54]
 800794a: 6013         	str	r3, [r2]
; 	val2 = SysTick->VAL;
 800794c: 4b26         	ldr	r3, [pc, #0x98]         @ 0x80079e8 <sys_clock_set_timeout+0x1e8>
 800794e: 689b         	ldr	r3, [r3, #0x8]
 8007950: 653b         	str	r3, [r7, #0x50]
; 	SysTick->LOAD = last_load - 1;
 8007952: 4b26         	ldr	r3, [pc, #0x98]         @ 0x80079ec <sys_clock_set_timeout+0x1ec>
 8007954: 681b         	ldr	r3, [r3]
 8007956: 4a24         	ldr	r2, [pc, #0x90]         @ 0x80079e8 <sys_clock_set_timeout+0x1e8>
 8007958: 3b01         	subs	r3, #0x1
 800795a: 6053         	str	r3, [r2, #0x4]
; 	SysTick->VAL = 0; /* resets timer to last_load */
 800795c: 4b22         	ldr	r3, [pc, #0x88]         @ 0x80079e8 <sys_clock_set_timeout+0x1e8>
 800795e: 2200         	movs	r2, #0x0
 8007960: 609a         	str	r2, [r3, #0x8]
; 	if (val1 < val2) {
 8007962: 6dfa         	ldr	r2, [r7, #0x5c]
 8007964: 6d3b         	ldr	r3, [r7, #0x50]
 8007966: 429a         	cmp	r2, r3
 8007968: d216         	bhs	0x8007998 <sys_clock_set_timeout+0x198> @ imm = #0x2c
; 		cycle_count += (val1 + (last_load_ - val2));
 800796a: 6e7a         	ldr	r2, [r7, #0x64]
 800796c: 6d3b         	ldr	r3, [r7, #0x50]
 800796e: 1ad2         	subs	r2, r2, r3
 8007970: 6dfb         	ldr	r3, [r7, #0x5c]
 8007972: 4413         	add	r3, r2
 8007974: 2200         	movs	r2, #0x0
 8007976: 4698         	mov	r8, r3
 8007978: 4691         	mov	r9, r2
 800797a: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x80079f4 <sys_clock_set_timeout+0x1f4>
 800797c: e9d3 2300    	ldrd	r2, r3, [r3]
 8007980: eb18 0102    	adds.w	r1, r8, r2
 8007984: 60b9         	str	r1, [r7, #0x8]
 8007986: eb49 0303    	adc.w	r3, r9, r3
 800798a: 60fb         	str	r3, [r7, #0xc]
 800798c: 4b19         	ldr	r3, [pc, #0x64]         @ 0x80079f4 <sys_clock_set_timeout+0x1f4>
 800798e: e9d7 1202    	ldrd	r1, r2, [r7, #8]
 8007992: e9c3 1200    	strd	r1, r2, [r3]
 8007996: e012         	b	0x80079be <sys_clock_set_timeout+0x1be> @ imm = #0x24
; 		cycle_count += (val1 - val2);
 8007998: 6dfa         	ldr	r2, [r7, #0x5c]
 800799a: 6d3b         	ldr	r3, [r7, #0x50]
 800799c: 1ad3         	subs	r3, r2, r3
 800799e: 2200         	movs	r2, #0x0
 80079a0: 461c         	mov	r4, r3
 80079a2: 4615         	mov	r5, r2
 80079a4: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x80079f4 <sys_clock_set_timeout+0x1f4>
 80079a6: e9d3 2300    	ldrd	r2, r3, [r3]
 80079aa: 18a1         	adds	r1, r4, r2
 80079ac: 6039         	str	r1, [r7]
 80079ae: eb45 0303    	adc.w	r3, r5, r3
 80079b2: 607b         	str	r3, [r7, #0x4]
 80079b4: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x80079f4 <sys_clock_set_timeout+0x1f4>
 80079b6: e9d7 1200    	ldrd	r1, r2, [r7]
 80079ba: e9c3 1200    	strd	r1, r2, [r3]
 80079be: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x80079f0 <sys_clock_set_timeout+0x1f0>
 80079c0: 637b         	str	r3, [r7, #0x34]
 80079c2: 6abb         	ldr	r3, [r7, #0x28]
 80079c4: 627b         	str	r3, [r7, #0x24]
; 	arch_irq_unlock(key.key);
 80079c6: 6a7b         	ldr	r3, [r7, #0x24]
 80079c8: 633b         	str	r3, [r7, #0x30]
 80079ca: 6b3b         	ldr	r3, [r7, #0x30]
 80079cc: 62fb         	str	r3, [r7, #0x2c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80079ce: 6afb         	ldr	r3, [r7, #0x2c]
 80079d0: f383 8811    	msr	basepri, r3
; }
 80079d4: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80079d6: f3bf 8f6f    	isb	sy
; }
 80079da: bf00         	nop
; }
 80079dc: bf00         	nop
; }
 80079de: bf00         	nop
; }
 80079e0: 3768         	adds	r7, #0x68
 80079e2: 46bd         	mov	sp, r7
 80079e4: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

080079e8 <$d>:
 80079e8: 10 e0 00 e0  	.word	0xe000e010
 80079ec: 3c 09 00 20  	.word	0x2000093c
 80079f0: 3c 09 00 20  	.word	0x2000093c
 80079f4: e0 01 00 20  	.word	0x200001e0
 80079f8: 40 09 00 20  	.word	0x20000940
 80079fc: e8 01 00 20  	.word	0x200001e8
 8007a00: 2d 34 a9 f9  	.word	0xf9a9342d
 8007a04: 20 94 ff 00  	.word	0x00ff9420

08007a08 <sys_clock_elapsed>:
; {
 8007a08: b580         	push	{r7, lr}
 8007a0a: b08e         	sub	sp, #0x38
 8007a0c: af00         	add	r7, sp, #0x0
 8007a0e: 4b22         	ldr	r3, [pc, #0x88]         @ 0x8007a98 <sys_clock_elapsed+0x90>
 8007a10: 623b         	str	r3, [r7, #0x20]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8007a12: f3ef 8311    	mrs	r3, basepri
 8007a16: 61fb         	str	r3, [r7, #0x1c]
;   return(result);
 8007a18: 69fb         	ldr	r3, [r7, #0x1c]
; 	key = __get_BASEPRI();
 8007a1a: 61bb         	str	r3, [r7, #0x18]
 8007a1c: 2310         	movs	r3, #0x10
 8007a1e: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8007a20: 697b         	ldr	r3, [r7, #0x14]
 8007a22: f383 8812    	msr	basepri_max, r3
; }
 8007a26: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8007a28: f3bf 8f6f    	isb	sy
; }
 8007a2c: bf00         	nop
; 	return key;
 8007a2e: 69bb         	ldr	r3, [r7, #0x18]
; 	k.key = arch_irq_lock();
 8007a30: 607b         	str	r3, [r7, #0x4]
 8007a32: 6a3b         	ldr	r3, [r7, #0x20]
 8007a34: 613b         	str	r3, [r7, #0x10]
; }
 8007a36: bf00         	nop
 8007a38: 6a3b         	ldr	r3, [r7, #0x20]
 8007a3a: 60fb         	str	r3, [r7, #0xc]
; }
 8007a3c: bf00         	nop
; 	return k;
 8007a3e: 687b         	ldr	r3, [r7, #0x4]
 8007a40: 60bb         	str	r3, [r7, #0x8]
; 	uint32_t unannounced = cycle_count - announced_cycles;
 8007a42: 4b16         	ldr	r3, [pc, #0x58]         @ 0x8007a9c <sys_clock_elapsed+0x94>
 8007a44: e9d3 2300    	ldrd	r2, r3, [r3]
 8007a48: 4611         	mov	r1, r2
 8007a4a: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8007aa0 <sys_clock_elapsed+0x98>
 8007a4c: e9d3 2300    	ldrd	r2, r3, [r3]
 8007a50: 4613         	mov	r3, r2
 8007a52: 1acb         	subs	r3, r1, r3
 8007a54: 637b         	str	r3, [r7, #0x34]
; 	uint32_t cyc = elapsed() + unannounced;
 8007a56: f7ff fe3f    	bl	0x80076d8 <elapsed>     @ imm = #-0x382
 8007a5a: 4602         	mov	r2, r0
 8007a5c: 6b7b         	ldr	r3, [r7, #0x34]
 8007a5e: 4413         	add	r3, r2
 8007a60: 633b         	str	r3, [r7, #0x30]
 8007a62: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x8007a98 <sys_clock_elapsed+0x90>
 8007a64: 62fb         	str	r3, [r7, #0x2c]
 8007a66: 68bb         	ldr	r3, [r7, #0x8]
 8007a68: 603b         	str	r3, [r7]
; 	arch_irq_unlock(key.key);
 8007a6a: 683b         	ldr	r3, [r7]
 8007a6c: 62bb         	str	r3, [r7, #0x28]
 8007a6e: 6abb         	ldr	r3, [r7, #0x28]
 8007a70: 627b         	str	r3, [r7, #0x24]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8007a72: 6a7b         	ldr	r3, [r7, #0x24]
 8007a74: f383 8811    	msr	basepri, r3
; }
 8007a78: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8007a7a: f3bf 8f6f    	isb	sy
; }
 8007a7e: bf00         	nop
; }
 8007a80: bf00         	nop
; }
 8007a82: bf00         	nop
; 	return cyc / CYC_PER_TICK;
 8007a84: 6b3b         	ldr	r3, [r7, #0x30]
 8007a86: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8007aa4 <sys_clock_elapsed+0x9c>
 8007a88: fba2 2303    	umull	r2, r3, r2, r3
 8007a8c: 0b9b         	lsrs	r3, r3, #0xe
; }
 8007a8e: 4618         	mov	r0, r3
 8007a90: 3738         	adds	r7, #0x38
 8007a92: 46bd         	mov	sp, r7
 8007a94: bd80         	pop	{r7, pc}
 8007a96: bf00         	nop

08007a98 <$d>:
 8007a98: 3c 09 00 20  	.word	0x2000093c
 8007a9c: e0 01 00 20  	.word	0x200001e0
 8007aa0: e8 01 00 20  	.word	0x200001e8
 8007aa4: 2d 34 a9 f9  	.word	0xf9a9342d

08007aa8 <sys_clock_cycle_get_32>:
; {
 8007aa8: b580         	push	{r7, lr}
 8007aaa: b08e         	sub	sp, #0x38
 8007aac: af00         	add	r7, sp, #0x0
 8007aae: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x8007b24 <sys_clock_cycle_get_32+0x7c>
 8007ab0: 627b         	str	r3, [r7, #0x24]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8007ab2: f3ef 8311    	mrs	r3, basepri
 8007ab6: 623b         	str	r3, [r7, #0x20]
;   return(result);
 8007ab8: 6a3b         	ldr	r3, [r7, #0x20]
; 	key = __get_BASEPRI();
 8007aba: 61fb         	str	r3, [r7, #0x1c]
 8007abc: 2310         	movs	r3, #0x10
 8007abe: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8007ac0: 69bb         	ldr	r3, [r7, #0x18]
 8007ac2: f383 8812    	msr	basepri_max, r3
; }
 8007ac6: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8007ac8: f3bf 8f6f    	isb	sy
; }
 8007acc: bf00         	nop
; 	return key;
 8007ace: 69fb         	ldr	r3, [r7, #0x1c]
; 	k.key = arch_irq_lock();
 8007ad0: 60bb         	str	r3, [r7, #0x8]
 8007ad2: 6a7b         	ldr	r3, [r7, #0x24]
 8007ad4: 617b         	str	r3, [r7, #0x14]
; }
 8007ad6: bf00         	nop
 8007ad8: 6a7b         	ldr	r3, [r7, #0x24]
 8007ada: 613b         	str	r3, [r7, #0x10]
; }
 8007adc: bf00         	nop
; 	return k;
 8007ade: 68bb         	ldr	r3, [r7, #0x8]
 8007ae0: 60fb         	str	r3, [r7, #0xc]
; 	uint32_t ret = cycle_count;
 8007ae2: 4b11         	ldr	r3, [pc, #0x44]         @ 0x8007b28 <sys_clock_cycle_get_32+0x80>
 8007ae4: e9d3 2300    	ldrd	r2, r3, [r3]
 8007ae8: 4613         	mov	r3, r2
 8007aea: 637b         	str	r3, [r7, #0x34]
; 	ret += elapsed();
 8007aec: f7ff fdf4    	bl	0x80076d8 <elapsed>     @ imm = #-0x418
 8007af0: 4602         	mov	r2, r0
 8007af2: 6b7b         	ldr	r3, [r7, #0x34]
 8007af4: 4413         	add	r3, r2
 8007af6: 637b         	str	r3, [r7, #0x34]
 8007af8: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8007b24 <sys_clock_cycle_get_32+0x7c>
 8007afa: 633b         	str	r3, [r7, #0x30]
 8007afc: 68fb         	ldr	r3, [r7, #0xc]
 8007afe: 607b         	str	r3, [r7, #0x4]
; 	arch_irq_unlock(key.key);
 8007b00: 687b         	ldr	r3, [r7, #0x4]
 8007b02: 62fb         	str	r3, [r7, #0x2c]
 8007b04: 6afb         	ldr	r3, [r7, #0x2c]
 8007b06: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8007b08: 6abb         	ldr	r3, [r7, #0x28]
 8007b0a: f383 8811    	msr	basepri, r3
; }
 8007b0e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8007b10: f3bf 8f6f    	isb	sy
; }
 8007b14: bf00         	nop
; }
 8007b16: bf00         	nop
; }
 8007b18: bf00         	nop
; 	return ret;
 8007b1a: 6b7b         	ldr	r3, [r7, #0x34]
; }
 8007b1c: 4618         	mov	r0, r3
 8007b1e: 3738         	adds	r7, #0x38
 8007b20: 46bd         	mov	sp, r7
 8007b22: bd80         	pop	{r7, pc}

08007b24 <$d>:
 8007b24: 3c 09 00 20  	.word	0x2000093c
 8007b28: e0 01 00 20  	.word	0x200001e0

08007b2c <sys_clock_driver_init>:
; {
 8007b2c: b580         	push	{r7, lr}
 8007b2e: af00         	add	r7, sp, #0x0
; 	NVIC_SetPriority(SysTick_IRQn, _IRQ_PRIO_OFFSET);
 8007b30: 2101         	movs	r1, #0x1
 8007b32: f04f 30ff    	mov.w	r0, #0xffffffff
 8007b36: f7ff fda5    	bl	0x8007684 <__NVIC_SetPriority> @ imm = #-0x4b6
; 	last_load = CYC_PER_TICK;
 8007b3a: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8007b6c <sys_clock_driver_init+0x40>
 8007b3c: f244 12a0    	movw	r2, #0x41a0
 8007b40: 601a         	str	r2, [r3]
; 	overflow_cyc = 0U;
 8007b42: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8007b70 <sys_clock_driver_init+0x44>
 8007b44: 2200         	movs	r2, #0x0
 8007b46: 601a         	str	r2, [r3]
; 	SysTick->LOAD = last_load - 1;
 8007b48: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8007b6c <sys_clock_driver_init+0x40>
 8007b4a: 681b         	ldr	r3, [r3]
 8007b4c: 4a09         	ldr	r2, [pc, #0x24]         @ 0x8007b74 <sys_clock_driver_init+0x48>
 8007b4e: 3b01         	subs	r3, #0x1
 8007b50: 6053         	str	r3, [r2, #0x4]
; 	SysTick->VAL = 0; /* resets timer to last_load */
 8007b52: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8007b74 <sys_clock_driver_init+0x48>
 8007b54: 2200         	movs	r2, #0x0
 8007b56: 609a         	str	r2, [r3, #0x8]
; 	SysTick->CTRL |= (SysTick_CTRL_ENABLE_Msk |
 8007b58: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8007b74 <sys_clock_driver_init+0x48>
 8007b5a: 681b         	ldr	r3, [r3]
 8007b5c: 4a05         	ldr	r2, [pc, #0x14]         @ 0x8007b74 <sys_clock_driver_init+0x48>
 8007b5e: f043 0307    	orr	r3, r3, #0x7
 8007b62: 6013         	str	r3, [r2]
; 	return 0;
 8007b64: 2300         	movs	r3, #0x0
; }
 8007b66: 4618         	mov	r0, r3
 8007b68: bd80         	pop	{r7, pc}
 8007b6a: bf00         	nop

08007b6c <$d>:
 8007b6c: 3c 09 00 20  	.word	0x2000093c
 8007b70: 40 09 00 20  	.word	0x20000940
 8007b74: 10 e0 00 e0  	.word	0xe000e010

08007b78 <get_can_id>:
; static int get_can_id(const struct device *dev) {
 8007b78: b480         	push	{r7}
 8007b7a: b085         	sub	sp, #0x14
 8007b7c: af00         	add	r7, sp, #0x0
 8007b7e: 6078         	str	r0, [r7, #0x4]
;     const struct dm_motor_config *cfg = dev->config;
 8007b80: 687b         	ldr	r3, [r7, #0x4]
 8007b82: 685b         	ldr	r3, [r3, #0x4]
 8007b84: 60bb         	str	r3, [r7, #0x8]
;     for (int i = 0; i < CAN_COUNT; i++) {
 8007b86: 2300         	movs	r3, #0x0
 8007b88: 60fb         	str	r3, [r7, #0xc]
 8007b8a: e00c         	b	0x8007ba6 <get_can_id+0x2e> @ imm = #0x18
;         if (can_devices[i] == cfg->common.phy) {
 8007b8c: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x8007bbc <get_can_id+0x44>
 8007b8e: 68fb         	ldr	r3, [r7, #0xc]
 8007b90: f852 2023    	ldr.w	r2, [r2, r3, lsl #2]
 8007b94: 68bb         	ldr	r3, [r7, #0x8]
 8007b96: 681b         	ldr	r3, [r3]
 8007b98: 429a         	cmp	r2, r3
 8007b9a: d101         	bne	0x8007ba0 <get_can_id+0x28> @ imm = #0x2
;             return i;
 8007b9c: 68fb         	ldr	r3, [r7, #0xc]
 8007b9e: e007         	b	0x8007bb0 <get_can_id+0x38> @ imm = #0xe
;     for (int i = 0; i < CAN_COUNT; i++) {
 8007ba0: 68fb         	ldr	r3, [r7, #0xc]
 8007ba2: 3301         	adds	r3, #0x1
 8007ba4: 60fb         	str	r3, [r7, #0xc]
 8007ba6: 68fb         	ldr	r3, [r7, #0xc]
 8007ba8: 2b01         	cmp	r3, #0x1
 8007baa: ddef         	ble	0x8007b8c <get_can_id+0x14> @ imm = #-0x22
;     return -1;
 8007bac: f04f 33ff    	mov.w	r3, #0xffffffff
; }
 8007bb0: 4618         	mov	r0, r3
 8007bb2: 3714         	adds	r7, #0x14
 8007bb4: 46bd         	mov	sp, r7
 8007bb6: bc80         	pop	{r7}
 8007bb8: 4770         	bx	lr
 8007bba: bf00         	nop

08007bbc <$d>:
 8007bbc: d0 00 00 20  	.word	0x200000d0

08007bc0 <dm_init>:
; int dm_init(const struct device *dev) {
 8007bc0: b580         	push	{r7, lr}
 8007bc2: b084         	sub	sp, #0x10
 8007bc4: af00         	add	r7, sp, #0x0
 8007bc6: 6078         	str	r0, [r7, #0x4]
;     const struct dm_motor_config *cfg = dev->config;
 8007bc8: 687b         	ldr	r3, [r7, #0x4]
 8007bca: 685b         	ldr	r3, [r3, #0x4]
 8007bcc: 60fb         	str	r3, [r7, #0xc]
;     can_start(cfg->common.phy);
 8007bce: 68fb         	ldr	r3, [r7, #0xc]
 8007bd0: 681b         	ldr	r3, [r3]
 8007bd2: 4618         	mov	r0, r3
 8007bd4: f00a fdf5    	bl	0x80127c2 <can_start>   @ imm = #0xabea
;     int can_id = get_can_id(dev);
 8007bd8: 6878         	ldr	r0, [r7, #0x4]
 8007bda: f7ff ffcd    	bl	0x8007b78 <get_can_id>  @ imm = #-0x66
 8007bde: 60b8         	str	r0, [r7, #0x8]
;     k_sem_init(&tx_queue_sem[can_id], 3, 3); // 
 8007be0: 68bb         	ldr	r3, [r7, #0x8]
 8007be2: 011b         	lsls	r3, r3, #0x4
 8007be4: 4a0c         	ldr	r2, [pc, #0x30]         @ 0x8007c18 <dm_init+0x58>
 8007be6: 4413         	add	r3, r2
 8007be8: 2203         	movs	r2, #0x3
 8007bea: 2103         	movs	r1, #0x3
 8007bec: 4618         	mov	r0, r3
 8007bee: f00a fd49    	bl	0x8012684 <k_sem_init>  @ imm = #0xaa92
;     if (!device_is_ready(cfg->common.phy))
 8007bf2: 68fb         	ldr	r3, [r7, #0xc]
 8007bf4: 681b         	ldr	r3, [r3]
 8007bf6: 4618         	mov	r0, r3
 8007bf8: f00a fd38    	bl	0x801266c <device_is_ready> @ imm = #0xaa70
 8007bfc: 4603         	mov	r3, r0
 8007bfe: f083 0301    	eor	r3, r3, #0x1
 8007c02: b2db         	uxtb	r3, r3
 8007c04: 2b00         	cmp	r3, #0x0
 8007c06: d002         	beq	0x8007c0e <dm_init+0x4e> @ imm = #0x4
;         return -1;
 8007c08: f04f 33ff    	mov.w	r3, #0xffffffff
 8007c0c: e000         	b	0x8007c10 <dm_init+0x50> @ imm = #0x0
;     return 0;
 8007c0e: 2300         	movs	r3, #0x0
; }
 8007c10: 4618         	mov	r0, r3
 8007c12: 3710         	adds	r7, #0x10
 8007c14: 46bd         	mov	sp, r7
 8007c16: bd80         	pop	{r7, pc}

08007c18 <$d>:
 8007c18: 44 09 00 20  	.word	0x20000944

08007c1c <dm_send_queued>:
; int dm_send_queued(struct tx_frame *frame, struct k_msgq *msgq) {
 8007c1c: b590         	push	{r4, r7, lr}
 8007c1e: b08d         	sub	sp, #0x34
 8007c20: af04         	add	r7, sp, #0x10
 8007c22: 6078         	str	r0, [r7, #0x4]
 8007c24: 6039         	str	r1, [r7]
;     int err = k_sem_take(frame->sem, K_NO_WAIT);
 8007c26: 687b         	ldr	r3, [r7, #0x4]
 8007c28: 6859         	ldr	r1, [r3, #0x4]
 8007c2a: f04f 0200    	mov.w	r2, #0x0
 8007c2e: f04f 0300    	mov.w	r3, #0x0
 8007c32: 4608         	mov	r0, r1
 8007c34: f00a fd36    	bl	0x80126a4 <k_sem_take>  @ imm = #0xaa6c
 8007c38: 61f8         	str	r0, [r7, #0x1c]
;     if (err == 0) {
 8007c3a: 69fb         	ldr	r3, [r7, #0x1c]
 8007c3c: 2b00         	cmp	r3, #0x0
 8007c3e: d111         	bne	0x8007c64 <dm_send_queued+0x48> @ imm = #0x22
;         can_send(frame->can_dev, &frame->frame, K_NO_WAIT, can_tx_callback, frame->sem);
 8007c40: 687b         	ldr	r3, [r7, #0x4]
 8007c42: 6818         	ldr	r0, [r3]
 8007c44: 687b         	ldr	r3, [r7, #0x4]
 8007c46: f103 0408    	add.w	r4, r3, #0x8
 8007c4a: f04f 0200    	mov.w	r2, #0x0
 8007c4e: f04f 0300    	mov.w	r3, #0x0
 8007c52: 6879         	ldr	r1, [r7, #0x4]
 8007c54: 6849         	ldr	r1, [r1, #0x4]
 8007c56: 9101         	str	r1, [sp, #0x4]
 8007c58: 4928         	ldr	r1, [pc, #0xa0]         @ 0x8007cfc <dm_send_queued+0xe0>
 8007c5a: 9100         	str	r1, [sp]
 8007c5c: 4621         	mov	r1, r4
 8007c5e: f00a fdbc    	bl	0x80127da <can_send>    @ imm = #0xab78
 8007c62: e045         	b	0x8007cf0 <dm_send_queued+0xd4> @ imm = #0x8a
;     } else if (err == -EBUSY) {
 8007c64: 69fb         	ldr	r3, [r7, #0x1c]
 8007c66: f113 0f10    	cmn.w	r3, #0x10
 8007c6a: d141         	bne	0x8007cf0 <dm_send_queued+0xd4> @ imm = #0x82
;         LOG_ERR("CAN TX queue is full");
 8007c6c: 2304         	movs	r3, #0x4
 8007c6e: 2b00         	cmp	r3, #0x0
 8007c70: d016         	beq	0x8007ca0 <dm_send_queued+0x84> @ imm = #0x2c
 8007c72: 2301         	movs	r3, #0x1
 8007c74: 76fb         	strb	r3, [r7, #0x1b]
 8007c76: 7efb         	ldrb	r3, [r7, #0x1b]
 8007c78: f083 0301    	eor	r3, r3, #0x1
 8007c7c: b2db         	uxtb	r3, r3
 8007c7e: 2b00         	cmp	r3, #0x0
 8007c80: d10e         	bne	0x8007ca0 <dm_send_queued+0x84> @ imm = #0x1c
 8007c82: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x8007d00 <dm_send_queued+0xe4>
 8007c84: 6819         	ldr	r1, [r3]
 8007c86: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x8007d04 <dm_send_queued+0xe8>
 8007c88: 9302         	str	r3, [sp, #0x8]
 8007c8a: 2300         	movs	r3, #0x0
 8007c8c: 9301         	str	r3, [sp, #0x4]
 8007c8e: 2300         	movs	r3, #0x0
 8007c90: 9300         	str	r3, [sp]
 8007c92: 2300         	movs	r3, #0x0
 8007c94: 2201         	movs	r2, #0x1
 8007c96: 2000         	movs	r0, #0x0
 8007c98: f00a fd43    	bl	0x8012722 <z_log_msg_runtime_create> @ imm = #0xaa86
 8007c9c: 2300         	movs	r3, #0x0
 8007c9e: 617b         	str	r3, [r7, #0x14]
;         err = k_msgq_put(msgq, frame, K_NO_WAIT);
 8007ca0: f04f 0200    	mov.w	r2, #0x0
 8007ca4: f04f 0300    	mov.w	r3, #0x0
 8007ca8: 6879         	ldr	r1, [r7, #0x4]
 8007caa: 6838         	ldr	r0, [r7]
 8007cac: f00a fd15    	bl	0x80126da <k_msgq_put>  @ imm = #0xaa2a
 8007cb0: 61f8         	str	r0, [r7, #0x1c]
;         if (err) {
 8007cb2: 69fb         	ldr	r3, [r7, #0x1c]
 8007cb4: 2b00         	cmp	r3, #0x0
 8007cb6: d01b         	beq	0x8007cf0 <dm_send_queued+0xd4> @ imm = #0x36
;             LOG_ERR("Failed to put CAN frame into TX queue: %d", err);
 8007cb8: 2304         	movs	r3, #0x4
 8007cba: 2b00         	cmp	r3, #0x0
 8007cbc: d018         	beq	0x8007cf0 <dm_send_queued+0xd4> @ imm = #0x30
 8007cbe: 2301         	movs	r3, #0x1
 8007cc0: 74fb         	strb	r3, [r7, #0x13]
 8007cc2: 7cfb         	ldrb	r3, [r7, #0x13]
 8007cc4: f083 0301    	eor	r3, r3, #0x1
 8007cc8: b2db         	uxtb	r3, r3
 8007cca: 2b00         	cmp	r3, #0x0
 8007ccc: d110         	bne	0x8007cf0 <dm_send_queued+0xd4> @ imm = #0x20
 8007cce: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8007d00 <dm_send_queued+0xe4>
 8007cd0: 6819         	ldr	r1, [r3]
 8007cd2: 69fb         	ldr	r3, [r7, #0x1c]
 8007cd4: 9303         	str	r3, [sp, #0xc]
 8007cd6: 4b0c         	ldr	r3, [pc, #0x30]         @ 0x8007d08 <dm_send_queued+0xec>
 8007cd8: 9302         	str	r3, [sp, #0x8]
 8007cda: 2300         	movs	r3, #0x0
 8007cdc: 9301         	str	r3, [sp, #0x4]
 8007cde: 2300         	movs	r3, #0x0
 8007ce0: 9300         	str	r3, [sp]
 8007ce2: 2300         	movs	r3, #0x0
 8007ce4: 2201         	movs	r2, #0x1
 8007ce6: 2000         	movs	r0, #0x0
 8007ce8: f00a fd1b    	bl	0x8012722 <z_log_msg_runtime_create> @ imm = #0xaa36
 8007cec: 2300         	movs	r3, #0x0
 8007cee: 60fb         	str	r3, [r7, #0xc]
;     return err;
 8007cf0: 69f9         	ldr	r1, [r7, #0x1c]
 8007cf2: 460b         	mov	r3, r1
; }
 8007cf4: 4618         	mov	r0, r3
 8007cf6: 3724         	adds	r7, #0x24
 8007cf8: 46bd         	mov	sp, r7
 8007cfa: bd90         	pop	{r4, r7, pc}

08007cfc <$d>:
 8007cfc: e7 28 01 08  	.word	0x080128e7
 8007d00: d8 00 00 20  	.word	0x200000d8
 8007d04: c0 5a 01 08  	.word	0x08015ac0
 8007d08: d8 5a 01 08  	.word	0x08015ad8

08007d0c <dm_motor_control>:
; void dm_motor_control(const struct device *dev, enum motor_cmd cmd) {
 8007d0c: b590         	push	{r4, r7, lr}
 8007d0e: b097         	sub	sp, #0x5c
 8007d10: af04         	add	r7, sp, #0x10
 8007d12: 6078         	str	r0, [r7, #0x4]
 8007d14: 460b         	mov	r3, r1
 8007d16: 70fb         	strb	r3, [r7, #0x3]
;     struct dm_motor_data         *data = dev->data;
 8007d18: 687b         	ldr	r3, [r7, #0x4]
 8007d1a: 691b         	ldr	r3, [r3, #0x10]
 8007d1c: 643b         	str	r3, [r7, #0x40]
;     const struct dm_motor_config *cfg  = dev->config;
 8007d1e: 687b         	ldr	r3, [r7, #0x4]
 8007d20: 685b         	ldr	r3, [r3, #0x4]
 8007d22: 63fb         	str	r3, [r7, #0x3c]
;     frame.id    = cfg->common.tx_id;
 8007d24: 6bfb         	ldr	r3, [r7, #0x3c]
 8007d26: 689b         	ldr	r3, [r3, #0x8]
 8007d28: 623b         	str	r3, [r7, #0x20]
;     frame.flags = 0;
 8007d2a: 2300         	movs	r3, #0x0
 8007d2c: f887 3025    	strb.w	r3, [r7, #0x25]
;     frame.dlc   = 8;
 8007d30: 2308         	movs	r3, #0x8
 8007d32: f887 3024    	strb.w	r3, [r7, #0x24]
;     int err    = 0;
 8007d36: 2300         	movs	r3, #0x0
 8007d38: 647b         	str	r3, [r7, #0x44]
;     int can_id = get_can_id(dev);
 8007d3a: 6878         	ldr	r0, [r7, #0x4]
 8007d3c: f7ff ff1c    	bl	0x8007b78 <get_can_id>  @ imm = #-0x1c8
 8007d40: 63b8         	str	r0, [r7, #0x38]
;     struct tx_frame tx_frame = {
 8007d42: f107 0308    	add.w	r3, r7, #0x8
 8007d46: 2200         	movs	r2, #0x0
 8007d48: 601a         	str	r2, [r3]
 8007d4a: 605a         	str	r2, [r3, #0x4]
 8007d4c: 609a         	str	r2, [r3, #0x8]
 8007d4e: 60da         	str	r2, [r3, #0xc]
 8007d50: 611a         	str	r2, [r3, #0x10]
 8007d52: 615a         	str	r2, [r3, #0x14]
;         .can_dev = cfg->common.phy,
 8007d54: 6bfb         	ldr	r3, [r7, #0x3c]
 8007d56: 681b         	ldr	r3, [r3]
;     struct tx_frame tx_frame = {
 8007d58: 60bb         	str	r3, [r7, #0x8]
;         .sem     = &tx_queue_sem[can_id],
 8007d5a: 6bbb         	ldr	r3, [r7, #0x38]
 8007d5c: 011b         	lsls	r3, r3, #0x4
 8007d5e: 4a4f         	ldr	r2, [pc, #0x13c]        @ 0x8007e9c <dm_motor_control+0x190>
 8007d60: 4413         	add	r3, r2
;     struct tx_frame tx_frame = {
 8007d62: 60fb         	str	r3, [r7, #0xc]
;     switch (cmd) {
 8007d64: 78fb         	ldrb	r3, [r7, #0x3]
 8007d66: 2b04         	cmp	r3, #0x4
 8007d68: d872         	bhi	0x8007e50 <dm_motor_control+0x144> @ imm = #0xe4
 8007d6a: a201         	adr	r2, #4 <dm_motor_control+0x63>
 8007d6c: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]

08007d70 <$d>:
 8007d70: 85 7d 00 08  	.word	0x08007d85
 8007d74: b7 7d 00 08  	.word	0x08007db7
 8007d78: e9 7d 00 08  	.word	0x08007de9
 8007d7c: 15 7e 00 08  	.word	0x08007e15
 8007d80: 25 7e 00 08  	.word	0x08007e25

08007d84 <$t>:
;         data->online = true;
 8007d84: 6c3b         	ldr	r3, [r7, #0x40]
 8007d86: 2201         	movs	r2, #0x1
 8007d88: 771a         	strb	r2, [r3, #0x1c]
;         memcpy(frame.data, enable_frame, 8);
 8007d8a: 4a45         	ldr	r2, [pc, #0x114]        @ 0x8007ea0 <dm_motor_control+0x194>
 8007d8c: f107 0328    	add.w	r3, r7, #0x28
 8007d90: e892 0003    	ldm.w	r2, {r0, r1}
 8007d94: e883 0003    	stm.w	r3, {r0, r1}
;         tx_frame.frame = frame;
 8007d98: f107 0410    	add.w	r4, r7, #0x10
 8007d9c: f107 0320    	add.w	r3, r7, #0x20
 8007da0: cb0f         	ldm	r3, {r0, r1, r2, r3}
 8007da2: e884 000f    	stm.w	r4, {r0, r1, r2, r3}
;         err = dm_send_queued(&tx_frame, &dm_can_tx_msgq);
 8007da6: f107 0308    	add.w	r3, r7, #0x8
 8007daa: 493e         	ldr	r1, [pc, #0xf8]         @ 0x8007ea4 <dm_motor_control+0x198>
 8007dac: 4618         	mov	r0, r3
 8007dae: f7ff ff35    	bl	0x8007c1c <dm_send_queued> @ imm = #-0x196
 8007db2: 6478         	str	r0, [r7, #0x44]
;         break;
 8007db4: e04c         	b	0x8007e50 <dm_motor_control+0x144> @ imm = #0x98
;         data->online = false;
 8007db6: 6c3b         	ldr	r3, [r7, #0x40]
 8007db8: 2200         	movs	r2, #0x0
 8007dba: 771a         	strb	r2, [r3, #0x1c]
;         memcpy(frame.data, disable_frame, 8);
 8007dbc: 4a3a         	ldr	r2, [pc, #0xe8]         @ 0x8007ea8 <dm_motor_control+0x19c>
 8007dbe: f107 0328    	add.w	r3, r7, #0x28
 8007dc2: e892 0003    	ldm.w	r2, {r0, r1}
 8007dc6: e883 0003    	stm.w	r3, {r0, r1}
;         tx_frame.frame = frame;
 8007dca: f107 0410    	add.w	r4, r7, #0x10
 8007dce: f107 0320    	add.w	r3, r7, #0x20
 8007dd2: cb0f         	ldm	r3, {r0, r1, r2, r3}
 8007dd4: e884 000f    	stm.w	r4, {r0, r1, r2, r3}
;         err = dm_send_queued(&tx_frame, &dm_can_tx_msgq);
 8007dd8: f107 0308    	add.w	r3, r7, #0x8
 8007ddc: 4931         	ldr	r1, [pc, #0xc4]         @ 0x8007ea4 <dm_motor_control+0x198>
 8007dde: 4618         	mov	r0, r3
 8007de0: f7ff ff1c    	bl	0x8007c1c <dm_send_queued> @ imm = #-0x1c8
 8007de4: 6478         	str	r0, [r7, #0x44]
;         break;
 8007de6: e033         	b	0x8007e50 <dm_motor_control+0x144> @ imm = #0x66
;         memcpy(frame.data, set_zero_frame, 8);
 8007de8: 4a30         	ldr	r2, [pc, #0xc0]         @ 0x8007eac <dm_motor_control+0x1a0>
 8007dea: f107 0328    	add.w	r3, r7, #0x28
 8007dee: e892 0003    	ldm.w	r2, {r0, r1}
 8007df2: e883 0003    	stm.w	r3, {r0, r1}
;         tx_frame.frame = frame;
 8007df6: f107 0410    	add.w	r4, r7, #0x10
 8007dfa: f107 0320    	add.w	r3, r7, #0x20
 8007dfe: cb0f         	ldm	r3, {r0, r1, r2, r3}
 8007e00: e884 000f    	stm.w	r4, {r0, r1, r2, r3}
;         err = dm_send_queued(&tx_frame, &dm_can_tx_msgq);
 8007e04: f107 0308    	add.w	r3, r7, #0x8
 8007e08: 4926         	ldr	r1, [pc, #0x98]         @ 0x8007ea4 <dm_motor_control+0x198>
 8007e0a: 4618         	mov	r0, r3
 8007e0c: f7ff ff06    	bl	0x8007c1c <dm_send_queued> @ imm = #-0x1f4
 8007e10: 6478         	str	r0, [r7, #0x44]
;         break;
 8007e12: e01d         	b	0x8007e50 <dm_motor_control+0x144> @ imm = #0x3a
;     case CLEAR_PID: memset(&data->params, 0, sizeof(data->params)); break;
 8007e14: 6c3b         	ldr	r3, [r7, #0x40]
 8007e16: 3330         	adds	r3, #0x30
 8007e18: 220c         	movs	r2, #0xc
 8007e1a: 2100         	movs	r1, #0x0
 8007e1c: 4618         	mov	r0, r3
 8007e1e: f00c f97d    	bl	0x801411c <memset>      @ imm = #0xc2fa
 8007e22: e015         	b	0x8007e50 <dm_motor_control+0x144> @ imm = #0x2a
;         memcpy(frame.data, clear_error_frame, 8);
 8007e24: 4a22         	ldr	r2, [pc, #0x88]         @ 0x8007eb0 <dm_motor_control+0x1a4>
 8007e26: f107 0328    	add.w	r3, r7, #0x28
 8007e2a: e892 0003    	ldm.w	r2, {r0, r1}
 8007e2e: e883 0003    	stm.w	r3, {r0, r1}
;         tx_frame.frame = frame;
 8007e32: f107 0410    	add.w	r4, r7, #0x10
 8007e36: f107 0320    	add.w	r3, r7, #0x20
 8007e3a: cb0f         	ldm	r3, {r0, r1, r2, r3}
 8007e3c: e884 000f    	stm.w	r4, {r0, r1, r2, r3}
;         err = dm_send_queued(&tx_frame, &dm_can_tx_msgq);
 8007e40: f107 0308    	add.w	r3, r7, #0x8
 8007e44: 4917         	ldr	r1, [pc, #0x5c]         @ 0x8007ea4 <dm_motor_control+0x198>
 8007e46: 4618         	mov	r0, r3
 8007e48: f7ff fee8    	bl	0x8007c1c <dm_send_queued> @ imm = #-0x230
 8007e4c: 6478         	str	r0, [r7, #0x44]
;         break;
 8007e4e: bf00         	nop
;     if (err != 0) {
 8007e50: 6c7b         	ldr	r3, [r7, #0x44]
 8007e52: 2b00         	cmp	r3, #0x0
 8007e54: d01e         	beq	0x8007e94 <dm_motor_control+0x188> @ imm = #0x3c
;         LOG_ERR("Failed to send CAN frame: %d", err);
 8007e56: 2304         	movs	r3, #0x4
 8007e58: 2b00         	cmp	r3, #0x0
 8007e5a: d01b         	beq	0x8007e94 <dm_motor_control+0x188> @ imm = #0x36
 8007e5c: 2301         	movs	r3, #0x1
 8007e5e: f887 3037    	strb.w	r3, [r7, #0x37]
 8007e62: f897 3037    	ldrb.w	r3, [r7, #0x37]
 8007e66: f083 0301    	eor	r3, r3, #0x1
 8007e6a: b2db         	uxtb	r3, r3
 8007e6c: 2b00         	cmp	r3, #0x0
 8007e6e: d111         	bne	0x8007e94 <dm_motor_control+0x188> @ imm = #0x22
 8007e70: 4b10         	ldr	r3, [pc, #0x40]         @ 0x8007eb4 <dm_motor_control+0x1a8>
 8007e72: 6819         	ldr	r1, [r3]
 8007e74: 6c7b         	ldr	r3, [r7, #0x44]
 8007e76: 9303         	str	r3, [sp, #0xc]
 8007e78: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x8007eb8 <dm_motor_control+0x1ac>
 8007e7a: 9302         	str	r3, [sp, #0x8]
 8007e7c: 2300         	movs	r3, #0x0
 8007e7e: 9301         	str	r3, [sp, #0x4]
 8007e80: 2300         	movs	r3, #0x0
 8007e82: 9300         	str	r3, [sp]
 8007e84: 2300         	movs	r3, #0x0
 8007e86: 2201         	movs	r2, #0x1
 8007e88: 2000         	movs	r0, #0x0
 8007e8a: f00a fc4a    	bl	0x8012722 <z_log_msg_runtime_create> @ imm = #0xa894
 8007e8e: 2300         	movs	r3, #0x0
 8007e90: 633b         	str	r3, [r7, #0x30]
; }
 8007e92: e7ff         	b	0x8007e94 <dm_motor_control+0x188> @ imm = #-0x2
 8007e94: bf00         	nop
 8007e96: 374c         	adds	r7, #0x4c
 8007e98: 46bd         	mov	sp, r7
 8007e9a: bd90         	pop	{r4, r7, pc}

08007e9c <$d>:
 8007e9c: 44 09 00 20  	.word	0x20000944
 8007ea0: dc 66 01 08  	.word	0x080166dc
 8007ea4: b4 01 00 20  	.word	0x200001b4
 8007ea8: e4 66 01 08  	.word	0x080166e4
 8007eac: ec 66 01 08  	.word	0x080166ec
 8007eb0: f4 66 01 08  	.word	0x080166f4
 8007eb4: d8 00 00 20  	.word	0x200000d8
 8007eb8: 04 5b 01 08  	.word	0x08015b04

08007ebc <dm_motor_pack>:
; static void dm_motor_pack(const struct device *dev, struct can_frame *frame) {
 8007ebc: b580         	push	{r7, lr}
 8007ebe: b08a         	sub	sp, #0x28
 8007ec0: af00         	add	r7, sp, #0x0
 8007ec2: 6078         	str	r0, [r7, #0x4]
 8007ec4: 6039         	str	r1, [r7]
;     struct dm_motor_data         *data = dev->data;
 8007ec6: 687b         	ldr	r3, [r7, #0x4]
 8007ec8: 691b         	ldr	r3, [r3, #0x10]
 8007eca: 627b         	str	r3, [r7, #0x24]
;     const struct dm_motor_config *cfg  = dev->config;
 8007ecc: 687b         	ldr	r3, [r7, #0x4]
 8007ece: 685b         	ldr	r3, [r3, #0x4]
 8007ed0: 623b         	str	r3, [r7, #0x20]
;     frame->id    = cfg->common.tx_id + data->tx_offset;
 8007ed2: 6a3b         	ldr	r3, [r7, #0x20]
 8007ed4: 689a         	ldr	r2, [r3, #0x8]
 8007ed6: 6a7b         	ldr	r3, [r7, #0x24]
 8007ed8: 699b         	ldr	r3, [r3, #0x18]
 8007eda: 4413         	add	r3, r2
 8007edc: 461a         	mov	r2, r3
 8007ede: 683b         	ldr	r3, [r7]
 8007ee0: 601a         	str	r2, [r3]
;     frame->dlc   = 8;
 8007ee2: 683b         	ldr	r3, [r7]
 8007ee4: 2208         	movs	r2, #0x8
 8007ee6: 711a         	strb	r2, [r3, #0x4]
;     frame->flags = 0;
 8007ee8: 683b         	ldr	r3, [r7]
 8007eea: 2200         	movs	r2, #0x0
 8007eec: 715a         	strb	r2, [r3, #0x5]
;     switch (data->common.mode) {
 8007eee: 6a7b         	ldr	r3, [r7, #0x24]
 8007ef0: 7d1b         	ldrb	r3, [r3, #0x14]
 8007ef2: 2b02         	cmp	r3, #0x2
 8007ef4: f000 80a1    	beq.w	0x800803a <dm_motor_pack+0x17e> @ imm = #0x142
 8007ef8: 2b02         	cmp	r3, #0x2
 8007efa: f300 80b2    	bgt.w	0x8008062 <dm_motor_pack+0x1a6> @ imm = #0x164
 8007efe: 2b00         	cmp	r3, #0x0
 8007f00: d002         	beq	0x8007f08 <dm_motor_pack+0x4c> @ imm = #0x4
 8007f02: 2b01         	cmp	r3, #0x1
 8007f04: d072         	beq	0x8007fec <dm_motor_pack+0x130> @ imm = #0xe4
;     default: break;
 8007f06: e0ac         	b	0x8008062 <dm_motor_pack+0x1a6> @ imm = #0x158
;         pos_tmp = float_to_uint(data->target_angle, -cfg->p_max, cfg->p_max, 16);
 8007f08: 6a7b         	ldr	r3, [r7, #0x24]
 8007f0a: 6a58         	ldr	r0, [r3, #0x24]
 8007f0c: 6a3b         	ldr	r3, [r7, #0x20]
 8007f0e: 6d9b         	ldr	r3, [r3, #0x58]
 8007f10: f083 4100    	eor	r1, r3, #0x80000000
 8007f14: 6a3b         	ldr	r3, [r7, #0x20]
 8007f16: 6d9a         	ldr	r2, [r3, #0x58]
 8007f18: 2310         	movs	r3, #0x10
 8007f1a: f00a fcb4    	bl	0x8012886 <float_to_uint> @ imm = #0xa968
 8007f1e: 4603         	mov	r3, r0
 8007f20: 82fb         	strh	r3, [r7, #0x16]
;         vel_tmp = float_to_uint(data->target_rpm, -cfg->v_max, cfg->v_max, 12);
 8007f22: 6a7b         	ldr	r3, [r7, #0x24]
 8007f24: 6a98         	ldr	r0, [r3, #0x28]
 8007f26: 6a3b         	ldr	r3, [r7, #0x20]
 8007f28: 6d5b         	ldr	r3, [r3, #0x54]
 8007f2a: f083 4100    	eor	r1, r3, #0x80000000
 8007f2e: 6a3b         	ldr	r3, [r7, #0x20]
 8007f30: 6d5a         	ldr	r2, [r3, #0x54]
 8007f32: 230c         	movs	r3, #0xc
 8007f34: f00a fca7    	bl	0x8012886 <float_to_uint> @ imm = #0xa94e
 8007f38: 4603         	mov	r3, r0
 8007f3a: 82bb         	strh	r3, [r7, #0x14]
;         tor_tmp = float_to_uint(data->target_torque, -cfg->t_max, cfg->t_max, 12);
 8007f3c: 6a7b         	ldr	r3, [r7, #0x24]
 8007f3e: 6ad8         	ldr	r0, [r3, #0x2c]
 8007f40: 6a3b         	ldr	r3, [r7, #0x20]
 8007f42: 6ddb         	ldr	r3, [r3, #0x5c]
 8007f44: f083 4100    	eor	r1, r3, #0x80000000
 8007f48: 6a3b         	ldr	r3, [r7, #0x20]
 8007f4a: 6dda         	ldr	r2, [r3, #0x5c]
 8007f4c: 230c         	movs	r3, #0xc
 8007f4e: f00a fc9a    	bl	0x8012886 <float_to_uint> @ imm = #0xa934
 8007f52: 4603         	mov	r3, r0
 8007f54: 827b         	strh	r3, [r7, #0x12]
;         kp_tmp  = float_to_uint(data->params.k_p, 0, 500, 12);
 8007f56: 6a7b         	ldr	r3, [r7, #0x24]
 8007f58: 6b18         	ldr	r0, [r3, #0x30]
 8007f5a: 230c         	movs	r3, #0xc
 8007f5c: 4a43         	ldr	r2, [pc, #0x10c]        @ 0x800806c <dm_motor_pack+0x1b0>
 8007f5e: f04f 0100    	mov.w	r1, #0x0
 8007f62: f00a fc90    	bl	0x8012886 <float_to_uint> @ imm = #0xa920
 8007f66: 4603         	mov	r3, r0
 8007f68: 823b         	strh	r3, [r7, #0x10]
;         kd_tmp  = float_to_uint(data->params.k_d, 0, 5, 12);
 8007f6a: 6a7b         	ldr	r3, [r7, #0x24]
 8007f6c: 6b98         	ldr	r0, [r3, #0x38]
 8007f6e: 230c         	movs	r3, #0xc
 8007f70: 4a3f         	ldr	r2, [pc, #0xfc]         @ 0x8008070 <dm_motor_pack+0x1b4>
 8007f72: f04f 0100    	mov.w	r1, #0x0
 8007f76: f00a fc86    	bl	0x8012886 <float_to_uint> @ imm = #0xa90c
 8007f7a: 4603         	mov	r3, r0
 8007f7c: 81fb         	strh	r3, [r7, #0xe]
;         frame->data[0] = (pos_tmp >> 8);
 8007f7e: 8afb         	ldrh	r3, [r7, #0x16]
 8007f80: 0a1b         	lsrs	r3, r3, #0x8
 8007f82: b29b         	uxth	r3, r3
 8007f84: b2da         	uxtb	r2, r3
 8007f86: 683b         	ldr	r3, [r7]
 8007f88: 721a         	strb	r2, [r3, #0x8]
;         frame->data[1] = pos_tmp;
 8007f8a: 8afb         	ldrh	r3, [r7, #0x16]
 8007f8c: b2da         	uxtb	r2, r3
 8007f8e: 683b         	ldr	r3, [r7]
 8007f90: 725a         	strb	r2, [r3, #0x9]
;         frame->data[2] = (vel_tmp >> 4);
 8007f92: 8abb         	ldrh	r3, [r7, #0x14]
 8007f94: 091b         	lsrs	r3, r3, #0x4
 8007f96: b29b         	uxth	r3, r3
 8007f98: b2da         	uxtb	r2, r3
 8007f9a: 683b         	ldr	r3, [r7]
 8007f9c: 729a         	strb	r2, [r3, #0xa]
;         frame->data[3] = ((vel_tmp & 0xF) << 4) | (kp_tmp >> 8);
 8007f9e: 8abb         	ldrh	r3, [r7, #0x14]
 8007fa0: 011b         	lsls	r3, r3, #0x4
 8007fa2: b25a         	sxtb	r2, r3
 8007fa4: 8a3b         	ldrh	r3, [r7, #0x10]
 8007fa6: 0a1b         	lsrs	r3, r3, #0x8
 8007fa8: b29b         	uxth	r3, r3
 8007faa: b25b         	sxtb	r3, r3
 8007fac: 4313         	orrs	r3, r2
 8007fae: b25b         	sxtb	r3, r3
 8007fb0: b2da         	uxtb	r2, r3
 8007fb2: 683b         	ldr	r3, [r7]
 8007fb4: 72da         	strb	r2, [r3, #0xb]
;         frame->data[4] = kp_tmp;
 8007fb6: 8a3b         	ldrh	r3, [r7, #0x10]
 8007fb8: b2da         	uxtb	r2, r3
 8007fba: 683b         	ldr	r3, [r7]
 8007fbc: 731a         	strb	r2, [r3, #0xc]
;         frame->data[5] = (kd_tmp >> 4);
 8007fbe: 89fb         	ldrh	r3, [r7, #0xe]
 8007fc0: 091b         	lsrs	r3, r3, #0x4
 8007fc2: b29b         	uxth	r3, r3
 8007fc4: b2da         	uxtb	r2, r3
 8007fc6: 683b         	ldr	r3, [r7]
 8007fc8: 735a         	strb	r2, [r3, #0xd]
;         frame->data[6] = ((kd_tmp & 0xF) << 4) | (tor_tmp >> 8);
 8007fca: 89fb         	ldrh	r3, [r7, #0xe]
 8007fcc: 011b         	lsls	r3, r3, #0x4
 8007fce: b25a         	sxtb	r2, r3
 8007fd0: 8a7b         	ldrh	r3, [r7, #0x12]
 8007fd2: 0a1b         	lsrs	r3, r3, #0x8
 8007fd4: b29b         	uxth	r3, r3
 8007fd6: b25b         	sxtb	r3, r3
 8007fd8: 4313         	orrs	r3, r2
 8007fda: b25b         	sxtb	r3, r3
 8007fdc: b2da         	uxtb	r2, r3
 8007fde: 683b         	ldr	r3, [r7]
 8007fe0: 739a         	strb	r2, [r3, #0xe]
;         frame->data[7] = tor_tmp;
 8007fe2: 8a7b         	ldrh	r3, [r7, #0x12]
 8007fe4: b2da         	uxtb	r2, r3
 8007fe6: 683b         	ldr	r3, [r7]
 8007fe8: 73da         	strb	r2, [r3, #0xf]
;         break;
 8007fea: e03b         	b	0x8008064 <dm_motor_pack+0x1a8> @ imm = #0x76
;         pbuf = (uint8_t *)&data->target_angle;
 8007fec: 6a7b         	ldr	r3, [r7, #0x24]
 8007fee: 3324         	adds	r3, #0x24
 8007ff0: 61bb         	str	r3, [r7, #0x18]
;         vbuf = (uint8_t *)&data->target_rpm;
 8007ff2: 6a7b         	ldr	r3, [r7, #0x24]
 8007ff4: 3328         	adds	r3, #0x28
 8007ff6: 61fb         	str	r3, [r7, #0x1c]
;         frame->data[0] = *pbuf;
 8007ff8: 69bb         	ldr	r3, [r7, #0x18]
 8007ffa: 781a         	ldrb	r2, [r3]
 8007ffc: 683b         	ldr	r3, [r7]
 8007ffe: 721a         	strb	r2, [r3, #0x8]
;         frame->data[1] = *(pbuf + 1);
 8008000: 69bb         	ldr	r3, [r7, #0x18]
 8008002: 785a         	ldrb	r2, [r3, #0x1]
 8008004: 683b         	ldr	r3, [r7]
 8008006: 725a         	strb	r2, [r3, #0x9]
;         frame->data[2] = *(pbuf + 2);
 8008008: 69bb         	ldr	r3, [r7, #0x18]
 800800a: 789a         	ldrb	r2, [r3, #0x2]
 800800c: 683b         	ldr	r3, [r7]
 800800e: 729a         	strb	r2, [r3, #0xa]
;         frame->data[3] = *(pbuf + 3);
 8008010: 69bb         	ldr	r3, [r7, #0x18]
 8008012: 78da         	ldrb	r2, [r3, #0x3]
 8008014: 683b         	ldr	r3, [r7]
 8008016: 72da         	strb	r2, [r3, #0xb]
;         frame->data[4] = *vbuf;
 8008018: 69fb         	ldr	r3, [r7, #0x1c]
 800801a: 781a         	ldrb	r2, [r3]
 800801c: 683b         	ldr	r3, [r7]
 800801e: 731a         	strb	r2, [r3, #0xc]
;         frame->data[5] = *(vbuf + 1);
 8008020: 69fb         	ldr	r3, [r7, #0x1c]
 8008022: 785a         	ldrb	r2, [r3, #0x1]
 8008024: 683b         	ldr	r3, [r7]
 8008026: 735a         	strb	r2, [r3, #0xd]
;         frame->data[6] = *(vbuf + 2);
 8008028: 69fb         	ldr	r3, [r7, #0x1c]
 800802a: 789a         	ldrb	r2, [r3, #0x2]
 800802c: 683b         	ldr	r3, [r7]
 800802e: 739a         	strb	r2, [r3, #0xe]
;         frame->data[7] = *(vbuf + 3);
 8008030: 69fb         	ldr	r3, [r7, #0x1c]
 8008032: 78da         	ldrb	r2, [r3, #0x3]
 8008034: 683b         	ldr	r3, [r7]
 8008036: 73da         	strb	r2, [r3, #0xf]
;         break;
 8008038: e014         	b	0x8008064 <dm_motor_pack+0x1a8> @ imm = #0x28
;         vbuf = (uint8_t *)&data->target_rpm;
 800803a: 6a7b         	ldr	r3, [r7, #0x24]
 800803c: 3328         	adds	r3, #0x28
 800803e: 61fb         	str	r3, [r7, #0x1c]
;         frame->data[0] = *vbuf;
 8008040: 69fb         	ldr	r3, [r7, #0x1c]
 8008042: 781a         	ldrb	r2, [r3]
 8008044: 683b         	ldr	r3, [r7]
 8008046: 721a         	strb	r2, [r3, #0x8]
;         frame->data[1] = *(vbuf + 1);
 8008048: 69fb         	ldr	r3, [r7, #0x1c]
 800804a: 785a         	ldrb	r2, [r3, #0x1]
 800804c: 683b         	ldr	r3, [r7]
 800804e: 725a         	strb	r2, [r3, #0x9]
;         frame->data[2] = *(vbuf + 2);
 8008050: 69fb         	ldr	r3, [r7, #0x1c]
 8008052: 789a         	ldrb	r2, [r3, #0x2]
 8008054: 683b         	ldr	r3, [r7]
 8008056: 729a         	strb	r2, [r3, #0xa]
;         frame->data[3] = *(vbuf + 3);
 8008058: 69fb         	ldr	r3, [r7, #0x1c]
 800805a: 78da         	ldrb	r2, [r3, #0x3]
 800805c: 683b         	ldr	r3, [r7]
 800805e: 72da         	strb	r2, [r3, #0xb]
;         break;
 8008060: e000         	b	0x8008064 <dm_motor_pack+0x1a8> @ imm = #0x0
;     default: break;
 8008062: bf00         	nop
; }
 8008064: bf00         	nop
 8008066: 3728         	adds	r7, #0x28
 8008068: 46bd         	mov	sp, r7
 800806a: bd80         	pop	{r7, pc}

0800806c <$d>:
 800806c: 00 00 fa 43  	.word	0x43fa0000
 8008070: 00 00 a0 40  	.word	0x40a00000

08008074 <dm_motor_set_mode>:
; int dm_motor_set_mode(const struct device *dev, enum motor_mode mode) {
 8008074: b580         	push	{r7, lr}
 8008076: b08a         	sub	sp, #0x28
 8008078: af00         	add	r7, sp, #0x0
 800807a: 6078         	str	r0, [r7, #0x4]
 800807c: 460b         	mov	r3, r1
 800807e: 70fb         	strb	r3, [r7, #0x3]
;     struct dm_motor_data         *data = dev->data;
 8008080: 687b         	ldr	r3, [r7, #0x4]
 8008082: 691b         	ldr	r3, [r3, #0x10]
 8008084: 623b         	str	r3, [r7, #0x20]
;     const struct dm_motor_config *cfg  = dev->config;
 8008086: 687b         	ldr	r3, [r7, #0x4]
 8008088: 685b         	ldr	r3, [r3, #0x4]
 800808a: 61fb         	str	r3, [r7, #0x1c]
;     data->common.mode = mode;
 800808c: 6a3b         	ldr	r3, [r7, #0x20]
 800808e: 78fa         	ldrb	r2, [r7, #0x3]
 8008090: 751a         	strb	r2, [r3, #0x14]
;     switch (mode) {
 8008092: 78fb         	ldrb	r3, [r7, #0x3]
 8008094: 2b03         	cmp	r3, #0x3
 8008096: d835         	bhi	0x8008104 <dm_motor_set_mode+0x90> @ imm = #0x6a
 8008098: a201         	adr	r2, #4 <dm_motor_set_mode+0x29>
 800809a: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]
 800809e: bf00         	nop

080080a0 <$d>:
 80080a0: b1 80 00 08  	.word	0x080080b1
 80080a4: c1 80 00 08  	.word	0x080080c1
 80080a8: dd 80 00 08  	.word	0x080080dd
 80080ac: f9 80 00 08  	.word	0x080080f9

080080b0 <$t>:
;         strcpy(mode_str, "mit");
 80080b0: f107 030c    	add.w	r3, r7, #0xc
 80080b4: 4a32         	ldr	r2, [pc, #0xc8]         @ 0x8008180 <dm_motor_set_mode+0x10c>
 80080b6: 601a         	str	r2, [r3]
;         data->tx_offset = 0x0;
 80080b8: 6a3b         	ldr	r3, [r7, #0x20]
 80080ba: 2200         	movs	r2, #0x0
 80080bc: 619a         	str	r2, [r3, #0x18]
;         break;
 80080be: e022         	b	0x8008106 <dm_motor_set_mode+0x92> @ imm = #0x44
;         strcpy(mode_str, "pv");
 80080c0: f107 030c    	add.w	r3, r7, #0xc
 80080c4: 4a2f         	ldr	r2, [pc, #0xbc]         @ 0x8008184 <dm_motor_set_mode+0x110>
 80080c6: 6812         	ldr	r2, [r2]
 80080c8: 4611         	mov	r1, r2
 80080ca: 8019         	strh	r1, [r3]
 80080cc: 3302         	adds	r3, #0x2
 80080ce: 0c12         	lsrs	r2, r2, #0x10
 80080d0: 701a         	strb	r2, [r3]
;         data->tx_offset = 0x100;
 80080d2: 6a3b         	ldr	r3, [r7, #0x20]
 80080d4: f44f 7280    	mov.w	r2, #0x100
 80080d8: 619a         	str	r2, [r3, #0x18]
;         break;
 80080da: e014         	b	0x8008106 <dm_motor_set_mode+0x92> @ imm = #0x28
;         strcpy(mode_str, "vo");
 80080dc: f107 030c    	add.w	r3, r7, #0xc
 80080e0: 4a29         	ldr	r2, [pc, #0xa4]         @ 0x8008188 <dm_motor_set_mode+0x114>
 80080e2: 6812         	ldr	r2, [r2]
 80080e4: 4611         	mov	r1, r2
 80080e6: 8019         	strh	r1, [r3]
 80080e8: 3302         	adds	r3, #0x2
 80080ea: 0c12         	lsrs	r2, r2, #0x10
 80080ec: 701a         	strb	r2, [r3]
;         data->tx_offset = 0x200;
 80080ee: 6a3b         	ldr	r3, [r7, #0x20]
 80080f0: f44f 7200    	mov.w	r2, #0x200
 80080f4: 619a         	str	r2, [r3, #0x18]
;         break;
 80080f6: e006         	b	0x8008106 <dm_motor_set_mode+0x92> @ imm = #0xc
;         data->online = false;
 80080f8: 6a3b         	ldr	r3, [r7, #0x20]
 80080fa: 2200         	movs	r2, #0x0
 80080fc: 771a         	strb	r2, [r3, #0x1c]
;         return -ENOSYS;
 80080fe: f06f 0357    	mvn	r3, #0x57
 8008102: e039         	b	0x8008178 <dm_motor_set_mode+0x104> @ imm = #0x72
;     default: break;
 8008104: bf00         	nop
;     for (int i = 0; i < SIZE_OF_ARRAY(cfg->common.controller); i++) {
 8008106: 2300         	movs	r3, #0x0
 8008108: 627b         	str	r3, [r7, #0x24]
 800810a: e02f         	b	0x800816c <dm_motor_set_mode+0xf8> @ imm = #0x5e
;         if (cfg->common.controller[i] == NULL)
 800810c: 69fb         	ldr	r3, [r7, #0x1c]
 800810e: 6a7a         	ldr	r2, [r7, #0x24]
 8008110: 3204         	adds	r2, #0x4
 8008112: f853 3022    	ldr.w	r3, [r3, r2, lsl #2]
 8008116: 2b00         	cmp	r3, #0x0
 8008118: d02c         	beq	0x8008174 <dm_motor_set_mode+0x100> @ imm = #0x58
;         if (strcmp(cfg->common.capabilities[i], mode_str) == 0) {
 800811a: 6a7a         	ldr	r2, [r7, #0x24]
 800811c: 4613         	mov	r3, r2
 800811e: 005b         	lsls	r3, r3, #0x1
 8008120: 4413         	add	r3, r2
 8008122: 009b         	lsls	r3, r3, #0x2
 8008124: 3320         	adds	r3, #0x20
 8008126: 69fa         	ldr	r2, [r7, #0x1c]
 8008128: 4413         	add	r3, r2
 800812a: f107 020c    	add.w	r2, r7, #0xc
 800812e: 4611         	mov	r1, r2
 8008130: 4618         	mov	r0, r3
 8008132: f7f8 fb3d    	bl	0x80007b0 <strcmp>      @ imm = #-0x7986
 8008136: 4603         	mov	r3, r0
 8008138: 2b00         	cmp	r3, #0x0
 800813a: d114         	bne	0x8008166 <dm_motor_set_mode+0xf2> @ imm = #0x28
;             const struct pid_single_config *params = pid_get_params(cfg->common.controller[i]);
 800813c: 69fb         	ldr	r3, [r7, #0x1c]
 800813e: 6a7a         	ldr	r2, [r7, #0x24]
 8008140: 3204         	adds	r2, #0x4
 8008142: f853 3022    	ldr.w	r3, [r3, r2, lsl #2]
 8008146: 4618         	mov	r0, r3
 8008148: f00a fb1f    	bl	0x801278a <pid_get_params> @ imm = #0xa63e
 800814c: 61b8         	str	r0, [r7, #0x18]
;             data->common.mode = mode;
 800814e: 6a3b         	ldr	r3, [r7, #0x20]
 8008150: 78fa         	ldrb	r2, [r7, #0x3]
 8008152: 751a         	strb	r2, [r3, #0x14]
;             data->params.k_p  = params->k_p;
 8008154: 69bb         	ldr	r3, [r7, #0x18]
 8008156: 681a         	ldr	r2, [r3]
 8008158: 6a3b         	ldr	r3, [r7, #0x20]
 800815a: 631a         	str	r2, [r3, #0x30]
;             data->params.k_d  = params->k_d;
 800815c: 69bb         	ldr	r3, [r7, #0x18]
 800815e: 689a         	ldr	r2, [r3, #0x8]
 8008160: 6a3b         	ldr	r3, [r7, #0x20]
 8008162: 639a         	str	r2, [r3, #0x38]
;             break;
 8008164: e007         	b	0x8008176 <dm_motor_set_mode+0x102> @ imm = #0xe
;     for (int i = 0; i < SIZE_OF_ARRAY(cfg->common.controller); i++) {
 8008166: 6a7b         	ldr	r3, [r7, #0x24]
 8008168: 3301         	adds	r3, #0x1
 800816a: 627b         	str	r3, [r7, #0x24]
 800816c: 6a7b         	ldr	r3, [r7, #0x24]
 800816e: 2b03         	cmp	r3, #0x3
 8008170: d9cc         	bls	0x800810c <dm_motor_set_mode+0x98> @ imm = #-0x68
 8008172: e000         	b	0x8008176 <dm_motor_set_mode+0x102> @ imm = #0x0
;             break;
 8008174: bf00         	nop
;     return 0;
 8008176: 2300         	movs	r3, #0x0
; }
 8008178: 4618         	mov	r0, r3
 800817a: 3728         	adds	r7, #0x28
 800817c: 46bd         	mov	sp, r7
 800817e: bd80         	pop	{r7, pc}

08008180 <$d>:
 8008180: 6d 69 74 00  	.word	0x0074696d
 8008184: 24 5b 01 08  	.word	0x08015b24
 8008188: 28 5b 01 08  	.word	0x08015b28

0800818c <get_motor_id>:
; int get_motor_id(int id) {
 800818c: b480         	push	{r7}
 800818e: b087         	sub	sp, #0x1c
 8008190: af00         	add	r7, sp, #0x0
 8008192: 6078         	str	r0, [r7, #0x4]
;     for (int i = 0; i < MOTOR_COUNT; i++) {
 8008194: 2300         	movs	r3, #0x0
 8008196: 617b         	str	r3, [r7, #0x14]
 8008198: e011         	b	0x80081be <get_motor_id+0x32> @ imm = #0x22
;         const struct device          *dev = motor_devices[i];
 800819a: 4a0e         	ldr	r2, [pc, #0x38]         @ 0x80081d4 <get_motor_id+0x48>
 800819c: 697b         	ldr	r3, [r7, #0x14]
 800819e: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 80081a2: 613b         	str	r3, [r7, #0x10]
;         const struct dm_motor_config *cfg = (const struct dm_motor_config *)(dev->config);
 80081a4: 693b         	ldr	r3, [r7, #0x10]
 80081a6: 685b         	ldr	r3, [r3, #0x4]
 80081a8: 60fb         	str	r3, [r7, #0xc]
;         if (cfg->common.rx_id == id) {
 80081aa: 68fb         	ldr	r3, [r7, #0xc]
 80081ac: 68db         	ldr	r3, [r3, #0xc]
 80081ae: 687a         	ldr	r2, [r7, #0x4]
 80081b0: 429a         	cmp	r2, r3
 80081b2: d101         	bne	0x80081b8 <get_motor_id+0x2c> @ imm = #0x2
;             return i;
 80081b4: 697b         	ldr	r3, [r7, #0x14]
 80081b6: e007         	b	0x80081c8 <get_motor_id+0x3c> @ imm = #0xe
;     for (int i = 0; i < MOTOR_COUNT; i++) {
 80081b8: 697b         	ldr	r3, [r7, #0x14]
 80081ba: 3301         	adds	r3, #0x1
 80081bc: 617b         	str	r3, [r7, #0x14]
 80081be: 697b         	ldr	r3, [r7, #0x14]
 80081c0: 2b00         	cmp	r3, #0x0
 80081c2: ddea         	ble	0x800819a <get_motor_id+0xe> @ imm = #-0x2c
;     return -1;
 80081c4: f04f 33ff    	mov.w	r3, #0xffffffff
; }
 80081c8: 4618         	mov	r0, r3
 80081ca: 371c         	adds	r7, #0x1c
 80081cc: 46bd         	mov	sp, r7
 80081ce: bc80         	pop	{r7}
 80081d0: 4770         	bx	lr
 80081d2: bf00         	nop

080081d4 <$d>:
 80081d4: cc 00 00 20  	.word	0x200000cc

080081d8 <dm_motor_ctrl_entry>:
; static void dm_motor_ctrl_entry(void *arg1, void *arg2, void *arg3) {
 80081d8: b590         	push	{r4, r7, lr}
 80081da: b0bf         	sub	sp, #0xfc
 80081dc: af04         	add	r7, sp, #0x10
 80081de: 60f8         	str	r0, [r7, #0xc]
 80081e0: 60b9         	str	r1, [r7, #0x8]
 80081e2: 607a         	str	r2, [r7, #0x4]
;     LOG_ERR("DM motor control thread started");
 80081e4: 2304         	movs	r3, #0x4
 80081e6: 2b00         	cmp	r3, #0x0
 80081e8: d019         	beq	0x800821e <dm_motor_ctrl_entry+0x46> @ imm = #0x32
 80081ea: 2301         	movs	r3, #0x1
 80081ec: f887 30d3    	strb.w	r3, [r7, #0xd3]
 80081f0: f897 30d3    	ldrb.w	r3, [r7, #0xd3]
 80081f4: f083 0301    	eor	r3, r3, #0x1
 80081f8: b2db         	uxtb	r3, r3
 80081fa: 2b00         	cmp	r3, #0x0
 80081fc: d10f         	bne	0x800821e <dm_motor_ctrl_entry+0x46> @ imm = #0x1e
 80081fe: 4bbb         	ldr	r3, [pc, #0x2ec]        @ 0x80084ec <dm_motor_ctrl_entry+0x314>
 8008200: 6819         	ldr	r1, [r3]
 8008202: 4bbb         	ldr	r3, [pc, #0x2ec]        @ 0x80084f0 <dm_motor_ctrl_entry+0x318>
 8008204: 9302         	str	r3, [sp, #0x8]
 8008206: 2300         	movs	r3, #0x0
 8008208: 9301         	str	r3, [sp, #0x4]
 800820a: 2300         	movs	r3, #0x0
 800820c: 9300         	str	r3, [sp]
 800820e: 2300         	movs	r3, #0x0
 8008210: 2201         	movs	r2, #0x1
 8008212: 2000         	movs	r0, #0x0
 8008214: f00a fa85    	bl	0x8012722 <z_log_msg_runtime_create> @ imm = #0xa50a
 8008218: 2300         	movs	r3, #0x0
 800821a: f8c7 30cc    	str.w	r3, [r7, #0xcc]
;     for (int i = 0; i < MOTOR_COUNT; i++) {
 800821e: 2300         	movs	r3, #0x0
 8008220: f8c7 30d8    	str.w	r3, [r7, #0xd8]
 8008224: e059         	b	0x80082da <dm_motor_ctrl_entry+0x102> @ imm = #0xb2
;         int                           can_id = 0;
 8008226: 2300         	movs	r3, #0x0
 8008228: f8c7 30d4    	str.w	r3, [r7, #0xd4]
;             (const struct dm_motor_config *)(motor_devices[i]->config);
 800822c: 4ab1         	ldr	r2, [pc, #0x2c4]        @ 0x80084f4 <dm_motor_ctrl_entry+0x31c>
 800822e: f8d7 30d8    	ldr.w	r3, [r7, #0xd8]
 8008232: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
;         const struct dm_motor_config *cfg =
 8008236: 685b         	ldr	r3, [r3, #0x4]
 8008238: 667b         	str	r3, [r7, #0x64]
;         for (int j = 0; j < CAN_COUNT; j++) {
 800823a: 2300         	movs	r3, #0x0
 800823c: f8c7 30e0    	str.w	r3, [r7, #0xe0]
 8008240: e012         	b	0x8008268 <dm_motor_ctrl_entry+0x90> @ imm = #0x24
;             if (can_devices[j] == cfg->common.phy) {
 8008242: 4aad         	ldr	r2, [pc, #0x2b4]        @ 0x80084f8 <dm_motor_ctrl_entry+0x320>
 8008244: f8d7 30e0    	ldr.w	r3, [r7, #0xe0]
 8008248: f852 2023    	ldr.w	r2, [r2, r3, lsl #2]
 800824c: 6e7b         	ldr	r3, [r7, #0x64]
 800824e: 681b         	ldr	r3, [r3]
 8008250: 429a         	cmp	r2, r3
 8008252: d104         	bne	0x800825e <dm_motor_ctrl_entry+0x86> @ imm = #0x8
;                 can_id = j;
 8008254: f8d7 30e0    	ldr.w	r3, [r7, #0xe0]
 8008258: f8c7 30d4    	str.w	r3, [r7, #0xd4]
;                 break;
 800825c: e008         	b	0x8008270 <dm_motor_ctrl_entry+0x98> @ imm = #0x10
;         for (int j = 0; j < CAN_COUNT; j++) {
 800825e: f8d7 30e0    	ldr.w	r3, [r7, #0xe0]
 8008262: 3301         	adds	r3, #0x1
 8008264: f8c7 30e0    	str.w	r3, [r7, #0xe0]
 8008268: f8d7 30e0    	ldr.w	r3, [r7, #0xe0]
 800826c: 2b01         	cmp	r3, #0x1
 800826e: dde8         	ble	0x8008242 <dm_motor_ctrl_entry+0x6a> @ imm = #-0x30
;         filters[can_id].id &= cfg->common.rx_id & 0xFF;
 8008270: 49a2         	ldr	r1, [pc, #0x288]        @ 0x80084fc <dm_motor_ctrl_entry+0x324>
 8008272: f8d7 20d4    	ldr.w	r2, [r7, #0xd4]
 8008276: 4613         	mov	r3, r2
 8008278: 005b         	lsls	r3, r3, #0x1
 800827a: 4413         	add	r3, r2
 800827c: 009b         	lsls	r3, r3, #0x2
 800827e: 440b         	add	r3, r1
 8008280: 681b         	ldr	r3, [r3]
 8008282: 6e7a         	ldr	r2, [r7, #0x64]
 8008284: 68d2         	ldr	r2, [r2, #0xc]
 8008286: 4013         	ands	r3, r2
 8008288: b2d9         	uxtb	r1, r3
 800828a: 489c         	ldr	r0, [pc, #0x270]        @ 0x80084fc <dm_motor_ctrl_entry+0x324>
 800828c: f8d7 20d4    	ldr.w	r2, [r7, #0xd4]
 8008290: 4613         	mov	r3, r2
 8008292: 005b         	lsls	r3, r3, #0x1
 8008294: 4413         	add	r3, r2
 8008296: 009b         	lsls	r3, r3, #0x2
 8008298: 4403         	add	r3, r0
 800829a: 6019         	str	r1, [r3]
;         filters[can_id].mask = ~(filters[can_id].mask ^ (cfg->common.rx_id & 0xFF)) & 0xFF;
 800829c: 4997         	ldr	r1, [pc, #0x25c]        @ 0x80084fc <dm_motor_ctrl_entry+0x324>
 800829e: f8d7 20d4    	ldr.w	r2, [r7, #0xd4]
 80082a2: 4613         	mov	r3, r2
 80082a4: 005b         	lsls	r3, r3, #0x1
 80082a6: 4413         	add	r3, r2
 80082a8: 009b         	lsls	r3, r3, #0x2
 80082aa: 440b         	add	r3, r1
 80082ac: 3304         	adds	r3, #0x4
 80082ae: 681a         	ldr	r2, [r3]
 80082b0: 6e7b         	ldr	r3, [r7, #0x64]
 80082b2: 68db         	ldr	r3, [r3, #0xc]
 80082b4: b2db         	uxtb	r3, r3
 80082b6: 4053         	eors	r3, r2
 80082b8: 43db         	mvns	r3, r3
 80082ba: b2d9         	uxtb	r1, r3
 80082bc: 488f         	ldr	r0, [pc, #0x23c]        @ 0x80084fc <dm_motor_ctrl_entry+0x324>
 80082be: f8d7 20d4    	ldr.w	r2, [r7, #0xd4]
 80082c2: 4613         	mov	r3, r2
 80082c4: 005b         	lsls	r3, r3, #0x1
 80082c6: 4413         	add	r3, r2
 80082c8: 009b         	lsls	r3, r3, #0x2
 80082ca: 4403         	add	r3, r0
 80082cc: 3304         	adds	r3, #0x4
 80082ce: 6019         	str	r1, [r3]
;     for (int i = 0; i < MOTOR_COUNT; i++) {
 80082d0: f8d7 30d8    	ldr.w	r3, [r7, #0xd8]
 80082d4: 3301         	adds	r3, #0x1
 80082d6: f8c7 30d8    	str.w	r3, [r7, #0xd8]
 80082da: f8d7 30d8    	ldr.w	r3, [r7, #0xd8]
 80082de: 2b00         	cmp	r3, #0x0
 80082e0: dda1         	ble	0x8008226 <dm_motor_ctrl_entry+0x4e> @ imm = #-0xbe
;     for (int i = 0; i < CAN_COUNT; i++) {
 80082e2: 2300         	movs	r3, #0x0
 80082e4: f8c7 30dc    	str.w	r3, [r7, #0xdc]
 80082e8: e052         	b	0x8008390 <dm_motor_ctrl_entry+0x1b8> @ imm = #0xa4
;         filters[i].mask |= 0x700;
 80082ea: 4984         	ldr	r1, [pc, #0x210]        @ 0x80084fc <dm_motor_ctrl_entry+0x324>
 80082ec: f8d7 20dc    	ldr.w	r2, [r7, #0xdc]
 80082f0: 4613         	mov	r3, r2
 80082f2: 005b         	lsls	r3, r3, #0x1
 80082f4: 4413         	add	r3, r2
 80082f6: 009b         	lsls	r3, r3, #0x2
 80082f8: 440b         	add	r3, r1
 80082fa: 3304         	adds	r3, #0x4
 80082fc: 681b         	ldr	r3, [r3]
 80082fe: f443 61e0    	orr	r1, r3, #0x700
 8008302: 487e         	ldr	r0, [pc, #0x1f8]        @ 0x80084fc <dm_motor_ctrl_entry+0x324>
 8008304: f8d7 20dc    	ldr.w	r2, [r7, #0xdc]
 8008308: 4613         	mov	r3, r2
 800830a: 005b         	lsls	r3, r3, #0x1
 800830c: 4413         	add	r3, r2
 800830e: 009b         	lsls	r3, r3, #0x2
 8008310: 4403         	add	r3, r0
 8008312: 3304         	adds	r3, #0x4
 8008314: 6019         	str	r1, [r3]
;         const struct device *can_dev = can_devices[i];
 8008316: 4a78         	ldr	r2, [pc, #0x1e0]        @ 0x80084f8 <dm_motor_ctrl_entry+0x320>
 8008318: f8d7 30dc    	ldr.w	r3, [r7, #0xdc]
 800831c: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 8008320: 677b         	str	r3, [r7, #0x74]
;         can_start(can_dev);
 8008322: 6f78         	ldr	r0, [r7, #0x74]
 8008324: f00a fa4d    	bl	0x80127c2 <can_start>   @ imm = #0xa49a
;         int err = can_add_rx_filter_msgq(can_dev, &dm_can_rx_msgq, &filters[i]);
 8008328: f8d7 20dc    	ldr.w	r2, [r7, #0xdc]
 800832c: 4613         	mov	r3, r2
 800832e: 005b         	lsls	r3, r3, #0x1
 8008330: 4413         	add	r3, r2
 8008332: 009b         	lsls	r3, r3, #0x2
 8008334: 4a71         	ldr	r2, [pc, #0x1c4]        @ 0x80084fc <dm_motor_ctrl_entry+0x324>
 8008336: 4413         	add	r3, r2
 8008338: 461a         	mov	r2, r3
 800833a: 4971         	ldr	r1, [pc, #0x1c4]        @ 0x8008500 <dm_motor_ctrl_entry+0x328>
 800833c: 6f78         	ldr	r0, [r7, #0x74]
 800833e: f00a fa62    	bl	0x8012806 <can_add_rx_filter_msgq> @ imm = #0xa4c4
 8008342: 6738         	str	r0, [r7, #0x70]
;         if (err < 0)
 8008344: 6f3b         	ldr	r3, [r7, #0x70]
 8008346: 2b00         	cmp	r3, #0x0
 8008348: da1d         	bge	0x8008386 <dm_motor_ctrl_entry+0x1ae> @ imm = #0x3a
;             LOG_ERR("Error adding CAN filter (err %d)", err);
 800834a: 2304         	movs	r3, #0x4
 800834c: 2b00         	cmp	r3, #0x0
 800834e: d01a         	beq	0x8008386 <dm_motor_ctrl_entry+0x1ae> @ imm = #0x34
 8008350: 2301         	movs	r3, #0x1
 8008352: f887 306f    	strb.w	r3, [r7, #0x6f]
 8008356: f897 306f    	ldrb.w	r3, [r7, #0x6f]
 800835a: f083 0301    	eor	r3, r3, #0x1
 800835e: b2db         	uxtb	r3, r3
 8008360: 2b00         	cmp	r3, #0x0
 8008362: d110         	bne	0x8008386 <dm_motor_ctrl_entry+0x1ae> @ imm = #0x20
 8008364: 4b61         	ldr	r3, [pc, #0x184]        @ 0x80084ec <dm_motor_ctrl_entry+0x314>
 8008366: 6819         	ldr	r1, [r3]
 8008368: 6f3b         	ldr	r3, [r7, #0x70]
 800836a: 9303         	str	r3, [sp, #0xc]
 800836c: 4b65         	ldr	r3, [pc, #0x194]        @ 0x8008504 <dm_motor_ctrl_entry+0x32c>
 800836e: 9302         	str	r3, [sp, #0x8]
 8008370: 2300         	movs	r3, #0x0
 8008372: 9301         	str	r3, [sp, #0x4]
 8008374: 2300         	movs	r3, #0x0
 8008376: 9300         	str	r3, [sp]
 8008378: 2300         	movs	r3, #0x0
 800837a: 2201         	movs	r2, #0x1
 800837c: 2000         	movs	r0, #0x0
 800837e: f00a f9d0    	bl	0x8012722 <z_log_msg_runtime_create> @ imm = #0xa3a0
 8008382: 2300         	movs	r3, #0x0
 8008384: 66bb         	str	r3, [r7, #0x68]
;     for (int i = 0; i < CAN_COUNT; i++) {
 8008386: f8d7 30dc    	ldr.w	r3, [r7, #0xdc]
 800838a: 3301         	adds	r3, #0x1
 800838c: f8c7 30dc    	str.w	r3, [r7, #0xdc]
 8008390: f8d7 30dc    	ldr.w	r3, [r7, #0xdc]
 8008394: 2b01         	cmp	r3, #0x1
 8008396: dda8         	ble	0x80082ea <dm_motor_ctrl_entry+0x112> @ imm = #-0xb0
;         while (!k_msgq_get(&dm_can_rx_msgq, &rx_frame, K_MSEC(1))) {
 8008398: e10b         	b	0x80085b2 <dm_motor_ctrl_entry+0x3da> @ imm = #0x216
;             int id = get_motor_id(rx_frame.id);
 800839a: 6c7b         	ldr	r3, [r7, #0x44]
 800839c: 4618         	mov	r0, r3
 800839e: f7ff fef5    	bl	0x800818c <get_motor_id> @ imm = #-0x216
 80083a2: f8c7 00c8    	str.w	r0, [r7, #0xc8]
;             if (id == -1) {
 80083a6: f8d7 30c8    	ldr.w	r3, [r7, #0xc8]
 80083aa: f1b3 3fff    	cmp.w	r3, #0xffffffff
 80083ae: d120         	bne	0x80083f2 <dm_motor_ctrl_entry+0x21a> @ imm = #0x40
;                 LOG_ERR("Unknown motor ID: %d", rx_frame.id);
 80083b0: 2304         	movs	r3, #0x4
 80083b2: 2b00         	cmp	r3, #0x0
 80083b4: d01c         	beq	0x80083f0 <dm_motor_ctrl_entry+0x218> @ imm = #0x38
 80083b6: 2301         	movs	r3, #0x1
 80083b8: f887 30bb    	strb.w	r3, [r7, #0xbb]
 80083bc: f897 30bb    	ldrb.w	r3, [r7, #0xbb]
 80083c0: f083 0301    	eor	r3, r3, #0x1
 80083c4: b2db         	uxtb	r3, r3
 80083c6: 2b00         	cmp	r3, #0x0
 80083c8: d112         	bne	0x80083f0 <dm_motor_ctrl_entry+0x218> @ imm = #0x24
 80083ca: 4b48         	ldr	r3, [pc, #0x120]        @ 0x80084ec <dm_motor_ctrl_entry+0x314>
 80083cc: 6819         	ldr	r1, [r3]
 80083ce: 6c7b         	ldr	r3, [r7, #0x44]
 80083d0: 9303         	str	r3, [sp, #0xc]
 80083d2: 4b4d         	ldr	r3, [pc, #0x134]        @ 0x8008508 <dm_motor_ctrl_entry+0x330>
 80083d4: 9302         	str	r3, [sp, #0x8]
 80083d6: 2300         	movs	r3, #0x0
 80083d8: 9301         	str	r3, [sp, #0x4]
 80083da: 2300         	movs	r3, #0x0
 80083dc: 9300         	str	r3, [sp]
 80083de: 2300         	movs	r3, #0x0
 80083e0: 2201         	movs	r2, #0x1
 80083e2: 2000         	movs	r0, #0x0
 80083e4: f00a f99d    	bl	0x8012722 <z_log_msg_runtime_create> @ imm = #0xa33a
 80083e8: 2300         	movs	r3, #0x0
 80083ea: f8c7 30b4    	str.w	r3, [r7, #0xb4]
;                 break;
 80083ee: e0ed         	b	0x80085cc <dm_motor_ctrl_entry+0x3f4> @ imm = #0x1da
 80083f0: e0ec         	b	0x80085cc <dm_motor_ctrl_entry+0x3f4> @ imm = #0x1d8
;             struct dm_motor_data *data = (struct dm_motor_data *)(motor_devices[id]->data);
 80083f2: 4a40         	ldr	r2, [pc, #0x100]        @ 0x80084f4 <dm_motor_ctrl_entry+0x31c>
 80083f4: f8d7 30c8    	ldr.w	r3, [r7, #0xc8]
 80083f8: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 80083fc: 691b         	ldr	r3, [r3, #0x10]
 80083fe: f8c7 30c4    	str.w	r3, [r7, #0xc4]
;                 (const struct dm_motor_config *)(motor_devices[id]->config);
 8008402: 4a3c         	ldr	r2, [pc, #0xf0]         @ 0x80084f4 <dm_motor_ctrl_entry+0x31c>
 8008404: f8d7 30c8    	ldr.w	r3, [r7, #0xc8]
 8008408: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
;             const struct dm_motor_config *cfg =
 800840c: 685b         	ldr	r3, [r3, #0x4]
 800840e: f8c7 30c0    	str.w	r3, [r7, #0xc0]
;             data->missed_times--;
 8008412: f8d7 30c4    	ldr.w	r3, [r7, #0xc4]
 8008416: f993 301d    	ldrsb.w	r3, [r3, #0x1d]
 800841a: b2db         	uxtb	r3, r3
 800841c: 3b01         	subs	r3, #0x1
 800841e: b2db         	uxtb	r3, r3
 8008420: b25a         	sxtb	r2, r3
 8008422: f8d7 30c4    	ldr.w	r3, [r7, #0xc4]
 8008426: 775a         	strb	r2, [r3, #0x1d]
;             data->err = rx_frame.data[0] >> 4;
 8008428: f897 304c    	ldrb.w	r3, [r7, #0x4c]
 800842c: 091b         	lsrs	r3, r3, #0x4
 800842e: b2db         	uxtb	r3, r3
 8008430: b25a         	sxtb	r2, r3
 8008432: f8d7 30c4    	ldr.w	r3, [r7, #0xc4]
 8008436: 779a         	strb	r2, [r3, #0x1e]
;             float prev_angle   = data->common.angle;
 8008438: f8d7 30c4    	ldr.w	r3, [r7, #0xc4]
 800843c: 681b         	ldr	r3, [r3]
 800843e: f8c7 30bc    	str.w	r3, [r7, #0xbc]
;             data->common.angle = (uint_to_float((rx_frame.data[1] << 8) | rx_frame.data[2],
 8008442: f897 304d    	ldrb.w	r3, [r7, #0x4d]
 8008446: 021b         	lsls	r3, r3, #0x8
 8008448: f897 204e    	ldrb.w	r2, [r7, #0x4e]
 800844c: ea43 0002    	orr.w	r0, r3, r2
;                                                 -cfg->p_max, cfg->p_max, 16)) *
 8008450: f8d7 30c0    	ldr.w	r3, [r7, #0xc0]
 8008454: 6d9b         	ldr	r3, [r3, #0x58]
;             data->common.angle = (uint_to_float((rx_frame.data[1] << 8) | rx_frame.data[2],
 8008456: f083 4100    	eor	r1, r3, #0x80000000
;                                                 -cfg->p_max, cfg->p_max, 16)) *
 800845a: f8d7 30c0    	ldr.w	r3, [r7, #0xc0]
 800845e: 6d9a         	ldr	r2, [r3, #0x58]
;             data->common.angle = (uint_to_float((rx_frame.data[1] << 8) | rx_frame.data[2],
 8008460: 2310         	movs	r3, #0x10
 8008462: f00a f9e0    	bl	0x8012826 <uint_to_float> @ imm = #0xa3c0
 8008466: 4603         	mov	r3, r0
;                                                 -cfg->p_max, cfg->p_max, 16)) *
 8008468: 4928         	ldr	r1, [pc, #0xa0]         @ 0x800850c <dm_motor_ctrl_entry+0x334>
 800846a: 4618         	mov	r0, r3
 800846c: f7f7 ff9a    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x80cc
 8008470: 4603         	mov	r3, r0
;                                  RAD2DEG;
 8008472: 4927         	ldr	r1, [pc, #0x9c]         @ 0x8008510 <dm_motor_ctrl_entry+0x338>
 8008474: 4618         	mov	r0, r3
 8008476: f7f8 f849    	bl	0x800050c <__divsf3>    @ imm = #-0x7f6e
 800847a: 4603         	mov	r3, r0
 800847c: 461a         	mov	r2, r3
;             data->common.angle = (uint_to_float((rx_frame.data[1] << 8) | rx_frame.data[2],
 800847e: f8d7 30c4    	ldr.w	r3, [r7, #0xc4]
 8008482: 601a         	str	r2, [r3]
;             data->delta_deg_sum += data->common.angle - prev_angle;
 8008484: f8d7 30c4    	ldr.w	r3, [r7, #0xc4]
 8008488: 6a1c         	ldr	r4, [r3, #0x20]
 800848a: f8d7 30c4    	ldr.w	r3, [r7, #0xc4]
 800848e: 681b         	ldr	r3, [r3]
 8008490: f8d7 10bc    	ldr.w	r1, [r7, #0xbc]
 8008494: 4618         	mov	r0, r3
 8008496: f7f7 fe7b    	bl	0x8000190 <__subsf3>    @ imm = #-0x830a
 800849a: 4603         	mov	r3, r0
 800849c: 4619         	mov	r1, r3
 800849e: 4620         	mov	r0, r4
 80084a0: f7f7 fe78    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x8310
 80084a4: 4603         	mov	r3, r0
 80084a6: 461a         	mov	r2, r3
 80084a8: f8d7 30c4    	ldr.w	r3, [r7, #0xc4]
 80084ac: 621a         	str	r2, [r3, #0x20]
;             if (data->delta_deg_sum > 360) {
 80084ae: f8d7 30c4    	ldr.w	r3, [r7, #0xc4]
 80084b2: 6a1b         	ldr	r3, [r3, #0x20]
 80084b4: 4917         	ldr	r1, [pc, #0x5c]         @ 0x8008514 <dm_motor_ctrl_entry+0x33c>
 80084b6: 4618         	mov	r0, r3
 80084b8: f7f8 f930    	bl	0x800071c <__aeabi_fcmpgt> @ imm = #-0x7da0
 80084bc: 4603         	mov	r3, r0
 80084be: 2b00         	cmp	r3, #0x0
 80084c0: d02a         	beq	0x8008518 <dm_motor_ctrl_entry+0x340> @ imm = #0x54
;                 data->common.round_cnt++;
 80084c2: f8d7 30c4    	ldr.w	r3, [r7, #0xc4]
 80084c6: 691b         	ldr	r3, [r3, #0x10]
 80084c8: 1c5a         	adds	r2, r3, #0x1
 80084ca: f8d7 30c4    	ldr.w	r3, [r7, #0xc4]
 80084ce: 611a         	str	r2, [r3, #0x10]
;                 data->delta_deg_sum -= 360.0f;
 80084d0: f8d7 30c4    	ldr.w	r3, [r7, #0xc4]
 80084d4: 6a1b         	ldr	r3, [r3, #0x20]
 80084d6: 490f         	ldr	r1, [pc, #0x3c]         @ 0x8008514 <dm_motor_ctrl_entry+0x33c>
 80084d8: 4618         	mov	r0, r3
 80084da: f7f7 fe59    	bl	0x8000190 <__subsf3>    @ imm = #-0x834e
 80084de: 4603         	mov	r3, r0
 80084e0: 461a         	mov	r2, r3
 80084e2: f8d7 30c4    	ldr.w	r3, [r7, #0xc4]
 80084e6: 621a         	str	r2, [r3, #0x20]
 80084e8: e033         	b	0x8008552 <dm_motor_ctrl_entry+0x37a> @ imm = #0x66
 80084ea: bf00         	nop

080084ec <$d>:
 80084ec: d8 00 00 20  	.word	0x200000d8
 80084f0: 2c 5b 01 08  	.word	0x08015b2c
 80084f4: cc 00 00 20  	.word	0x200000cc
 80084f8: d0 00 00 20  	.word	0x200000d0
 80084fc: 64 09 00 20  	.word	0x20000964
 8008500: 8c 01 00 20  	.word	0x2000018c
 8008504: 4c 5b 01 08  	.word	0x08015b4c
 8008508: 70 5b 01 08  	.word	0x08015b70
 800850c: 00 00 34 43  	.word	0x43340000
 8008510: db 0f 49 40  	.word	0x40490fdb
 8008514: 00 00 b4 43  	.word	0x43b40000

08008518 <$t>:
;             } else if (data->delta_deg_sum < -360) {
 8008518: f8d7 30c4    	ldr.w	r3, [r7, #0xc4]
 800851c: 6a1b         	ldr	r3, [r3, #0x20]
 800851e: 49ba         	ldr	r1, [pc, #0x2e8]        @ 0x8008808 <dm_motor_ctrl_entry+0x630>
 8008520: 4618         	mov	r0, r3
 8008522: f7f8 f8dd    	bl	0x80006e0 <__aeabi_fcmplt> @ imm = #-0x7e46
 8008526: 4603         	mov	r3, r0
 8008528: 2b00         	cmp	r3, #0x0
 800852a: d012         	beq	0x8008552 <dm_motor_ctrl_entry+0x37a> @ imm = #0x24
;                 data->common.round_cnt--;
 800852c: f8d7 30c4    	ldr.w	r3, [r7, #0xc4]
 8008530: 691b         	ldr	r3, [r3, #0x10]
 8008532: 1e5a         	subs	r2, r3, #0x1
 8008534: f8d7 30c4    	ldr.w	r3, [r7, #0xc4]
 8008538: 611a         	str	r2, [r3, #0x10]
;                 data->delta_deg_sum += 360.0f;
 800853a: f8d7 30c4    	ldr.w	r3, [r7, #0xc4]
 800853e: 6a1b         	ldr	r3, [r3, #0x20]
 8008540: 49b2         	ldr	r1, [pc, #0x2c8]        @ 0x800880c <dm_motor_ctrl_entry+0x634>
 8008542: 4618         	mov	r0, r3
 8008544: f7f7 fe26    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x83b4
 8008548: 4603         	mov	r3, r0
 800854a: 461a         	mov	r2, r3
 800854c: f8d7 30c4    	ldr.w	r3, [r7, #0xc4]
 8008550: 621a         	str	r2, [r3, #0x20]
;             data->common.rpm = uint_to_float((rx_frame.data[3] << 4) | (rx_frame.data[4] >> 4),
 8008552: f897 304f    	ldrb.w	r3, [r7, #0x4f]
 8008556: 011b         	lsls	r3, r3, #0x4
 8008558: f897 2050    	ldrb.w	r2, [r7, #0x50]
 800855c: 0912         	lsrs	r2, r2, #0x4
 800855e: b2d2         	uxtb	r2, r2
 8008560: ea43 0002    	orr.w	r0, r3, r2
;                                              -cfg->v_max, cfg->v_max, 12);
 8008564: f8d7 30c0    	ldr.w	r3, [r7, #0xc0]
 8008568: 6d5b         	ldr	r3, [r3, #0x54]
;             data->common.rpm = uint_to_float((rx_frame.data[3] << 4) | (rx_frame.data[4] >> 4),
 800856a: f083 4100    	eor	r1, r3, #0x80000000
;                                              -cfg->v_max, cfg->v_max, 12);
 800856e: f8d7 30c0    	ldr.w	r3, [r7, #0xc0]
 8008572: 6d5a         	ldr	r2, [r3, #0x54]
;             data->common.rpm = uint_to_float((rx_frame.data[3] << 4) | (rx_frame.data[4] >> 4),
 8008574: 230c         	movs	r3, #0xc
 8008576: f00a f956    	bl	0x8012826 <uint_to_float> @ imm = #0xa2ac
 800857a: 4602         	mov	r2, r0
 800857c: f8d7 30c4    	ldr.w	r3, [r7, #0xc4]
 8008580: 605a         	str	r2, [r3, #0x4]
;                 ((rx_frame.data[4] & 0xF) << 8) | rx_frame.data[5], -cfg->t_max, cfg->t_max, 12);
 8008582: f897 3050    	ldrb.w	r3, [r7, #0x50]
 8008586: 021b         	lsls	r3, r3, #0x8
 8008588: f403 6370    	and	r3, r3, #0xf00
 800858c: f897 2051    	ldrb.w	r2, [r7, #0x51]
;             data->common.torque = uint_to_float(
 8008590: ea43 0002    	orr.w	r0, r3, r2
;                 ((rx_frame.data[4] & 0xF) << 8) | rx_frame.data[5], -cfg->t_max, cfg->t_max, 12);
 8008594: f8d7 30c0    	ldr.w	r3, [r7, #0xc0]
 8008598: 6ddb         	ldr	r3, [r3, #0x5c]
;             data->common.torque = uint_to_float(
 800859a: f083 4100    	eor	r1, r3, #0x80000000
;                 ((rx_frame.data[4] & 0xF) << 8) | rx_frame.data[5], -cfg->t_max, cfg->t_max, 12);
 800859e: f8d7 30c0    	ldr.w	r3, [r7, #0xc0]
 80085a2: 6dda         	ldr	r2, [r3, #0x5c]
;             data->common.torque = uint_to_float(
 80085a4: 230c         	movs	r3, #0xc
 80085a6: f00a f93e    	bl	0x8012826 <uint_to_float> @ imm = #0xa27c
 80085aa: 4602         	mov	r2, r0
 80085ac: f8d7 30c4    	ldr.w	r3, [r7, #0xc4]
 80085b0: 609a         	str	r2, [r3, #0x8]
;         while (!k_msgq_get(&dm_can_rx_msgq, &rx_frame, K_MSEC(1))) {
 80085b2: f04f 020a    	mov.w	r2, #0xa
 80085b6: f04f 0300    	mov.w	r3, #0x0
 80085ba: f107 0144    	add.w	r1, r7, #0x44
 80085be: 4894         	ldr	r0, [pc, #0x250]        @ 0x8008810 <dm_motor_ctrl_entry+0x638>
 80085c0: f00a f89d    	bl	0x80126fe <k_msgq_get>  @ imm = #0xa13a
 80085c4: 4603         	mov	r3, r0
 80085c6: 2b00         	cmp	r3, #0x0
 80085c8: f43f aee7    	beq.w	0x800839a <dm_motor_ctrl_entry+0x1c2> @ imm = #-0x232
;         for (int i = 0; i < MOTOR_COUNT; i++) {
 80085cc: 2300         	movs	r3, #0x0
 80085ce: f8c7 30e4    	str.w	r3, [r7, #0xe4]
 80085d2: e169         	b	0x80088a8 <dm_motor_ctrl_entry+0x6d0> @ imm = #0x2d2
;             struct dm_motor_data         *data = motor_devices[i]->data;
 80085d4: 4a8f         	ldr	r2, [pc, #0x23c]        @ 0x8008814 <dm_motor_ctrl_entry+0x63c>
 80085d6: f8d7 30e4    	ldr.w	r3, [r7, #0xe4]
 80085da: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 80085de: 691b         	ldr	r3, [r3, #0x10]
 80085e0: f8c7 30ac    	str.w	r3, [r7, #0xac]
;             const struct dm_motor_config *cfg  = motor_devices[i]->config;
 80085e4: 4a8b         	ldr	r2, [pc, #0x22c]        @ 0x8008814 <dm_motor_ctrl_entry+0x63c>
 80085e6: f8d7 30e4    	ldr.w	r3, [r7, #0xe4]
 80085ea: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 80085ee: 685b         	ldr	r3, [r3, #0x4]
 80085f0: f8c7 30a8    	str.w	r3, [r7, #0xa8]
;             if (data->online) {
 80085f4: f8d7 30ac    	ldr.w	r3, [r7, #0xac]
 80085f8: 7f1b         	ldrb	r3, [r3, #0x1c]
 80085fa: 2b00         	cmp	r3, #0x0
 80085fc: f000 811c    	beq.w	0x8008838 <dm_motor_ctrl_entry+0x660> @ imm = #0x238
;                 int can_id = get_can_id(motor_devices[i]);
 8008600: 4a84         	ldr	r2, [pc, #0x210]        @ 0x8008814 <dm_motor_ctrl_entry+0x63c>
 8008602: f8d7 30e4    	ldr.w	r3, [r7, #0xe4]
 8008606: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800860a: 4618         	mov	r0, r3
 800860c: f7ff fab4    	bl	0x8007b78 <get_can_id>  @ imm = #-0xa98
 8008610: f8c7 009c    	str.w	r0, [r7, #0x9c]
;                 int err    = k_sem_take(&tx_queue_sem[can_id], K_NO_WAIT);
 8008614: f8d7 309c    	ldr.w	r3, [r7, #0x9c]
 8008618: 011b         	lsls	r3, r3, #0x4
 800861a: 4a7f         	ldr	r2, [pc, #0x1fc]        @ 0x8008818 <dm_motor_ctrl_entry+0x640>
 800861c: 1899         	adds	r1, r3, r2
 800861e: f04f 0200    	mov.w	r2, #0x0
 8008622: f04f 0300    	mov.w	r3, #0x0
 8008626: 4608         	mov	r0, r1
 8008628: f00a f83c    	bl	0x80126a4 <k_sem_take>  @ imm = #0xa078
 800862c: f8c7 0098    	str.w	r0, [r7, #0x98]
;                 if (err == 0) {
 8008630: f8d7 3098    	ldr.w	r3, [r7, #0x98]
 8008634: 2b00         	cmp	r3, #0x0
 8008636: d11f         	bne	0x8008678 <dm_motor_ctrl_entry+0x4a0> @ imm = #0x3e
;                     dm_motor_pack(motor_devices[i], &tx_frame);
 8008638: 4a76         	ldr	r2, [pc, #0x1d8]        @ 0x8008814 <dm_motor_ctrl_entry+0x63c>
 800863a: f8d7 30e4    	ldr.w	r3, [r7, #0xe4]
 800863e: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 8008642: f107 0254    	add.w	r2, r7, #0x54
 8008646: 4611         	mov	r1, r2
 8008648: 4618         	mov	r0, r3
 800864a: f7ff fc37    	bl	0x8007ebc <dm_motor_pack> @ imm = #-0x792
;                     can_send(cfg->common.phy, &tx_frame, K_NO_WAIT, can_tx_callback,
 800864e: f8d7 30a8    	ldr.w	r3, [r7, #0xa8]
 8008652: 6818         	ldr	r0, [r3]
 8008654: f04f 0200    	mov.w	r2, #0x0
 8008658: f04f 0300    	mov.w	r3, #0x0
;                              &tx_queue_sem[can_id]);
 800865c: f8d7 109c    	ldr.w	r1, [r7, #0x9c]
 8008660: 0109         	lsls	r1, r1, #0x4
 8008662: 4c6d         	ldr	r4, [pc, #0x1b4]        @ 0x8008818 <dm_motor_ctrl_entry+0x640>
 8008664: 4421         	add	r1, r4
;                     can_send(cfg->common.phy, &tx_frame, K_NO_WAIT, can_tx_callback,
 8008666: f107 0454    	add.w	r4, r7, #0x54
 800866a: 9101         	str	r1, [sp, #0x4]
 800866c: 496b         	ldr	r1, [pc, #0x1ac]        @ 0x800881c <dm_motor_ctrl_entry+0x644>
 800866e: 9100         	str	r1, [sp]
 8008670: 4621         	mov	r1, r4
 8008672: f00a f8b2    	bl	0x80127da <can_send>    @ imm = #0xa164
 8008676: e061         	b	0x800873c <dm_motor_ctrl_entry+0x564> @ imm = #0xc2
;                 } else if (err == -EBUSY) {
 8008678: f8d7 3098    	ldr.w	r3, [r7, #0x98]
 800867c: f113 0f10    	cmn.w	r3, #0x10
 8008680: d15c         	bne	0x800873c <dm_motor_ctrl_entry+0x564> @ imm = #0xb8
;                         .can_dev = cfg->common.phy,
 8008682: f8d7 30a8    	ldr.w	r3, [r7, #0xa8]
 8008686: 681b         	ldr	r3, [r3]
;                     struct tx_frame queued_frame = {
 8008688: 617b         	str	r3, [r7, #0x14]
;                         .sem     = &tx_queue_sem[can_id],
 800868a: f8d7 309c    	ldr.w	r3, [r7, #0x9c]
 800868e: 011b         	lsls	r3, r3, #0x4
 8008690: 4a61         	ldr	r2, [pc, #0x184]        @ 0x8008818 <dm_motor_ctrl_entry+0x640>
 8008692: 4413         	add	r3, r2
;                     struct tx_frame queued_frame = {
 8008694: 61bb         	str	r3, [r7, #0x18]
 8008696: f107 041c    	add.w	r4, r7, #0x1c
 800869a: f107 0354    	add.w	r3, r7, #0x54
 800869e: cb0f         	ldm	r3, {r0, r1, r2, r3}
 80086a0: e884 000f    	stm.w	r4, {r0, r1, r2, r3}
;                     LOG_ERR("CAN TX queue is full");
 80086a4: 2304         	movs	r3, #0x4
 80086a6: 2b00         	cmp	r3, #0x0
 80086a8: d019         	beq	0x80086de <dm_motor_ctrl_entry+0x506> @ imm = #0x32
 80086aa: 2301         	movs	r3, #0x1
 80086ac: f887 3097    	strb.w	r3, [r7, #0x97]
 80086b0: f897 3097    	ldrb.w	r3, [r7, #0x97]
 80086b4: f083 0301    	eor	r3, r3, #0x1
 80086b8: b2db         	uxtb	r3, r3
 80086ba: 2b00         	cmp	r3, #0x0
 80086bc: d10f         	bne	0x80086de <dm_motor_ctrl_entry+0x506> @ imm = #0x1e
 80086be: 4b58         	ldr	r3, [pc, #0x160]        @ 0x8008820 <dm_motor_ctrl_entry+0x648>
 80086c0: 6819         	ldr	r1, [r3]
 80086c2: 4b58         	ldr	r3, [pc, #0x160]        @ 0x8008824 <dm_motor_ctrl_entry+0x64c>
 80086c4: 9302         	str	r3, [sp, #0x8]
 80086c6: 2300         	movs	r3, #0x0
 80086c8: 9301         	str	r3, [sp, #0x4]
 80086ca: 2300         	movs	r3, #0x0
 80086cc: 9300         	str	r3, [sp]
 80086ce: 2300         	movs	r3, #0x0
 80086d0: 2201         	movs	r2, #0x1
 80086d2: 2000         	movs	r0, #0x0
 80086d4: f00a f825    	bl	0x8012722 <z_log_msg_runtime_create> @ imm = #0xa04a
 80086d8: 2300         	movs	r3, #0x0
 80086da: f8c7 3090    	str.w	r3, [r7, #0x90]
;                     err = k_msgq_put(&dm_can_tx_msgq, &queued_frame, K_NO_WAIT);
 80086de: f04f 0200    	mov.w	r2, #0x0
 80086e2: f04f 0300    	mov.w	r3, #0x0
 80086e6: f107 0114    	add.w	r1, r7, #0x14
 80086ea: 484f         	ldr	r0, [pc, #0x13c]        @ 0x8008828 <dm_motor_ctrl_entry+0x650>
 80086ec: f009 fff5    	bl	0x80126da <k_msgq_put>  @ imm = #0x9fea
 80086f0: f8c7 0098    	str.w	r0, [r7, #0x98]
;                     if (err) {
 80086f4: f8d7 3098    	ldr.w	r3, [r7, #0x98]
 80086f8: 2b00         	cmp	r3, #0x0
 80086fa: d01f         	beq	0x800873c <dm_motor_ctrl_entry+0x564> @ imm = #0x3e
;                         LOG_ERR("Failed to put CAN frame into TX queue: %d", err);
 80086fc: 2304         	movs	r3, #0x4
 80086fe: 2b00         	cmp	r3, #0x0
 8008700: d01c         	beq	0x800873c <dm_motor_ctrl_entry+0x564> @ imm = #0x38
 8008702: 2301         	movs	r3, #0x1
 8008704: f887 308f    	strb.w	r3, [r7, #0x8f]
 8008708: f897 308f    	ldrb.w	r3, [r7, #0x8f]
 800870c: f083 0301    	eor	r3, r3, #0x1
 8008710: b2db         	uxtb	r3, r3
 8008712: 2b00         	cmp	r3, #0x0
 8008714: d112         	bne	0x800873c <dm_motor_ctrl_entry+0x564> @ imm = #0x24
 8008716: 4b42         	ldr	r3, [pc, #0x108]        @ 0x8008820 <dm_motor_ctrl_entry+0x648>
 8008718: 6819         	ldr	r1, [r3]
 800871a: f8d7 3098    	ldr.w	r3, [r7, #0x98]
 800871e: 9303         	str	r3, [sp, #0xc]
 8008720: 4b42         	ldr	r3, [pc, #0x108]        @ 0x800882c <dm_motor_ctrl_entry+0x654>
 8008722: 9302         	str	r3, [sp, #0x8]
 8008724: 2300         	movs	r3, #0x0
 8008726: 9301         	str	r3, [sp, #0x4]
 8008728: 2300         	movs	r3, #0x0
 800872a: 9300         	str	r3, [sp]
 800872c: 2300         	movs	r3, #0x0
 800872e: 2201         	movs	r2, #0x1
 8008730: 2000         	movs	r0, #0x0
 8008732: f009 fff6    	bl	0x8012722 <z_log_msg_runtime_create> @ imm = #0x9fec
 8008736: 2300         	movs	r3, #0x0
 8008738: f8c7 3088    	str.w	r3, [r7, #0x88]
;                 if (++data->missed_times > 0) {
 800873c: f8d7 30ac    	ldr.w	r3, [r7, #0xac]
 8008740: f993 301d    	ldrsb.w	r3, [r3, #0x1d]
 8008744: b2db         	uxtb	r3, r3
 8008746: 3301         	adds	r3, #0x1
 8008748: b2db         	uxtb	r3, r3
 800874a: b25a         	sxtb	r2, r3
 800874c: f8d7 30ac    	ldr.w	r3, [r7, #0xac]
 8008750: 775a         	strb	r2, [r3, #0x1d]
 8008752: f8d7 30ac    	ldr.w	r3, [r7, #0xac]
 8008756: f993 301d    	ldrsb.w	r3, [r3, #0x1d]
 800875a: 2b00         	cmp	r3, #0x0
 800875c: dd28         	ble	0x80087b0 <dm_motor_ctrl_entry+0x5d8> @ imm = #0x50
;                     LOG_ERR("Motor %d is not responding, trying to recover...", i);
 800875e: 2304         	movs	r3, #0x4
 8008760: 2b00         	cmp	r3, #0x0
 8008762: d01b         	beq	0x800879c <dm_motor_ctrl_entry+0x5c4> @ imm = #0x36
 8008764: 2301         	movs	r3, #0x1
 8008766: f887 307f    	strb.w	r3, [r7, #0x7f]
 800876a: f897 307f    	ldrb.w	r3, [r7, #0x7f]
 800876e: f083 0301    	eor	r3, r3, #0x1
 8008772: b2db         	uxtb	r3, r3
 8008774: 2b00         	cmp	r3, #0x0
 8008776: d111         	bne	0x800879c <dm_motor_ctrl_entry+0x5c4> @ imm = #0x22
 8008778: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x8008820 <dm_motor_ctrl_entry+0x648>
 800877a: 6819         	ldr	r1, [r3]
 800877c: f8d7 30e4    	ldr.w	r3, [r7, #0xe4]
 8008780: 9303         	str	r3, [sp, #0xc]
 8008782: 4b2b         	ldr	r3, [pc, #0xac]         @ 0x8008830 <dm_motor_ctrl_entry+0x658>
 8008784: 9302         	str	r3, [sp, #0x8]
 8008786: 2300         	movs	r3, #0x0
 8008788: 9301         	str	r3, [sp, #0x4]
 800878a: 2300         	movs	r3, #0x0
 800878c: 9300         	str	r3, [sp]
 800878e: 2300         	movs	r3, #0x0
 8008790: 2201         	movs	r2, #0x1
 8008792: 2000         	movs	r0, #0x0
 8008794: f009 ffc5    	bl	0x8012722 <z_log_msg_runtime_create> @ imm = #0x9f8a
 8008798: 2300         	movs	r3, #0x0
 800879a: 67bb         	str	r3, [r7, #0x78]
;                     dm_motor_control(motor_devices[i], CLEAR_ERROR);
 800879c: 4a1d         	ldr	r2, [pc, #0x74]         @ 0x8008814 <dm_motor_ctrl_entry+0x63c>
 800879e: f8d7 30e4    	ldr.w	r3, [r7, #0xe4]
 80087a2: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 80087a6: 2104         	movs	r1, #0x4
 80087a8: 4618         	mov	r0, r3
 80087aa: f7ff faaf    	bl	0x8007d0c <dm_motor_control> @ imm = #-0xaa2
 80087ae: e076         	b	0x800889e <dm_motor_ctrl_entry+0x6c6> @ imm = #0xec
;                 } else if (data->missed_times > 3) {
 80087b0: f8d7 30ac    	ldr.w	r3, [r7, #0xac]
 80087b4: f993 301d    	ldrsb.w	r3, [r3, #0x1d]
 80087b8: 2b03         	cmp	r3, #0x3
 80087ba: dd70         	ble	0x800889e <dm_motor_ctrl_entry+0x6c6> @ imm = #0xe0
;                     LOG_ERR("Motor %d is not responding, setting it to offline...", i);
 80087bc: 2304         	movs	r3, #0x4
 80087be: 2b00         	cmp	r3, #0x0
 80087c0: d01c         	beq	0x80087fc <dm_motor_ctrl_entry+0x624> @ imm = #0x38
 80087c2: 2301         	movs	r3, #0x1
 80087c4: f887 3087    	strb.w	r3, [r7, #0x87]
 80087c8: f897 3087    	ldrb.w	r3, [r7, #0x87]
 80087cc: f083 0301    	eor	r3, r3, #0x1
 80087d0: b2db         	uxtb	r3, r3
 80087d2: 2b00         	cmp	r3, #0x0
 80087d4: d112         	bne	0x80087fc <dm_motor_ctrl_entry+0x624> @ imm = #0x24
 80087d6: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8008820 <dm_motor_ctrl_entry+0x648>
 80087d8: 6819         	ldr	r1, [r3]
 80087da: f8d7 30e4    	ldr.w	r3, [r7, #0xe4]
 80087de: 9303         	str	r3, [sp, #0xc]
 80087e0: 4b14         	ldr	r3, [pc, #0x50]         @ 0x8008834 <dm_motor_ctrl_entry+0x65c>
 80087e2: 9302         	str	r3, [sp, #0x8]
 80087e4: 2300         	movs	r3, #0x0
 80087e6: 9301         	str	r3, [sp, #0x4]
 80087e8: 2300         	movs	r3, #0x0
 80087ea: 9300         	str	r3, [sp]
 80087ec: 2300         	movs	r3, #0x0
 80087ee: 2201         	movs	r2, #0x1
 80087f0: 2000         	movs	r0, #0x0
 80087f2: f009 ff96    	bl	0x8012722 <z_log_msg_runtime_create> @ imm = #0x9f2c
 80087f6: 2300         	movs	r3, #0x0
 80087f8: f8c7 3080    	str.w	r3, [r7, #0x80]
;                     data->online = false;
 80087fc: f8d7 30ac    	ldr.w	r3, [r7, #0xac]
 8008800: 2200         	movs	r2, #0x0
 8008802: 771a         	strb	r2, [r3, #0x1c]
 8008804: e04b         	b	0x800889e <dm_motor_ctrl_entry+0x6c6> @ imm = #0x96
 8008806: bf00         	nop

08008808 <$d>:
 8008808: 00 00 b4 c3  	.word	0xc3b40000
 800880c: 00 00 b4 43  	.word	0x43b40000
 8008810: 8c 01 00 20  	.word	0x2000018c
 8008814: cc 00 00 20  	.word	0x200000cc
 8008818: 44 09 00 20  	.word	0x20000944
 800881c: e7 28 01 08  	.word	0x080128e7
 8008820: d8 00 00 20  	.word	0x200000d8
 8008824: c0 5a 01 08  	.word	0x08015ac0
 8008828: b4 01 00 20  	.word	0x200001b4
 800882c: d8 5a 01 08  	.word	0x08015ad8
 8008830: 88 5b 01 08  	.word	0x08015b88
 8008834: bc 5b 01 08  	.word	0x08015bbc

08008838 <$t>:
;             } else if (data->missed_times < 3) {
 8008838: f8d7 30ac    	ldr.w	r3, [r7, #0xac]
 800883c: f993 301d    	ldrsb.w	r3, [r3, #0x1d]
 8008840: 2b02         	cmp	r3, #0x2
 8008842: dc2c         	bgt	0x800889e <dm_motor_ctrl_entry+0x6c6> @ imm = #0x58
;                 dm_motor_control(motor_devices[i], CLEAR_ERROR);
 8008844: 4a31         	ldr	r2, [pc, #0xc4]         @ 0x800890c <dm_motor_ctrl_entry+0x734>
 8008846: f8d7 30e4    	ldr.w	r3, [r7, #0xe4]
 800884a: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800884e: 2104         	movs	r1, #0x4
 8008850: 4618         	mov	r0, r3
 8008852: f7ff fa5b    	bl	0x8007d0c <dm_motor_control> @ imm = #-0xb4a
;                 data->online = true;
 8008856: f8d7 30ac    	ldr.w	r3, [r7, #0xac]
 800885a: 2201         	movs	r2, #0x1
 800885c: 771a         	strb	r2, [r3, #0x1c]
;                 LOG_ERR("Motor %d is responding again, resuming...", i);
 800885e: 2304         	movs	r3, #0x4
 8008860: 2b00         	cmp	r3, #0x0
 8008862: d01c         	beq	0x800889e <dm_motor_ctrl_entry+0x6c6> @ imm = #0x38
 8008864: 2301         	movs	r3, #0x1
 8008866: f887 30a7    	strb.w	r3, [r7, #0xa7]
 800886a: f897 30a7    	ldrb.w	r3, [r7, #0xa7]
 800886e: f083 0301    	eor	r3, r3, #0x1
 8008872: b2db         	uxtb	r3, r3
 8008874: 2b00         	cmp	r3, #0x0
 8008876: d112         	bne	0x800889e <dm_motor_ctrl_entry+0x6c6> @ imm = #0x24
 8008878: 4b25         	ldr	r3, [pc, #0x94]         @ 0x8008910 <dm_motor_ctrl_entry+0x738>
 800887a: 6819         	ldr	r1, [r3]
 800887c: f8d7 30e4    	ldr.w	r3, [r7, #0xe4]
 8008880: 9303         	str	r3, [sp, #0xc]
 8008882: 4b24         	ldr	r3, [pc, #0x90]         @ 0x8008914 <dm_motor_ctrl_entry+0x73c>
 8008884: 9302         	str	r3, [sp, #0x8]
 8008886: 2300         	movs	r3, #0x0
 8008888: 9301         	str	r3, [sp, #0x4]
 800888a: 2300         	movs	r3, #0x0
 800888c: 9300         	str	r3, [sp]
 800888e: 2300         	movs	r3, #0x0
 8008890: 2201         	movs	r2, #0x1
 8008892: 2000         	movs	r0, #0x0
 8008894: f009 ff45    	bl	0x8012722 <z_log_msg_runtime_create> @ imm = #0x9e8a
 8008898: 2300         	movs	r3, #0x0
 800889a: f8c7 30a0    	str.w	r3, [r7, #0xa0]
;         for (int i = 0; i < MOTOR_COUNT; i++) {
 800889e: f8d7 30e4    	ldr.w	r3, [r7, #0xe4]
 80088a2: 3301         	adds	r3, #0x1
 80088a4: f8c7 30e4    	str.w	r3, [r7, #0xe4]
 80088a8: f8d7 30e4    	ldr.w	r3, [r7, #0xe4]
 80088ac: 2b00         	cmp	r3, #0x0
 80088ae: f77f ae91    	ble.w	0x80085d4 <dm_motor_ctrl_entry+0x3fc> @ imm = #-0x2de
;         while (k_msgq_put(&dm_can_tx_msgq, &frame, K_NO_WAIT) != -ENOMSG) {
 80088b2: e01d         	b	0x80088f0 <dm_motor_ctrl_entry+0x718> @ imm = #0x3a
;             int err = k_sem_take(frame.sem, K_USEC(200));
 80088b4: 6b39         	ldr	r1, [r7, #0x30]
 80088b6: f04f 0202    	mov.w	r2, #0x2
 80088ba: f04f 0300    	mov.w	r3, #0x0
 80088be: 4608         	mov	r0, r1
 80088c0: f009 fef0    	bl	0x80126a4 <k_sem_take>  @ imm = #0x9de0
 80088c4: f8c7 00b0    	str.w	r0, [r7, #0xb0]
;             if (err == 0) {
 80088c8: f8d7 30b0    	ldr.w	r3, [r7, #0xb0]
 80088cc: 2b00         	cmp	r3, #0x0
 80088ce: d10f         	bne	0x80088f0 <dm_motor_ctrl_entry+0x718> @ imm = #0x1e
;                 can_send(frame.can_dev, &frame.frame, K_NO_WAIT, can_tx_callback, frame.sem);
 80088d0: 6afc         	ldr	r4, [r7, #0x2c]
 80088d2: f04f 0200    	mov.w	r2, #0x0
 80088d6: f04f 0300    	mov.w	r3, #0x0
 80088da: 6b39         	ldr	r1, [r7, #0x30]
 80088dc: f107 002c    	add.w	r0, r7, #0x2c
 80088e0: 3008         	adds	r0, #0x8
 80088e2: 9101         	str	r1, [sp, #0x4]
 80088e4: 490c         	ldr	r1, [pc, #0x30]         @ 0x8008918 <dm_motor_ctrl_entry+0x740>
 80088e6: 9100         	str	r1, [sp]
 80088e8: 4601         	mov	r1, r0
 80088ea: 4620         	mov	r0, r4
 80088ec: f009 ff75    	bl	0x80127da <can_send>    @ imm = #0x9eea
;         while (k_msgq_put(&dm_can_tx_msgq, &frame, K_NO_WAIT) != -ENOMSG) {
 80088f0: f04f 0200    	mov.w	r2, #0x0
 80088f4: f04f 0300    	mov.w	r3, #0x0
 80088f8: f107 012c    	add.w	r1, r7, #0x2c
 80088fc: 4807         	ldr	r0, [pc, #0x1c]         @ 0x800891c <dm_motor_ctrl_entry+0x744>
 80088fe: f009 feec    	bl	0x80126da <k_msgq_put>  @ imm = #0x9dd8
 8008902: 4603         	mov	r3, r0
 8008904: f113 0f23    	cmn.w	r3, #0x23
 8008908: d1d4         	bne	0x80088b4 <dm_motor_ctrl_entry+0x6dc> @ imm = #-0x58
;     for (;;) {
 800890a: e545         	b	0x8008398 <dm_motor_ctrl_entry+0x1c0> @ imm = #-0x576

0800890c <$d>:
 800890c: cc 00 00 20  	.word	0x200000cc
 8008910: d8 00 00 20  	.word	0x200000d8
 8008914: f4 5b 01 08  	.word	0x08015bf4
 8008918: e7 28 01 08  	.word	0x080128e7
 800891c: b4 01 00 20  	.word	0x200001b4

08008920 <float_equal>:
; static bool float_equal(float a, float b) { return fabsf(a - b) < 0.0001f; }
 8008920: b590         	push	{r4, r7, lr}
 8008922: b083         	sub	sp, #0xc
 8008924: af00         	add	r7, sp, #0x0
 8008926: 6078         	str	r0, [r7, #0x4]
 8008928: 6039         	str	r1, [r7]
 800892a: 6839         	ldr	r1, [r7]
 800892c: 6878         	ldr	r0, [r7, #0x4]
 800892e: f7f7 fc2f    	bl	0x8000190 <__subsf3>    @ imm = #-0x87a2
 8008932: 4603         	mov	r3, r0
 8008934: f023 4300    	bic	r3, r3, #0x80000000
 8008938: 2201         	movs	r2, #0x1
 800893a: 4614         	mov	r4, r2
 800893c: 4906         	ldr	r1, [pc, #0x18]         @ 0x8008958 <float_equal+0x38>
 800893e: 4618         	mov	r0, r3
 8008940: f7f7 fece    	bl	0x80006e0 <__aeabi_fcmplt> @ imm = #-0x8264
 8008944: 4603         	mov	r3, r0
 8008946: 2b00         	cmp	r3, #0x0
 8008948: d101         	bne	0x800894e <float_equal+0x2e> @ imm = #0x2
 800894a: 2300         	movs	r3, #0x0
 800894c: 461c         	mov	r4, r3
 800894e: b2e3         	uxtb	r3, r4
 8008950: 4618         	mov	r0, r3
 8008952: 370c         	adds	r7, #0xc
 8008954: 46bd         	mov	sp, r7
 8008956: bd90         	pop	{r4, r7, pc}

08008958 <$d>:
 8008958: 17 b7 d1 38  	.word	0x38d1b717

0800895c <pid_mit_calc>:
; static void pid_mit_calc(const struct device *pid_dev) {
 800895c: e92d 43b0    	push.w	{r4, r5, r7, r8, r9, lr}
 8008960: b08a         	sub	sp, #0x28
 8008962: af00         	add	r7, sp, #0x0
 8008964: 6078         	str	r0, [r7, #0x4]
;     const struct pid_mit_config *pid_para = pid_dev->config;
 8008966: 687b         	ldr	r3, [r7, #0x4]
 8008968: 685b         	ldr	r3, [r3, #0x4]
 800896a: 627b         	str	r3, [r7, #0x24]
;     struct pid_mit_data         *pid_data = pid_dev->data;
 800896c: 687b         	ldr	r3, [r7, #0x4]
 800896e: 691b         	ldr	r3, [r3, #0x10]
 8008970: 623b         	str	r3, [r7, #0x20]
;     if (pid_data->curr == NULL) {
 8008972: 6a3b         	ldr	r3, [r7, #0x20]
 8008974: 689b         	ldr	r3, [r3, #0x8]
 8008976: 2b00         	cmp	r3, #0x0
 8008978: f000 80af    	beq.w	0x8008ada <pid_mit_calc+0x17e> @ imm = #0x15e
;     float kp     = pid_para->common.k_p;
 800897c: 6a7b         	ldr	r3, [r7, #0x24]
 800897e: 681b         	ldr	r3, [r3]
 8008980: 61fb         	str	r3, [r7, #0x1c]
;     float ki     = pid_para->common.k_i;
 8008982: 6a7b         	ldr	r3, [r7, #0x24]
 8008984: 685b         	ldr	r3, [r3, #0x4]
 8008986: 61bb         	str	r3, [r7, #0x18]
;     float kd     = pid_para->common.k_d;
 8008988: 6a7b         	ldr	r3, [r7, #0x24]
 800898a: 689b         	ldr	r3, [r3, #0x8]
 800898c: 617b         	str	r3, [r7, #0x14]
;     float err    = *(pid_data->ref) - *(pid_data->curr);
 800898e: 6a3b         	ldr	r3, [r7, #0x20]
 8008990: 681b         	ldr	r3, [r3]
 8008992: 681a         	ldr	r2, [r3]
 8008994: 6a3b         	ldr	r3, [r7, #0x20]
 8008996: 689b         	ldr	r3, [r3, #0x8]
 8008998: 681b         	ldr	r3, [r3]
 800899a: 4619         	mov	r1, r3
 800899c: 4610         	mov	r0, r2
 800899e: f7f7 fbf7    	bl	0x8000190 <__subsf3>    @ imm = #-0x8812
 80089a2: 4603         	mov	r3, r0
 80089a4: 613b         	str	r3, [r7, #0x10]
;     float deltaT = k_cyc_to_us_near32(*(pid_data->curr_time) - *(pid_data->prev_time));
 80089a6: 6a3b         	ldr	r3, [r7, #0x20]
 80089a8: 69db         	ldr	r3, [r3, #0x1c]
 80089aa: 681a         	ldr	r2, [r3]
 80089ac: 6a3b         	ldr	r3, [r7, #0x20]
 80089ae: 6a1b         	ldr	r3, [r3, #0x20]
 80089b0: 681b         	ldr	r3, [r3]
 80089b2: 1ad3         	subs	r3, r2, r3
 80089b4: 2b00         	cmp	r3, #0x0
 80089b6: db11         	blt	0x80089dc <pid_mit_calc+0x80> @ imm = #0x22
 80089b8: 6a3b         	ldr	r3, [r7, #0x20]
 80089ba: 69db         	ldr	r3, [r3, #0x1c]
 80089bc: 681a         	ldr	r2, [r3]
 80089be: 6a3b         	ldr	r3, [r7, #0x20]
 80089c0: 6a1b         	ldr	r3, [r3, #0x20]
 80089c2: 681b         	ldr	r3, [r3]
 80089c4: 1ad3         	subs	r3, r2, r3
 80089c6: 3354         	adds	r3, #0x54
 80089c8: 08db         	lsrs	r3, r3, #0x3
 80089ca: 4a46         	ldr	r2, [pc, #0x118]        @ 0x8008ae4 <pid_mit_calc+0x188>
 80089cc: fba2 2303    	umull	r2, r3, r2, r3
 80089d0: 085b         	lsrs	r3, r3, #0x1
 80089d2: 4618         	mov	r0, r3
 80089d4: f7f7 fc8e    	bl	0x80002f4 <__floatunsisf> @ imm = #-0x86e4
 80089d8: 4603         	mov	r3, r0
 80089da: e01c         	b	0x8008a16 <pid_mit_calc+0xba> @ imm = #0x38
 80089dc: 6a3b         	ldr	r3, [r7, #0x20]
 80089de: 69db         	ldr	r3, [r3, #0x1c]
 80089e0: 681a         	ldr	r2, [r3]
 80089e2: 6a3b         	ldr	r3, [r7, #0x20]
 80089e4: 6a1b         	ldr	r3, [r3, #0x20]
 80089e6: 681b         	ldr	r3, [r3]
 80089e8: 1ad3         	subs	r3, r2, r3
 80089ea: 17da         	asrs	r2, r3, #0x1f
 80089ec: 461c         	mov	r4, r3
 80089ee: 4615         	mov	r5, r2
 80089f0: f114 0854    	adds.w	r8, r4, #0x54
 80089f4: f145 0900    	adc	r9, r5, #0x0
 80089f8: f04f 02a8    	mov.w	r2, #0xa8
 80089fc: f04f 0300    	mov.w	r3, #0x0
 8008a00: 4640         	mov	r0, r8
 8008a02: 4649         	mov	r1, r9
 8008a04: f7f7 feba    	bl	0x800077c <__aeabi_uldivmod> @ imm = #-0x828c
 8008a08: 4602         	mov	r2, r0
 8008a0a: 460b         	mov	r3, r1
 8008a0c: 4613         	mov	r3, r2
 8008a0e: 4618         	mov	r0, r3
 8008a10: f7f7 fc70    	bl	0x80002f4 <__floatunsisf> @ imm = #-0x8720
 8008a14: 4603         	mov	r3, r0
 8008a16: 60fb         	str	r3, [r7, #0xc]
;     if (!float_equal(ki, 0))
 8008a18: f04f 0100    	mov.w	r1, #0x0
 8008a1c: 69b8         	ldr	r0, [r7, #0x18]
 8008a1e: f7ff ff7f    	bl	0x8008920 <float_equal> @ imm = #-0x102
 8008a22: 4603         	mov	r3, r0
 8008a24: f083 0301    	eor	r3, r3, #0x1
 8008a28: b2db         	uxtb	r3, r3
 8008a2a: 2b00         	cmp	r3, #0x0
 8008a2c: d019         	beq	0x8008a62 <pid_mit_calc+0x106> @ imm = #0x32
;         pid_data->err_integral += (err * deltaT) / (1000000 * ki);
 8008a2e: 6a3b         	ldr	r3, [r7, #0x20]
 8008a30: 691c         	ldr	r4, [r3, #0x10]
 8008a32: 68f9         	ldr	r1, [r7, #0xc]
 8008a34: 6938         	ldr	r0, [r7, #0x10]
 8008a36: f7f7 fcb5    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x8696
 8008a3a: 4603         	mov	r3, r0
 8008a3c: 461d         	mov	r5, r3
 8008a3e: 492a         	ldr	r1, [pc, #0xa8]         @ 0x8008ae8 <pid_mit_calc+0x18c>
 8008a40: 69b8         	ldr	r0, [r7, #0x18]
 8008a42: f7f7 fcaf    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x86a2
 8008a46: 4603         	mov	r3, r0
 8008a48: 4619         	mov	r1, r3
 8008a4a: 4628         	mov	r0, r5
 8008a4c: f7f7 fd5e    	bl	0x800050c <__divsf3>    @ imm = #-0x8544
 8008a50: 4603         	mov	r3, r0
 8008a52: 4619         	mov	r1, r3
 8008a54: 4620         	mov	r0, r4
 8008a56: f7f7 fb9d    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x88c6
 8008a5a: 4603         	mov	r3, r0
 8008a5c: 461a         	mov	r2, r3
 8008a5e: 6a3b         	ldr	r3, [r7, #0x20]
 8008a60: 611a         	str	r2, [r3, #0x10]
;     if (!float_equal(kd, 0)) {
 8008a62: f04f 0100    	mov.w	r1, #0x0
 8008a66: 6978         	ldr	r0, [r7, #0x14]
 8008a68: f7ff ff5a    	bl	0x8008920 <float_equal> @ imm = #-0x14c
 8008a6c: 4603         	mov	r3, r0
 8008a6e: f083 0301    	eor	r3, r3, #0x1
 8008a72: b2db         	uxtb	r3, r3
 8008a74: 2b00         	cmp	r3, #0x0
 8008a76: d017         	beq	0x8008aa8 <pid_mit_calc+0x14c> @ imm = #0x2e
;         pid_data->err_derivate = kd * (*(pid_data->detri_ref) - *(pid_data->detri_curr)) / deltaT;
 8008a78: 6a3b         	ldr	r3, [r7, #0x20]
 8008a7a: 685b         	ldr	r3, [r3, #0x4]
 8008a7c: 681a         	ldr	r2, [r3]
 8008a7e: 6a3b         	ldr	r3, [r7, #0x20]
 8008a80: 68db         	ldr	r3, [r3, #0xc]
 8008a82: 681b         	ldr	r3, [r3]
 8008a84: 4619         	mov	r1, r3
 8008a86: 4610         	mov	r0, r2
 8008a88: f7f7 fb82    	bl	0x8000190 <__subsf3>    @ imm = #-0x88fc
 8008a8c: 4603         	mov	r3, r0
 8008a8e: 6979         	ldr	r1, [r7, #0x14]
 8008a90: 4618         	mov	r0, r3
 8008a92: f7f7 fc87    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x86f2
 8008a96: 4603         	mov	r3, r0
 8008a98: 68f9         	ldr	r1, [r7, #0xc]
 8008a9a: 4618         	mov	r0, r3
 8008a9c: f7f7 fd36    	bl	0x800050c <__divsf3>    @ imm = #-0x8594
 8008aa0: 4603         	mov	r3, r0
 8008aa2: 461a         	mov	r2, r3
 8008aa4: 6a3b         	ldr	r3, [r7, #0x20]
 8008aa6: 615a         	str	r2, [r3, #0x14]
;     *(pid_data->output) = kp * (err + pid_data->err_integral + pid_data->err_derivate);
 8008aa8: 6a3b         	ldr	r3, [r7, #0x20]
 8008aaa: 691b         	ldr	r3, [r3, #0x10]
 8008aac: 6939         	ldr	r1, [r7, #0x10]
 8008aae: 4618         	mov	r0, r3
 8008ab0: f7f7 fb70    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x8920
 8008ab4: 4603         	mov	r3, r0
 8008ab6: 461a         	mov	r2, r3
 8008ab8: 6a3b         	ldr	r3, [r7, #0x20]
 8008aba: 695b         	ldr	r3, [r3, #0x14]
 8008abc: 4619         	mov	r1, r3
 8008abe: 4610         	mov	r0, r2
 8008ac0: f7f7 fb68    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x8930
 8008ac4: 4603         	mov	r3, r0
 8008ac6: 461a         	mov	r2, r3
 8008ac8: 6a3b         	ldr	r3, [r7, #0x20]
 8008aca: 6a5c         	ldr	r4, [r3, #0x24]
 8008acc: 69f9         	ldr	r1, [r7, #0x1c]
 8008ace: 4610         	mov	r0, r2
 8008ad0: f7f7 fc68    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x8730
 8008ad4: 4603         	mov	r3, r0
 8008ad6: 6023         	str	r3, [r4]
;     return;
 8008ad8: e000         	b	0x8008adc <pid_mit_calc+0x180> @ imm = #0x0
;         return;
 8008ada: bf00         	nop
; }
 8008adc: 3728         	adds	r7, #0x28
 8008ade: 46bd         	mov	sp, r7
 8008ae0: e8bd 83b0    	pop.w	{r4, r5, r7, r8, r9, pc}

08008ae4 <$d>:
 8008ae4: 19 86 61 18  	.word	0x18618619
 8008ae8: 00 24 74 49  	.word	0x49742400

08008aec <HAL_RCC_GetSysClockFreq>:
; {
 8008aec: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 8008af0: b090         	sub	sp, #0x40
 8008af2: af00         	add	r7, sp, #0x0
;   uint32_t pllm = 0U;
 8008af4: 2300         	movs	r3, #0x0
 8008af6: 637b         	str	r3, [r7, #0x34]
;   uint32_t pllvco = 0U;
 8008af8: 2300         	movs	r3, #0x0
 8008afa: 63fb         	str	r3, [r7, #0x3c]
;   uint32_t pllp = 0U;
 8008afc: 2300         	movs	r3, #0x0
 8008afe: 633b         	str	r3, [r7, #0x30]
;   uint32_t sysclockfreq = 0U;
 8008b00: 2300         	movs	r3, #0x0
 8008b02: 63bb         	str	r3, [r7, #0x38]
;   switch (RCC->CFGR & RCC_CFGR_SWS)
 8008b04: 4b59         	ldr	r3, [pc, #0x164]        @ 0x8008c6c <HAL_RCC_GetSysClockFreq+0x180>
 8008b06: 689b         	ldr	r3, [r3, #0x8]
 8008b08: f003 030c    	and	r3, r3, #0xc
 8008b0c: 2b08         	cmp	r3, #0x8
 8008b0e: d00d         	beq	0x8008b2c <HAL_RCC_GetSysClockFreq+0x40> @ imm = #0x1a
 8008b10: 2b08         	cmp	r3, #0x8
 8008b12: f200 80a2    	bhi.w	0x8008c5a <HAL_RCC_GetSysClockFreq+0x16e> @ imm = #0x144
 8008b16: 2b00         	cmp	r3, #0x0
 8008b18: d002         	beq	0x8008b20 <HAL_RCC_GetSysClockFreq+0x34> @ imm = #0x4
 8008b1a: 2b04         	cmp	r3, #0x4
 8008b1c: d003         	beq	0x8008b26 <HAL_RCC_GetSysClockFreq+0x3a> @ imm = #0x6
 8008b1e: e09c         	b	0x8008c5a <HAL_RCC_GetSysClockFreq+0x16e> @ imm = #0x138
;       sysclockfreq = HSI_VALUE;
 8008b20: 4b53         	ldr	r3, [pc, #0x14c]        @ 0x8008c70 <HAL_RCC_GetSysClockFreq+0x184>
 8008b22: 63bb         	str	r3, [r7, #0x38]
;       break;
 8008b24: e09c         	b	0x8008c60 <HAL_RCC_GetSysClockFreq+0x174> @ imm = #0x138
;       sysclockfreq = HSE_VALUE;
 8008b26: 4b53         	ldr	r3, [pc, #0x14c]        @ 0x8008c74 <HAL_RCC_GetSysClockFreq+0x188>
 8008b28: 63bb         	str	r3, [r7, #0x38]
;       break;
 8008b2a: e099         	b	0x8008c60 <HAL_RCC_GetSysClockFreq+0x174> @ imm = #0x132
;       pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8008b2c: 4b4f         	ldr	r3, [pc, #0x13c]        @ 0x8008c6c <HAL_RCC_GetSysClockFreq+0x180>
 8008b2e: 685b         	ldr	r3, [r3, #0x4]
 8008b30: f003 033f    	and	r3, r3, #0x3f
 8008b34: 637b         	str	r3, [r7, #0x34]
;       if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 8008b36: 4b4d         	ldr	r3, [pc, #0x134]        @ 0x8008c6c <HAL_RCC_GetSysClockFreq+0x180>
 8008b38: 685b         	ldr	r3, [r3, #0x4]
 8008b3a: f403 0380    	and	r3, r3, #0x400000
 8008b3e: 2b00         	cmp	r3, #0x0
 8008b40: d027         	beq	0x8008b92 <HAL_RCC_GetSysClockFreq+0xa6> @ imm = #0x4e
;         pllvco = (uint32_t)((((uint64_t) HSE_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8008b42: 4b4a         	ldr	r3, [pc, #0x128]        @ 0x8008c6c <HAL_RCC_GetSysClockFreq+0x180>
 8008b44: 685b         	ldr	r3, [r3, #0x4]
 8008b46: 099b         	lsrs	r3, r3, #0x6
 8008b48: 2200         	movs	r2, #0x0
 8008b4a: 623b         	str	r3, [r7, #0x20]
 8008b4c: 627a         	str	r2, [r7, #0x24]
 8008b4e: 6a3b         	ldr	r3, [r7, #0x20]
 8008b50: f3c3 0008    	ubfx	r0, r3, #0x0, #0x9
 8008b54: 2100         	movs	r1, #0x0
 8008b56: 4b47         	ldr	r3, [pc, #0x11c]        @ 0x8008c74 <HAL_RCC_GetSysClockFreq+0x188>
 8008b58: fb03 f201    	mul	r2, r3, r1
 8008b5c: 2300         	movs	r3, #0x0
 8008b5e: fb00 f303    	mul	r3, r0, r3
 8008b62: 4413         	add	r3, r2
 8008b64: 4a43         	ldr	r2, [pc, #0x10c]        @ 0x8008c74 <HAL_RCC_GetSysClockFreq+0x188>
 8008b66: fba0 2102    	umull	r2, r1, r0, r2
 8008b6a: 62f9         	str	r1, [r7, #0x2c]
 8008b6c: 62ba         	str	r2, [r7, #0x28]
 8008b6e: 6afa         	ldr	r2, [r7, #0x2c]
 8008b70: 4413         	add	r3, r2
 8008b72: 62fb         	str	r3, [r7, #0x2c]
 8008b74: 6b7b         	ldr	r3, [r7, #0x34]
 8008b76: 2200         	movs	r2, #0x0
 8008b78: 61bb         	str	r3, [r7, #0x18]
 8008b7a: 61fa         	str	r2, [r7, #0x1c]
 8008b7c: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 8008b80: e9d7 010a    	ldrd	r0, r1, [r7, #40]
 8008b84: f7f7 fdfa    	bl	0x800077c <__aeabi_uldivmod> @ imm = #-0x840c
 8008b88: 4602         	mov	r2, r0
 8008b8a: 460b         	mov	r3, r1
 8008b8c: 4613         	mov	r3, r2
 8008b8e: 63fb         	str	r3, [r7, #0x3c]
 8008b90: e055         	b	0x8008c3e <HAL_RCC_GetSysClockFreq+0x152> @ imm = #0xaa
;         pllvco = (uint32_t)((((uint64_t) HSI_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8008b92: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x8008c6c <HAL_RCC_GetSysClockFreq+0x180>
 8008b94: 685b         	ldr	r3, [r3, #0x4]
 8008b96: 099b         	lsrs	r3, r3, #0x6
 8008b98: 2200         	movs	r2, #0x0
 8008b9a: 613b         	str	r3, [r7, #0x10]
 8008b9c: 617a         	str	r2, [r7, #0x14]
 8008b9e: 693b         	ldr	r3, [r7, #0x10]
 8008ba0: f3c3 0a08    	ubfx	r10, r3, #0x0, #0x9
 8008ba4: f04f 0b00    	mov.w	r11, #0x0
 8008ba8: 4652         	mov	r2, r10
 8008baa: 465b         	mov	r3, r11
 8008bac: f04f 0000    	mov.w	r0, #0x0
 8008bb0: f04f 0100    	mov.w	r1, #0x0
 8008bb4: 0159         	lsls	r1, r3, #0x5
 8008bb6: ea41 61d2    	orr.w	r1, r1, r2, lsr #27
 8008bba: 0150         	lsls	r0, r2, #0x5
 8008bbc: 4602         	mov	r2, r0
 8008bbe: 460b         	mov	r3, r1
 8008bc0: ebb2 080a    	subs.w	r8, r2, r10
 8008bc4: eb63 090b    	sbc.w	r9, r3, r11
 8008bc8: f04f 0200    	mov.w	r2, #0x0
 8008bcc: f04f 0300    	mov.w	r3, #0x0
 8008bd0: ea4f 1389    	lsl.w	r3, r9, #0x6
 8008bd4: ea43 6398    	orr.w	r3, r3, r8, lsr #26
 8008bd8: ea4f 1288    	lsl.w	r2, r8, #0x6
 8008bdc: ebb2 0408    	subs.w	r4, r2, r8
 8008be0: eb63 0509    	sbc.w	r5, r3, r9
 8008be4: f04f 0200    	mov.w	r2, #0x0
 8008be8: f04f 0300    	mov.w	r3, #0x0
 8008bec: 00eb         	lsls	r3, r5, #0x3
 8008bee: ea43 7354    	orr.w	r3, r3, r4, lsr #29
 8008bf2: 00e2         	lsls	r2, r4, #0x3
 8008bf4: 4614         	mov	r4, r2
 8008bf6: 461d         	mov	r5, r3
 8008bf8: eb14 030a    	adds.w	r3, r4, r10
 8008bfc: 603b         	str	r3, [r7]
 8008bfe: eb45 030b    	adc.w	r3, r5, r11
 8008c02: 607b         	str	r3, [r7, #0x4]
 8008c04: f04f 0200    	mov.w	r2, #0x0
 8008c08: f04f 0300    	mov.w	r3, #0x0
 8008c0c: e9d7 4500    	ldrd	r4, r5, [r7]
 8008c10: 4629         	mov	r1, r5
 8008c12: 028b         	lsls	r3, r1, #0xa
 8008c14: 4620         	mov	r0, r4
 8008c16: 4629         	mov	r1, r5
 8008c18: 4604         	mov	r4, r0
 8008c1a: ea43 5394    	orr.w	r3, r3, r4, lsr #22
 8008c1e: 4601         	mov	r1, r0
 8008c20: 028a         	lsls	r2, r1, #0xa
 8008c22: 4610         	mov	r0, r2
 8008c24: 4619         	mov	r1, r3
 8008c26: 6b7b         	ldr	r3, [r7, #0x34]
 8008c28: 2200         	movs	r2, #0x0
 8008c2a: 60bb         	str	r3, [r7, #0x8]
 8008c2c: 60fa         	str	r2, [r7, #0xc]
 8008c2e: e9d7 2302    	ldrd	r2, r3, [r7, #8]
 8008c32: f7f7 fda3    	bl	0x800077c <__aeabi_uldivmod> @ imm = #-0x84ba
 8008c36: 4602         	mov	r2, r0
 8008c38: 460b         	mov	r3, r1
 8008c3a: 4613         	mov	r3, r2
 8008c3c: 63fb         	str	r3, [r7, #0x3c]
;       pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1U) * 2U);
 8008c3e: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8008c6c <HAL_RCC_GetSysClockFreq+0x180>
 8008c40: 685b         	ldr	r3, [r3, #0x4]
 8008c42: 0c1b         	lsrs	r3, r3, #0x10
 8008c44: f003 0303    	and	r3, r3, #0x3
 8008c48: 3301         	adds	r3, #0x1
 8008c4a: 005b         	lsls	r3, r3, #0x1
 8008c4c: 633b         	str	r3, [r7, #0x30]
;       sysclockfreq = pllvco / pllp;
 8008c4e: 6bfa         	ldr	r2, [r7, #0x3c]
 8008c50: 6b3b         	ldr	r3, [r7, #0x30]
 8008c52: fbb2 f3f3    	udiv	r3, r2, r3
 8008c56: 63bb         	str	r3, [r7, #0x38]
;       break;
 8008c58: e002         	b	0x8008c60 <HAL_RCC_GetSysClockFreq+0x174> @ imm = #0x4
;       sysclockfreq = HSI_VALUE;
 8008c5a: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8008c70 <HAL_RCC_GetSysClockFreq+0x184>
 8008c5c: 63bb         	str	r3, [r7, #0x38]
;       break;
 8008c5e: bf00         	nop
;   return sysclockfreq;
 8008c60: 6bbb         	ldr	r3, [r7, #0x38]
; }
 8008c62: 4618         	mov	r0, r3
 8008c64: 3740         	adds	r7, #0x40
 8008c66: 46bd         	mov	sp, r7
 8008c68: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

08008c6c <$d>:
 8008c6c: 00 38 02 40  	.word	0x40023800
 8008c70: 00 24 f4 00  	.word	0x00f42400
 8008c74: 00 1b b7 00  	.word	0x00b71b00

08008c78 <LL_FLASH_SetLatency>:
; {
 8008c78: b480         	push	{r7}
 8008c7a: b083         	sub	sp, #0xc
 8008c7c: af00         	add	r7, sp, #0x0
 8008c7e: 6078         	str	r0, [r7, #0x4]
;   MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, Latency);
 8008c80: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8008c9c <LL_FLASH_SetLatency+0x24>
 8008c82: 681b         	ldr	r3, [r3]
 8008c84: f023 0207    	bic	r2, r3, #0x7
 8008c88: 4904         	ldr	r1, [pc, #0x10]         @ 0x8008c9c <LL_FLASH_SetLatency+0x24>
 8008c8a: 687b         	ldr	r3, [r7, #0x4]
 8008c8c: 4313         	orrs	r3, r2
 8008c8e: 600b         	str	r3, [r1]
; }
 8008c90: bf00         	nop
 8008c92: 370c         	adds	r7, #0xc
 8008c94: 46bd         	mov	sp, r7
 8008c96: bc80         	pop	{r7}
 8008c98: 4770         	bx	lr
 8008c9a: bf00         	nop

08008c9c <$d>:
 8008c9c: 00 3c 02 40  	.word	0x40023c00

08008ca0 <LL_FLASH_GetLatency>:
; {
 8008ca0: b480         	push	{r7}
 8008ca2: af00         	add	r7, sp, #0x0
;   return (uint32_t)(READ_BIT(FLASH->ACR, FLASH_ACR_LATENCY));
 8008ca4: 4b03         	ldr	r3, [pc, #0xc]          @ 0x8008cb4 <LL_FLASH_GetLatency+0x14>
 8008ca6: 681b         	ldr	r3, [r3]
 8008ca8: f003 0307    	and	r3, r3, #0x7
; }
 8008cac: 4618         	mov	r0, r3
 8008cae: 46bd         	mov	sp, r7
 8008cb0: bc80         	pop	{r7}
 8008cb2: 4770         	bx	lr

08008cb4 <$d>:
 8008cb4: 00 3c 02 40  	.word	0x40023c00

08008cb8 <LL_PWR_GetRegulVoltageScaling>:
; {
 8008cb8: b480         	push	{r7}
 8008cba: af00         	add	r7, sp, #0x0
;   return (uint32_t)(READ_BIT(PWR->CR, PWR_CR_VOS));
 8008cbc: 4b03         	ldr	r3, [pc, #0xc]          @ 0x8008ccc <LL_PWR_GetRegulVoltageScaling+0x14>
 8008cbe: 681b         	ldr	r3, [r3]
 8008cc0: f403 4380    	and	r3, r3, #0x4000
; }
 8008cc4: 4618         	mov	r0, r3
 8008cc6: 46bd         	mov	sp, r7
 8008cc8: bc80         	pop	{r7}
 8008cca: 4770         	bx	lr

08008ccc <$d>:
 8008ccc: 00 70 00 40  	.word	0x40007000

08008cd0 <LL_SetFlashLatency>:
; {
 8008cd0: b580         	push	{r7, lr}
 8008cd2: b086         	sub	sp, #0x18
 8008cd4: af00         	add	r7, sp, #0x0
 8008cd6: 6078         	str	r0, [r7, #0x4]
;   uint32_t latency = LL_FLASH_LATENCY_0;  /* default value 0WS */
 8008cd8: 2300         	movs	r3, #0x0
 8008cda: 613b         	str	r3, [r7, #0x10]
;   ErrorStatus status = SUCCESS;
 8008cdc: 2300         	movs	r3, #0x0
 8008cde: 73fb         	strb	r3, [r7, #0xf]
;   if(HCLK_Frequency == 0U)
 8008ce0: 687b         	ldr	r3, [r7, #0x4]
 8008ce2: 2b00         	cmp	r3, #0x0
 8008ce4: d102         	bne	0x8008cec <LL_SetFlashLatency+0x1c> @ imm = #0x4
;     status = ERROR;
 8008ce6: 2301         	movs	r3, #0x1
 8008ce8: 73fb         	strb	r3, [r7, #0xf]
 8008cea: e078         	b	0x8008dde <LL_SetFlashLatency+0x10e> @ imm = #0xf0
;     if(LL_PWR_GetRegulVoltageScaling() == LL_PWR_REGU_VOLTAGE_SCALE1)
 8008cec: f7ff ffe4    	bl	0x8008cb8 <LL_PWR_GetRegulVoltageScaling> @ imm = #-0x38
 8008cf0: 4603         	mov	r3, r0
 8008cf2: f5b3 4f80    	cmp.w	r3, #0x4000
 8008cf6: d12d         	bne	0x8008d54 <LL_SetFlashLatency+0x84> @ imm = #0x5a
;       if((HCLK_Frequency > UTILS_SCALE1_LATENCY5_FREQ)&&(latency == LL_FLASH_LATENCY_0))
 8008cf8: 687b         	ldr	r3, [r7, #0x4]
 8008cfa: 4a3b         	ldr	r2, [pc, #0xec]         @ 0x8008de8 <LL_SetFlashLatency+0x118>
 8008cfc: 4293         	cmp	r3, r2
 8008cfe: d904         	bls	0x8008d0a <LL_SetFlashLatency+0x3a> @ imm = #0x8
 8008d00: 693b         	ldr	r3, [r7, #0x10]
 8008d02: 2b00         	cmp	r3, #0x0
 8008d04: d101         	bne	0x8008d0a <LL_SetFlashLatency+0x3a> @ imm = #0x2
;         latency = LL_FLASH_LATENCY_5;
 8008d06: 2305         	movs	r3, #0x5
 8008d08: 613b         	str	r3, [r7, #0x10]
;       if((HCLK_Frequency > UTILS_SCALE1_LATENCY4_FREQ)&&(latency == LL_FLASH_LATENCY_0))
 8008d0a: 687b         	ldr	r3, [r7, #0x4]
 8008d0c: 4a37         	ldr	r2, [pc, #0xdc]         @ 0x8008dec <LL_SetFlashLatency+0x11c>
 8008d0e: 4293         	cmp	r3, r2
 8008d10: d904         	bls	0x8008d1c <LL_SetFlashLatency+0x4c> @ imm = #0x8
 8008d12: 693b         	ldr	r3, [r7, #0x10]
 8008d14: 2b00         	cmp	r3, #0x0
 8008d16: d101         	bne	0x8008d1c <LL_SetFlashLatency+0x4c> @ imm = #0x2
;         latency = LL_FLASH_LATENCY_4;
 8008d18: 2304         	movs	r3, #0x4
 8008d1a: 613b         	str	r3, [r7, #0x10]
;       if((HCLK_Frequency > UTILS_SCALE1_LATENCY3_FREQ)&&(latency == LL_FLASH_LATENCY_0))
 8008d1c: 687b         	ldr	r3, [r7, #0x4]
 8008d1e: 4a34         	ldr	r2, [pc, #0xd0]         @ 0x8008df0 <LL_SetFlashLatency+0x120>
 8008d20: 4293         	cmp	r3, r2
 8008d22: d904         	bls	0x8008d2e <LL_SetFlashLatency+0x5e> @ imm = #0x8
 8008d24: 693b         	ldr	r3, [r7, #0x10]
 8008d26: 2b00         	cmp	r3, #0x0
 8008d28: d101         	bne	0x8008d2e <LL_SetFlashLatency+0x5e> @ imm = #0x2
;         latency = LL_FLASH_LATENCY_3;
 8008d2a: 2303         	movs	r3, #0x3
 8008d2c: 613b         	str	r3, [r7, #0x10]
;       if((HCLK_Frequency > UTILS_SCALE1_LATENCY2_FREQ)&&(latency == LL_FLASH_LATENCY_0))
 8008d2e: 687b         	ldr	r3, [r7, #0x4]
 8008d30: 4a30         	ldr	r2, [pc, #0xc0]         @ 0x8008df4 <LL_SetFlashLatency+0x124>
 8008d32: 4293         	cmp	r3, r2
 8008d34: d905         	bls	0x8008d42 <LL_SetFlashLatency+0x72> @ imm = #0xa
 8008d36: 693b         	ldr	r3, [r7, #0x10]
 8008d38: 2b00         	cmp	r3, #0x0
 8008d3a: d102         	bne	0x8008d42 <LL_SetFlashLatency+0x72> @ imm = #0x4
;         latency = LL_FLASH_LATENCY_2;
 8008d3c: 2302         	movs	r3, #0x2
 8008d3e: 613b         	str	r3, [r7, #0x10]
 8008d40: e008         	b	0x8008d54 <LL_SetFlashLatency+0x84> @ imm = #0x10
;         if((HCLK_Frequency > UTILS_SCALE1_LATENCY1_FREQ)&&(latency == LL_FLASH_LATENCY_0))
 8008d42: 687b         	ldr	r3, [r7, #0x4]
 8008d44: 4a2c         	ldr	r2, [pc, #0xb0]         @ 0x8008df8 <LL_SetFlashLatency+0x128>
 8008d46: 4293         	cmp	r3, r2
 8008d48: d904         	bls	0x8008d54 <LL_SetFlashLatency+0x84> @ imm = #0x8
 8008d4a: 693b         	ldr	r3, [r7, #0x10]
 8008d4c: 2b00         	cmp	r3, #0x0
 8008d4e: d101         	bne	0x8008d54 <LL_SetFlashLatency+0x84> @ imm = #0x2
;           latency = LL_FLASH_LATENCY_1;
 8008d50: 2301         	movs	r3, #0x1
 8008d52: 613b         	str	r3, [r7, #0x10]
;     if(LL_PWR_GetRegulVoltageScaling() == LL_PWR_REGU_VOLTAGE_SCALE2)
 8008d54: f7ff ffb0    	bl	0x8008cb8 <LL_PWR_GetRegulVoltageScaling> @ imm = #-0xa0
 8008d58: 4603         	mov	r3, r0
 8008d5a: 2b00         	cmp	r3, #0x0
 8008d5c: d124         	bne	0x8008da8 <LL_SetFlashLatency+0xd8> @ imm = #0x48
;       if((HCLK_Frequency > UTILS_SCALE2_LATENCY4_FREQ)&&(latency == LL_FLASH_LATENCY_0))
 8008d5e: 687b         	ldr	r3, [r7, #0x4]
 8008d60: 4a22         	ldr	r2, [pc, #0x88]         @ 0x8008dec <LL_SetFlashLatency+0x11c>
 8008d62: 4293         	cmp	r3, r2
 8008d64: d904         	bls	0x8008d70 <LL_SetFlashLatency+0xa0> @ imm = #0x8
 8008d66: 693b         	ldr	r3, [r7, #0x10]
 8008d68: 2b00         	cmp	r3, #0x0
 8008d6a: d101         	bne	0x8008d70 <LL_SetFlashLatency+0xa0> @ imm = #0x2
;         latency = LL_FLASH_LATENCY_4;
 8008d6c: 2304         	movs	r3, #0x4
 8008d6e: 613b         	str	r3, [r7, #0x10]
;       if((HCLK_Frequency > UTILS_SCALE2_LATENCY3_FREQ)&&(latency == LL_FLASH_LATENCY_0))
 8008d70: 687b         	ldr	r3, [r7, #0x4]
 8008d72: 4a1f         	ldr	r2, [pc, #0x7c]         @ 0x8008df0 <LL_SetFlashLatency+0x120>
 8008d74: 4293         	cmp	r3, r2
 8008d76: d904         	bls	0x8008d82 <LL_SetFlashLatency+0xb2> @ imm = #0x8
 8008d78: 693b         	ldr	r3, [r7, #0x10]
 8008d7a: 2b00         	cmp	r3, #0x0
 8008d7c: d101         	bne	0x8008d82 <LL_SetFlashLatency+0xb2> @ imm = #0x2
;         latency = LL_FLASH_LATENCY_3;
 8008d7e: 2303         	movs	r3, #0x3
 8008d80: 613b         	str	r3, [r7, #0x10]
;       if((HCLK_Frequency > UTILS_SCALE2_LATENCY2_FREQ)&&(latency == LL_FLASH_LATENCY_0))
 8008d82: 687b         	ldr	r3, [r7, #0x4]
 8008d84: 4a1b         	ldr	r2, [pc, #0x6c]         @ 0x8008df4 <LL_SetFlashLatency+0x124>
 8008d86: 4293         	cmp	r3, r2
 8008d88: d905         	bls	0x8008d96 <LL_SetFlashLatency+0xc6> @ imm = #0xa
 8008d8a: 693b         	ldr	r3, [r7, #0x10]
 8008d8c: 2b00         	cmp	r3, #0x0
 8008d8e: d102         	bne	0x8008d96 <LL_SetFlashLatency+0xc6> @ imm = #0x4
;         latency = LL_FLASH_LATENCY_2;
 8008d90: 2302         	movs	r3, #0x2
 8008d92: 613b         	str	r3, [r7, #0x10]
 8008d94: e008         	b	0x8008da8 <LL_SetFlashLatency+0xd8> @ imm = #0x10
;         if((HCLK_Frequency > UTILS_SCALE2_LATENCY1_FREQ)&&(latency == LL_FLASH_LATENCY_0))
 8008d96: 687b         	ldr	r3, [r7, #0x4]
 8008d98: 4a17         	ldr	r2, [pc, #0x5c]         @ 0x8008df8 <LL_SetFlashLatency+0x128>
 8008d9a: 4293         	cmp	r3, r2
 8008d9c: d904         	bls	0x8008da8 <LL_SetFlashLatency+0xd8> @ imm = #0x8
 8008d9e: 693b         	ldr	r3, [r7, #0x10]
 8008da0: 2b00         	cmp	r3, #0x0
 8008da2: d101         	bne	0x8008da8 <LL_SetFlashLatency+0xd8> @ imm = #0x2
;           latency = LL_FLASH_LATENCY_1;
 8008da4: 2301         	movs	r3, #0x1
 8008da6: 613b         	str	r3, [r7, #0x10]
;     LL_FLASH_SetLatency(latency);
 8008da8: 6938         	ldr	r0, [r7, #0x10]
 8008daa: f7ff ff65    	bl	0x8008c78 <LL_FLASH_SetLatency> @ imm = #-0x136
;     timeout = 2;
 8008dae: 2302         	movs	r3, #0x2
 8008db0: 617b         	str	r3, [r7, #0x14]
;     getlatency = LL_FLASH_GetLatency();
 8008db2: f7ff ff75    	bl	0x8008ca0 <LL_FLASH_GetLatency> @ imm = #-0x116
 8008db6: 60b8         	str	r0, [r7, #0x8]
;     timeout--;
 8008db8: 697b         	ldr	r3, [r7, #0x14]
 8008dba: 3b01         	subs	r3, #0x1
 8008dbc: 617b         	str	r3, [r7, #0x14]
;     } while ((getlatency != latency) && (timeout > 0));
 8008dbe: 68ba         	ldr	r2, [r7, #0x8]
 8008dc0: 693b         	ldr	r3, [r7, #0x10]
 8008dc2: 429a         	cmp	r2, r3
 8008dc4: d002         	beq	0x8008dcc <LL_SetFlashLatency+0xfc> @ imm = #0x4
 8008dc6: 697b         	ldr	r3, [r7, #0x14]
 8008dc8: 2b00         	cmp	r3, #0x0
 8008dca: d1f2         	bne	0x8008db2 <LL_SetFlashLatency+0xe2> @ imm = #-0x1c
;     if(getlatency != latency)
 8008dcc: 68ba         	ldr	r2, [r7, #0x8]
 8008dce: 693b         	ldr	r3, [r7, #0x10]
 8008dd0: 429a         	cmp	r2, r3
 8008dd2: d002         	beq	0x8008dda <LL_SetFlashLatency+0x10a> @ imm = #0x4
;       status = ERROR;
 8008dd4: 2301         	movs	r3, #0x1
 8008dd6: 73fb         	strb	r3, [r7, #0xf]
 8008dd8: e001         	b	0x8008dde <LL_SetFlashLatency+0x10e> @ imm = #0x2
;       status = SUCCESS;
 8008dda: 2300         	movs	r3, #0x0
 8008ddc: 73fb         	strb	r3, [r7, #0xf]
;   return status;
 8008dde: 7bfb         	ldrb	r3, [r7, #0xf]
; }
 8008de0: 4618         	mov	r0, r3
 8008de2: 3718         	adds	r7, #0x18
 8008de4: 46bd         	mov	sp, r7
 8008de6: bd80         	pop	{r7, pc}

08008de8 <$d>:
 8008de8: 80 d1 f0 08  	.word	0x08f0d180
 8008dec: 00 0e 27 07  	.word	0x07270e00
 8008df0: 80 4a 5d 05  	.word	0x055d4a80
 8008df4: 00 87 93 03  	.word	0x03938700
 8008df8: 80 c3 c9 01  	.word	0x01c9c380

08008dfc <z_device_state_init>:
; {
 8008dfc: b580         	push	{r7, lr}
 8008dfe: b082         	sub	sp, #0x8
 8008e00: af00         	add	r7, sp, #0x0
; 	STRUCT_SECTION_FOREACH(device, dev) {
 8008e02: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x8008e30 <z_device_state_init+0x34>
 8008e04: 607b         	str	r3, [r7, #0x4]
 8008e06: e005         	b	0x8008e14 <z_device_state_init+0x18> @ imm = #0xa
; 		k_object_init(dev);
 8008e08: 6878         	ldr	r0, [r7, #0x4]
 8008e0a: f009 fe79    	bl	0x8012b00 <k_object_init> @ imm = #0x9cf2
; 	STRUCT_SECTION_FOREACH(device, dev) {
 8008e0e: 687b         	ldr	r3, [r7, #0x4]
 8008e10: 3314         	adds	r3, #0x14
 8008e12: 607b         	str	r3, [r7, #0x4]
 8008e14: 687b         	ldr	r3, [r7, #0x4]
 8008e16: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8008e34 <z_device_state_init+0x38>
 8008e18: 4293         	cmp	r3, r2
 8008e1a: bf34         	ite	lo
 8008e1c: 2301         	movlo	r3, #0x1
 8008e1e: 2300         	movhs	r3, #0x0
 8008e20: b2db         	uxtb	r3, r3
 8008e22: 2b00         	cmp	r3, #0x0
 8008e24: d1f0         	bne	0x8008e08 <z_device_state_init+0xc> @ imm = #-0x20
; }
 8008e26: bf00         	nop
 8008e28: bf00         	nop
 8008e2a: 3708         	adds	r7, #0x8
 8008e2c: 46bd         	mov	sp, r7
 8008e2e: bd80         	pop	{r7, pc}

08008e30 <$d>:
 8008e30: a4 45 01 08  	.word	0x080145a4
 8008e34: 20 47 01 08  	.word	0x08014720

08008e38 <k_sys_fatal_error_handler>:
; {
 8008e38: b580         	push	{r7, lr}
 8008e3a: b088         	sub	sp, #0x20
 8008e3c: af04         	add	r7, sp, #0x10
 8008e3e: 6078         	str	r0, [r7, #0x4]
 8008e40: 6039         	str	r1, [r7]
; 	LOG_PANIC();
 8008e42: f009 feb0    	bl	0x8012ba6 <log_panic>   @ imm = #0x9d60
; 	LOG_ERR("Halting system");
 8008e46: 2303         	movs	r3, #0x3
 8008e48: 2b00         	cmp	r3, #0x0
 8008e4a: d016         	beq	0x8008e7a <k_sys_fatal_error_handler+0x42> @ imm = #0x2c
 8008e4c: 2301         	movs	r3, #0x1
 8008e4e: 73fb         	strb	r3, [r7, #0xf]
 8008e50: 7bfb         	ldrb	r3, [r7, #0xf]
 8008e52: f083 0301    	eor	r3, r3, #0x1
 8008e56: b2db         	uxtb	r3, r3
 8008e58: 2b00         	cmp	r3, #0x0
 8008e5a: d10e         	bne	0x8008e7a <k_sys_fatal_error_handler+0x42> @ imm = #0x1c
 8008e5c: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8008e80 <k_sys_fatal_error_handler+0x48>
 8008e5e: 6819         	ldr	r1, [r3]
 8008e60: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8008e84 <k_sys_fatal_error_handler+0x4c>
 8008e62: 9302         	str	r3, [sp, #0x8]
 8008e64: 2300         	movs	r3, #0x0
 8008e66: 9301         	str	r3, [sp, #0x4]
 8008e68: 2300         	movs	r3, #0x0
 8008e6a: 9300         	str	r3, [sp]
 8008e6c: 2300         	movs	r3, #0x0
 8008e6e: 2201         	movs	r2, #0x1
 8008e70: 2000         	movs	r0, #0x0
 8008e72: f009 fe7a    	bl	0x8012b6a <z_log_msg_runtime_create> @ imm = #0x9cf4
 8008e76: 2300         	movs	r3, #0x0
 8008e78: 60bb         	str	r3, [r7, #0x8]
; 	arch_system_halt(reason);
 8008e7a: 6878         	ldr	r0, [r7, #0x4]
 8008e7c: f009 fea4    	bl	0x8012bc8 <arch_system_halt> @ imm = #0x9d48

08008e80 <$d>:
 8008e80: f8 00 00 20  	.word	0x200000f8
 8008e84: 40 5c 01 08  	.word	0x08015c40

08008e88 <thread_name_get>:
; {
 8008e88: b580         	push	{r7, lr}
 8008e8a: b084         	sub	sp, #0x10
 8008e8c: af00         	add	r7, sp, #0x0
 8008e8e: 6078         	str	r0, [r7, #0x4]
; 	const char *thread_name = (thread != NULL) ? k_thread_name_get(thread) : NULL;
 8008e90: 687b         	ldr	r3, [r7, #0x4]
 8008e92: 2b00         	cmp	r3, #0x0
 8008e94: d004         	beq	0x8008ea0 <thread_name_get+0x18> @ imm = #0x8
 8008e96: 6878         	ldr	r0, [r7, #0x4]
 8008e98: f00a fb09    	bl	0x80134ae <k_thread_name_get> @ imm = #0xa612
 8008e9c: 4603         	mov	r3, r0
 8008e9e: e000         	b	0x8008ea2 <thread_name_get+0x1a> @ imm = #0x0
 8008ea0: 2300         	movs	r3, #0x0
 8008ea2: 60fb         	str	r3, [r7, #0xc]
; 	if ((thread_name == NULL) || (thread_name[0] == '\0')) {
 8008ea4: 68fb         	ldr	r3, [r7, #0xc]
 8008ea6: 2b00         	cmp	r3, #0x0
 8008ea8: d003         	beq	0x8008eb2 <thread_name_get+0x2a> @ imm = #0x6
 8008eaa: 68fb         	ldr	r3, [r7, #0xc]
 8008eac: 781b         	ldrb	r3, [r3]
 8008eae: 2b00         	cmp	r3, #0x0
 8008eb0: d101         	bne	0x8008eb6 <thread_name_get+0x2e> @ imm = #0x2
; 		thread_name = "unknown";
 8008eb2: 4b03         	ldr	r3, [pc, #0xc]          @ 0x8008ec0 <thread_name_get+0x38>
 8008eb4: 60fb         	str	r3, [r7, #0xc]
; 	return thread_name;
 8008eb6: 68fb         	ldr	r3, [r7, #0xc]
; }
 8008eb8: 4618         	mov	r0, r3
 8008eba: 3710         	adds	r7, #0x10
 8008ebc: 46bd         	mov	sp, r7
 8008ebe: bd80         	pop	{r7, pc}

08008ec0 <$d>:
 8008ec0: 50 5c 01 08  	.word	0x08015c50

08008ec4 <reason_to_str>:
; {
 8008ec4: b480         	push	{r7}
 8008ec6: b083         	sub	sp, #0xc
 8008ec8: af00         	add	r7, sp, #0x0
 8008eca: 6078         	str	r0, [r7, #0x4]
; 	switch (reason) {
 8008ecc: 687b         	ldr	r3, [r7, #0x4]
 8008ece: 2b04         	cmp	r3, #0x4
 8008ed0: d816         	bhi	0x8008f00 <reason_to_str+0x3c> @ imm = #0x2c
 8008ed2: a201         	adr	r2, #4 <reason_to_str+0x13>
 8008ed4: f852 f023    	ldr.w	pc, [r2, r3, lsl #2]

08008ed8 <$d>:
 8008ed8: ed 8e 00 08  	.word	0x08008eed
 8008edc: f1 8e 00 08  	.word	0x08008ef1
 8008ee0: f5 8e 00 08  	.word	0x08008ef5
 8008ee4: f9 8e 00 08  	.word	0x08008ef9
 8008ee8: fd 8e 00 08  	.word	0x08008efd

08008eec <$t>:
; 		return "CPU exception";
 8008eec: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8008f0c <reason_to_str+0x48>
 8008eee: e008         	b	0x8008f02 <reason_to_str+0x3e> @ imm = #0x10
; 		return "Unhandled interrupt";
 8008ef0: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8008f10 <reason_to_str+0x4c>
 8008ef2: e006         	b	0x8008f02 <reason_to_str+0x3e> @ imm = #0xc
; 		return "Stack overflow";
 8008ef4: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8008f14 <reason_to_str+0x50>
 8008ef6: e004         	b	0x8008f02 <reason_to_str+0x3e> @ imm = #0x8
; 		return "Kernel oops";
 8008ef8: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8008f18 <reason_to_str+0x54>
 8008efa: e002         	b	0x8008f02 <reason_to_str+0x3e> @ imm = #0x4
; 		return "Kernel panic";
 8008efc: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8008f1c <reason_to_str+0x58>
 8008efe: e000         	b	0x8008f02 <reason_to_str+0x3e> @ imm = #0x0
; 		return "Unknown error";
 8008f00: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x8008f20 <reason_to_str+0x5c>
; }
 8008f02: 4618         	mov	r0, r3
 8008f04: 370c         	adds	r7, #0xc
 8008f06: 46bd         	mov	sp, r7
 8008f08: bc80         	pop	{r7}
 8008f0a: 4770         	bx	lr

08008f0c <$d>:
 8008f0c: 58 5c 01 08  	.word	0x08015c58
 8008f10: 68 5c 01 08  	.word	0x08015c68
 8008f14: 7c 5c 01 08  	.word	0x08015c7c
 8008f18: 8c 5c 01 08  	.word	0x08015c8c
 8008f1c: 98 5c 01 08  	.word	0x08015c98
 8008f20: a8 5c 01 08  	.word	0x08015ca8

08008f24 <z_fatal_error>:
; {
 8008f24: b590         	push	{r4, r7, lr}
 8008f26: b099         	sub	sp, #0x64
 8008f28: af06         	add	r7, sp, #0x18
 8008f2a: 6078         	str	r0, [r7, #0x4]
 8008f2c: 6039         	str	r1, [r7]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8008f2e: f3ef 8311    	mrs	r3, basepri
 8008f32: 623b         	str	r3, [r7, #0x20]
;   return(result);
 8008f34: 6a3b         	ldr	r3, [r7, #0x20]
; 	key = __get_BASEPRI();
 8008f36: 61fb         	str	r3, [r7, #0x1c]
 8008f38: 2310         	movs	r3, #0x10
 8008f3a: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8008f3c: 69bb         	ldr	r3, [r7, #0x18]
 8008f3e: f383 8812    	msr	basepri_max, r3
; }
 8008f42: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8008f44: f3bf 8f6f    	isb	sy
; }
 8008f48: bf00         	nop
; 	return key;
 8008f4a: 69fb         	ldr	r3, [r7, #0x1c]
; 	unsigned int key = arch_irq_lock();
 8008f4c: 63bb         	str	r3, [r7, #0x38]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8008f4e: 4b50         	ldr	r3, [pc, #0x140]        @ 0x8009090 <z_fatal_error+0x16c>
 8008f50: 689b         	ldr	r3, [r3, #0x8]
 8008f52: 627b         	str	r3, [r7, #0x24]
; 	return ret;
 8008f54: 6a7b         	ldr	r3, [r7, #0x24]
; 			arch_current_thread() : NULL;
 8008f56: 643b         	str	r3, [r7, #0x40]
; 	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
 8008f58: 2303         	movs	r3, #0x3
 8008f5a: 2b00         	cmp	r3, #0x0
 8008f5c: d023         	beq	0x8008fa6 <z_fatal_error+0x82> @ imm = #0x46
 8008f5e: 2301         	movs	r3, #0x1
 8008f60: f887 303f    	strb.w	r3, [r7, #0x3f]
 8008f64: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 8008f68: f083 0301    	eor	r3, r3, #0x1
 8008f6c: b2db         	uxtb	r3, r3
 8008f6e: 2b00         	cmp	r3, #0x0
 8008f70: d119         	bne	0x8008fa6 <z_fatal_error+0x82> @ imm = #0x32
 8008f72: 4b48         	ldr	r3, [pc, #0x120]        @ 0x8009094 <z_fatal_error+0x170>
 8008f74: 681c         	ldr	r4, [r3]
 8008f76: 6878         	ldr	r0, [r7, #0x4]
 8008f78: f7ff ffa4    	bl	0x8008ec4 <reason_to_str> @ imm = #-0xb8
 8008f7c: 4603         	mov	r3, r0
 8008f7e: 4a44         	ldr	r2, [pc, #0x110]        @ 0x8009090 <z_fatal_error+0x16c>
 8008f80: 7c12         	ldrb	r2, [r2, #0x10]
 8008f82: 9205         	str	r2, [sp, #0x14]
 8008f84: 9304         	str	r3, [sp, #0x10]
 8008f86: 687b         	ldr	r3, [r7, #0x4]
 8008f88: 9303         	str	r3, [sp, #0xc]
 8008f8a: 4b43         	ldr	r3, [pc, #0x10c]        @ 0x8009098 <z_fatal_error+0x174>
 8008f8c: 9302         	str	r3, [sp, #0x8]
 8008f8e: 2300         	movs	r3, #0x0
 8008f90: 9301         	str	r3, [sp, #0x4]
 8008f92: 2300         	movs	r3, #0x0
 8008f94: 9300         	str	r3, [sp]
 8008f96: 2300         	movs	r3, #0x0
 8008f98: 2201         	movs	r2, #0x1
 8008f9a: 4621         	mov	r1, r4
 8008f9c: 2000         	movs	r0, #0x0
 8008f9e: f009 fde4    	bl	0x8012b6a <z_log_msg_runtime_create> @ imm = #0x9bc8
 8008fa2: 2300         	movs	r3, #0x0
 8008fa4: 647b         	str	r3, [r7, #0x44]
; 	if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
 8008fa6: 683b         	ldr	r3, [r7]
 8008fa8: 2b00         	cmp	r3, #0x0
 8008faa: d028         	beq	0x8008ffe <z_fatal_error+0xda> @ imm = #0x50
 8008fac: 683b         	ldr	r3, [r7]
 8008fae: 617b         	str	r3, [r7, #0x14]
; 	return (esf->basic.xpsr & IPSR_ISR_Msk) ? (true) : (false);
 8008fb0: 697b         	ldr	r3, [r7, #0x14]
 8008fb2: 69db         	ldr	r3, [r3, #0x1c]
 8008fb4: f3c3 0308    	ubfx	r3, r3, #0x0, #0x9
 8008fb8: 2b00         	cmp	r3, #0x0
 8008fba: bf14         	ite	ne
 8008fbc: 2301         	movne	r3, #0x1
 8008fbe: 2300         	moveq	r3, #0x0
 8008fc0: b2db         	uxtb	r3, r3
; 	if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
 8008fc2: 2b00         	cmp	r3, #0x0
 8008fc4: d01b         	beq	0x8008ffe <z_fatal_error+0xda> @ imm = #0x36
; 		LOG_ERR("Fault during interrupt handling\n");
 8008fc6: 2303         	movs	r3, #0x3
 8008fc8: 2b00         	cmp	r3, #0x0
 8008fca: d018         	beq	0x8008ffe <z_fatal_error+0xda> @ imm = #0x30
 8008fcc: 2301         	movs	r3, #0x1
 8008fce: f887 3037    	strb.w	r3, [r7, #0x37]
 8008fd2: f897 3037    	ldrb.w	r3, [r7, #0x37]
 8008fd6: f083 0301    	eor	r3, r3, #0x1
 8008fda: b2db         	uxtb	r3, r3
 8008fdc: 2b00         	cmp	r3, #0x0
 8008fde: d10e         	bne	0x8008ffe <z_fatal_error+0xda> @ imm = #0x1c
 8008fe0: 4b2c         	ldr	r3, [pc, #0xb0]         @ 0x8009094 <z_fatal_error+0x170>
 8008fe2: 6819         	ldr	r1, [r3]
 8008fe4: 4b2d         	ldr	r3, [pc, #0xb4]         @ 0x800909c <z_fatal_error+0x178>
 8008fe6: 9302         	str	r3, [sp, #0x8]
 8008fe8: 2300         	movs	r3, #0x0
 8008fea: 9301         	str	r3, [sp, #0x4]
 8008fec: 2300         	movs	r3, #0x0
 8008fee: 9300         	str	r3, [sp]
 8008ff0: 2300         	movs	r3, #0x0
 8008ff2: 2201         	movs	r2, #0x1
 8008ff4: 2000         	movs	r0, #0x0
 8008ff6: f009 fdb8    	bl	0x8012b6a <z_log_msg_runtime_create> @ imm = #0x9b70
 8008ffa: 2300         	movs	r3, #0x0
 8008ffc: 633b         	str	r3, [r7, #0x30]
; 		LOG_ERR("Current thread: %p (%s)", thread, thread_name_get(thread));
 8008ffe: 2303         	movs	r3, #0x3
 8009000: 2b00         	cmp	r3, #0x0
 8009002: d020         	beq	0x8009046 <z_fatal_error+0x122> @ imm = #0x40
 8009004: 2301         	movs	r3, #0x1
 8009006: f887 302f    	strb.w	r3, [r7, #0x2f]
 800900a: f897 302f    	ldrb.w	r3, [r7, #0x2f]
 800900e: f083 0301    	eor	r3, r3, #0x1
 8009012: b2db         	uxtb	r3, r3
 8009014: 2b00         	cmp	r3, #0x0
 8009016: d116         	bne	0x8009046 <z_fatal_error+0x122> @ imm = #0x2c
 8009018: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x8009094 <z_fatal_error+0x170>
 800901a: 681c         	ldr	r4, [r3]
 800901c: 6c38         	ldr	r0, [r7, #0x40]
 800901e: f7ff ff33    	bl	0x8008e88 <thread_name_get> @ imm = #-0x19a
 8009022: 4603         	mov	r3, r0
 8009024: 9304         	str	r3, [sp, #0x10]
 8009026: 6c3b         	ldr	r3, [r7, #0x40]
 8009028: 9303         	str	r3, [sp, #0xc]
 800902a: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x80090a0 <z_fatal_error+0x17c>
 800902c: 9302         	str	r3, [sp, #0x8]
 800902e: 2300         	movs	r3, #0x0
 8009030: 9301         	str	r3, [sp, #0x4]
 8009032: 2300         	movs	r3, #0x0
 8009034: 9300         	str	r3, [sp]
 8009036: 2300         	movs	r3, #0x0
 8009038: 2201         	movs	r2, #0x1
 800903a: 4621         	mov	r1, r4
 800903c: 2000         	movs	r0, #0x0
 800903e: f009 fd94    	bl	0x8012b6a <z_log_msg_runtime_create> @ imm = #0x9b28
 8009042: 2300         	movs	r3, #0x0
 8009044: 62bb         	str	r3, [r7, #0x28]
; 	coredump(reason, esf, thread);
 8009046: 6c3a         	ldr	r2, [r7, #0x40]
 8009048: 6839         	ldr	r1, [r7]
 800904a: 6878         	ldr	r0, [r7, #0x4]
 800904c: f009 fdb1    	bl	0x8012bb2 <coredump>    @ imm = #0x9b62
; 	k_sys_fatal_error_handler(reason, esf);
 8009050: 6839         	ldr	r1, [r7]
 8009052: 6878         	ldr	r0, [r7, #0x4]
 8009054: f7ff fef0    	bl	0x8008e38 <k_sys_fatal_error_handler> @ imm = #-0x220
; 		if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
 8009058: 683b         	ldr	r3, [r7]
 800905a: 2b00         	cmp	r3, #0x0
 800905c: d006         	beq	0x800906c <z_fatal_error+0x148> @ imm = #0xc
 800905e: 683b         	ldr	r3, [r7]
 8009060: 613b         	str	r3, [r7, #0x10]
; 	return (esf->basic.xpsr & IPSR_ISR_Msk) ? (true) : (false);
 8009062: 693b         	ldr	r3, [r7, #0x10]
 8009064: 69db         	ldr	r3, [r3, #0x1c]
 8009066: f3c3 0308    	ubfx	r3, r3, #0x0, #0x9
 800906a: 2b00         	cmp	r3, #0x0
 800906c: 6bbb         	ldr	r3, [r7, #0x38]
 800906e: 60fb         	str	r3, [r7, #0xc]
 8009070: 68fb         	ldr	r3, [r7, #0xc]
 8009072: 60bb         	str	r3, [r7, #0x8]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8009074: 68bb         	ldr	r3, [r7, #0x8]
 8009076: f383 8811    	msr	basepri, r3
; }
 800907a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800907c: f3bf 8f6f    	isb	sy
; }
 8009080: bf00         	nop
; }
 8009082: bf00         	nop
; 		k_thread_abort(thread);
 8009084: 6c38         	ldr	r0, [r7, #0x40]
 8009086: f009 fd65    	bl	0x8012b54 <k_thread_abort> @ imm = #0x9aca
; }
 800908a: 374c         	adds	r7, #0x4c
 800908c: 46bd         	mov	sp, r7
 800908e: bd90         	pop	{r4, r7, pc}

08009090 <$d>:
 8009090: c0 02 00 20  	.word	0x200002c0
 8009094: f8 00 00 20  	.word	0x200000f8
 8009098: b8 5c 01 08  	.word	0x08015cb8
 800909c: e0 5c 01 08  	.word	0x08015ce0
 80090a0: 04 5d 01 08  	.word	0x08015d04

080090a4 <__NVIC_SetPriority>:
; {
 80090a4: b480         	push	{r7}
 80090a6: b083         	sub	sp, #0xc
 80090a8: af00         	add	r7, sp, #0x0
 80090aa: 4603         	mov	r3, r0
 80090ac: 6039         	str	r1, [r7]
 80090ae: 71fb         	strb	r3, [r7, #0x7]
;   if ((int32_t)(IRQn) >= 0)
 80090b0: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 80090b4: 2b00         	cmp	r3, #0x0
 80090b6: db0a         	blt	0x80090ce <__NVIC_SetPriority+0x2a> @ imm = #0x14
;     NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80090b8: 683b         	ldr	r3, [r7]
 80090ba: b2da         	uxtb	r2, r3
 80090bc: 490c         	ldr	r1, [pc, #0x30]         @ 0x80090f0 <__NVIC_SetPriority+0x4c>
 80090be: f997 3007    	ldrsb.w	r3, [r7, #0x7]
 80090c2: 0112         	lsls	r2, r2, #0x4
 80090c4: b2d2         	uxtb	r2, r2
 80090c6: 440b         	add	r3, r1
 80090c8: f883 2300    	strb.w	r2, [r3, #0x300]
; }
 80090cc: e00a         	b	0x80090e4 <__NVIC_SetPriority+0x40> @ imm = #0x14
;     SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80090ce: 683b         	ldr	r3, [r7]
 80090d0: b2da         	uxtb	r2, r3
 80090d2: 4908         	ldr	r1, [pc, #0x20]         @ 0x80090f4 <__NVIC_SetPriority+0x50>
 80090d4: 79fb         	ldrb	r3, [r7, #0x7]
 80090d6: f003 030f    	and	r3, r3, #0xf
 80090da: 3b04         	subs	r3, #0x4
 80090dc: 0112         	lsls	r2, r2, #0x4
 80090de: b2d2         	uxtb	r2, r2
 80090e0: 440b         	add	r3, r1
 80090e2: 761a         	strb	r2, [r3, #0x18]
; }
 80090e4: bf00         	nop
 80090e6: 370c         	adds	r7, #0xc
 80090e8: 46bd         	mov	sp, r7
 80090ea: bc80         	pop	{r7}
 80090ec: 4770         	bx	lr
 80090ee: bf00         	nop

080090f0 <$d>:
 80090f0: 00 e1 00 e0  	.word	0xe000e100
 80090f4: 00 ed 00 e0  	.word	0xe000ed00

080090f8 <z_add_thread_timeout>:
; {
 80090f8: b580         	push	{r7, lr}
 80090fa: b084         	sub	sp, #0x10
 80090fc: af00         	add	r7, sp, #0x0
 80090fe: 60f8         	str	r0, [r7, #0xc]
 8009100: e9c7 2300    	strd	r2, r3, [r7]
; 	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
 8009104: 68fb         	ldr	r3, [r7, #0xc]
 8009106: f103 0018    	add.w	r0, r3, #0x18
 800910a: e9d7 2300    	ldrd	r2, r3, [r7]
 800910e: 4903         	ldr	r1, [pc, #0xc]          @ 0x800911c <z_add_thread_timeout+0x24>
 8009110: f002 ff90    	bl	0x800c034 <z_add_timeout> @ imm = #0x2f20
; }
 8009114: bf00         	nop
 8009116: 3710         	adds	r7, #0x10
 8009118: 46bd         	mov	sp, r7
 800911a: bd80         	pop	{r7, pc}

0800911c <$d>:
 800911c: 91 3b 01 08  	.word	0x08013b91

08009120 <z_dummy_thread_init>:
; {
 8009120: b480         	push	{r7}
 8009122: b085         	sub	sp, #0x14
 8009124: af00         	add	r7, sp, #0x0
 8009126: 6078         	str	r0, [r7, #0x4]
; 	dummy_thread->base.thread_state = _THREAD_DUMMY;
 8009128: 687b         	ldr	r3, [r7, #0x4]
 800912a: 2201         	movs	r2, #0x1
 800912c: 735a         	strb	r2, [r3, #0xd]
; 	dummy_thread->base.user_options = K_ESSENTIAL;
 800912e: 687b         	ldr	r3, [r7, #0x4]
 8009130: 2201         	movs	r2, #0x1
 8009132: 731a         	strb	r2, [r3, #0xc]
; 	dummy_thread->stack_info.start = 0U;
 8009134: 687b         	ldr	r3, [r7, #0x4]
 8009136: 2200         	movs	r2, #0x0
 8009138: f8c3 20b4    	str.w	r2, [r3, #0xb4]
; 	dummy_thread->stack_info.size = 0U;
 800913c: 687b         	ldr	r3, [r7, #0x4]
 800913e: 2200         	movs	r2, #0x0
 8009140: f8c3 20b8    	str.w	r2, [r3, #0xb8]
; 	dummy_thread->resource_pool = NULL;
 8009144: 687b         	ldr	r3, [r7, #0x4]
 8009146: 2200         	movs	r2, #0x0
 8009148: f8c3 20c0    	str.w	r2, [r3, #0xc0]
 800914c: 687b         	ldr	r3, [r7, #0x4]
 800914e: 60fb         	str	r3, [r7, #0xc]
; 	_current_cpu->current = thread;
 8009150: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8009164 <z_dummy_thread_init+0x44>
 8009152: 68fb         	ldr	r3, [r7, #0xc]
 8009154: 6093         	str	r3, [r2, #0x8]
; }
 8009156: bf00         	nop
; }
 8009158: bf00         	nop
 800915a: 3714         	adds	r7, #0x14
 800915c: 46bd         	mov	sp, r7
 800915e: bc80         	pop	{r7}
 8009160: 4770         	bx	lr
 8009162: bf00         	nop

08009164 <$d>:
 8009164: c0 02 00 20  	.word	0x200002c0

08009168 <z_init_static_threads>:
; {
 8009168: b5f0         	push	{r4, r5, r6, r7, lr}
 800916a: b08f         	sub	sp, #0x3c
 800916c: af06         	add	r7, sp, #0x18
; 	STRUCT_SECTION_FOREACH(_static_thread_data, thread_data) {
 800916e: 4b31         	ldr	r3, [pc, #0xc4]         @ 0x8009234 <z_init_static_threads+0xcc>
 8009170: 61fb         	str	r3, [r7, #0x1c]
 8009172: e029         	b	0x80091c8 <z_init_static_threads+0x60> @ imm = #0x52
; 		z_setup_new_thread(
 8009174: 69fb         	ldr	r3, [r7, #0x1c]
 8009176: 681e         	ldr	r6, [r3]
 8009178: 69fb         	ldr	r3, [r7, #0x1c]
 800917a: 685b         	ldr	r3, [r3, #0x4]
 800917c: 60fb         	str	r3, [r7, #0xc]
 800917e: 69fb         	ldr	r3, [r7, #0x1c]
 8009180: 689a         	ldr	r2, [r3, #0x8]
 8009182: 60ba         	str	r2, [r7, #0x8]
 8009184: 69fb         	ldr	r3, [r7, #0x1c]
 8009186: 68d8         	ldr	r0, [r3, #0xc]
 8009188: 6078         	str	r0, [r7, #0x4]
 800918a: 69fb         	ldr	r3, [r7, #0x1c]
 800918c: 691b         	ldr	r3, [r3, #0x10]
 800918e: 69fa         	ldr	r2, [r7, #0x1c]
 8009190: 6952         	ldr	r2, [r2, #0x14]
 8009192: 69f9         	ldr	r1, [r7, #0x1c]
 8009194: 6989         	ldr	r1, [r1, #0x18]
 8009196: 69f8         	ldr	r0, [r7, #0x1c]
 8009198: 69c0         	ldr	r0, [r0, #0x1c]
 800919a: 69fc         	ldr	r4, [r7, #0x1c]
 800919c: 6a24         	ldr	r4, [r4, #0x20]
 800919e: 69fd         	ldr	r5, [r7, #0x1c]
 80091a0: 6a6d         	ldr	r5, [r5, #0x24]
 80091a2: 9505         	str	r5, [sp, #0x14]
 80091a4: 9404         	str	r4, [sp, #0x10]
 80091a6: 9003         	str	r0, [sp, #0xc]
 80091a8: 9102         	str	r1, [sp, #0x8]
 80091aa: 9201         	str	r2, [sp, #0x4]
 80091ac: 9300         	str	r3, [sp]
 80091ae: 687b         	ldr	r3, [r7, #0x4]
 80091b0: 68ba         	ldr	r2, [r7, #0x8]
 80091b2: 68f9         	ldr	r1, [r7, #0xc]
 80091b4: 4630         	mov	r0, r6
 80091b6: f001 f89d    	bl	0x800a2f4 <z_setup_new_thread> @ imm = #0x113a
; 		thread_data->init_thread->init_data = thread_data;
 80091ba: 69fb         	ldr	r3, [r7, #0x1c]
 80091bc: 681b         	ldr	r3, [r3]
 80091be: 69fa         	ldr	r2, [r7, #0x1c]
 80091c0: 665a         	str	r2, [r3, #0x64]
; 	STRUCT_SECTION_FOREACH(_static_thread_data, thread_data) {
 80091c2: 69fb         	ldr	r3, [r7, #0x1c]
 80091c4: 3330         	adds	r3, #0x30
 80091c6: 61fb         	str	r3, [r7, #0x1c]
 80091c8: 69fb         	ldr	r3, [r7, #0x1c]
 80091ca: 4a1b         	ldr	r2, [pc, #0x6c]         @ 0x8009238 <z_init_static_threads+0xd0>
 80091cc: 4293         	cmp	r3, r2
 80091ce: bf34         	ite	lo
 80091d0: 2301         	movlo	r3, #0x1
 80091d2: 2300         	movhs	r3, #0x0
 80091d4: b2db         	uxtb	r3, r3
 80091d6: 2b00         	cmp	r3, #0x0
 80091d8: d1cc         	bne	0x8009174 <z_init_static_threads+0xc> @ imm = #-0x68
; 	k_sched_lock();
 80091da: f002 f8ad    	bl	0x800b338 <k_sched_lock> @ imm = #0x215a
; 	STRUCT_SECTION_FOREACH(_static_thread_data, thread_data) {
 80091de: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8009234 <z_init_static_threads+0xcc>
 80091e0: 61bb         	str	r3, [r7, #0x18]
 80091e2: e018         	b	0x8009216 <z_init_static_threads+0xae> @ imm = #0x30
; 		k_timeout_t init_delay = Z_THREAD_INIT_DELAY(thread_data);
 80091e4: 69bb         	ldr	r3, [r7, #0x18]
 80091e6: e9d3 230a    	ldrd	r2, r3, [r3, #40]
 80091ea: e9c7 2304    	strd	r2, r3, [r7, #16]
; 		if (!K_TIMEOUT_EQ(init_delay, K_FOREVER)) {
 80091ee: e9d7 2304    	ldrd	r2, r3, [r7, #16]
 80091f2: f04f 30ff    	mov.w	r0, #0xffffffff
 80091f6: f04f 31ff    	mov.w	r1, #0xffffffff
 80091fa: 428b         	cmp	r3, r1
 80091fc: bf08         	it	eq
 80091fe: 4282         	cmpeq	r2, r0
 8009200: d006         	beq	0x8009210 <z_init_static_threads+0xa8> @ imm = #0xc
; 			thread_schedule_new(thread_data->init_thread,
 8009202: 69bb         	ldr	r3, [r7, #0x18]
 8009204: 6819         	ldr	r1, [r3]
 8009206: e9d7 2304    	ldrd	r2, r3, [r7, #16]
 800920a: 4608         	mov	r0, r1
 800920c: f009 fd10    	bl	0x8012c30 <thread_schedule_new> @ imm = #0x9a20
; 	STRUCT_SECTION_FOREACH(_static_thread_data, thread_data) {
 8009210: 69bb         	ldr	r3, [r7, #0x18]
 8009212: 3330         	adds	r3, #0x30
 8009214: 61bb         	str	r3, [r7, #0x18]
 8009216: 69bb         	ldr	r3, [r7, #0x18]
 8009218: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x8009238 <z_init_static_threads+0xd0>
 800921a: 4293         	cmp	r3, r2
 800921c: bf34         	ite	lo
 800921e: 2301         	movlo	r3, #0x1
 8009220: 2300         	movhs	r3, #0x0
 8009222: b2db         	uxtb	r3, r3
 8009224: 2b00         	cmp	r3, #0x0
 8009226: d1dd         	bne	0x80091e4 <z_init_static_threads+0x7c> @ imm = #-0x46
; 	k_sched_unlock();
 8009228: f002 f8c6    	bl	0x800b3b8 <k_sched_unlock> @ imm = #0x218c
; }
 800922c: bf00         	nop
 800922e: 3724         	adds	r7, #0x24
 8009230: 46bd         	mov	sp, r7
 8009232: bdf0         	pop	{r4, r5, r6, r7, pc}

08009234 <$d>:
 8009234: b0 49 01 08  	.word	0x080149b0
 8009238: e0 49 01 08  	.word	0x080149e0

0800923c <z_bss_zero>:
; {
 800923c: b580         	push	{r7, lr}
 800923e: af00         	add	r7, sp, #0x0
; 	z_early_memset(__bss_start, 0, __bss_end - __bss_start);
 8009240: 4a04         	ldr	r2, [pc, #0x10]         @ 0x8009254 <z_bss_zero+0x18>
 8009242: 4b05         	ldr	r3, [pc, #0x14]         @ 0x8009258 <z_bss_zero+0x1c>
 8009244: 1ad3         	subs	r3, r2, r3
 8009246: 461a         	mov	r2, r3
 8009248: 2100         	movs	r1, #0x0
 800924a: 4803         	ldr	r0, [pc, #0xc]          @ 0x8009258 <z_bss_zero+0x1c>
 800924c: f009 fd3d    	bl	0x8012cca <z_early_memset> @ imm = #0x9a7a
; }
 8009250: bd80         	pop	{r7, pc}
 8009252: bf00         	nop

08009254 <$d>:
 8009254: f8 09 00 20  	.word	0x200009f8
 8009258: e0 01 00 20  	.word	0x200001e0

0800925c <z_sys_init_run_level>:
; {
 800925c: b580         	push	{r7, lr}
 800925e: b086         	sub	sp, #0x18
 8009260: af00         	add	r7, sp, #0x0
 8009262: 4603         	mov	r3, r0
 8009264: 71fb         	strb	r3, [r7, #0x7]
; 	for (entry = levels[level]; entry < levels[level+1]; entry++) {
 8009266: 79fb         	ldrb	r3, [r7, #0x7]
 8009268: 4a11         	ldr	r2, [pc, #0x44]         @ 0x80092b0 <z_sys_init_run_level+0x54>
 800926a: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 800926e: 617b         	str	r3, [r7, #0x14]
 8009270: e011         	b	0x8009296 <z_sys_init_run_level+0x3a> @ imm = #0x22
; 		const struct device *dev = entry->dev;
 8009272: 697b         	ldr	r3, [r7, #0x14]
 8009274: 685b         	ldr	r3, [r3, #0x4]
 8009276: 613b         	str	r3, [r7, #0x10]
; 		if (dev != NULL) {
 8009278: 693b         	ldr	r3, [r7, #0x10]
 800927a: 2b00         	cmp	r3, #0x0
 800927c: d004         	beq	0x8009288 <z_sys_init_run_level+0x2c> @ imm = #0x8
; 			result = do_device_init(entry);
 800927e: 6978         	ldr	r0, [r7, #0x14]
 8009280: f009 fd41    	bl	0x8012d06 <do_device_init> @ imm = #0x9a82
 8009284: 60f8         	str	r0, [r7, #0xc]
 8009286: e003         	b	0x8009290 <z_sys_init_run_level+0x34> @ imm = #0x6
; 			result = entry->init_fn.sys();
 8009288: 697b         	ldr	r3, [r7, #0x14]
 800928a: 681b         	ldr	r3, [r3]
 800928c: 4798         	blx	r3
 800928e: 60f8         	str	r0, [r7, #0xc]
; 	for (entry = levels[level]; entry < levels[level+1]; entry++) {
 8009290: 697b         	ldr	r3, [r7, #0x14]
 8009292: 3308         	adds	r3, #0x8
 8009294: 617b         	str	r3, [r7, #0x14]
 8009296: 79fb         	ldrb	r3, [r7, #0x7]
 8009298: 3301         	adds	r3, #0x1
 800929a: 4a05         	ldr	r2, [pc, #0x14]         @ 0x80092b0 <z_sys_init_run_level+0x54>
 800929c: f852 3023    	ldr.w	r3, [r2, r3, lsl #2]
 80092a0: 697a         	ldr	r2, [r7, #0x14]
 80092a2: 429a         	cmp	r2, r3
 80092a4: d3e5         	blo	0x8009272 <z_sys_init_run_level+0x16> @ imm = #-0x36
; }
 80092a6: bf00         	nop
 80092a8: bf00         	nop
 80092aa: 3718         	adds	r7, #0x18
 80092ac: 46bd         	mov	sp, r7
 80092ae: bd80         	pop	{r7, pc}

080092b0 <$d>:
 80092b0: fc 00 00 20  	.word	0x200000fc

080092b4 <bg_thread_main>:
; {
 80092b4: b580         	push	{r7, lr}
 80092b6: b084         	sub	sp, #0x10
 80092b8: af00         	add	r7, sp, #0x0
 80092ba: 60f8         	str	r0, [r7, #0xc]
 80092bc: 60b9         	str	r1, [r7, #0x8]
 80092be: 607a         	str	r2, [r7, #0x4]
; 	z_sys_post_kernel = true;
 80092c0: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x80092f0 <bg_thread_main+0x3c>
 80092c2: 2201         	movs	r2, #0x1
 80092c4: 701a         	strb	r2, [r3]
; 	z_sys_init_run_level(INIT_LEVEL_POST_KERNEL);
 80092c6: 2003         	movs	r0, #0x3
 80092c8: f7ff ffc8    	bl	0x800925c <z_sys_init_run_level> @ imm = #-0x70
; 	boot_banner();
 80092cc: f003 f9ac    	bl	0x800c628 <boot_banner> @ imm = #0x3358
; 	z_init_static();
 80092d0: f009 fd4f    	bl	0x8012d72 <z_init_static> @ imm = #0x9a9e
; 	z_sys_init_run_level(INIT_LEVEL_APPLICATION);
 80092d4: 2004         	movs	r0, #0x4
 80092d6: f7ff ffc1    	bl	0x800925c <z_sys_init_run_level> @ imm = #-0x7e
; 	z_init_static_threads();
 80092da: f7ff ff45    	bl	0x8009168 <z_init_static_threads> @ imm = #-0x176
; 	(void)main();
 80092de: f7f7 fbc9    	bl	0x8000a74 <main>        @ imm = #-0x886e
; 	z_thread_essential_clear(&z_main_thread);
 80092e2: 4804         	ldr	r0, [pc, #0x10]         @ 0x80092f4 <bg_thread_main+0x40>
 80092e4: f009 fcd1    	bl	0x8012c8a <z_thread_essential_clear> @ imm = #0x99a2
; } /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
 80092e8: bf00         	nop
 80092ea: 3710         	adds	r7, #0x10
 80092ec: 46bd         	mov	sp, r7
 80092ee: bd80         	pop	{r7, pc}

080092f0 <$d>:
 80092f0: f6 09 00 20  	.word	0x200009f6
 80092f4: 00 03 00 20  	.word	0x20000300

080092f8 <init_idle_thread>:
; {
 80092f8: b580         	push	{r7, lr}
 80092fa: b08c         	sub	sp, #0x30
 80092fc: af06         	add	r7, sp, #0x18
 80092fe: 6078         	str	r0, [r7, #0x4]
; 	struct k_thread *thread = &z_idle_threads[i];
 8009300: 687b         	ldr	r3, [r7, #0x4]
 8009302: 22d0         	movs	r2, #0xd0
 8009304: fb02 f303    	mul	r3, r2, r3
 8009308: 4a17         	ldr	r2, [pc, #0x5c]         @ 0x8009368 <init_idle_thread+0x70>
 800930a: 4413         	add	r3, r2
 800930c: 617b         	str	r3, [r7, #0x14]
; 	k_thread_stack_t *stack = z_idle_stacks[i];
 800930e: 687a         	ldr	r2, [r7, #0x4]
 8009310: 4613         	mov	r3, r2
 8009312: 009b         	lsls	r3, r3, #0x2
 8009314: 4413         	add	r3, r2
 8009316: 019b         	lsls	r3, r3, #0x6
 8009318: 4a14         	ldr	r2, [pc, #0x50]         @ 0x800936c <init_idle_thread+0x74>
 800931a: 4413         	add	r3, r2
 800931c: 613b         	str	r3, [r7, #0x10]
; 	size_t stack_size = K_KERNEL_STACK_SIZEOF(z_idle_stacks[i]);
 800931e: f44f 73a0    	mov.w	r3, #0x140
 8009322: 60fb         	str	r3, [r7, #0xc]
; 	char *tname = "idle";
 8009324: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8009370 <init_idle_thread+0x78>
 8009326: 60bb         	str	r3, [r7, #0x8]
; 			  stack_size, idle, &_kernel.cpus[i],
 8009328: 687a         	ldr	r2, [r7, #0x4]
 800932a: 4613         	mov	r3, r2
 800932c: 00db         	lsls	r3, r3, #0x3
 800932e: 1a9b         	subs	r3, r3, r2
 8009330: 009b         	lsls	r3, r3, #0x2
 8009332: 4a10         	ldr	r2, [pc, #0x40]         @ 0x8009374 <init_idle_thread+0x7c>
 8009334: 4413         	add	r3, r2
; 	z_setup_new_thread(thread, stack,
 8009336: 68ba         	ldr	r2, [r7, #0x8]
 8009338: 9205         	str	r2, [sp, #0x14]
 800933a: 2201         	movs	r2, #0x1
 800933c: 9204         	str	r2, [sp, #0x10]
 800933e: 220f         	movs	r2, #0xf
 8009340: 9203         	str	r2, [sp, #0xc]
 8009342: 2200         	movs	r2, #0x0
 8009344: 9202         	str	r2, [sp, #0x8]
 8009346: 2200         	movs	r2, #0x0
 8009348: 9201         	str	r2, [sp, #0x4]
 800934a: 9300         	str	r3, [sp]
 800934c: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x8009378 <init_idle_thread+0x80>
 800934e: 68fa         	ldr	r2, [r7, #0xc]
 8009350: 6939         	ldr	r1, [r7, #0x10]
 8009352: 6978         	ldr	r0, [r7, #0x14]
 8009354: f000 ffce    	bl	0x800a2f4 <z_setup_new_thread> @ imm = #0xf9c
; 	z_mark_thread_as_not_suspended(thread);
 8009358: 6978         	ldr	r0, [r7, #0x14]
 800935a: f009 fc86    	bl	0x8012c6a <z_mark_thread_as_not_suspended> @ imm = #0x990c
; }
 800935e: bf00         	nop
 8009360: 3718         	adds	r7, #0x18
 8009362: 46bd         	mov	sp, r7
 8009364: bd80         	pop	{r7, pc}
 8009366: bf00         	nop

08009368 <$d>:
 8009368: d0 03 00 20  	.word	0x200003d0
 800936c: f8 15 00 20  	.word	0x200015f8
 8009370: 20 5d 01 08  	.word	0x08015d20
 8009374: c0 02 00 20  	.word	0x200002c0
 8009378: 8b 2d 01 08  	.word	0x08012d8b

0800937c <z_init_cpu>:
; {
 800937c: b580         	push	{r7, lr}
 800937e: b082         	sub	sp, #0x8
 8009380: af00         	add	r7, sp, #0x0
 8009382: 6078         	str	r0, [r7, #0x4]
; 	init_idle_thread(id);
 8009384: 6878         	ldr	r0, [r7, #0x4]
 8009386: f7ff ffb7    	bl	0x80092f8 <init_idle_thread> @ imm = #-0x92
; 	_kernel.cpus[id].idle_thread = &z_idle_threads[id];
 800938a: 687b         	ldr	r3, [r7, #0x4]
 800938c: 22d0         	movs	r2, #0xd0
 800938e: fb02 f303    	mul	r3, r2, r3
 8009392: 4a23         	ldr	r2, [pc, #0x8c]         @ 0x8009420 <z_init_cpu+0xa4>
 8009394: 1899         	adds	r1, r3, r2
 8009396: 4823         	ldr	r0, [pc, #0x8c]         @ 0x8009424 <z_init_cpu+0xa8>
 8009398: 687a         	ldr	r2, [r7, #0x4]
 800939a: 4613         	mov	r3, r2
 800939c: 00db         	lsls	r3, r3, #0x3
 800939e: 1a9b         	subs	r3, r3, r2
 80093a0: 009b         	lsls	r3, r3, #0x2
 80093a2: 4403         	add	r3, r0
 80093a4: 330c         	adds	r3, #0xc
 80093a6: 6019         	str	r1, [r3]
; 	_kernel.cpus[id].id = id;
 80093a8: 687b         	ldr	r3, [r7, #0x4]
 80093aa: b2d8         	uxtb	r0, r3
 80093ac: 491d         	ldr	r1, [pc, #0x74]         @ 0x8009424 <z_init_cpu+0xa8>
 80093ae: 687a         	ldr	r2, [r7, #0x4]
 80093b0: 4613         	mov	r3, r2
 80093b2: 00db         	lsls	r3, r3, #0x3
 80093b4: 1a9b         	subs	r3, r3, r2
 80093b6: 009b         	lsls	r3, r3, #0x2
 80093b8: 440b         	add	r3, r1
 80093ba: 3310         	adds	r3, #0x10
 80093bc: 4602         	mov	r2, r0
 80093be: 701a         	strb	r2, [r3]
; 		(K_KERNEL_STACK_BUFFER(z_interrupt_stacks[id]) +
 80093c0: 687b         	ldr	r3, [r7, #0x4]
 80093c2: 02db         	lsls	r3, r3, #0xb
 80093c4: 4a18         	ldr	r2, [pc, #0x60]         @ 0x8009428 <z_init_cpu+0xac>
 80093c6: 4413         	add	r3, r2
 80093c8: 4618         	mov	r0, r3
 80093ca: f009 fc11    	bl	0x8012bf0 <K_KERNEL_STACK_BUFFER> @ imm = #0x9822
 80093ce: 4603         	mov	r3, r0
 80093d0: f503 6100    	add.w	r1, r3, #0x800
; 	_kernel.cpus[id].irq_stack =
 80093d4: 4813         	ldr	r0, [pc, #0x4c]         @ 0x8009424 <z_init_cpu+0xa8>
 80093d6: 687a         	ldr	r2, [r7, #0x4]
 80093d8: 4613         	mov	r3, r2
 80093da: 00db         	lsls	r3, r3, #0x3
 80093dc: 1a9b         	subs	r3, r3, r2
 80093de: 009b         	lsls	r3, r3, #0x2
 80093e0: 4403         	add	r3, r0
 80093e2: 3304         	adds	r3, #0x4
 80093e4: 6019         	str	r1, [r3]
; 	_kernel.cpus[id].usage = &_kernel.usage[id];
 80093e6: 687b         	ldr	r3, [r7, #0x4]
 80093e8: 3303         	adds	r3, #0x3
 80093ea: 011b         	lsls	r3, r3, #0x4
 80093ec: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x8009424 <z_init_cpu+0xa8>
 80093ee: 1899         	adds	r1, r3, r2
 80093f0: 480c         	ldr	r0, [pc, #0x30]         @ 0x8009424 <z_init_cpu+0xa8>
 80093f2: 687a         	ldr	r2, [r7, #0x4]
 80093f4: 4613         	mov	r3, r2
 80093f6: 00db         	lsls	r3, r3, #0x3
 80093f8: 1a9b         	subs	r3, r3, r2
 80093fa: 009b         	lsls	r3, r3, #0x2
 80093fc: 4403         	add	r3, r0
 80093fe: 3318         	adds	r3, #0x18
 8009400: 6019         	str	r1, [r3]
; 	_kernel.cpus[id].usage->track_usage =
 8009402: 4908         	ldr	r1, [pc, #0x20]         @ 0x8009424 <z_init_cpu+0xa8>
 8009404: 687a         	ldr	r2, [r7, #0x4]
 8009406: 4613         	mov	r3, r2
 8009408: 00db         	lsls	r3, r3, #0x3
 800940a: 1a9b         	subs	r3, r3, r2
 800940c: 009b         	lsls	r3, r3, #0x2
 800940e: 440b         	add	r3, r1
 8009410: 3318         	adds	r3, #0x18
 8009412: 681b         	ldr	r3, [r3]
 8009414: 2201         	movs	r2, #0x1
 8009416: 721a         	strb	r2, [r3, #0x8]
; }
 8009418: bf00         	nop
 800941a: 3708         	adds	r7, #0x8
 800941c: 46bd         	mov	sp, r7
 800941e: bd80         	pop	{r7, pc}

08009420 <$d>:
 8009420: d0 03 00 20  	.word	0x200003d0
 8009424: c0 02 00 20  	.word	0x200002c0
 8009428: 38 17 00 20  	.word	0x20001738

0800942c <prepare_multithreading>:
; {
 800942c: b580         	push	{r7, lr}
 800942e: b088         	sub	sp, #0x20
 8009430: af06         	add	r7, sp, #0x18
; 	z_sched_init();
 8009432: f002 f89f    	bl	0x800b574 <z_sched_init> @ imm = #0x213e
; 	_kernel.ready_q.cache = &z_main_thread;
 8009436: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8009480 <prepare_multithreading+0x54>
 8009438: 4a12         	ldr	r2, [pc, #0x48]         @ 0x8009484 <prepare_multithreading+0x58>
 800943a: 61da         	str	r2, [r3, #0x1c]
; 	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
 800943c: 4b12         	ldr	r3, [pc, #0x48]         @ 0x8009488 <prepare_multithreading+0x5c>
 800943e: 9305         	str	r3, [sp, #0x14]
 8009440: 2301         	movs	r3, #0x1
 8009442: 9304         	str	r3, [sp, #0x10]
 8009444: 2300         	movs	r3, #0x0
 8009446: 9303         	str	r3, [sp, #0xc]
 8009448: 2300         	movs	r3, #0x0
 800944a: 9302         	str	r3, [sp, #0x8]
 800944c: 2300         	movs	r3, #0x0
 800944e: 9301         	str	r3, [sp, #0x4]
 8009450: 2300         	movs	r3, #0x0
 8009452: 9300         	str	r3, [sp]
 8009454: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800948c <prepare_multithreading+0x60>
 8009456: f44f 6280    	mov.w	r2, #0x400
 800945a: 490d         	ldr	r1, [pc, #0x34]         @ 0x8009490 <prepare_multithreading+0x64>
 800945c: 4809         	ldr	r0, [pc, #0x24]         @ 0x8009484 <prepare_multithreading+0x58>
 800945e: f000 ff49    	bl	0x800a2f4 <z_setup_new_thread> @ imm = #0xe92
 8009462: 6078         	str	r0, [r7, #0x4]
; 	z_mark_thread_as_not_suspended(&z_main_thread);
 8009464: 4807         	ldr	r0, [pc, #0x1c]         @ 0x8009484 <prepare_multithreading+0x58>
 8009466: f009 fc00    	bl	0x8012c6a <z_mark_thread_as_not_suspended> @ imm = #0x9800
; 	z_ready_thread(&z_main_thread);
 800946a: 4806         	ldr	r0, [pc, #0x18]         @ 0x8009484 <prepare_multithreading+0x58>
 800946c: f001 fa0a    	bl	0x800a884 <z_ready_thread> @ imm = #0x1414
; 	z_init_cpu(0);
 8009470: 2000         	movs	r0, #0x0
 8009472: f7ff ff83    	bl	0x800937c <z_init_cpu>  @ imm = #-0xfa
; 	return stack_ptr;
 8009476: 687b         	ldr	r3, [r7, #0x4]
; }
 8009478: 4618         	mov	r0, r3
 800947a: 3708         	adds	r7, #0x8
 800947c: 46bd         	mov	sp, r7
 800947e: bd80         	pop	{r7, pc}

08009480 <$d>:
 8009480: c0 02 00 20  	.word	0x200002c0
 8009484: 00 03 00 20  	.word	0x20000300
 8009488: 28 5d 01 08  	.word	0x08015d28
 800948c: b5 92 00 08  	.word	0x080092b5
 8009490: f8 11 00 20  	.word	0x200011f8

08009494 <switch_to_main_thread>:
; {
 8009494: b580         	push	{r7, lr}
 8009496: b082         	sub	sp, #0x8
 8009498: af00         	add	r7, sp, #0x0
 800949a: 6078         	str	r0, [r7, #0x4]
; 	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
 800949c: 4a02         	ldr	r2, [pc, #0x8]          @ 0x80094a8 <switch_to_main_thread+0x14>
 800949e: 6879         	ldr	r1, [r7, #0x4]
 80094a0: 4802         	ldr	r0, [pc, #0x8]          @ 0x80094ac <switch_to_main_thread+0x18>
 80094a2: f7f9 fecb    	bl	0x800323c <arch_switch_to_main_thread> @ imm = #-0x626a
 80094a6: bf00         	nop

080094a8 <$d>:
 80094a8: b5 92 00 08  	.word	0x080092b5
 80094ac: 00 03 00 20  	.word	0x20000300

080094b0 <z_cstart>:
; {
 80094b0: b580         	push	{r7, lr}
 80094b2: b082         	sub	sp, #0x8
 80094b4: af00         	add	r7, sp, #0x0
; 	gcov_static_init();
 80094b6: f009 fbf8    	bl	0x8012caa <gcov_static_init> @ imm = #0x97f0
; 	z_sys_init_run_level(INIT_LEVEL_EARLY);
 80094ba: 2000         	movs	r0, #0x0
 80094bc: f7ff fece    	bl	0x800925c <z_sys_init_run_level> @ imm = #-0x264
; 		(uint32_t)(K_KERNEL_STACK_BUFFER(z_interrupt_stacks[0])) +
 80094c0: 482d         	ldr	r0, [pc, #0xb4]         @ 0x8009578 <z_cstart+0xc8>
 80094c2: f009 fb95    	bl	0x8012bf0 <K_KERNEL_STACK_BUFFER> @ imm = #0x972a
 80094c6: 4603         	mov	r3, r0
; 	uint32_t msp =
 80094c8: f503 6300    	add.w	r3, r3, #0x800
 80094cc: 607b         	str	r3, [r7, #0x4]
 80094ce: 687b         	ldr	r3, [r7, #0x4]
 80094d0: 603b         	str	r3, [r7]
;   __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
 80094d2: 683b         	ldr	r3, [r7]
 80094d4: f383 8808    	msr	msp, r3
; }
 80094d8: bf00         	nop
; 	SCB->CCR |= SCB_CCR_STKALIGN_Msk;
 80094da: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x800957c <z_cstart+0xcc>
 80094dc: 695b         	ldr	r3, [r3, #0x14]
 80094de: 4a27         	ldr	r2, [pc, #0x9c]         @ 0x800957c <z_cstart+0xcc>
 80094e0: f443 7300    	orr	r3, r3, #0x200
 80094e4: 6153         	str	r3, [r2, #0x14]
; }
 80094e6: bf00         	nop
; 	NVIC_SetPriority(PendSV_IRQn, _EXC_PENDSV_PRIO);
 80094e8: 21ff         	movs	r1, #0xff
 80094ea: f06f 0001    	mvn	r0, #0x1
 80094ee: f7ff fdd9    	bl	0x80090a4 <__NVIC_SetPriority> @ imm = #-0x44e
; 	NVIC_SetPriority(SVCall_IRQn, _EXC_SVC_PRIO);
 80094f2: 2100         	movs	r1, #0x0
 80094f4: f06f 0004    	mvn	r0, #0x4
 80094f8: f7ff fdd4    	bl	0x80090a4 <__NVIC_SetPriority> @ imm = #-0x458
; 	NVIC_SetPriority(MemoryManagement_IRQn, _EXC_FAULT_PRIO);
 80094fc: 2100         	movs	r1, #0x0
 80094fe: f06f 000b    	mvn	r0, #0xb
 8009502: f7ff fdcf    	bl	0x80090a4 <__NVIC_SetPriority> @ imm = #-0x462
; 	NVIC_SetPriority(BusFault_IRQn, _EXC_FAULT_PRIO);
 8009506: 2100         	movs	r1, #0x0
 8009508: f06f 000a    	mvn	r0, #0xa
 800950c: f7ff fdca    	bl	0x80090a4 <__NVIC_SetPriority> @ imm = #-0x46c
; 	NVIC_SetPriority(UsageFault_IRQn, _EXC_FAULT_PRIO);
 8009510: 2100         	movs	r1, #0x0
 8009512: f06f 0009    	mvn	r0, #0x9
 8009516: f7ff fdc5    	bl	0x80090a4 <__NVIC_SetPriority> @ imm = #-0x476
; 	NVIC_SetPriority(DebugMonitor_IRQn, _EXC_FAULT_PRIO);
 800951a: 2100         	movs	r1, #0x0
 800951c: f06f 0003    	mvn	r0, #0x3
 8009520: f7ff fdc0    	bl	0x80090a4 <__NVIC_SetPriority> @ imm = #-0x480
; 	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
 8009524: 4b15         	ldr	r3, [pc, #0x54]         @ 0x800957c <z_cstart+0xcc>
 8009526: 6a5b         	ldr	r3, [r3, #0x24]
 8009528: 4a14         	ldr	r2, [pc, #0x50]         @ 0x800957c <z_cstart+0xcc>
 800952a: f443 23e0    	orr	r3, r3, #0x70000
 800952e: 6253         	str	r3, [r2, #0x24]
; }
 8009530: bf00         	nop
; 	z_arm_fault_init();
 8009532: f7f9 fceb    	bl	0x8002f0c <z_arm_fault_init> @ imm = #-0x662a
; 	z_arm_cpu_idle_init();
 8009536: f7f9 feb1    	bl	0x800329c <z_arm_cpu_idle_init> @ imm = #-0x629e
; 	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
 800953a: 4b10         	ldr	r3, [pc, #0x40]         @ 0x800957c <z_cstart+0xcc>
 800953c: f04f 32ff    	mov.w	r2, #0xffffffff
 8009540: 629a         	str	r2, [r3, #0x28]
; 	SCB->HFSR = 0xffffffff;
 8009542: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800957c <z_cstart+0xcc>
 8009544: f04f 32ff    	mov.w	r2, #0xffffffff
 8009548: 62da         	str	r2, [r3, #0x2c]
; }
 800954a: bf00         	nop
; }
 800954c: bf00         	nop
; 	LOG_CORE_INIT();
 800954e: f7f7 ff67    	bl	0x8001420 <log_core_init> @ imm = #-0x8132
; 	z_dummy_thread_init(&_thread_dummy);
 8009552: 480b         	ldr	r0, [pc, #0x2c]         @ 0x8009580 <z_cstart+0xd0>
 8009554: f7ff fde4    	bl	0x8009120 <z_dummy_thread_init> @ imm = #-0x438
; 	z_device_state_init();
 8009558: f7ff fc50    	bl	0x8008dfc <z_device_state_init> @ imm = #-0x760
; 	soc_early_init_hook();
 800955c: f7f7 ff2c    	bl	0x80013b8 <soc_early_init_hook> @ imm = #-0x81a8
; 	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_1);
 8009560: 2001         	movs	r0, #0x1
 8009562: f7ff fe7b    	bl	0x800925c <z_sys_init_run_level> @ imm = #-0x30a
; 	z_sys_init_run_level(INIT_LEVEL_PRE_KERNEL_2);
 8009566: 2002         	movs	r0, #0x2
 8009568: f7ff fe78    	bl	0x800925c <z_sys_init_run_level> @ imm = #-0x310
; 	switch_to_main_thread(prepare_multithreading());
 800956c: f7ff ff5e    	bl	0x800942c <prepare_multithreading> @ imm = #-0x144
 8009570: 4603         	mov	r3, r0
 8009572: 4618         	mov	r0, r3
 8009574: f7ff ff8e    	bl	0x8009494 <switch_to_main_thread> @ imm = #-0xe4

08009578 <$d>:
 8009578: 38 17 00 20  	.word	0x20001738
 800957c: 00 ed 00 e0  	.word	0xe000ed00
 8009580: a0 04 00 20  	.word	0x200004a0

08009584 <z_impl_k_msgq_put>:
; {
 8009584: b580         	push	{r7, lr}
 8009586: b09c         	sub	sp, #0x70
 8009588: af02         	add	r7, sp, #0x8
 800958a: 60f8         	str	r0, [r7, #0xc]
 800958c: 60b9         	str	r1, [r7, #0x8]
 800958e: e9c7 2300    	strd	r2, r3, [r7]
; 	key = k_spin_lock(&msgq->lock);
 8009592: 68fb         	ldr	r3, [r7, #0xc]
 8009594: 3308         	adds	r3, #0x8
 8009596: 65fb         	str	r3, [r7, #0x5c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8009598: f3ef 8311    	mrs	r3, basepri
 800959c: 65bb         	str	r3, [r7, #0x58]
;   return(result);
 800959e: 6dbb         	ldr	r3, [r7, #0x58]
; 	key = __get_BASEPRI();
 80095a0: 657b         	str	r3, [r7, #0x54]
 80095a2: 2310         	movs	r3, #0x10
 80095a4: 653b         	str	r3, [r7, #0x50]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 80095a6: 6d3b         	ldr	r3, [r7, #0x50]
 80095a8: f383 8812    	msr	basepri_max, r3
; }
 80095ac: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80095ae: f3bf 8f6f    	isb	sy
; }
 80095b2: bf00         	nop
; 	return key;
 80095b4: 6d7b         	ldr	r3, [r7, #0x54]
; 	k.key = arch_irq_lock();
 80095b6: 613b         	str	r3, [r7, #0x10]
 80095b8: 6dfb         	ldr	r3, [r7, #0x5c]
 80095ba: 64fb         	str	r3, [r7, #0x4c]
; }
 80095bc: bf00         	nop
 80095be: 6dfb         	ldr	r3, [r7, #0x5c]
 80095c0: 64bb         	str	r3, [r7, #0x48]
; }
 80095c2: bf00         	nop
; 	return k;
 80095c4: 693b         	ldr	r3, [r7, #0x10]
 80095c6: 61bb         	str	r3, [r7, #0x18]
; 	if (msgq->used_msgs < msgq->max_msgs) {
 80095c8: 68fb         	ldr	r3, [r7, #0xc]
 80095ca: 6a1a         	ldr	r2, [r3, #0x20]
 80095cc: 68fb         	ldr	r3, [r7, #0xc]
 80095ce: 68db         	ldr	r3, [r3, #0xc]
 80095d0: 429a         	cmp	r2, r3
 80095d2: d267         	bhs	0x80096a4 <z_impl_k_msgq_put+0x120> @ imm = #0xce
; 		pending_thread = z_unpend_first_thread(&msgq->wait_q);
 80095d4: 68fb         	ldr	r3, [r7, #0xc]
 80095d6: 647b         	str	r3, [r7, #0x44]
; 	struct k_thread *thread = NULL;
 80095d8: 2300         	movs	r3, #0x0
 80095da: 643b         	str	r3, [r7, #0x40]
; 		thread = _priq_wait_best(&wait_q->waitq);
 80095dc: 6c7b         	ldr	r3, [r7, #0x44]
 80095de: 63fb         	str	r3, [r7, #0x3c]
; 	struct k_thread *thread = NULL;
 80095e0: 2300         	movs	r3, #0x0
 80095e2: 63bb         	str	r3, [r7, #0x38]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 80095e4: 6bf8         	ldr	r0, [r7, #0x3c]
 80095e6: f009 fc10    	bl	0x8012e0a <sys_dlist_peek_head> @ imm = #0x9820
 80095ea: 6378         	str	r0, [r7, #0x34]
; 	if (n != NULL) {
 80095ec: 6b7b         	ldr	r3, [r7, #0x34]
 80095ee: 2b00         	cmp	r3, #0x0
 80095f0: d001         	beq	0x80095f6 <z_impl_k_msgq_put+0x72> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 80095f2: 6b7b         	ldr	r3, [r7, #0x34]
 80095f4: 63bb         	str	r3, [r7, #0x38]
; 	return thread;
 80095f6: 6bbb         	ldr	r3, [r7, #0x38]
; 		thread = _priq_wait_best(&wait_q->waitq);
 80095f8: 643b         	str	r3, [r7, #0x40]
; 		if (unlikely(thread != NULL)) {
 80095fa: 6c3b         	ldr	r3, [r7, #0x40]
 80095fc: 2b00         	cmp	r3, #0x0
 80095fe: bf14         	ite	ne
 8009600: 2301         	movne	r3, #0x1
 8009602: 2300         	moveq	r3, #0x0
 8009604: b2db         	uxtb	r3, r3
 8009606: 2b00         	cmp	r3, #0x0
 8009608: d005         	beq	0x8009616 <z_impl_k_msgq_put+0x92> @ imm = #0xa
; 			unpend_thread_no_timeout(thread);
 800960a: 6c38         	ldr	r0, [r7, #0x40]
 800960c: f009 fc44    	bl	0x8012e98 <unpend_thread_no_timeout> @ imm = #0x9888
; 			(void)z_abort_thread_timeout(thread);
 8009610: 6c38         	ldr	r0, [r7, #0x40]
 8009612: f009 fc23    	bl	0x8012e5c <z_abort_thread_timeout> @ imm = #0x9846
; 	return thread;
 8009616: 6c3b         	ldr	r3, [r7, #0x40]
; 		pending_thread = z_unpend_first_thread(&msgq->wait_q);
 8009618: 663b         	str	r3, [r7, #0x60]
; 		if (unlikely(pending_thread != NULL)) {
 800961a: 6e3b         	ldr	r3, [r7, #0x60]
 800961c: 2b00         	cmp	r3, #0x0
 800961e: bf14         	ite	ne
 8009620: 2301         	movne	r3, #0x1
 8009622: 2300         	moveq	r3, #0x0
 8009624: b2db         	uxtb	r3, r3
 8009626: 2b00         	cmp	r3, #0x0
 8009628: d01b         	beq	0x8009662 <z_impl_k_msgq_put+0xde> @ imm = #0x36
; 			(void)memcpy(pending_thread->base.swap_data, data,
 800962a: 6e3b         	ldr	r3, [r7, #0x60]
 800962c: 6958         	ldr	r0, [r3, #0x14]
 800962e: 68fb         	ldr	r3, [r7, #0xc]
 8009630: 689b         	ldr	r3, [r3, #0x8]
 8009632: 461a         	mov	r2, r3
 8009634: 68b9         	ldr	r1, [r7, #0x8]
 8009636: f00a fd63    	bl	0x8014100 <memcpy>      @ imm = #0xaac6
 800963a: 6e3b         	ldr	r3, [r7, #0x60]
 800963c: 633b         	str	r3, [r7, #0x30]
 800963e: 2300         	movs	r3, #0x0
 8009640: 62fb         	str	r3, [r7, #0x2c]
; 	thread->arch.swap_return_value = value;
 8009642: 6b3b         	ldr	r3, [r7, #0x30]
 8009644: 6afa         	ldr	r2, [r7, #0x2c]
 8009646: f8c3 20cc    	str.w	r2, [r3, #0xcc]
; }
 800964a: bf00         	nop
; 			z_ready_thread(pending_thread);
 800964c: 6e38         	ldr	r0, [r7, #0x60]
 800964e: f001 f919    	bl	0x800a884 <z_ready_thread> @ imm = #0x1232
; 			z_reschedule(&msgq->lock, key);
 8009652: 68fb         	ldr	r3, [r7, #0xc]
 8009654: 3308         	adds	r3, #0x8
 8009656: 69b9         	ldr	r1, [r7, #0x18]
 8009658: 4618         	mov	r0, r3
 800965a: f00a facf    	bl	0x8013bfc <z_reschedule> @ imm = #0xa59e
; 			return 0;
 800965e: 2300         	movs	r3, #0x0
 8009660: e056         	b	0x8009710 <z_impl_k_msgq_put+0x18c> @ imm = #0xac
; 			(void)memcpy(msgq->write_ptr, (char *)data, msgq->msg_size);
 8009662: 68fb         	ldr	r3, [r7, #0xc]
 8009664: 69d8         	ldr	r0, [r3, #0x1c]
 8009666: 68fb         	ldr	r3, [r7, #0xc]
 8009668: 689b         	ldr	r3, [r3, #0x8]
 800966a: 461a         	mov	r2, r3
 800966c: 68b9         	ldr	r1, [r7, #0x8]
 800966e: f00a fd47    	bl	0x8014100 <memcpy>      @ imm = #0xaa8e
; 			msgq->write_ptr += msgq->msg_size;
 8009672: 68fb         	ldr	r3, [r7, #0xc]
 8009674: 69da         	ldr	r2, [r3, #0x1c]
 8009676: 68fb         	ldr	r3, [r7, #0xc]
 8009678: 689b         	ldr	r3, [r3, #0x8]
 800967a: 441a         	add	r2, r3
 800967c: 68fb         	ldr	r3, [r7, #0xc]
 800967e: 61da         	str	r2, [r3, #0x1c]
; 			if (msgq->write_ptr == msgq->buffer_end) {
 8009680: 68fb         	ldr	r3, [r7, #0xc]
 8009682: 69da         	ldr	r2, [r3, #0x1c]
 8009684: 68fb         	ldr	r3, [r7, #0xc]
 8009686: 695b         	ldr	r3, [r3, #0x14]
 8009688: 429a         	cmp	r2, r3
 800968a: d103         	bne	0x8009694 <z_impl_k_msgq_put+0x110> @ imm = #0x6
; 				msgq->write_ptr = msgq->buffer_start;
 800968c: 68fb         	ldr	r3, [r7, #0xc]
 800968e: 691a         	ldr	r2, [r3, #0x10]
 8009690: 68fb         	ldr	r3, [r7, #0xc]
 8009692: 61da         	str	r2, [r3, #0x1c]
; 			msgq->used_msgs++;
 8009694: 68fb         	ldr	r3, [r7, #0xc]
 8009696: 6a1b         	ldr	r3, [r3, #0x20]
 8009698: 1c5a         	adds	r2, r3, #0x1
 800969a: 68fb         	ldr	r3, [r7, #0xc]
 800969c: 621a         	str	r2, [r3, #0x20]
; 		result = 0;
 800969e: 2300         	movs	r3, #0x0
 80096a0: 667b         	str	r3, [r7, #0x64]
 80096a2: e022         	b	0x80096ea <z_impl_k_msgq_put+0x166> @ imm = #0x44
; 	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
 80096a4: e9d7 2300    	ldrd	r2, r3, [r7]
 80096a8: f04f 0000    	mov.w	r0, #0x0
 80096ac: f04f 0100    	mov.w	r1, #0x0
 80096b0: 428b         	cmp	r3, r1
 80096b2: bf08         	it	eq
 80096b4: 4282         	cmpeq	r2, r0
 80096b6: d103         	bne	0x80096c0 <z_impl_k_msgq_put+0x13c> @ imm = #0x6
; 		result = -ENOMSG;
 80096b8: f06f 0322    	mvn	r3, #0x22
 80096bc: 667b         	str	r3, [r7, #0x64]
 80096be: e014         	b	0x80096ea <z_impl_k_msgq_put+0x166> @ imm = #0x28
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80096c0: 4b15         	ldr	r3, [pc, #0x54]         @ 0x8009718 <z_impl_k_msgq_put+0x194>
 80096c2: 689b         	ldr	r3, [r3, #0x8]
 80096c4: 62bb         	str	r3, [r7, #0x28]
; 	return ret;
 80096c6: 6abb         	ldr	r3, [r7, #0x28]
; 		arch_current_thread()->base.swap_data = (void *) data;
 80096c8: 68ba         	ldr	r2, [r7, #0x8]
 80096ca: 615a         	str	r2, [r3, #0x14]
; 		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
 80096cc: 68fb         	ldr	r3, [r7, #0xc]
 80096ce: f103 0008    	add.w	r0, r3, #0x8
 80096d2: 68f9         	ldr	r1, [r7, #0xc]
 80096d4: e9d7 2300    	ldrd	r2, r3, [r7]
 80096d8: e9cd 2300    	strd	r2, r3, [sp]
 80096dc: 460a         	mov	r2, r1
 80096de: 69b9         	ldr	r1, [r7, #0x18]
 80096e0: f001 fc8c    	bl	0x800affc <z_pend_curr> @ imm = #0x1918
 80096e4: 6678         	str	r0, [r7, #0x64]
; 		return result;
 80096e6: 6e7b         	ldr	r3, [r7, #0x64]
 80096e8: e012         	b	0x8009710 <z_impl_k_msgq_put+0x18c> @ imm = #0x24
; 	k_spin_unlock(&msgq->lock, key);
 80096ea: 68fb         	ldr	r3, [r7, #0xc]
 80096ec: 3308         	adds	r3, #0x8
 80096ee: 627b         	str	r3, [r7, #0x24]
 80096f0: 69bb         	ldr	r3, [r7, #0x18]
 80096f2: 617b         	str	r3, [r7, #0x14]
; 	arch_irq_unlock(key.key);
 80096f4: 697b         	ldr	r3, [r7, #0x14]
 80096f6: 623b         	str	r3, [r7, #0x20]
 80096f8: 6a3b         	ldr	r3, [r7, #0x20]
 80096fa: 61fb         	str	r3, [r7, #0x1c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80096fc: 69fb         	ldr	r3, [r7, #0x1c]
 80096fe: f383 8811    	msr	basepri, r3
; }
 8009702: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8009704: f3bf 8f6f    	isb	sy
; }
 8009708: bf00         	nop
; }
 800970a: bf00         	nop
; }
 800970c: bf00         	nop
; 	return result;
 800970e: 6e7b         	ldr	r3, [r7, #0x64]
; }
 8009710: 4618         	mov	r0, r3
 8009712: 3768         	adds	r7, #0x68
 8009714: 46bd         	mov	sp, r7
 8009716: bd80         	pop	{r7, pc}

08009718 <$d>:
 8009718: c0 02 00 20  	.word	0x200002c0

0800971c <z_impl_k_msgq_get>:
; {
 800971c: b580         	push	{r7, lr}
 800971e: b09c         	sub	sp, #0x70
 8009720: af02         	add	r7, sp, #0x8
 8009722: 60f8         	str	r0, [r7, #0xc]
 8009724: 60b9         	str	r1, [r7, #0x8]
 8009726: e9c7 2300    	strd	r2, r3, [r7]
; 	key = k_spin_lock(&msgq->lock);
 800972a: 68fb         	ldr	r3, [r7, #0xc]
 800972c: 3308         	adds	r3, #0x8
 800972e: 65fb         	str	r3, [r7, #0x5c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8009730: f3ef 8311    	mrs	r3, basepri
 8009734: 65bb         	str	r3, [r7, #0x58]
;   return(result);
 8009736: 6dbb         	ldr	r3, [r7, #0x58]
; 	key = __get_BASEPRI();
 8009738: 657b         	str	r3, [r7, #0x54]
 800973a: 2310         	movs	r3, #0x10
 800973c: 653b         	str	r3, [r7, #0x50]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800973e: 6d3b         	ldr	r3, [r7, #0x50]
 8009740: f383 8812    	msr	basepri_max, r3
; }
 8009744: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8009746: f3bf 8f6f    	isb	sy
; }
 800974a: bf00         	nop
; 	return key;
 800974c: 6d7b         	ldr	r3, [r7, #0x54]
; 	k.key = arch_irq_lock();
 800974e: 613b         	str	r3, [r7, #0x10]
 8009750: 6dfb         	ldr	r3, [r7, #0x5c]
 8009752: 64fb         	str	r3, [r7, #0x4c]
; }
 8009754: bf00         	nop
 8009756: 6dfb         	ldr	r3, [r7, #0x5c]
 8009758: 64bb         	str	r3, [r7, #0x48]
; }
 800975a: bf00         	nop
; 	return k;
 800975c: 693b         	ldr	r3, [r7, #0x10]
 800975e: 61bb         	str	r3, [r7, #0x18]
; 	if (msgq->used_msgs > 0U) {
 8009760: 68fb         	ldr	r3, [r7, #0xc]
 8009762: 6a1b         	ldr	r3, [r3, #0x20]
 8009764: 2b00         	cmp	r3, #0x0
 8009766: d07e         	beq	0x8009866 <z_impl_k_msgq_get+0x14a> @ imm = #0xfc
; 		(void)memcpy((char *)data, msgq->read_ptr, msgq->msg_size);
 8009768: 68fb         	ldr	r3, [r7, #0xc]
 800976a: 6999         	ldr	r1, [r3, #0x18]
 800976c: 68fb         	ldr	r3, [r7, #0xc]
 800976e: 689b         	ldr	r3, [r3, #0x8]
 8009770: 461a         	mov	r2, r3
 8009772: 68b8         	ldr	r0, [r7, #0x8]
 8009774: f00a fcc4    	bl	0x8014100 <memcpy>      @ imm = #0xa988
; 		msgq->read_ptr += msgq->msg_size;
 8009778: 68fb         	ldr	r3, [r7, #0xc]
 800977a: 699a         	ldr	r2, [r3, #0x18]
 800977c: 68fb         	ldr	r3, [r7, #0xc]
 800977e: 689b         	ldr	r3, [r3, #0x8]
 8009780: 441a         	add	r2, r3
 8009782: 68fb         	ldr	r3, [r7, #0xc]
 8009784: 619a         	str	r2, [r3, #0x18]
; 		if (msgq->read_ptr == msgq->buffer_end) {
 8009786: 68fb         	ldr	r3, [r7, #0xc]
 8009788: 699a         	ldr	r2, [r3, #0x18]
 800978a: 68fb         	ldr	r3, [r7, #0xc]
 800978c: 695b         	ldr	r3, [r3, #0x14]
 800978e: 429a         	cmp	r2, r3
 8009790: d103         	bne	0x800979a <z_impl_k_msgq_get+0x7e> @ imm = #0x6
; 			msgq->read_ptr = msgq->buffer_start;
 8009792: 68fb         	ldr	r3, [r7, #0xc]
 8009794: 691a         	ldr	r2, [r3, #0x10]
 8009796: 68fb         	ldr	r3, [r7, #0xc]
 8009798: 619a         	str	r2, [r3, #0x18]
; 		msgq->used_msgs--;
 800979a: 68fb         	ldr	r3, [r7, #0xc]
 800979c: 6a1b         	ldr	r3, [r3, #0x20]
 800979e: 1e5a         	subs	r2, r3, #0x1
 80097a0: 68fb         	ldr	r3, [r7, #0xc]
 80097a2: 621a         	str	r2, [r3, #0x20]
; 		pending_thread = z_unpend_first_thread(&msgq->wait_q);
 80097a4: 68fb         	ldr	r3, [r7, #0xc]
 80097a6: 647b         	str	r3, [r7, #0x44]
; 	struct k_thread *thread = NULL;
 80097a8: 2300         	movs	r3, #0x0
 80097aa: 643b         	str	r3, [r7, #0x40]
; 		thread = _priq_wait_best(&wait_q->waitq);
 80097ac: 6c7b         	ldr	r3, [r7, #0x44]
 80097ae: 63fb         	str	r3, [r7, #0x3c]
; 	struct k_thread *thread = NULL;
 80097b0: 2300         	movs	r3, #0x0
 80097b2: 63bb         	str	r3, [r7, #0x38]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 80097b4: 6bf8         	ldr	r0, [r7, #0x3c]
 80097b6: f009 fb28    	bl	0x8012e0a <sys_dlist_peek_head> @ imm = #0x9650
 80097ba: 6378         	str	r0, [r7, #0x34]
; 	if (n != NULL) {
 80097bc: 6b7b         	ldr	r3, [r7, #0x34]
 80097be: 2b00         	cmp	r3, #0x0
 80097c0: d001         	beq	0x80097c6 <z_impl_k_msgq_get+0xaa> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 80097c2: 6b7b         	ldr	r3, [r7, #0x34]
 80097c4: 63bb         	str	r3, [r7, #0x38]
; 	return thread;
 80097c6: 6bbb         	ldr	r3, [r7, #0x38]
; 		thread = _priq_wait_best(&wait_q->waitq);
 80097c8: 643b         	str	r3, [r7, #0x40]
; 		if (unlikely(thread != NULL)) {
 80097ca: 6c3b         	ldr	r3, [r7, #0x40]
 80097cc: 2b00         	cmp	r3, #0x0
 80097ce: bf14         	ite	ne
 80097d0: 2301         	movne	r3, #0x1
 80097d2: 2300         	moveq	r3, #0x0
 80097d4: b2db         	uxtb	r3, r3
 80097d6: 2b00         	cmp	r3, #0x0
 80097d8: d005         	beq	0x80097e6 <z_impl_k_msgq_get+0xca> @ imm = #0xa
; 			unpend_thread_no_timeout(thread);
 80097da: 6c38         	ldr	r0, [r7, #0x40]
 80097dc: f009 fb5c    	bl	0x8012e98 <unpend_thread_no_timeout> @ imm = #0x96b8
; 			(void)z_abort_thread_timeout(thread);
 80097e0: 6c38         	ldr	r0, [r7, #0x40]
 80097e2: f009 fb3b    	bl	0x8012e5c <z_abort_thread_timeout> @ imm = #0x9676
; 	return thread;
 80097e6: 6c3b         	ldr	r3, [r7, #0x40]
; 		pending_thread = z_unpend_first_thread(&msgq->wait_q);
 80097e8: 663b         	str	r3, [r7, #0x60]
; 		if (unlikely(pending_thread != NULL)) {
 80097ea: 6e3b         	ldr	r3, [r7, #0x60]
 80097ec: 2b00         	cmp	r3, #0x0
 80097ee: bf14         	ite	ne
 80097f0: 2301         	movne	r3, #0x1
 80097f2: 2300         	moveq	r3, #0x0
 80097f4: b2db         	uxtb	r3, r3
 80097f6: 2b00         	cmp	r3, #0x0
 80097f8: d032         	beq	0x8009860 <z_impl_k_msgq_get+0x144> @ imm = #0x64
; 			(void)memcpy(msgq->write_ptr, (char *)pending_thread->base.swap_data,
 80097fa: 68fb         	ldr	r3, [r7, #0xc]
 80097fc: 69d8         	ldr	r0, [r3, #0x1c]
 80097fe: 6e3b         	ldr	r3, [r7, #0x60]
 8009800: 6959         	ldr	r1, [r3, #0x14]
 8009802: 68fb         	ldr	r3, [r7, #0xc]
 8009804: 689b         	ldr	r3, [r3, #0x8]
 8009806: 461a         	mov	r2, r3
 8009808: f00a fc7a    	bl	0x8014100 <memcpy>      @ imm = #0xa8f4
; 			msgq->write_ptr += msgq->msg_size;
 800980c: 68fb         	ldr	r3, [r7, #0xc]
 800980e: 69da         	ldr	r2, [r3, #0x1c]
 8009810: 68fb         	ldr	r3, [r7, #0xc]
 8009812: 689b         	ldr	r3, [r3, #0x8]
 8009814: 441a         	add	r2, r3
 8009816: 68fb         	ldr	r3, [r7, #0xc]
 8009818: 61da         	str	r2, [r3, #0x1c]
; 			if (msgq->write_ptr == msgq->buffer_end) {
 800981a: 68fb         	ldr	r3, [r7, #0xc]
 800981c: 69da         	ldr	r2, [r3, #0x1c]
 800981e: 68fb         	ldr	r3, [r7, #0xc]
 8009820: 695b         	ldr	r3, [r3, #0x14]
 8009822: 429a         	cmp	r2, r3
 8009824: d103         	bne	0x800982e <z_impl_k_msgq_get+0x112> @ imm = #0x6
; 				msgq->write_ptr = msgq->buffer_start;
 8009826: 68fb         	ldr	r3, [r7, #0xc]
 8009828: 691a         	ldr	r2, [r3, #0x10]
 800982a: 68fb         	ldr	r3, [r7, #0xc]
 800982c: 61da         	str	r2, [r3, #0x1c]
; 			msgq->used_msgs++;
 800982e: 68fb         	ldr	r3, [r7, #0xc]
 8009830: 6a1b         	ldr	r3, [r3, #0x20]
 8009832: 1c5a         	adds	r2, r3, #0x1
 8009834: 68fb         	ldr	r3, [r7, #0xc]
 8009836: 621a         	str	r2, [r3, #0x20]
 8009838: 6e3b         	ldr	r3, [r7, #0x60]
 800983a: 633b         	str	r3, [r7, #0x30]
 800983c: 2300         	movs	r3, #0x0
 800983e: 62fb         	str	r3, [r7, #0x2c]
; 	thread->arch.swap_return_value = value;
 8009840: 6b3b         	ldr	r3, [r7, #0x30]
 8009842: 6afa         	ldr	r2, [r7, #0x2c]
 8009844: f8c3 20cc    	str.w	r2, [r3, #0xcc]
; }
 8009848: bf00         	nop
; 			z_ready_thread(pending_thread);
 800984a: 6e38         	ldr	r0, [r7, #0x60]
 800984c: f001 f81a    	bl	0x800a884 <z_ready_thread> @ imm = #0x1034
; 			z_reschedule(&msgq->lock, key);
 8009850: 68fb         	ldr	r3, [r7, #0xc]
 8009852: 3308         	adds	r3, #0x8
 8009854: 69b9         	ldr	r1, [r7, #0x18]
 8009856: 4618         	mov	r0, r3
 8009858: f00a f9d0    	bl	0x8013bfc <z_reschedule> @ imm = #0xa3a0
; 			return 0;
 800985c: 2300         	movs	r3, #0x0
 800985e: e038         	b	0x80098d2 <z_impl_k_msgq_get+0x1b6> @ imm = #0x70
; 		result = 0;
 8009860: 2300         	movs	r3, #0x0
 8009862: 667b         	str	r3, [r7, #0x64]
 8009864: e022         	b	0x80098ac <z_impl_k_msgq_get+0x190> @ imm = #0x44
; 	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
 8009866: e9d7 2300    	ldrd	r2, r3, [r7]
 800986a: f04f 0000    	mov.w	r0, #0x0
 800986e: f04f 0100    	mov.w	r1, #0x0
 8009872: 428b         	cmp	r3, r1
 8009874: bf08         	it	eq
 8009876: 4282         	cmpeq	r2, r0
 8009878: d103         	bne	0x8009882 <z_impl_k_msgq_get+0x166> @ imm = #0x6
; 		result = -ENOMSG;
 800987a: f06f 0322    	mvn	r3, #0x22
 800987e: 667b         	str	r3, [r7, #0x64]
 8009880: e014         	b	0x80098ac <z_impl_k_msgq_get+0x190> @ imm = #0x28
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8009882: 4b16         	ldr	r3, [pc, #0x58]         @ 0x80098dc <z_impl_k_msgq_get+0x1c0>
 8009884: 689b         	ldr	r3, [r3, #0x8]
 8009886: 62bb         	str	r3, [r7, #0x28]
; 	return ret;
 8009888: 6abb         	ldr	r3, [r7, #0x28]
; 		arch_current_thread()->base.swap_data = data;
 800988a: 68ba         	ldr	r2, [r7, #0x8]
 800988c: 615a         	str	r2, [r3, #0x14]
; 		result = z_pend_curr(&msgq->lock, key, &msgq->wait_q, timeout);
 800988e: 68fb         	ldr	r3, [r7, #0xc]
 8009890: f103 0008    	add.w	r0, r3, #0x8
 8009894: 68f9         	ldr	r1, [r7, #0xc]
 8009896: e9d7 2300    	ldrd	r2, r3, [r7]
 800989a: e9cd 2300    	strd	r2, r3, [sp]
 800989e: 460a         	mov	r2, r1
 80098a0: 69b9         	ldr	r1, [r7, #0x18]
 80098a2: f001 fbab    	bl	0x800affc <z_pend_curr> @ imm = #0x1756
 80098a6: 6678         	str	r0, [r7, #0x64]
; 		return result;
 80098a8: 6e7b         	ldr	r3, [r7, #0x64]
 80098aa: e012         	b	0x80098d2 <z_impl_k_msgq_get+0x1b6> @ imm = #0x24
; 	k_spin_unlock(&msgq->lock, key);
 80098ac: 68fb         	ldr	r3, [r7, #0xc]
 80098ae: 3308         	adds	r3, #0x8
 80098b0: 627b         	str	r3, [r7, #0x24]
 80098b2: 69bb         	ldr	r3, [r7, #0x18]
 80098b4: 617b         	str	r3, [r7, #0x14]
; 	arch_irq_unlock(key.key);
 80098b6: 697b         	ldr	r3, [r7, #0x14]
 80098b8: 623b         	str	r3, [r7, #0x20]
 80098ba: 6a3b         	ldr	r3, [r7, #0x20]
 80098bc: 61fb         	str	r3, [r7, #0x1c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80098be: 69fb         	ldr	r3, [r7, #0x1c]
 80098c0: f383 8811    	msr	basepri, r3
; }
 80098c4: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80098c6: f3bf 8f6f    	isb	sy
; }
 80098ca: bf00         	nop
; }
 80098cc: bf00         	nop
; }
 80098ce: bf00         	nop
; 	return result;
 80098d0: 6e7b         	ldr	r3, [r7, #0x64]
; }
 80098d2: 4618         	mov	r0, r3
 80098d4: 3768         	adds	r7, #0x68
 80098d6: 46bd         	mov	sp, r7
 80098d8: bd80         	pop	{r7, pc}
 80098da: bf00         	nop

080098dc <$d>:
 80098dc: c0 02 00 20  	.word	0x200002c0

080098e0 <adjust_owner_prio>:
; {
 80098e0: b5b0         	push	{r4, r5, r7, lr}
 80098e2: b08c         	sub	sp, #0x30
 80098e4: af08         	add	r7, sp, #0x20
 80098e6: 6078         	str	r0, [r7, #0x4]
 80098e8: 6039         	str	r1, [r7]
; 	if (mutex->owner->base.prio != new_prio) {
 80098ea: 687b         	ldr	r3, [r7, #0x4]
 80098ec: 689b         	ldr	r3, [r3, #0x8]
 80098ee: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 80098f2: 461a         	mov	r2, r3
 80098f4: 683b         	ldr	r3, [r7]
 80098f6: 4293         	cmp	r3, r2
 80098f8: d03a         	beq	0x8009970 <adjust_owner_prio+0x90> @ imm = #0x74
; 		LOG_DBG("%p (ready (y/n): %c) prio changed to %d (was %d)",
 80098fa: 2303         	movs	r3, #0x3
 80098fc: 2b03         	cmp	r3, #0x3
 80098fe: d92f         	bls	0x8009960 <adjust_owner_prio+0x80> @ imm = #0x5e
 8009900: 2301         	movs	r3, #0x1
 8009902: 72fb         	strb	r3, [r7, #0xb]
 8009904: 7afb         	ldrb	r3, [r7, #0xb]
 8009906: f083 0301    	eor	r3, r3, #0x1
 800990a: b2db         	uxtb	r3, r3
 800990c: 2b00         	cmp	r3, #0x0
 800990e: d127         	bne	0x8009960 <adjust_owner_prio+0x80> @ imm = #0x4e
 8009910: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x800997c <adjust_owner_prio+0x9c>
 8009912: 681d         	ldr	r5, [r3]
 8009914: 687b         	ldr	r3, [r7, #0x4]
 8009916: 689c         	ldr	r4, [r3, #0x8]
 8009918: 687b         	ldr	r3, [r7, #0x4]
 800991a: 689b         	ldr	r3, [r3, #0x8]
 800991c: 4618         	mov	r0, r3
 800991e: f009 fb99    	bl	0x8013054 <z_is_thread_ready> @ imm = #0x9732
 8009922: 4603         	mov	r3, r0
 8009924: 2b00         	cmp	r3, #0x0
 8009926: d001         	beq	0x800992c <adjust_owner_prio+0x4c> @ imm = #0x2
 8009928: 2379         	movs	r3, #0x79
 800992a: e000         	b	0x800992e <adjust_owner_prio+0x4e> @ imm = #0x0
 800992c: 236e         	movs	r3, #0x6e
 800992e: 687a         	ldr	r2, [r7, #0x4]
 8009930: 6892         	ldr	r2, [r2, #0x8]
 8009932: f992 200e    	ldrsb.w	r2, [r2, #0xe]
 8009936: 9207         	str	r2, [sp, #0x1c]
 8009938: 683a         	ldr	r2, [r7]
 800993a: 9206         	str	r2, [sp, #0x18]
 800993c: 9305         	str	r3, [sp, #0x14]
 800993e: 9404         	str	r4, [sp, #0x10]
 8009940: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x8009980 <adjust_owner_prio+0xa0>
 8009942: 9303         	str	r3, [sp, #0xc]
 8009944: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x8009984 <adjust_owner_prio+0xa4>
 8009946: 9302         	str	r3, [sp, #0x8]
 8009948: 2308         	movs	r3, #0x8
 800994a: 9301         	str	r3, [sp, #0x4]
 800994c: 2300         	movs	r3, #0x0
 800994e: 9300         	str	r3, [sp]
 8009950: 2300         	movs	r3, #0x0
 8009952: 2204         	movs	r2, #0x4
 8009954: 4629         	mov	r1, r5
 8009956: 2000         	movs	r0, #0x0
 8009958: f009 fc20    	bl	0x801319c <z_log_msg_runtime_create> @ imm = #0x9840
 800995c: 2300         	movs	r3, #0x0
 800995e: 60fb         	str	r3, [r7, #0xc]
; 		return z_thread_prio_set(mutex->owner, new_prio);
 8009960: 687b         	ldr	r3, [r7, #0x4]
 8009962: 689b         	ldr	r3, [r3, #0x8]
 8009964: 6839         	ldr	r1, [r7]
 8009966: 4618         	mov	r0, r3
 8009968: f001 fb8e    	bl	0x800b088 <z_thread_prio_set> @ imm = #0x171c
 800996c: 4603         	mov	r3, r0
 800996e: e000         	b	0x8009972 <adjust_owner_prio+0x92> @ imm = #0x0
; 	return false;
 8009970: 2300         	movs	r3, #0x0
; }
 8009972: 4618         	mov	r0, r3
 8009974: 3710         	adds	r7, #0x10
 8009976: 46bd         	mov	sp, r7
 8009978: bdb0         	pop	{r4, r5, r7, pc}
 800997a: bf00         	nop

0800997c <$d>:
 800997c: 14 01 00 20  	.word	0x20000114
 8009980: 98 67 01 08  	.word	0x08016798
 8009984: 30 5d 01 08  	.word	0x08015d30

08009988 <z_impl_k_mutex_lock>:
; {
 8009988: b580         	push	{r7, lr}
 800998a: b0be         	sub	sp, #0xf8
 800998c: af08         	add	r7, sp, #0x20
 800998e: 60f8         	str	r0, [r7, #0xc]
 8009990: e9c7 2300    	strd	r2, r3, [r7]
; 	bool resched = false;
 8009994: 2300         	movs	r3, #0x0
 8009996: f887 30d7    	strb.w	r3, [r7, #0xd7]
 800999a: 4ba6         	ldr	r3, [pc, #0x298]        @ 0x8009c34 <z_impl_k_mutex_lock+0x2ac>
 800999c: f8c7 3094    	str.w	r3, [r7, #0x94]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80099a0: f3ef 8311    	mrs	r3, basepri
 80099a4: f8c7 3090    	str.w	r3, [r7, #0x90]
;   return(result);
 80099a8: f8d7 3090    	ldr.w	r3, [r7, #0x90]
; 	key = __get_BASEPRI();
 80099ac: f8c7 308c    	str.w	r3, [r7, #0x8c]
 80099b0: 2310         	movs	r3, #0x10
 80099b2: f8c7 3088    	str.w	r3, [r7, #0x88]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 80099b6: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 80099ba: f383 8812    	msr	basepri_max, r3
; }
 80099be: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80099c0: f3bf 8f6f    	isb	sy
; }
 80099c4: bf00         	nop
; 	return key;
 80099c6: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
; 	k.key = arch_irq_lock();
 80099ca: 617b         	str	r3, [r7, #0x14]
 80099cc: f8d7 3094    	ldr.w	r3, [r7, #0x94]
 80099d0: f8c7 3084    	str.w	r3, [r7, #0x84]
; }
 80099d4: bf00         	nop
 80099d6: f8d7 3094    	ldr.w	r3, [r7, #0x94]
 80099da: f8c7 3080    	str.w	r3, [r7, #0x80]
; }
 80099de: bf00         	nop
; 	return k;
 80099e0: 697b         	ldr	r3, [r7, #0x14]
 80099e2: 627b         	str	r3, [r7, #0x24]
; 	if (likely((mutex->lock_count == 0U) || (mutex->owner == arch_current_thread()))) {
 80099e4: 68fb         	ldr	r3, [r7, #0xc]
 80099e6: 68db         	ldr	r3, [r3, #0xc]
 80099e8: 2b00         	cmp	r3, #0x0
 80099ea: bf0c         	ite	eq
 80099ec: 2301         	moveq	r3, #0x1
 80099ee: 2300         	movne	r3, #0x0
 80099f0: b2db         	uxtb	r3, r3
 80099f2: 2b00         	cmp	r3, #0x0
 80099f4: d10c         	bne	0x8009a10 <z_impl_k_mutex_lock+0x88> @ imm = #0x18
 80099f6: 68fb         	ldr	r3, [r7, #0xc]
 80099f8: 689a         	ldr	r2, [r3, #0x8]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 80099fa: 4b8f         	ldr	r3, [pc, #0x23c]        @ 0x8009c38 <z_impl_k_mutex_lock+0x2b0>
 80099fc: 689b         	ldr	r3, [r3, #0x8]
 80099fe: 67fb         	str	r3, [r7, #0x7c]
; 	return ret;
 8009a00: 6ffb         	ldr	r3, [r7, #0x7c]
; 	if (likely((mutex->lock_count == 0U) || (mutex->owner == arch_current_thread()))) {
 8009a02: 429a         	cmp	r2, r3
 8009a04: bf0c         	ite	eq
 8009a06: 2301         	moveq	r3, #0x1
 8009a08: 2300         	movne	r3, #0x0
 8009a0a: b2db         	uxtb	r3, r3
 8009a0c: 2b00         	cmp	r3, #0x0
 8009a0e: d001         	beq	0x8009a14 <z_impl_k_mutex_lock+0x8c> @ imm = #0x2
 8009a10: 2301         	movs	r3, #0x1
 8009a12: e000         	b	0x8009a16 <z_impl_k_mutex_lock+0x8e> @ imm = #0x0
 8009a14: 2300         	movs	r3, #0x0
 8009a16: 2b00         	cmp	r3, #0x0
 8009a18: d059         	beq	0x8009ace <z_impl_k_mutex_lock+0x146> @ imm = #0xb2
; 		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
 8009a1a: 68fb         	ldr	r3, [r7, #0xc]
 8009a1c: 68db         	ldr	r3, [r3, #0xc]
; 					arch_current_thread()->base.prio :
 8009a1e: 2b00         	cmp	r3, #0x0
 8009a20: d106         	bne	0x8009a30 <z_impl_k_mutex_lock+0xa8> @ imm = #0xc
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8009a22: 4b85         	ldr	r3, [pc, #0x214]        @ 0x8009c38 <z_impl_k_mutex_lock+0x2b0>
 8009a24: 689b         	ldr	r3, [r3, #0x8]
 8009a26: 67bb         	str	r3, [r7, #0x78]
; 	return ret;
 8009a28: 6fbb         	ldr	r3, [r7, #0x78]
; 					arch_current_thread()->base.prio :
 8009a2a: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 8009a2e: e001         	b	0x8009a34 <z_impl_k_mutex_lock+0xac> @ imm = #0x2
 8009a30: 68fb         	ldr	r3, [r7, #0xc]
 8009a32: 691b         	ldr	r3, [r3, #0x10]
; 		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
 8009a34: 68fa         	ldr	r2, [r7, #0xc]
 8009a36: 6113         	str	r3, [r2, #0x10]
; 		mutex->lock_count++;
 8009a38: 68fb         	ldr	r3, [r7, #0xc]
 8009a3a: 68db         	ldr	r3, [r3, #0xc]
 8009a3c: 1c5a         	adds	r2, r3, #0x1
 8009a3e: 68fb         	ldr	r3, [r7, #0xc]
 8009a40: 60da         	str	r2, [r3, #0xc]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8009a42: 4b7d         	ldr	r3, [pc, #0x1f4]        @ 0x8009c38 <z_impl_k_mutex_lock+0x2b0>
 8009a44: 689b         	ldr	r3, [r3, #0x8]
 8009a46: 677b         	str	r3, [r7, #0x74]
; 	return ret;
 8009a48: 6f7a         	ldr	r2, [r7, #0x74]
; 		mutex->owner = arch_current_thread();
 8009a4a: 68fb         	ldr	r3, [r7, #0xc]
 8009a4c: 609a         	str	r2, [r3, #0x8]
; 		LOG_DBG("%p took mutex %p, count: %d, orig prio: %d",
 8009a4e: 2303         	movs	r3, #0x3
 8009a50: 2b03         	cmp	r3, #0x3
 8009a52: d929         	bls	0x8009aa8 <z_impl_k_mutex_lock+0x120> @ imm = #0x52
 8009a54: 2301         	movs	r3, #0x1
 8009a56: f887 309f    	strb.w	r3, [r7, #0x9f]
 8009a5a: f897 309f    	ldrb.w	r3, [r7, #0x9f]
 8009a5e: f083 0301    	eor	r3, r3, #0x1
 8009a62: b2db         	uxtb	r3, r3
 8009a64: 2b00         	cmp	r3, #0x0
 8009a66: d11f         	bne	0x8009aa8 <z_impl_k_mutex_lock+0x120> @ imm = #0x3e
 8009a68: 4b74         	ldr	r3, [pc, #0x1d0]        @ 0x8009c3c <z_impl_k_mutex_lock+0x2b4>
 8009a6a: 6818         	ldr	r0, [r3]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8009a6c: 4b72         	ldr	r3, [pc, #0x1c8]        @ 0x8009c38 <z_impl_k_mutex_lock+0x2b0>
 8009a6e: 689b         	ldr	r3, [r3, #0x8]
 8009a70: 673b         	str	r3, [r7, #0x70]
; 	return ret;
 8009a72: 6f3b         	ldr	r3, [r7, #0x70]
; 		LOG_DBG("%p took mutex %p, count: %d, orig prio: %d",
 8009a74: 68fa         	ldr	r2, [r7, #0xc]
 8009a76: 68d2         	ldr	r2, [r2, #0xc]
 8009a78: 68f9         	ldr	r1, [r7, #0xc]
 8009a7a: 6909         	ldr	r1, [r1, #0x10]
 8009a7c: 9107         	str	r1, [sp, #0x1c]
 8009a7e: 9206         	str	r2, [sp, #0x18]
 8009a80: 68fa         	ldr	r2, [r7, #0xc]
 8009a82: 9205         	str	r2, [sp, #0x14]
 8009a84: 9304         	str	r3, [sp, #0x10]
 8009a86: 4b6e         	ldr	r3, [pc, #0x1b8]        @ 0x8009c40 <z_impl_k_mutex_lock+0x2b8>
 8009a88: 9303         	str	r3, [sp, #0xc]
 8009a8a: 4b6e         	ldr	r3, [pc, #0x1b8]        @ 0x8009c44 <z_impl_k_mutex_lock+0x2bc>
 8009a8c: 9302         	str	r3, [sp, #0x8]
 8009a8e: 2308         	movs	r3, #0x8
 8009a90: 9301         	str	r3, [sp, #0x4]
 8009a92: 2300         	movs	r3, #0x0
 8009a94: 9300         	str	r3, [sp]
 8009a96: 2300         	movs	r3, #0x0
 8009a98: 2204         	movs	r2, #0x4
 8009a9a: 4601         	mov	r1, r0
 8009a9c: 2000         	movs	r0, #0x0
 8009a9e: f009 fb7d    	bl	0x801319c <z_log_msg_runtime_create> @ imm = #0x96fa
 8009aa2: 2300         	movs	r3, #0x0
 8009aa4: f8c7 3098    	str.w	r3, [r7, #0x98]
 8009aa8: 4b62         	ldr	r3, [pc, #0x188]        @ 0x8009c34 <z_impl_k_mutex_lock+0x2ac>
 8009aaa: 66fb         	str	r3, [r7, #0x6c]
 8009aac: 6a7b         	ldr	r3, [r7, #0x24]
 8009aae: 61bb         	str	r3, [r7, #0x18]
; 	arch_irq_unlock(key.key);
 8009ab0: 69bb         	ldr	r3, [r7, #0x18]
 8009ab2: 66bb         	str	r3, [r7, #0x68]
 8009ab4: 6ebb         	ldr	r3, [r7, #0x68]
 8009ab6: 667b         	str	r3, [r7, #0x64]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8009ab8: 6e7b         	ldr	r3, [r7, #0x64]
 8009aba: f383 8811    	msr	basepri, r3
; }
 8009abe: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8009ac0: f3bf 8f6f    	isb	sy
; }
 8009ac4: bf00         	nop
; }
 8009ac6: bf00         	nop
; }
 8009ac8: bf00         	nop
; 		return 0;
 8009aca: 2300         	movs	r3, #0x0
 8009acc: e193         	b	0x8009df6 <z_impl_k_mutex_lock+0x46e> @ imm = #0x326
; 	if (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {
 8009ace: e9d7 2300    	ldrd	r2, r3, [r7]
 8009ad2: f04f 0000    	mov.w	r0, #0x0
 8009ad6: f04f 0100    	mov.w	r1, #0x0
 8009ada: 428b         	cmp	r3, r1
 8009adc: bf08         	it	eq
 8009ade: 4282         	cmpeq	r2, r0
 8009ae0: bf0c         	ite	eq
 8009ae2: 2301         	moveq	r3, #0x1
 8009ae4: 2300         	movne	r3, #0x0
 8009ae6: b2db         	uxtb	r3, r3
 8009ae8: 2b00         	cmp	r3, #0x0
 8009aea: d013         	beq	0x8009b14 <z_impl_k_mutex_lock+0x18c> @ imm = #0x26
 8009aec: 4b51         	ldr	r3, [pc, #0x144]        @ 0x8009c34 <z_impl_k_mutex_lock+0x2ac>
 8009aee: 663b         	str	r3, [r7, #0x60]
 8009af0: 6a7b         	ldr	r3, [r7, #0x24]
 8009af2: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 8009af4: 693b         	ldr	r3, [r7, #0x10]
 8009af6: 65fb         	str	r3, [r7, #0x5c]
 8009af8: 6dfb         	ldr	r3, [r7, #0x5c]
 8009afa: 65bb         	str	r3, [r7, #0x58]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8009afc: 6dbb         	ldr	r3, [r7, #0x58]
 8009afe: f383 8811    	msr	basepri, r3
; }
 8009b02: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8009b04: f3bf 8f6f    	isb	sy
; }
 8009b08: bf00         	nop
; }
 8009b0a: bf00         	nop
; }
 8009b0c: bf00         	nop
; 		return -EBUSY;
 8009b0e: f06f 030f    	mvn	r3, #0xf
 8009b12: e170         	b	0x8009df6 <z_impl_k_mutex_lock+0x46e> @ imm = #0x2e0
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8009b14: 4b48         	ldr	r3, [pc, #0x120]        @ 0x8009c38 <z_impl_k_mutex_lock+0x2b0>
 8009b16: 689b         	ldr	r3, [r3, #0x8]
 8009b18: 657b         	str	r3, [r7, #0x54]
; 	return ret;
 8009b1a: 6d7b         	ldr	r3, [r7, #0x54]
; 	new_prio = new_prio_for_inheritance(arch_current_thread()->base.prio,
 8009b1c: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 8009b20: 461a         	mov	r2, r3
; 					    mutex->owner->base.prio);
 8009b22: 68fb         	ldr	r3, [r7, #0xc]
 8009b24: 689b         	ldr	r3, [r3, #0x8]
 8009b26: f993 300e    	ldrsb.w	r3, [r3, #0xe]
; 	new_prio = new_prio_for_inheritance(arch_current_thread()->base.prio,
 8009b2a: 4619         	mov	r1, r3
 8009b2c: 4610         	mov	r0, r2
 8009b2e: f009 fb69    	bl	0x8013204 <new_prio_for_inheritance> @ imm = #0x96d2
 8009b32: f8c7 00d0    	str.w	r0, [r7, #0xd0]
; 	LOG_DBG("adjusting prio up on mutex %p", mutex);
 8009b36: 2303         	movs	r3, #0x3
 8009b38: 2b03         	cmp	r3, #0x3
 8009b3a: d91d         	bls	0x8009b78 <z_impl_k_mutex_lock+0x1f0> @ imm = #0x3a
 8009b3c: 2301         	movs	r3, #0x1
 8009b3e: f887 30cf    	strb.w	r3, [r7, #0xcf]
 8009b42: f897 30cf    	ldrb.w	r3, [r7, #0xcf]
 8009b46: f083 0301    	eor	r3, r3, #0x1
 8009b4a: b2db         	uxtb	r3, r3
 8009b4c: 2b00         	cmp	r3, #0x0
 8009b4e: d113         	bne	0x8009b78 <z_impl_k_mutex_lock+0x1f0> @ imm = #0x26
 8009b50: 4b3a         	ldr	r3, [pc, #0xe8]         @ 0x8009c3c <z_impl_k_mutex_lock+0x2b4>
 8009b52: 6819         	ldr	r1, [r3]
 8009b54: 68fb         	ldr	r3, [r7, #0xc]
 8009b56: 9304         	str	r3, [sp, #0x10]
 8009b58: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x8009c40 <z_impl_k_mutex_lock+0x2b8>
 8009b5a: 9303         	str	r3, [sp, #0xc]
 8009b5c: 4b3a         	ldr	r3, [pc, #0xe8]         @ 0x8009c48 <z_impl_k_mutex_lock+0x2c0>
 8009b5e: 9302         	str	r3, [sp, #0x8]
 8009b60: 2308         	movs	r3, #0x8
 8009b62: 9301         	str	r3, [sp, #0x4]
 8009b64: 2300         	movs	r3, #0x0
 8009b66: 9300         	str	r3, [sp]
 8009b68: 2300         	movs	r3, #0x0
 8009b6a: 2204         	movs	r2, #0x4
 8009b6c: 2000         	movs	r0, #0x0
 8009b6e: f009 fb15    	bl	0x801319c <z_log_msg_runtime_create> @ imm = #0x962a
 8009b72: 2300         	movs	r3, #0x0
 8009b74: f8c7 30c8    	str.w	r3, [r7, #0xc8]
; 	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
 8009b78: 68fb         	ldr	r3, [r7, #0xc]
 8009b7a: 689b         	ldr	r3, [r3, #0x8]
 8009b7c: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 8009b80: 4619         	mov	r1, r3
 8009b82: f8d7 00d0    	ldr.w	r0, [r7, #0xd0]
 8009b86: f009 fac8    	bl	0x801311a <z_is_prio_higher> @ imm = #0x9590
 8009b8a: 4603         	mov	r3, r0
 8009b8c: 2b00         	cmp	r3, #0x0
 8009b8e: d007         	beq	0x8009ba0 <z_impl_k_mutex_lock+0x218> @ imm = #0xe
; 		resched = adjust_owner_prio(mutex, new_prio);
 8009b90: f8d7 10d0    	ldr.w	r1, [r7, #0xd0]
 8009b94: 68f8         	ldr	r0, [r7, #0xc]
 8009b96: f7ff fea3    	bl	0x80098e0 <adjust_owner_prio> @ imm = #-0x2ba
 8009b9a: 4603         	mov	r3, r0
 8009b9c: f887 30d7    	strb.w	r3, [r7, #0xd7]
; 	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
 8009ba0: 68f9         	ldr	r1, [r7, #0xc]
 8009ba2: e9d7 2300    	ldrd	r2, r3, [r7]
 8009ba6: e9cd 2300    	strd	r2, r3, [sp]
 8009baa: 460a         	mov	r2, r1
 8009bac: 6a79         	ldr	r1, [r7, #0x24]
 8009bae: 4821         	ldr	r0, [pc, #0x84]         @ 0x8009c34 <z_impl_k_mutex_lock+0x2ac>
 8009bb0: f001 fa24    	bl	0x800affc <z_pend_curr> @ imm = #0x1448
 8009bb4: f8c7 00c4    	str.w	r0, [r7, #0xc4]
; 	LOG_DBG("on mutex %p got_mutex value: %d", mutex, got_mutex);
 8009bb8: 2303         	movs	r3, #0x3
 8009bba: 2b03         	cmp	r3, #0x3
 8009bbc: d920         	bls	0x8009c00 <z_impl_k_mutex_lock+0x278> @ imm = #0x40
 8009bbe: 2301         	movs	r3, #0x1
 8009bc0: f887 30c3    	strb.w	r3, [r7, #0xc3]
 8009bc4: f897 30c3    	ldrb.w	r3, [r7, #0xc3]
 8009bc8: f083 0301    	eor	r3, r3, #0x1
 8009bcc: b2db         	uxtb	r3, r3
 8009bce: 2b00         	cmp	r3, #0x0
 8009bd0: d116         	bne	0x8009c00 <z_impl_k_mutex_lock+0x278> @ imm = #0x2c
 8009bd2: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x8009c3c <z_impl_k_mutex_lock+0x2b4>
 8009bd4: 6819         	ldr	r1, [r3]
 8009bd6: f8d7 30c4    	ldr.w	r3, [r7, #0xc4]
 8009bda: 9305         	str	r3, [sp, #0x14]
 8009bdc: 68fb         	ldr	r3, [r7, #0xc]
 8009bde: 9304         	str	r3, [sp, #0x10]
 8009be0: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x8009c40 <z_impl_k_mutex_lock+0x2b8>
 8009be2: 9303         	str	r3, [sp, #0xc]
 8009be4: 4b19         	ldr	r3, [pc, #0x64]         @ 0x8009c4c <z_impl_k_mutex_lock+0x2c4>
 8009be6: 9302         	str	r3, [sp, #0x8]
 8009be8: 2308         	movs	r3, #0x8
 8009bea: 9301         	str	r3, [sp, #0x4]
 8009bec: 2300         	movs	r3, #0x0
 8009bee: 9300         	str	r3, [sp]
 8009bf0: 2300         	movs	r3, #0x0
 8009bf2: 2204         	movs	r2, #0x4
 8009bf4: 2000         	movs	r0, #0x0
 8009bf6: f009 fad1    	bl	0x801319c <z_log_msg_runtime_create> @ imm = #0x95a2
 8009bfa: 2300         	movs	r3, #0x0
 8009bfc: f8c7 30bc    	str.w	r3, [r7, #0xbc]
; 	LOG_DBG("%p got mutex %p (y/n): %c", arch_current_thread(), mutex,
 8009c00: 2303         	movs	r3, #0x3
 8009c02: 2b03         	cmp	r3, #0x3
 8009c04: d939         	bls	0x8009c7a <z_impl_k_mutex_lock+0x2f2> @ imm = #0x72
 8009c06: 2301         	movs	r3, #0x1
 8009c08: f887 30bb    	strb.w	r3, [r7, #0xbb]
 8009c0c: f897 30bb    	ldrb.w	r3, [r7, #0xbb]
 8009c10: f083 0301    	eor	r3, r3, #0x1
 8009c14: b2db         	uxtb	r3, r3
 8009c16: 2b00         	cmp	r3, #0x0
 8009c18: d12f         	bne	0x8009c7a <z_impl_k_mutex_lock+0x2f2> @ imm = #0x5e
 8009c1a: 4b08         	ldr	r3, [pc, #0x20]         @ 0x8009c3c <z_impl_k_mutex_lock+0x2b4>
 8009c1c: 6819         	ldr	r1, [r3]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8009c1e: 4b06         	ldr	r3, [pc, #0x18]         @ 0x8009c38 <z_impl_k_mutex_lock+0x2b0>
 8009c20: 689b         	ldr	r3, [r3, #0x8]
 8009c22: 653b         	str	r3, [r7, #0x50]
; 	return ret;
 8009c24: 6d3b         	ldr	r3, [r7, #0x50]
; 	LOG_DBG("%p got mutex %p (y/n): %c", arch_current_thread(), mutex,
 8009c26: f8d7 20c4    	ldr.w	r2, [r7, #0xc4]
 8009c2a: 2a00         	cmp	r2, #0x0
 8009c2c: d010         	beq	0x8009c50 <z_impl_k_mutex_lock+0x2c8> @ imm = #0x20
 8009c2e: 2279         	movs	r2, #0x79
 8009c30: e00f         	b	0x8009c52 <z_impl_k_mutex_lock+0x2ca> @ imm = #0x1e
 8009c32: bf00         	nop

08009c34 <$d>:
 8009c34: e0 09 00 20  	.word	0x200009e0
 8009c38: c0 02 00 20  	.word	0x200002c0
 8009c3c: 14 01 00 20  	.word	0x20000114
 8009c40: ac 67 01 08  	.word	0x080167ac
 8009c44: 68 5d 01 08  	.word	0x08015d68
 8009c48: 98 5d 01 08  	.word	0x08015d98
 8009c4c: bc 5d 01 08  	.word	0x08015dbc

08009c50 <$t>:
 8009c50: 226e         	movs	r2, #0x6e
 8009c52: 9206         	str	r2, [sp, #0x18]
 8009c54: 68fa         	ldr	r2, [r7, #0xc]
 8009c56: 9205         	str	r2, [sp, #0x14]
 8009c58: 9304         	str	r3, [sp, #0x10]
 8009c5a: 4b69         	ldr	r3, [pc, #0x1a4]        @ 0x8009e00 <z_impl_k_mutex_lock+0x478>
 8009c5c: 9303         	str	r3, [sp, #0xc]
 8009c5e: 4b69         	ldr	r3, [pc, #0x1a4]        @ 0x8009e04 <z_impl_k_mutex_lock+0x47c>
 8009c60: 9302         	str	r3, [sp, #0x8]
 8009c62: 2308         	movs	r3, #0x8
 8009c64: 9301         	str	r3, [sp, #0x4]
 8009c66: 2300         	movs	r3, #0x0
 8009c68: 9300         	str	r3, [sp]
 8009c6a: 2300         	movs	r3, #0x0
 8009c6c: 2204         	movs	r2, #0x4
 8009c6e: 2000         	movs	r0, #0x0
 8009c70: f009 fa94    	bl	0x801319c <z_log_msg_runtime_create> @ imm = #0x9528
 8009c74: 2300         	movs	r3, #0x0
 8009c76: f8c7 30b4    	str.w	r3, [r7, #0xb4]
; 	if (got_mutex == 0) {
 8009c7a: f8d7 30c4    	ldr.w	r3, [r7, #0xc4]
 8009c7e: 2b00         	cmp	r3, #0x0
 8009c80: d101         	bne	0x8009c86 <z_impl_k_mutex_lock+0x2fe> @ imm = #0x2
; 		return 0;
 8009c82: 2300         	movs	r3, #0x0
 8009c84: e0b7         	b	0x8009df6 <z_impl_k_mutex_lock+0x46e> @ imm = #0x16e
; 	LOG_DBG("%p timeout on mutex %p", arch_current_thread(), mutex);
 8009c86: 2303         	movs	r3, #0x3
 8009c88: 2b03         	cmp	r3, #0x3
 8009c8a: d922         	bls	0x8009cd2 <z_impl_k_mutex_lock+0x34a> @ imm = #0x44
 8009c8c: 2301         	movs	r3, #0x1
 8009c8e: f887 30b3    	strb.w	r3, [r7, #0xb3]
 8009c92: f897 30b3    	ldrb.w	r3, [r7, #0xb3]
 8009c96: f083 0301    	eor	r3, r3, #0x1
 8009c9a: b2db         	uxtb	r3, r3
 8009c9c: 2b00         	cmp	r3, #0x0
 8009c9e: d118         	bne	0x8009cd2 <z_impl_k_mutex_lock+0x34a> @ imm = #0x30
 8009ca0: 4b59         	ldr	r3, [pc, #0x164]        @ 0x8009e08 <z_impl_k_mutex_lock+0x480>
 8009ca2: 6819         	ldr	r1, [r3]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8009ca4: 4b59         	ldr	r3, [pc, #0x164]        @ 0x8009e0c <z_impl_k_mutex_lock+0x484>
 8009ca6: 689b         	ldr	r3, [r3, #0x8]
 8009ca8: 64fb         	str	r3, [r7, #0x4c]
; 	return ret;
 8009caa: 6cfb         	ldr	r3, [r7, #0x4c]
; 	LOG_DBG("%p timeout on mutex %p", arch_current_thread(), mutex);
 8009cac: 68fa         	ldr	r2, [r7, #0xc]
 8009cae: 9205         	str	r2, [sp, #0x14]
 8009cb0: 9304         	str	r3, [sp, #0x10]
 8009cb2: 4b53         	ldr	r3, [pc, #0x14c]        @ 0x8009e00 <z_impl_k_mutex_lock+0x478>
 8009cb4: 9303         	str	r3, [sp, #0xc]
 8009cb6: 4b56         	ldr	r3, [pc, #0x158]        @ 0x8009e10 <z_impl_k_mutex_lock+0x488>
 8009cb8: 9302         	str	r3, [sp, #0x8]
 8009cba: 2308         	movs	r3, #0x8
 8009cbc: 9301         	str	r3, [sp, #0x4]
 8009cbe: 2300         	movs	r3, #0x0
 8009cc0: 9300         	str	r3, [sp]
 8009cc2: 2300         	movs	r3, #0x0
 8009cc4: 2204         	movs	r2, #0x4
 8009cc6: 2000         	movs	r0, #0x0
 8009cc8: f009 fa68    	bl	0x801319c <z_log_msg_runtime_create> @ imm = #0x94d0
 8009ccc: 2300         	movs	r3, #0x0
 8009cce: f8c7 30ac    	str.w	r3, [r7, #0xac]
 8009cd2: 4b50         	ldr	r3, [pc, #0x140]        @ 0x8009e14 <z_impl_k_mutex_lock+0x48c>
 8009cd4: 64bb         	str	r3, [r7, #0x48]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8009cd6: f3ef 8311    	mrs	r3, basepri
 8009cda: 647b         	str	r3, [r7, #0x44]
;   return(result);
 8009cdc: 6c7b         	ldr	r3, [r7, #0x44]
; 	key = __get_BASEPRI();
 8009cde: 643b         	str	r3, [r7, #0x40]
 8009ce0: 2310         	movs	r3, #0x10
 8009ce2: 63fb         	str	r3, [r7, #0x3c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8009ce4: 6bfb         	ldr	r3, [r7, #0x3c]
 8009ce6: f383 8812    	msr	basepri_max, r3
; }
 8009cea: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8009cec: f3bf 8f6f    	isb	sy
; }
 8009cf0: bf00         	nop
; 	return key;
 8009cf2: 6c3b         	ldr	r3, [r7, #0x40]
; 	k.key = arch_irq_lock();
 8009cf4: 61fb         	str	r3, [r7, #0x1c]
 8009cf6: 6cbb         	ldr	r3, [r7, #0x48]
 8009cf8: 63bb         	str	r3, [r7, #0x38]
; }
 8009cfa: bf00         	nop
 8009cfc: 6cbb         	ldr	r3, [r7, #0x48]
 8009cfe: 637b         	str	r3, [r7, #0x34]
; }
 8009d00: bf00         	nop
; 	return k;
 8009d02: 69fb         	ldr	r3, [r7, #0x1c]
 8009d04: 627b         	str	r3, [r7, #0x24]
; 	if (likely(mutex->owner != NULL)) {
 8009d06: 68fb         	ldr	r3, [r7, #0xc]
 8009d08: 689b         	ldr	r3, [r3, #0x8]
 8009d0a: 2b00         	cmp	r3, #0x0
 8009d0c: bf14         	ite	ne
 8009d0e: 2301         	movne	r3, #0x1
 8009d10: 2300         	moveq	r3, #0x0
 8009d12: b2db         	uxtb	r3, r3
 8009d14: 2b00         	cmp	r3, #0x0
 8009d16: d052         	beq	0x8009dbe <z_impl_k_mutex_lock+0x436> @ imm = #0xa4
; 		struct k_thread *waiter = z_waitq_head(&mutex->wait_q);
 8009d18: 68fb         	ldr	r3, [r7, #0xc]
 8009d1a: 4618         	mov	r0, r3
 8009d1c: f009 fa31    	bl	0x8013182 <z_waitq_head> @ imm = #0x9462
 8009d20: f8c7 00a8    	str.w	r0, [r7, #0xa8]
; 			new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
 8009d24: f8d7 30a8    	ldr.w	r3, [r7, #0xa8]
 8009d28: 2b00         	cmp	r3, #0x0
 8009d2a: d00c         	beq	0x8009d46 <z_impl_k_mutex_lock+0x3be> @ imm = #0x18
 8009d2c: f8d7 30a8    	ldr.w	r3, [r7, #0xa8]
 8009d30: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 8009d34: 461a         	mov	r2, r3
 8009d36: 68fb         	ldr	r3, [r7, #0xc]
 8009d38: 691b         	ldr	r3, [r3, #0x10]
 8009d3a: 4619         	mov	r1, r3
 8009d3c: 4610         	mov	r0, r2
 8009d3e: f009 fa61    	bl	0x8013204 <new_prio_for_inheritance> @ imm = #0x94c2
 8009d42: 4603         	mov	r3, r0
 8009d44: e001         	b	0x8009d4a <z_impl_k_mutex_lock+0x3c2> @ imm = #0x2
 8009d46: 68fb         	ldr	r3, [r7, #0xc]
 8009d48: 691b         	ldr	r3, [r3, #0x10]
; 		new_prio = (waiter != NULL) ?
 8009d4a: f8c7 30d0    	str.w	r3, [r7, #0xd0]
; 		LOG_DBG("adjusting prio down on mutex %p", mutex);
 8009d4e: 2303         	movs	r3, #0x3
 8009d50: 2b03         	cmp	r3, #0x3
 8009d52: d91d         	bls	0x8009d90 <z_impl_k_mutex_lock+0x408> @ imm = #0x3a
 8009d54: 2301         	movs	r3, #0x1
 8009d56: f887 30a7    	strb.w	r3, [r7, #0xa7]
 8009d5a: f897 30a7    	ldrb.w	r3, [r7, #0xa7]
 8009d5e: f083 0301    	eor	r3, r3, #0x1
 8009d62: b2db         	uxtb	r3, r3
 8009d64: 2b00         	cmp	r3, #0x0
 8009d66: d113         	bne	0x8009d90 <z_impl_k_mutex_lock+0x408> @ imm = #0x26
 8009d68: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x8009e08 <z_impl_k_mutex_lock+0x480>
 8009d6a: 6819         	ldr	r1, [r3]
 8009d6c: 68fb         	ldr	r3, [r7, #0xc]
 8009d6e: 9304         	str	r3, [sp, #0x10]
 8009d70: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x8009e00 <z_impl_k_mutex_lock+0x478>
 8009d72: 9303         	str	r3, [sp, #0xc]
 8009d74: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x8009e18 <z_impl_k_mutex_lock+0x490>
 8009d76: 9302         	str	r3, [sp, #0x8]
 8009d78: 2308         	movs	r3, #0x8
 8009d7a: 9301         	str	r3, [sp, #0x4]
 8009d7c: 2300         	movs	r3, #0x0
 8009d7e: 9300         	str	r3, [sp]
 8009d80: 2300         	movs	r3, #0x0
 8009d82: 2204         	movs	r2, #0x4
 8009d84: 2000         	movs	r0, #0x0
 8009d86: f009 fa09    	bl	0x801319c <z_log_msg_runtime_create> @ imm = #0x9412
 8009d8a: 2300         	movs	r3, #0x0
 8009d8c: f8c7 30a0    	str.w	r3, [r7, #0xa0]
; 		resched = adjust_owner_prio(mutex, new_prio) || resched;
 8009d90: f8d7 10d0    	ldr.w	r1, [r7, #0xd0]
 8009d94: 68f8         	ldr	r0, [r7, #0xc]
 8009d96: f7ff fda3    	bl	0x80098e0 <adjust_owner_prio> @ imm = #-0x4ba
 8009d9a: 4603         	mov	r3, r0
 8009d9c: 2b00         	cmp	r3, #0x0
 8009d9e: d103         	bne	0x8009da8 <z_impl_k_mutex_lock+0x420> @ imm = #0x6
 8009da0: f897 30d7    	ldrb.w	r3, [r7, #0xd7]
 8009da4: 2b00         	cmp	r3, #0x0
 8009da6: d001         	beq	0x8009dac <z_impl_k_mutex_lock+0x424> @ imm = #0x2
 8009da8: 2301         	movs	r3, #0x1
 8009daa: e000         	b	0x8009dae <z_impl_k_mutex_lock+0x426> @ imm = #0x0
 8009dac: 2300         	movs	r3, #0x0
 8009dae: f887 30d7    	strb.w	r3, [r7, #0xd7]
 8009db2: f897 30d7    	ldrb.w	r3, [r7, #0xd7]
 8009db6: f003 0301    	and	r3, r3, #0x1
 8009dba: f887 30d7    	strb.w	r3, [r7, #0xd7]
; 	if (resched) {
 8009dbe: f897 30d7    	ldrb.w	r3, [r7, #0xd7]
 8009dc2: 2b00         	cmp	r3, #0x0
 8009dc4: d004         	beq	0x8009dd0 <z_impl_k_mutex_lock+0x448> @ imm = #0x8
; 		z_reschedule(&lock, key);
 8009dc6: 6a79         	ldr	r1, [r7, #0x24]
 8009dc8: 4812         	ldr	r0, [pc, #0x48]         @ 0x8009e14 <z_impl_k_mutex_lock+0x48c>
 8009dca: f009 ff17    	bl	0x8013bfc <z_reschedule> @ imm = #0x9e2e
 8009dce: e010         	b	0x8009df2 <z_impl_k_mutex_lock+0x46a> @ imm = #0x20
 8009dd0: 4b10         	ldr	r3, [pc, #0x40]         @ 0x8009e14 <z_impl_k_mutex_lock+0x48c>
 8009dd2: 633b         	str	r3, [r7, #0x30]
 8009dd4: 6a7b         	ldr	r3, [r7, #0x24]
 8009dd6: 623b         	str	r3, [r7, #0x20]
; 	arch_irq_unlock(key.key);
 8009dd8: 6a3b         	ldr	r3, [r7, #0x20]
 8009dda: 62fb         	str	r3, [r7, #0x2c]
 8009ddc: 6afb         	ldr	r3, [r7, #0x2c]
 8009dde: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8009de0: 6abb         	ldr	r3, [r7, #0x28]
 8009de2: f383 8811    	msr	basepri, r3
; }
 8009de6: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8009de8: f3bf 8f6f    	isb	sy
; }
 8009dec: bf00         	nop
; }
 8009dee: bf00         	nop
; }
 8009df0: bf00         	nop
; 	return -EAGAIN;
 8009df2: f06f 030a    	mvn	r3, #0xa
; }
 8009df6: 4618         	mov	r0, r3
 8009df8: 37d8         	adds	r7, #0xd8
 8009dfa: 46bd         	mov	sp, r7
 8009dfc: bd80         	pop	{r7, pc}
 8009dfe: bf00         	nop

08009e00 <$d>:
 8009e00: ac 67 01 08  	.word	0x080167ac
 8009e04: e0 5d 01 08  	.word	0x08015de0
 8009e08: 14 01 00 20  	.word	0x20000114
 8009e0c: c0 02 00 20  	.word	0x200002c0
 8009e10: 00 5e 01 08  	.word	0x08015e00
 8009e14: e0 09 00 20  	.word	0x200009e0
 8009e18: 1c 5e 01 08  	.word	0x08015e1c

08009e1c <z_impl_k_mutex_unlock>:
; {
 8009e1c: b580         	push	{r7, lr}
 8009e1e: b0a4         	sub	sp, #0x90
 8009e20: af08         	add	r7, sp, #0x20
 8009e22: 6078         	str	r0, [r7, #0x4]
; 	CHECKIF(mutex->owner == NULL) {
 8009e24: 687b         	ldr	r3, [r7, #0x4]
 8009e26: 689b         	ldr	r3, [r3, #0x8]
 8009e28: 2b00         	cmp	r3, #0x0
 8009e2a: d102         	bne	0x8009e32 <z_impl_k_mutex_unlock+0x16> @ imm = #0x4
; 		return -EINVAL;
 8009e2c: f06f 0315    	mvn	r3, #0x15
 8009e30: e0dc         	b	0x8009fec <z_impl_k_mutex_unlock+0x1d0> @ imm = #0x1b8
; 	CHECKIF(mutex->owner != arch_current_thread()) {
 8009e32: 687b         	ldr	r3, [r7, #0x4]
 8009e34: 689a         	ldr	r2, [r3, #0x8]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 8009e36: 4b6f         	ldr	r3, [pc, #0x1bc]        @ 0x8009ff4 <z_impl_k_mutex_unlock+0x1d8>
 8009e38: 689b         	ldr	r3, [r3, #0x8]
 8009e3a: 65bb         	str	r3, [r7, #0x58]
; 	return ret;
 8009e3c: 6dbb         	ldr	r3, [r7, #0x58]
; 	CHECKIF(mutex->owner != arch_current_thread()) {
 8009e3e: 429a         	cmp	r2, r3
 8009e40: d002         	beq	0x8009e48 <z_impl_k_mutex_unlock+0x2c> @ imm = #0x4
; 		return -EPERM;
 8009e42: f04f 33ff    	mov.w	r3, #0xffffffff
 8009e46: e0d1         	b	0x8009fec <z_impl_k_mutex_unlock+0x1d0> @ imm = #0x1a2
; 	LOG_DBG("mutex %p lock_count: %d", mutex, mutex->lock_count);
 8009e48: 2303         	movs	r3, #0x3
 8009e4a: 2b03         	cmp	r3, #0x3
 8009e4c: d91f         	bls	0x8009e8e <z_impl_k_mutex_unlock+0x72> @ imm = #0x3e
 8009e4e: 2301         	movs	r3, #0x1
 8009e50: f887 306f    	strb.w	r3, [r7, #0x6f]
 8009e54: f897 306f    	ldrb.w	r3, [r7, #0x6f]
 8009e58: f083 0301    	eor	r3, r3, #0x1
 8009e5c: b2db         	uxtb	r3, r3
 8009e5e: 2b00         	cmp	r3, #0x0
 8009e60: d115         	bne	0x8009e8e <z_impl_k_mutex_unlock+0x72> @ imm = #0x2a
 8009e62: 4b65         	ldr	r3, [pc, #0x194]        @ 0x8009ff8 <z_impl_k_mutex_unlock+0x1dc>
 8009e64: 6819         	ldr	r1, [r3]
 8009e66: 687b         	ldr	r3, [r7, #0x4]
 8009e68: 68db         	ldr	r3, [r3, #0xc]
 8009e6a: 9305         	str	r3, [sp, #0x14]
 8009e6c: 687b         	ldr	r3, [r7, #0x4]
 8009e6e: 9304         	str	r3, [sp, #0x10]
 8009e70: 4b62         	ldr	r3, [pc, #0x188]        @ 0x8009ffc <z_impl_k_mutex_unlock+0x1e0>
 8009e72: 9303         	str	r3, [sp, #0xc]
 8009e74: 4b62         	ldr	r3, [pc, #0x188]        @ 0x800a000 <z_impl_k_mutex_unlock+0x1e4>
 8009e76: 9302         	str	r3, [sp, #0x8]
 8009e78: 2308         	movs	r3, #0x8
 8009e7a: 9301         	str	r3, [sp, #0x4]
 8009e7c: 2300         	movs	r3, #0x0
 8009e7e: 9300         	str	r3, [sp]
 8009e80: 2300         	movs	r3, #0x0
 8009e82: 2204         	movs	r2, #0x4
 8009e84: 2000         	movs	r0, #0x0
 8009e86: f009 f989    	bl	0x801319c <z_log_msg_runtime_create> @ imm = #0x9312
 8009e8a: 2300         	movs	r3, #0x0
 8009e8c: 66bb         	str	r3, [r7, #0x68]
; 	if (mutex->lock_count > 1U) {
 8009e8e: 687b         	ldr	r3, [r7, #0x4]
 8009e90: 68db         	ldr	r3, [r3, #0xc]
 8009e92: 2b01         	cmp	r3, #0x1
 8009e94: d905         	bls	0x8009ea2 <z_impl_k_mutex_unlock+0x86> @ imm = #0xa
; 		mutex->lock_count--;
 8009e96: 687b         	ldr	r3, [r7, #0x4]
 8009e98: 68db         	ldr	r3, [r3, #0xc]
 8009e9a: 1e5a         	subs	r2, r3, #0x1
 8009e9c: 687b         	ldr	r3, [r7, #0x4]
 8009e9e: 60da         	str	r2, [r3, #0xc]
; 		goto k_mutex_unlock_return;
 8009ea0: e0a3         	b	0x8009fea <z_impl_k_mutex_unlock+0x1ce> @ imm = #0x146
 8009ea2: 4b58         	ldr	r3, [pc, #0x160]        @ 0x800a004 <z_impl_k_mutex_unlock+0x1e8>
 8009ea4: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8009ea6: f3ef 8311    	mrs	r3, basepri
 8009eaa: 63fb         	str	r3, [r7, #0x3c]
;   return(result);
 8009eac: 6bfb         	ldr	r3, [r7, #0x3c]
; 	key = __get_BASEPRI();
 8009eae: 63bb         	str	r3, [r7, #0x38]
 8009eb0: 2310         	movs	r3, #0x10
 8009eb2: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8009eb4: 6b7b         	ldr	r3, [r7, #0x34]
 8009eb6: f383 8812    	msr	basepri_max, r3
; }
 8009eba: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8009ebc: f3bf 8f6f    	isb	sy
; }
 8009ec0: bf00         	nop
; 	return key;
 8009ec2: 6bbb         	ldr	r3, [r7, #0x38]
; 	k.key = arch_irq_lock();
 8009ec4: 60fb         	str	r3, [r7, #0xc]
 8009ec6: 6c3b         	ldr	r3, [r7, #0x40]
 8009ec8: 633b         	str	r3, [r7, #0x30]
; }
 8009eca: bf00         	nop
 8009ecc: 6c3b         	ldr	r3, [r7, #0x40]
 8009ece: 62fb         	str	r3, [r7, #0x2c]
; }
 8009ed0: bf00         	nop
; 	return k;
 8009ed2: 68fb         	ldr	r3, [r7, #0xc]
 8009ed4: 617b         	str	r3, [r7, #0x14]
; 	adjust_owner_prio(mutex, mutex->owner_orig_prio);
 8009ed6: 687b         	ldr	r3, [r7, #0x4]
 8009ed8: 691b         	ldr	r3, [r3, #0x10]
 8009eda: 4619         	mov	r1, r3
 8009edc: 6878         	ldr	r0, [r7, #0x4]
 8009ede: f7ff fcff    	bl	0x80098e0 <adjust_owner_prio> @ imm = #-0x602
; 	new_owner = z_unpend_first_thread(&mutex->wait_q);
 8009ee2: 687b         	ldr	r3, [r7, #0x4]
 8009ee4: 657b         	str	r3, [r7, #0x54]
; 	struct k_thread *thread = NULL;
 8009ee6: 2300         	movs	r3, #0x0
 8009ee8: 653b         	str	r3, [r7, #0x50]
; 		thread = _priq_wait_best(&wait_q->waitq);
 8009eea: 6d7b         	ldr	r3, [r7, #0x54]
 8009eec: 64fb         	str	r3, [r7, #0x4c]
; 	struct k_thread *thread = NULL;
 8009eee: 2300         	movs	r3, #0x0
 8009ef0: 64bb         	str	r3, [r7, #0x48]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 8009ef2: 6cf8         	ldr	r0, [r7, #0x4c]
 8009ef4: f009 f829    	bl	0x8012f4a <sys_dlist_peek_head> @ imm = #0x9052
 8009ef8: 6478         	str	r0, [r7, #0x44]
; 	if (n != NULL) {
 8009efa: 6c7b         	ldr	r3, [r7, #0x44]
 8009efc: 2b00         	cmp	r3, #0x0
 8009efe: d001         	beq	0x8009f04 <z_impl_k_mutex_unlock+0xe8> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 8009f00: 6c7b         	ldr	r3, [r7, #0x44]
 8009f02: 64bb         	str	r3, [r7, #0x48]
; 	return thread;
 8009f04: 6cbb         	ldr	r3, [r7, #0x48]
; 		thread = _priq_wait_best(&wait_q->waitq);
 8009f06: 653b         	str	r3, [r7, #0x50]
; 		if (unlikely(thread != NULL)) {
 8009f08: 6d3b         	ldr	r3, [r7, #0x50]
 8009f0a: 2b00         	cmp	r3, #0x0
 8009f0c: bf14         	ite	ne
 8009f0e: 2301         	movne	r3, #0x1
 8009f10: 2300         	moveq	r3, #0x0
 8009f12: b2db         	uxtb	r3, r3
 8009f14: 2b00         	cmp	r3, #0x0
 8009f16: d005         	beq	0x8009f24 <z_impl_k_mutex_unlock+0x108> @ imm = #0xa
; 			unpend_thread_no_timeout(thread);
 8009f18: 6d38         	ldr	r0, [r7, #0x50]
 8009f1a: f009 f90c    	bl	0x8013136 <unpend_thread_no_timeout> @ imm = #0x9218
; 			(void)z_abort_thread_timeout(thread);
 8009f1e: 6d38         	ldr	r0, [r7, #0x50]
 8009f20: f009 f85d    	bl	0x8012fde <z_abort_thread_timeout> @ imm = #0x90ba
; 	return thread;
 8009f24: 6d3b         	ldr	r3, [r7, #0x50]
; 	new_owner = z_unpend_first_thread(&mutex->wait_q);
 8009f26: 667b         	str	r3, [r7, #0x64]
; 	mutex->owner = new_owner;
 8009f28: 687b         	ldr	r3, [r7, #0x4]
 8009f2a: 6e7a         	ldr	r2, [r7, #0x64]
 8009f2c: 609a         	str	r2, [r3, #0x8]
; 	LOG_DBG("new owner of mutex %p: %p (prio: %d)",
 8009f2e: 2303         	movs	r3, #0x3
 8009f30: 2b03         	cmp	r3, #0x3
 8009f32: d927         	bls	0x8009f84 <z_impl_k_mutex_unlock+0x168> @ imm = #0x4e
 8009f34: 2301         	movs	r3, #0x1
 8009f36: f887 3063    	strb.w	r3, [r7, #0x63]
 8009f3a: f897 3063    	ldrb.w	r3, [r7, #0x63]
 8009f3e: f083 0301    	eor	r3, r3, #0x1
 8009f42: b2db         	uxtb	r3, r3
 8009f44: 2b00         	cmp	r3, #0x0
 8009f46: d11d         	bne	0x8009f84 <z_impl_k_mutex_unlock+0x168> @ imm = #0x3a
 8009f48: 4b2b         	ldr	r3, [pc, #0xac]         @ 0x8009ff8 <z_impl_k_mutex_unlock+0x1dc>
 8009f4a: 6819         	ldr	r1, [r3]
 8009f4c: 6e7b         	ldr	r3, [r7, #0x64]
 8009f4e: 2b00         	cmp	r3, #0x0
 8009f50: d003         	beq	0x8009f5a <z_impl_k_mutex_unlock+0x13e> @ imm = #0x6
 8009f52: 6e7b         	ldr	r3, [r7, #0x64]
 8009f54: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 8009f58: e000         	b	0x8009f5c <z_impl_k_mutex_unlock+0x140> @ imm = #0x0
 8009f5a: 4b2b         	ldr	r3, [pc, #0xac]         @ 0x800a008 <z_impl_k_mutex_unlock+0x1ec>
 8009f5c: 9306         	str	r3, [sp, #0x18]
 8009f5e: 6e7b         	ldr	r3, [r7, #0x64]
 8009f60: 9305         	str	r3, [sp, #0x14]
 8009f62: 687b         	ldr	r3, [r7, #0x4]
 8009f64: 9304         	str	r3, [sp, #0x10]
 8009f66: 4b25         	ldr	r3, [pc, #0x94]         @ 0x8009ffc <z_impl_k_mutex_unlock+0x1e0>
 8009f68: 9303         	str	r3, [sp, #0xc]
 8009f6a: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x800a00c <z_impl_k_mutex_unlock+0x1f0>
 8009f6c: 9302         	str	r3, [sp, #0x8]
 8009f6e: 2308         	movs	r3, #0x8
 8009f70: 9301         	str	r3, [sp, #0x4]
 8009f72: 2300         	movs	r3, #0x0
 8009f74: 9300         	str	r3, [sp]
 8009f76: 2300         	movs	r3, #0x0
 8009f78: 2204         	movs	r2, #0x4
 8009f7a: 2000         	movs	r0, #0x0
 8009f7c: f009 f90e    	bl	0x801319c <z_log_msg_runtime_create> @ imm = #0x921c
 8009f80: 2300         	movs	r3, #0x0
 8009f82: 65fb         	str	r3, [r7, #0x5c]
; 	if (unlikely(new_owner != NULL)) {
 8009f84: 6e7b         	ldr	r3, [r7, #0x64]
 8009f86: 2b00         	cmp	r3, #0x0
 8009f88: bf14         	ite	ne
 8009f8a: 2301         	movne	r3, #0x1
 8009f8c: 2300         	moveq	r3, #0x0
 8009f8e: b2db         	uxtb	r3, r3
 8009f90: 2b00         	cmp	r3, #0x0
 8009f92: d016         	beq	0x8009fc2 <z_impl_k_mutex_unlock+0x1a6> @ imm = #0x2c
; 		mutex->owner_orig_prio = new_owner->base.prio;
 8009f94: 6e7b         	ldr	r3, [r7, #0x64]
 8009f96: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 8009f9a: 461a         	mov	r2, r3
 8009f9c: 687b         	ldr	r3, [r7, #0x4]
 8009f9e: 611a         	str	r2, [r3, #0x10]
 8009fa0: 6e7b         	ldr	r3, [r7, #0x64]
 8009fa2: 62bb         	str	r3, [r7, #0x28]
 8009fa4: 2300         	movs	r3, #0x0
 8009fa6: 627b         	str	r3, [r7, #0x24]
; 	thread->arch.swap_return_value = value;
 8009fa8: 6abb         	ldr	r3, [r7, #0x28]
 8009faa: 6a7a         	ldr	r2, [r7, #0x24]
 8009fac: f8c3 20cc    	str.w	r2, [r3, #0xcc]
; }
 8009fb0: bf00         	nop
; 		z_ready_thread(new_owner);
 8009fb2: 6e78         	ldr	r0, [r7, #0x64]
 8009fb4: f000 fc66    	bl	0x800a884 <z_ready_thread> @ imm = #0x8cc
; 		z_reschedule(&lock, key);
 8009fb8: 6979         	ldr	r1, [r7, #0x14]
 8009fba: 4812         	ldr	r0, [pc, #0x48]         @ 0x800a004 <z_impl_k_mutex_unlock+0x1e8>
 8009fbc: f009 fe1e    	bl	0x8013bfc <z_reschedule> @ imm = #0x9c3c
 8009fc0: e013         	b	0x8009fea <z_impl_k_mutex_unlock+0x1ce> @ imm = #0x26
; 		mutex->lock_count = 0U;
 8009fc2: 687b         	ldr	r3, [r7, #0x4]
 8009fc4: 2200         	movs	r2, #0x0
 8009fc6: 60da         	str	r2, [r3, #0xc]
 8009fc8: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800a004 <z_impl_k_mutex_unlock+0x1e8>
 8009fca: 623b         	str	r3, [r7, #0x20]
 8009fcc: 697b         	ldr	r3, [r7, #0x14]
 8009fce: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 8009fd0: 693b         	ldr	r3, [r7, #0x10]
 8009fd2: 61fb         	str	r3, [r7, #0x1c]
 8009fd4: 69fb         	ldr	r3, [r7, #0x1c]
 8009fd6: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8009fd8: 69bb         	ldr	r3, [r7, #0x18]
 8009fda: f383 8811    	msr	basepri, r3
; }
 8009fde: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8009fe0: f3bf 8f6f    	isb	sy
; }
 8009fe4: bf00         	nop
; }
 8009fe6: bf00         	nop
; }
 8009fe8: bf00         	nop
; 	return 0;
 8009fea: 2300         	movs	r3, #0x0
; }
 8009fec: 4618         	mov	r0, r3
 8009fee: 3770         	adds	r7, #0x70
 8009ff0: 46bd         	mov	sp, r7
 8009ff2: bd80         	pop	{r7, pc}

08009ff4 <$d>:
 8009ff4: c0 02 00 20  	.word	0x200002c0
 8009ff8: 14 01 00 20  	.word	0x20000114
 8009ffc: c0 67 01 08  	.word	0x080167c0
 800a000: 40 5e 01 08  	.word	0x08015e40
 800a004: e0 09 00 20  	.word	0x200009e0
 800a008: 18 fc ff ff  	.word	0xfffffc18
 800a00c: 5c 5e 01 08  	.word	0x08015e5c

0800a010 <z_impl_k_sem_give>:
; {
 800a010: b580         	push	{r7, lr}
 800a012: b098         	sub	sp, #0x60
 800a014: af00         	add	r7, sp, #0x0
 800a016: 6078         	str	r0, [r7, #0x4]
 800a018: 4b43         	ldr	r3, [pc, #0x10c]        @ 0x800a128 <z_impl_k_sem_give+0x118>
 800a01a: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800a01c: f3ef 8311    	mrs	r3, basepri
 800a020: 63fb         	str	r3, [r7, #0x3c]
;   return(result);
 800a022: 6bfb         	ldr	r3, [r7, #0x3c]
; 	key = __get_BASEPRI();
 800a024: 63bb         	str	r3, [r7, #0x38]
 800a026: 2310         	movs	r3, #0x10
 800a028: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800a02a: 6b7b         	ldr	r3, [r7, #0x34]
 800a02c: f383 8812    	msr	basepri_max, r3
; }
 800a030: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800a032: f3bf 8f6f    	isb	sy
; }
 800a036: bf00         	nop
; 	return key;
 800a038: 6bbb         	ldr	r3, [r7, #0x38]
; 	k.key = arch_irq_lock();
 800a03a: 60fb         	str	r3, [r7, #0xc]
 800a03c: 6c3b         	ldr	r3, [r7, #0x40]
 800a03e: 633b         	str	r3, [r7, #0x30]
; }
 800a040: bf00         	nop
 800a042: 6c3b         	ldr	r3, [r7, #0x40]
 800a044: 62fb         	str	r3, [r7, #0x2c]
; }
 800a046: bf00         	nop
; 	return k;
 800a048: 68fb         	ldr	r3, [r7, #0xc]
 800a04a: 617b         	str	r3, [r7, #0x14]
; 	bool resched = true;
 800a04c: 2301         	movs	r3, #0x1
 800a04e: f887 305f    	strb.w	r3, [r7, #0x5f]
; 	thread = z_unpend_first_thread(&sem->wait_q);
 800a052: 687b         	ldr	r3, [r7, #0x4]
 800a054: 657b         	str	r3, [r7, #0x54]
; 	struct k_thread *thread = NULL;
 800a056: 2300         	movs	r3, #0x0
 800a058: 653b         	str	r3, [r7, #0x50]
; 		thread = _priq_wait_best(&wait_q->waitq);
 800a05a: 6d7b         	ldr	r3, [r7, #0x54]
 800a05c: 64fb         	str	r3, [r7, #0x4c]
; 	struct k_thread *thread = NULL;
 800a05e: 2300         	movs	r3, #0x0
 800a060: 64bb         	str	r3, [r7, #0x48]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 800a062: 6cf8         	ldr	r0, [r7, #0x4c]
 800a064: f009 f916    	bl	0x8013294 <sys_dlist_peek_head> @ imm = #0x922c
 800a068: 6478         	str	r0, [r7, #0x44]
; 	if (n != NULL) {
 800a06a: 6c7b         	ldr	r3, [r7, #0x44]
 800a06c: 2b00         	cmp	r3, #0x0
 800a06e: d001         	beq	0x800a074 <z_impl_k_sem_give+0x64> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 800a070: 6c7b         	ldr	r3, [r7, #0x44]
 800a072: 64bb         	str	r3, [r7, #0x48]
; 	return thread;
 800a074: 6cbb         	ldr	r3, [r7, #0x48]
; 		thread = _priq_wait_best(&wait_q->waitq);
 800a076: 653b         	str	r3, [r7, #0x50]
; 		if (unlikely(thread != NULL)) {
 800a078: 6d3b         	ldr	r3, [r7, #0x50]
 800a07a: 2b00         	cmp	r3, #0x0
 800a07c: bf14         	ite	ne
 800a07e: 2301         	movne	r3, #0x1
 800a080: 2300         	moveq	r3, #0x0
 800a082: b2db         	uxtb	r3, r3
 800a084: 2b00         	cmp	r3, #0x0
 800a086: d005         	beq	0x800a094 <z_impl_k_sem_give+0x84> @ imm = #0xa
; 			unpend_thread_no_timeout(thread);
 800a088: 6d38         	ldr	r0, [r7, #0x50]
 800a08a: f009 f95f    	bl	0x801334c <unpend_thread_no_timeout> @ imm = #0x92be
; 			(void)z_abort_thread_timeout(thread);
 800a08e: 6d38         	ldr	r0, [r7, #0x50]
 800a090: f009 f932    	bl	0x80132f8 <z_abort_thread_timeout> @ imm = #0x9264
; 	return thread;
 800a094: 6d3b         	ldr	r3, [r7, #0x50]
; 	thread = z_unpend_first_thread(&sem->wait_q);
 800a096: 65bb         	str	r3, [r7, #0x58]
; 	if (unlikely(thread != NULL)) {
 800a098: 6dbb         	ldr	r3, [r7, #0x58]
 800a09a: 2b00         	cmp	r3, #0x0
 800a09c: bf14         	ite	ne
 800a09e: 2301         	movne	r3, #0x1
 800a0a0: 2300         	moveq	r3, #0x0
 800a0a2: b2db         	uxtb	r3, r3
 800a0a4: 2b00         	cmp	r3, #0x0
 800a0a6: d00c         	beq	0x800a0c2 <z_impl_k_sem_give+0xb2> @ imm = #0x18
 800a0a8: 6dbb         	ldr	r3, [r7, #0x58]
 800a0aa: 62bb         	str	r3, [r7, #0x28]
 800a0ac: 2300         	movs	r3, #0x0
 800a0ae: 627b         	str	r3, [r7, #0x24]
; 	thread->arch.swap_return_value = value;
 800a0b0: 6abb         	ldr	r3, [r7, #0x28]
 800a0b2: 6a7a         	ldr	r2, [r7, #0x24]
 800a0b4: f8c3 20cc    	str.w	r2, [r3, #0xcc]
; }
 800a0b8: bf00         	nop
; 		z_ready_thread(thread);
 800a0ba: 6db8         	ldr	r0, [r7, #0x58]
 800a0bc: f000 fbe2    	bl	0x800a884 <z_ready_thread> @ imm = #0x7c4
 800a0c0: e013         	b	0x800a0ea <z_impl_k_sem_give+0xda> @ imm = #0x26
; 		sem->count += (sem->count != sem->limit) ? 1U : 0U;
 800a0c2: 687b         	ldr	r3, [r7, #0x4]
 800a0c4: 689b         	ldr	r3, [r3, #0x8]
 800a0c6: 687a         	ldr	r2, [r7, #0x4]
 800a0c8: 6891         	ldr	r1, [r2, #0x8]
 800a0ca: 687a         	ldr	r2, [r7, #0x4]
 800a0cc: 68d2         	ldr	r2, [r2, #0xc]
 800a0ce: 4291         	cmp	r1, r2
 800a0d0: d001         	beq	0x800a0d6 <z_impl_k_sem_give+0xc6> @ imm = #0x2
 800a0d2: 2201         	movs	r2, #0x1
 800a0d4: e000         	b	0x800a0d8 <z_impl_k_sem_give+0xc8> @ imm = #0x0
 800a0d6: 2200         	movs	r2, #0x0
 800a0d8: 441a         	add	r2, r3
 800a0da: 687b         	ldr	r3, [r7, #0x4]
 800a0dc: 609a         	str	r2, [r3, #0x8]
; 		resched = handle_poll_events(sem);
 800a0de: 6878         	ldr	r0, [r7, #0x4]
 800a0e0: f009 f970    	bl	0x80133c4 <handle_poll_events> @ imm = #0x92e0
 800a0e4: 4603         	mov	r3, r0
 800a0e6: f887 305f    	strb.w	r3, [r7, #0x5f]
; 	if (unlikely(resched)) {
 800a0ea: f897 305f    	ldrb.w	r3, [r7, #0x5f]
 800a0ee: 2b00         	cmp	r3, #0x0
 800a0f0: d004         	beq	0x800a0fc <z_impl_k_sem_give+0xec> @ imm = #0x8
; 		z_reschedule(&lock, key);
 800a0f2: 6979         	ldr	r1, [r7, #0x14]
 800a0f4: 480c         	ldr	r0, [pc, #0x30]         @ 0x800a128 <z_impl_k_sem_give+0x118>
 800a0f6: f009 fd81    	bl	0x8013bfc <z_reschedule> @ imm = #0x9b02
; }
 800a0fa: e010         	b	0x800a11e <z_impl_k_sem_give+0x10e> @ imm = #0x20
 800a0fc: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800a128 <z_impl_k_sem_give+0x118>
 800a0fe: 623b         	str	r3, [r7, #0x20]
 800a100: 697b         	ldr	r3, [r7, #0x14]
 800a102: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 800a104: 693b         	ldr	r3, [r7, #0x10]
 800a106: 61fb         	str	r3, [r7, #0x1c]
 800a108: 69fb         	ldr	r3, [r7, #0x1c]
 800a10a: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800a10c: 69bb         	ldr	r3, [r7, #0x18]
 800a10e: f383 8811    	msr	basepri, r3
; }
 800a112: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800a114: f3bf 8f6f    	isb	sy
; }
 800a118: bf00         	nop
; }
 800a11a: bf00         	nop
; }
 800a11c: bf00         	nop
; }
 800a11e: bf00         	nop
 800a120: 3760         	adds	r7, #0x60
 800a122: 46bd         	mov	sp, r7
 800a124: bd80         	pop	{r7, pc}
 800a126: bf00         	nop

0800a128 <$d>:
 800a128: e0 09 00 20  	.word	0x200009e0

0800a12c <z_impl_k_sem_take>:
; {
 800a12c: b580         	push	{r7, lr}
 800a12e: b098         	sub	sp, #0x60
 800a130: af02         	add	r7, sp, #0x8
 800a132: 60f8         	str	r0, [r7, #0xc]
 800a134: e9c7 2300    	strd	r2, r3, [r7]
 800a138: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x800a210 <z_impl_k_sem_take+0xe4>
 800a13a: 653b         	str	r3, [r7, #0x50]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800a13c: f3ef 8311    	mrs	r3, basepri
 800a140: 64fb         	str	r3, [r7, #0x4c]
;   return(result);
 800a142: 6cfb         	ldr	r3, [r7, #0x4c]
; 	key = __get_BASEPRI();
 800a144: 64bb         	str	r3, [r7, #0x48]
 800a146: 2310         	movs	r3, #0x10
 800a148: 647b         	str	r3, [r7, #0x44]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800a14a: 6c7b         	ldr	r3, [r7, #0x44]
 800a14c: f383 8812    	msr	basepri_max, r3
; }
 800a150: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800a152: f3bf 8f6f    	isb	sy
; }
 800a156: bf00         	nop
; 	return key;
 800a158: 6cbb         	ldr	r3, [r7, #0x48]
; 	k.key = arch_irq_lock();
 800a15a: 61bb         	str	r3, [r7, #0x18]
 800a15c: 6d3b         	ldr	r3, [r7, #0x50]
 800a15e: 643b         	str	r3, [r7, #0x40]
; }
 800a160: bf00         	nop
 800a162: 6d3b         	ldr	r3, [r7, #0x50]
 800a164: 63fb         	str	r3, [r7, #0x3c]
; }
 800a166: bf00         	nop
; 	return k;
 800a168: 69bb         	ldr	r3, [r7, #0x18]
 800a16a: 623b         	str	r3, [r7, #0x20]
; 	if (likely(sem->count > 0U)) {
 800a16c: 68fb         	ldr	r3, [r7, #0xc]
 800a16e: 689b         	ldr	r3, [r3, #0x8]
 800a170: 2b00         	cmp	r3, #0x0
 800a172: bf14         	ite	ne
 800a174: 2301         	movne	r3, #0x1
 800a176: 2300         	moveq	r3, #0x0
 800a178: b2db         	uxtb	r3, r3
 800a17a: 2b00         	cmp	r3, #0x0
 800a17c: d018         	beq	0x800a1b0 <z_impl_k_sem_take+0x84> @ imm = #0x30
; 		sem->count--;
 800a17e: 68fb         	ldr	r3, [r7, #0xc]
 800a180: 689b         	ldr	r3, [r3, #0x8]
 800a182: 1e5a         	subs	r2, r3, #0x1
 800a184: 68fb         	ldr	r3, [r7, #0xc]
 800a186: 609a         	str	r2, [r3, #0x8]
 800a188: 4b21         	ldr	r3, [pc, #0x84]         @ 0x800a210 <z_impl_k_sem_take+0xe4>
 800a18a: 63bb         	str	r3, [r7, #0x38]
 800a18c: 6a3b         	ldr	r3, [r7, #0x20]
 800a18e: 61fb         	str	r3, [r7, #0x1c]
; 	arch_irq_unlock(key.key);
 800a190: 69fb         	ldr	r3, [r7, #0x1c]
 800a192: 637b         	str	r3, [r7, #0x34]
 800a194: 6b7b         	ldr	r3, [r7, #0x34]
 800a196: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800a198: 6b3b         	ldr	r3, [r7, #0x30]
 800a19a: f383 8811    	msr	basepri, r3
; }
 800a19e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800a1a0: f3bf 8f6f    	isb	sy
; }
 800a1a4: bf00         	nop
; }
 800a1a6: bf00         	nop
; }
 800a1a8: bf00         	nop
; 		ret = 0;
 800a1aa: 2300         	movs	r3, #0x0
 800a1ac: 657b         	str	r3, [r7, #0x54]
; 		goto out;
 800a1ae: e029         	b	0x800a204 <z_impl_k_sem_take+0xd8> @ imm = #0x52
; 	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
 800a1b0: e9d7 2300    	ldrd	r2, r3, [r7]
 800a1b4: f04f 0000    	mov.w	r0, #0x0
 800a1b8: f04f 0100    	mov.w	r1, #0x0
 800a1bc: 428b         	cmp	r3, r1
 800a1be: bf08         	it	eq
 800a1c0: 4282         	cmpeq	r2, r0
 800a1c2: d114         	bne	0x800a1ee <z_impl_k_sem_take+0xc2> @ imm = #0x28
 800a1c4: 4b12         	ldr	r3, [pc, #0x48]         @ 0x800a210 <z_impl_k_sem_take+0xe4>
 800a1c6: 62fb         	str	r3, [r7, #0x2c]
 800a1c8: 6a3b         	ldr	r3, [r7, #0x20]
 800a1ca: 617b         	str	r3, [r7, #0x14]
; 	arch_irq_unlock(key.key);
 800a1cc: 697b         	ldr	r3, [r7, #0x14]
 800a1ce: 62bb         	str	r3, [r7, #0x28]
 800a1d0: 6abb         	ldr	r3, [r7, #0x28]
 800a1d2: 627b         	str	r3, [r7, #0x24]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800a1d4: 6a7b         	ldr	r3, [r7, #0x24]
 800a1d6: f383 8811    	msr	basepri, r3
; }
 800a1da: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800a1dc: f3bf 8f6f    	isb	sy
; }
 800a1e0: bf00         	nop
; }
 800a1e2: bf00         	nop
; }
 800a1e4: bf00         	nop
; 		ret = -EBUSY;
 800a1e6: f06f 030f    	mvn	r3, #0xf
 800a1ea: 657b         	str	r3, [r7, #0x54]
 800a1ec: e00a         	b	0x800a204 <z_impl_k_sem_take+0xd8> @ imm = #0x14
; 	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
 800a1ee: 68f9         	ldr	r1, [r7, #0xc]
 800a1f0: e9d7 2300    	ldrd	r2, r3, [r7]
 800a1f4: e9cd 2300    	strd	r2, r3, [sp]
 800a1f8: 460a         	mov	r2, r1
 800a1fa: 6a39         	ldr	r1, [r7, #0x20]
 800a1fc: 4804         	ldr	r0, [pc, #0x10]         @ 0x800a210 <z_impl_k_sem_take+0xe4>
 800a1fe: f000 fefd    	bl	0x800affc <z_pend_curr> @ imm = #0xdfa
 800a202: 6578         	str	r0, [r7, #0x54]
; 	return ret;
 800a204: 6d7b         	ldr	r3, [r7, #0x54]
; }
 800a206: 4618         	mov	r0, r3
 800a208: 3758         	adds	r7, #0x58
 800a20a: 46bd         	mov	sp, r7
 800a20c: bd80         	pop	{r7, pc}
 800a20e: bf00         	nop

0800a210 <$d>:
 800a210: e0 09 00 20  	.word	0x200009e0

0800a214 <setup_thread_stack>:
; {
 800a214: b580         	push	{r7, lr}
 800a216: b096         	sub	sp, #0x58
 800a218: af0a         	add	r7, sp, #0x28
 800a21a: 60f8         	str	r0, [r7, #0xc]
 800a21c: 60b9         	str	r1, [r7, #0x8]
 800a21e: 607a         	str	r2, [r7, #0x4]
; 	size_t delta = 0;
 800a220: 2300         	movs	r3, #0x0
 800a222: 62fb         	str	r3, [r7, #0x2c]
; 		stack_obj_size = K_KERNEL_STACK_LEN(stack_size);
 800a224: 687b         	ldr	r3, [r7, #0x4]
 800a226: 3307         	adds	r3, #0x7
 800a228: f023 0307    	bic	r3, r3, #0x7
 800a22c: 3307         	adds	r3, #0x7
 800a22e: f023 0307    	bic	r3, r3, #0x7
 800a232: 62bb         	str	r3, [r7, #0x28]
; 		stack_buf_start = K_KERNEL_STACK_BUFFER(stack);
 800a234: 68b8         	ldr	r0, [r7, #0x8]
 800a236: f009 f8ed    	bl	0x8013414 <K_KERNEL_STACK_BUFFER> @ imm = #0x91da
 800a23a: 6278         	str	r0, [r7, #0x24]
; 		stack_buf_size = stack_obj_size - K_KERNEL_STACK_RESERVED;
 800a23c: 6abb         	ldr	r3, [r7, #0x28]
 800a23e: 623b         	str	r3, [r7, #0x20]
; 	stack_ptr = (char *)stack + stack_obj_size;
 800a240: 68ba         	ldr	r2, [r7, #0x8]
 800a242: 6abb         	ldr	r3, [r7, #0x28]
 800a244: 4413         	add	r3, r2
 800a246: 61fb         	str	r3, [r7, #0x1c]
; 	LOG_DBG("stack %p for thread %p: obj_size=%zu buf_start=%p "
 800a248: 2303         	movs	r3, #0x3
 800a24a: 2b03         	cmp	r3, #0x3
 800a24c: d924         	bls	0x800a298 <setup_thread_stack+0x84> @ imm = #0x48
 800a24e: 2301         	movs	r3, #0x1
 800a250: 76fb         	strb	r3, [r7, #0x1b]
 800a252: 7efb         	ldrb	r3, [r7, #0x1b]
 800a254: f083 0301    	eor	r3, r3, #0x1
 800a258: b2db         	uxtb	r3, r3
 800a25a: 2b00         	cmp	r3, #0x0
 800a25c: d11c         	bne	0x800a298 <setup_thread_stack+0x84> @ imm = #0x38
 800a25e: 4b22         	ldr	r3, [pc, #0x88]         @ 0x800a2e8 <setup_thread_stack+0xd4>
 800a260: 6819         	ldr	r1, [r3]
 800a262: 69fb         	ldr	r3, [r7, #0x1c]
 800a264: 9309         	str	r3, [sp, #0x24]
 800a266: 6a3b         	ldr	r3, [r7, #0x20]
 800a268: 9308         	str	r3, [sp, #0x20]
 800a26a: 6a7b         	ldr	r3, [r7, #0x24]
 800a26c: 9307         	str	r3, [sp, #0x1c]
 800a26e: 6abb         	ldr	r3, [r7, #0x28]
 800a270: 9306         	str	r3, [sp, #0x18]
 800a272: 68fb         	ldr	r3, [r7, #0xc]
 800a274: 9305         	str	r3, [sp, #0x14]
 800a276: 68bb         	ldr	r3, [r7, #0x8]
 800a278: 9304         	str	r3, [sp, #0x10]
 800a27a: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x800a2ec <setup_thread_stack+0xd8>
 800a27c: 9303         	str	r3, [sp, #0xc]
 800a27e: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x800a2f0 <setup_thread_stack+0xdc>
 800a280: 9302         	str	r3, [sp, #0x8]
 800a282: 2308         	movs	r3, #0x8
 800a284: 9301         	str	r3, [sp, #0x4]
 800a286: 2300         	movs	r3, #0x0
 800a288: 9300         	str	r3, [sp]
 800a28a: 2300         	movs	r3, #0x0
 800a28c: 2204         	movs	r2, #0x4
 800a28e: 2000         	movs	r0, #0x0
 800a290: f009 f8ef    	bl	0x8013472 <z_log_msg_runtime_create> @ imm = #0x91de
 800a294: 2300         	movs	r3, #0x0
 800a296: 617b         	str	r3, [r7, #0x14]
; 	memset(stack_buf_start, 0xaa, stack_buf_size);
 800a298: 6a3a         	ldr	r2, [r7, #0x20]
 800a29a: 21aa         	movs	r1, #0xaa
 800a29c: 6a78         	ldr	r0, [r7, #0x24]
 800a29e: f009 ff3d    	bl	0x801411c <memset>      @ imm = #0x9e7a
; 	delta += arch_tls_stack_setup(new_thread, stack_ptr);
 800a2a2: 69f9         	ldr	r1, [r7, #0x1c]
 800a2a4: 68f8         	ldr	r0, [r7, #0xc]
 800a2a6: f004 fd95    	bl	0x800edd4 <arch_tls_stack_setup> @ imm = #0x4b2a
 800a2aa: 4602         	mov	r2, r0
 800a2ac: 6afb         	ldr	r3, [r7, #0x2c]
 800a2ae: 4413         	add	r3, r2
 800a2b0: 62fb         	str	r3, [r7, #0x2c]
; 	delta = ROUND_UP(delta, ARCH_STACK_PTR_ALIGN);
 800a2b2: 6afb         	ldr	r3, [r7, #0x2c]
 800a2b4: 3307         	adds	r3, #0x7
 800a2b6: f023 0307    	bic	r3, r3, #0x7
 800a2ba: 62fb         	str	r3, [r7, #0x2c]
; 	new_thread->stack_info.start = (uintptr_t)stack_buf_start;
 800a2bc: 6a7a         	ldr	r2, [r7, #0x24]
 800a2be: 68fb         	ldr	r3, [r7, #0xc]
 800a2c0: f8c3 20b4    	str.w	r2, [r3, #0xb4]
; 	new_thread->stack_info.size = stack_buf_size;
 800a2c4: 68fb         	ldr	r3, [r7, #0xc]
 800a2c6: 6a3a         	ldr	r2, [r7, #0x20]
 800a2c8: f8c3 20b8    	str.w	r2, [r3, #0xb8]
; 	new_thread->stack_info.delta = delta;
 800a2cc: 68fb         	ldr	r3, [r7, #0xc]
 800a2ce: 6afa         	ldr	r2, [r7, #0x2c]
 800a2d0: f8c3 20bc    	str.w	r2, [r3, #0xbc]
; 	stack_ptr -= delta;
 800a2d4: 6afb         	ldr	r3, [r7, #0x2c]
 800a2d6: 425b         	rsbs	r3, r3, #0
 800a2d8: 69fa         	ldr	r2, [r7, #0x1c]
 800a2da: 4413         	add	r3, r2
 800a2dc: 61fb         	str	r3, [r7, #0x1c]
; 	return stack_ptr;
 800a2de: 69fb         	ldr	r3, [r7, #0x1c]
; }
 800a2e0: 4618         	mov	r0, r3
 800a2e2: 3730         	adds	r7, #0x30
 800a2e4: 46bd         	mov	sp, r7
 800a2e6: bd80         	pop	{r7, pc}

0800a2e8 <$d>:
 800a2e8: 18 01 00 20  	.word	0x20000118
 800a2ec: d8 67 01 08  	.word	0x080167d8
 800a2f0: 90 5e 01 08  	.word	0x08015e90

0800a2f4 <z_setup_new_thread>:
; {
 800a2f4: b580         	push	{r7, lr}
 800a2f6: b09c         	sub	sp, #0x70
 800a2f8: af04         	add	r7, sp, #0x10
 800a2fa: 60f8         	str	r0, [r7, #0xc]
 800a2fc: 60b9         	str	r1, [r7, #0x8]
 800a2fe: 607a         	str	r2, [r7, #0x4]
 800a300: 603b         	str	r3, [r7]
; 	z_waitq_init(&new_thread->join_queue);
 800a302: 68fb         	ldr	r3, [r7, #0xc]
 800a304: 3368         	adds	r3, #0x68
 800a306: 4618         	mov	r0, r3
 800a308: f009 f8a7    	bl	0x801345a <z_waitq_init> @ imm = #0x914e
; 	z_init_thread_base(&new_thread->base, prio, _THREAD_SUSPENDED, options);
 800a30c: 68f8         	ldr	r0, [r7, #0xc]
 800a30e: 6fbb         	ldr	r3, [r7, #0x78]
 800a310: 2210         	movs	r2, #0x10
 800a312: 6f79         	ldr	r1, [r7, #0x74]
 800a314: f009 f8d6    	bl	0x80134c4 <z_init_thread_base> @ imm = #0x91ac
; 	stack_ptr = setup_thread_stack(new_thread, stack, stack_size);
 800a318: 687a         	ldr	r2, [r7, #0x4]
 800a31a: 68b9         	ldr	r1, [r7, #0x8]
 800a31c: 68f8         	ldr	r0, [r7, #0xc]
 800a31e: f7ff ff79    	bl	0x800a214 <setup_thread_stack> @ imm = #-0x10e
 800a322: 65f8         	str	r0, [r7, #0x5c]
; 	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
 800a324: 6f3b         	ldr	r3, [r7, #0x70]
 800a326: 9302         	str	r3, [sp, #0x8]
 800a328: 6efb         	ldr	r3, [r7, #0x6c]
 800a32a: 9301         	str	r3, [sp, #0x4]
 800a32c: 6ebb         	ldr	r3, [r7, #0x68]
 800a32e: 9300         	str	r3, [sp]
 800a330: 683b         	ldr	r3, [r7]
 800a332: 6dfa         	ldr	r2, [r7, #0x5c]
 800a334: 68b9         	ldr	r1, [r7, #0x8]
 800a336: 68f8         	ldr	r0, [r7, #0xc]
 800a338: f7f8 ff4e    	bl	0x80031d8 <arch_new_thread> @ imm = #-0x7164
; 	new_thread->init_data = NULL;
 800a33c: 68fb         	ldr	r3, [r7, #0xc]
 800a33e: 2200         	movs	r2, #0x0
 800a340: 665a         	str	r2, [r3, #0x64]
; 	new_thread->no_wake_on_timeout = false;
 800a342: 68fb         	ldr	r3, [r7, #0xc]
 800a344: 2200         	movs	r2, #0x0
 800a346: f883 207c    	strb.w	r2, [r3, #0x7c]
; 	new_thread->entry.pEntry = entry;
 800a34a: 68fb         	ldr	r3, [r7, #0xc]
 800a34c: 683a         	ldr	r2, [r7]
 800a34e: f8c3 2080    	str.w	r2, [r3, #0x80]
; 	new_thread->entry.parameter1 = p1;
 800a352: 68fb         	ldr	r3, [r7, #0xc]
 800a354: 6eba         	ldr	r2, [r7, #0x68]
 800a356: f8c3 2084    	str.w	r2, [r3, #0x84]
; 	new_thread->entry.parameter2 = p2;
 800a35a: 68fb         	ldr	r3, [r7, #0xc]
 800a35c: 6efa         	ldr	r2, [r7, #0x6c]
 800a35e: f8c3 2088    	str.w	r2, [r3, #0x88]
; 	new_thread->entry.parameter3 = p3;
 800a362: 68fb         	ldr	r3, [r7, #0xc]
 800a364: 6f3a         	ldr	r2, [r7, #0x70]
 800a366: f8c3 208c    	str.w	r2, [r3, #0x8c]
 800a36a: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x800a440 <z_setup_new_thread+0x14c>
 800a36c: 64fb         	str	r3, [r7, #0x4c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800a36e: f3ef 8311    	mrs	r3, basepri
 800a372: 64bb         	str	r3, [r7, #0x48]
;   return(result);
 800a374: 6cbb         	ldr	r3, [r7, #0x48]
; 	key = __get_BASEPRI();
 800a376: 647b         	str	r3, [r7, #0x44]
 800a378: 2310         	movs	r3, #0x10
 800a37a: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800a37c: 6c3b         	ldr	r3, [r7, #0x40]
 800a37e: f383 8812    	msr	basepri_max, r3
; }
 800a382: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800a384: f3bf 8f6f    	isb	sy
; }
 800a388: bf00         	nop
; 	return key;
 800a38a: 6c7b         	ldr	r3, [r7, #0x44]
; 	k.key = arch_irq_lock();
 800a38c: 617b         	str	r3, [r7, #0x14]
 800a38e: 6cfb         	ldr	r3, [r7, #0x4c]
 800a390: 63fb         	str	r3, [r7, #0x3c]
; }
 800a392: bf00         	nop
 800a394: 6cfb         	ldr	r3, [r7, #0x4c]
 800a396: 63bb         	str	r3, [r7, #0x38]
; }
 800a398: bf00         	nop
; 	return k;
 800a39a: 697b         	ldr	r3, [r7, #0x14]
 800a39c: 62fb         	str	r3, [r7, #0x2c]
; 	new_thread->next_thread = _kernel.threads;
 800a39e: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x800a444 <z_setup_new_thread+0x150>
 800a3a0: 6a9a         	ldr	r2, [r3, #0x28]
 800a3a2: 68fb         	ldr	r3, [r7, #0xc]
 800a3a4: f8c3 2090    	str.w	r2, [r3, #0x90]
; 	_kernel.threads = new_thread;
 800a3a8: 4a26         	ldr	r2, [pc, #0x98]         @ 0x800a444 <z_setup_new_thread+0x150>
 800a3aa: 68fb         	ldr	r3, [r7, #0xc]
 800a3ac: 6293         	str	r3, [r2, #0x28]
 800a3ae: 4b24         	ldr	r3, [pc, #0x90]         @ 0x800a440 <z_setup_new_thread+0x14c>
 800a3b0: 65bb         	str	r3, [r7, #0x58]
 800a3b2: 6afb         	ldr	r3, [r7, #0x2c]
 800a3b4: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 800a3b6: 693b         	ldr	r3, [r7, #0x10]
 800a3b8: 657b         	str	r3, [r7, #0x54]
 800a3ba: 6d7b         	ldr	r3, [r7, #0x54]
 800a3bc: 653b         	str	r3, [r7, #0x50]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800a3be: 6d3b         	ldr	r3, [r7, #0x50]
 800a3c0: f383 8811    	msr	basepri, r3
; }
 800a3c4: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800a3c6: f3bf 8f6f    	isb	sy
; }
 800a3ca: bf00         	nop
; }
 800a3cc: bf00         	nop
; }
 800a3ce: bf00         	nop
; 	if (name != NULL) {
 800a3d0: 6ffb         	ldr	r3, [r7, #0x7c]
 800a3d2: 2b00         	cmp	r3, #0x0
 800a3d4: d00b         	beq	0x800a3ee <z_setup_new_thread+0xfa> @ imm = #0x16
; 		strncpy(new_thread->name, name,
 800a3d6: 68fb         	ldr	r3, [r7, #0xc]
 800a3d8: 3394         	adds	r3, #0x94
 800a3da: 221f         	movs	r2, #0x1f
 800a3dc: 6ff9         	ldr	r1, [r7, #0x7c]
 800a3de: 4618         	mov	r0, r3
 800a3e0: f009 fea4    	bl	0x801412c <strncpy>     @ imm = #0x9d48
; 		new_thread->name[CONFIG_THREAD_MAX_NAME_LEN - 1] = '\0';
 800a3e4: 68fb         	ldr	r3, [r7, #0xc]
 800a3e6: 2200         	movs	r2, #0x0
 800a3e8: f883 20b3    	strb.w	r2, [r3, #0xb3]
 800a3ec: e003         	b	0x800a3f6 <z_setup_new_thread+0x102> @ imm = #0x6
; 		new_thread->name[0] = '\0';
 800a3ee: 68fb         	ldr	r3, [r7, #0xc]
 800a3f0: 2200         	movs	r2, #0x0
 800a3f2: f883 2094    	strb.w	r2, [r3, #0x94]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800a3f6: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x800a444 <z_setup_new_thread+0x150>
 800a3f8: 689b         	ldr	r3, [r3, #0x8]
 800a3fa: 637b         	str	r3, [r7, #0x34]
; 	return ret;
 800a3fc: 6b7b         	ldr	r3, [r7, #0x34]
; 	if (!arch_current_thread()) {
 800a3fe: 2b00         	cmp	r3, #0x0
 800a400: d105         	bne	0x800a40e <z_setup_new_thread+0x11a> @ imm = #0xa
; 		new_thread->resource_pool = NULL;
 800a402: 68fb         	ldr	r3, [r7, #0xc]
 800a404: 2200         	movs	r2, #0x0
 800a406: f8c3 20c0    	str.w	r2, [r3, #0xc0]
; 		return stack_ptr;
 800a40a: 6dfb         	ldr	r3, [r7, #0x5c]
 800a40c: e014         	b	0x800a438 <z_setup_new_thread+0x144> @ imm = #0x28
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800a40e: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800a444 <z_setup_new_thread+0x150>
 800a410: 689b         	ldr	r3, [r3, #0x8]
 800a412: 633b         	str	r3, [r7, #0x30]
; 	return ret;
 800a414: 6b3b         	ldr	r3, [r7, #0x30]
; 	new_thread->resource_pool = arch_current_thread()->resource_pool;
 800a416: f8d3 20c0    	ldr.w	r2, [r3, #0xc0]
 800a41a: 68fb         	ldr	r3, [r7, #0xc]
 800a41c: f8c3 20c0    	str.w	r2, [r3, #0xc0]
; 	new_thread->base.usage = (struct k_cycle_stats) {};
 800a420: 68fb         	ldr	r3, [r7, #0xc]
 800a422: 3330         	adds	r3, #0x30
 800a424: 2200         	movs	r2, #0x0
 800a426: 601a         	str	r2, [r3]
 800a428: 605a         	str	r2, [r3, #0x4]
 800a42a: 609a         	str	r2, [r3, #0x8]
 800a42c: 60da         	str	r2, [r3, #0xc]
; 	new_thread->base.usage.track_usage =
 800a42e: 68fb         	ldr	r3, [r7, #0xc]
 800a430: 2201         	movs	r2, #0x1
 800a432: f883 2038    	strb.w	r2, [r3, #0x38]
; 	return stack_ptr;
 800a436: 6dfb         	ldr	r3, [r7, #0x5c]
; }
 800a438: 4618         	mov	r0, r3
 800a43a: 3760         	adds	r7, #0x60
 800a43c: 46bd         	mov	sp, r7
 800a43e: bd80         	pop	{r7, pc}

0800a440 <$d>:
 800a440: f0 09 00 20  	.word	0x200009f0
 800a444: c0 02 00 20  	.word	0x200002c0

0800a448 <z_thread_mark_switched_in>:
; {
 800a448: b580         	push	{r7, lr}
 800a44a: b082         	sub	sp, #0x8
 800a44c: af00         	add	r7, sp, #0x0
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800a44e: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800a464 <z_thread_mark_switched_in+0x1c>
 800a450: 689b         	ldr	r3, [r3, #0x8]
 800a452: 607b         	str	r3, [r7, #0x4]
; 	return ret;
 800a454: 687b         	ldr	r3, [r7, #0x4]
; 	z_sched_usage_start(arch_current_thread());
 800a456: 4618         	mov	r0, r3
 800a458: f002 f87e    	bl	0x800c558 <z_sched_usage_start> @ imm = #0x20fc
; }
 800a45c: bf00         	nop
 800a45e: 3708         	adds	r7, #0x8
 800a460: 46bd         	mov	sp, r7
 800a462: bd80         	pop	{r7, pc}

0800a464 <$d>:
 800a464: c0 02 00 20  	.word	0x200002c0

0800a468 <z_add_thread_timeout>:
; {
 800a468: b580         	push	{r7, lr}
 800a46a: b084         	sub	sp, #0x10
 800a46c: af00         	add	r7, sp, #0x0
 800a46e: 60f8         	str	r0, [r7, #0xc]
 800a470: e9c7 2300    	strd	r2, r3, [r7]
; 	z_add_timeout(&thread->base.timeout, z_thread_timeout, ticks);
 800a474: 68fb         	ldr	r3, [r7, #0xc]
 800a476: f103 0018    	add.w	r0, r3, #0x18
 800a47a: e9d7 2300    	ldrd	r2, r3, [r7]
 800a47e: 4903         	ldr	r1, [pc, #0xc]          @ 0x800a48c <z_add_thread_timeout+0x24>
 800a480: f001 fdd8    	bl	0x800c034 <z_add_timeout> @ imm = #0x1bb0
; }
 800a484: bf00         	nop
 800a486: 3710         	adds	r7, #0x10
 800a488: 46bd         	mov	sp, r7
 800a48a: bd80         	pop	{r7, pc}

0800a48c <$d>:
 800a48c: 91 3b 01 08  	.word	0x08013b91

0800a490 <z_sched_lock>:
; {
 800a490: b480         	push	{r7}
 800a492: b083         	sub	sp, #0xc
 800a494: af00         	add	r7, sp, #0x0
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800a496: 4b06         	ldr	r3, [pc, #0x18]         @ 0x800a4b0 <z_sched_lock+0x20>
 800a498: 689b         	ldr	r3, [r3, #0x8]
 800a49a: 607b         	str	r3, [r7, #0x4]
; 	return ret;
 800a49c: 687b         	ldr	r3, [r7, #0x4]
; 	--arch_current_thread()->base.sched_locked;
 800a49e: 7bda         	ldrb	r2, [r3, #0xf]
 800a4a0: 3a01         	subs	r2, #0x1
 800a4a2: b2d2         	uxtb	r2, r2
 800a4a4: 73da         	strb	r2, [r3, #0xf]
; }
 800a4a6: bf00         	nop
 800a4a8: 370c         	adds	r7, #0xc
 800a4aa: 46bd         	mov	sp, r7
 800a4ac: bc80         	pop	{r7}
 800a4ae: 4770         	bx	lr

0800a4b0 <$d>:
 800a4b0: c0 02 00 20  	.word	0x200002c0

0800a4b4 <z_dummy_thread_init>:
; {
 800a4b4: b480         	push	{r7}
 800a4b6: b085         	sub	sp, #0x14
 800a4b8: af00         	add	r7, sp, #0x0
 800a4ba: 6078         	str	r0, [r7, #0x4]
; 	dummy_thread->base.thread_state = _THREAD_DUMMY;
 800a4bc: 687b         	ldr	r3, [r7, #0x4]
 800a4be: 2201         	movs	r2, #0x1
 800a4c0: 735a         	strb	r2, [r3, #0xd]
; 	dummy_thread->base.user_options = K_ESSENTIAL;
 800a4c2: 687b         	ldr	r3, [r7, #0x4]
 800a4c4: 2201         	movs	r2, #0x1
 800a4c6: 731a         	strb	r2, [r3, #0xc]
; 	dummy_thread->stack_info.start = 0U;
 800a4c8: 687b         	ldr	r3, [r7, #0x4]
 800a4ca: 2200         	movs	r2, #0x0
 800a4cc: f8c3 20b4    	str.w	r2, [r3, #0xb4]
; 	dummy_thread->stack_info.size = 0U;
 800a4d0: 687b         	ldr	r3, [r7, #0x4]
 800a4d2: 2200         	movs	r2, #0x0
 800a4d4: f8c3 20b8    	str.w	r2, [r3, #0xb8]
; 	dummy_thread->resource_pool = NULL;
 800a4d8: 687b         	ldr	r3, [r7, #0x4]
 800a4da: 2200         	movs	r2, #0x0
 800a4dc: f8c3 20c0    	str.w	r2, [r3, #0xc0]
 800a4e0: 687b         	ldr	r3, [r7, #0x4]
 800a4e2: 60fb         	str	r3, [r7, #0xc]
; 	_current_cpu->current = thread;
 800a4e4: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800a4f8 <z_dummy_thread_init+0x44>
 800a4e6: 68fb         	ldr	r3, [r7, #0xc]
 800a4e8: 6093         	str	r3, [r2, #0x8]
; }
 800a4ea: bf00         	nop
; }
 800a4ec: bf00         	nop
 800a4ee: 3714         	adds	r7, #0x14
 800a4f0: 46bd         	mov	sp, r7
 800a4f2: bc80         	pop	{r7}
 800a4f4: 4770         	bx	lr
 800a4f6: bf00         	nop

0800a4f8 <$d>:
 800a4f8: c0 02 00 20  	.word	0x200002c0

0800a4fc <move_thread_to_end_of_prio_q>:
; {
 800a4fc: b580         	push	{r7, lr}
 800a4fe: b09a         	sub	sp, #0x68
 800a500: af00         	add	r7, sp, #0x0
 800a502: 6078         	str	r0, [r7, #0x4]
; 	if (z_is_thread_queued(thread)) {
 800a504: 6878         	ldr	r0, [r7, #0x4]
 800a506: f009 f987    	bl	0x8013818 <z_is_thread_queued> @ imm = #0x930e
 800a50a: 4603         	mov	r3, r0
 800a50c: 2b00         	cmp	r3, #0x0
 800a50e: d01d         	beq	0x800a54c <move_thread_to_end_of_prio_q+0x50> @ imm = #0x3a
 800a510: 687b         	ldr	r3, [r7, #0x4]
 800a512: 667b         	str	r3, [r7, #0x64]
; 	thread->base.thread_state &= ~_THREAD_QUEUED;
 800a514: 6e7b         	ldr	r3, [r7, #0x64]
 800a516: 7b5b         	ldrb	r3, [r3, #0xd]
 800a518: f003 037f    	and	r3, r3, #0x7f
 800a51c: b2da         	uxtb	r2, r3
 800a51e: 6e7b         	ldr	r3, [r7, #0x64]
 800a520: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 800a522: 6e78         	ldr	r0, [r7, #0x64]
 800a524: f009 fa5d    	bl	0x80139e2 <should_queue_thread> @ imm = #0x94ba
 800a528: 4603         	mov	r3, r0
 800a52a: 2b00         	cmp	r3, #0x0
 800a52c: d00d         	beq	0x800a54a <move_thread_to_end_of_prio_q+0x4e> @ imm = #0x1a
 800a52e: 6e7b         	ldr	r3, [r7, #0x64]
 800a530: 663b         	str	r3, [r7, #0x60]
 800a532: 6e3b         	ldr	r3, [r7, #0x60]
 800a534: 65fb         	str	r3, [r7, #0x5c]
; 	return &_kernel.ready_q.runq;
 800a536: 4b67         	ldr	r3, [pc, #0x19c]        @ 0x800a6d4 <move_thread_to_end_of_prio_q+0x1d8>
 800a538: 65bb         	str	r3, [r7, #0x58]
 800a53a: 6e3b         	ldr	r3, [r7, #0x60]
 800a53c: 657b         	str	r3, [r7, #0x54]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 800a53e: 6d7b         	ldr	r3, [r7, #0x54]
 800a540: 4618         	mov	r0, r3
 800a542: f009 f88e    	bl	0x8013662 <sys_dlist_remove> @ imm = #0x911c
; }
 800a546: bf00         	nop
; }
 800a548: bf00         	nop
; }
 800a54a: bf00         	nop
 800a54c: 687b         	ldr	r3, [r7, #0x4]
 800a54e: 61fb         	str	r3, [r7, #0x1c]
; 	thread->base.thread_state |= _THREAD_QUEUED;
 800a550: 69fb         	ldr	r3, [r7, #0x1c]
 800a552: 7b5b         	ldrb	r3, [r3, #0xd]
 800a554: f063 037f    	orn	r3, r3, #0x7f
 800a558: b2da         	uxtb	r2, r3
 800a55a: 69fb         	ldr	r3, [r7, #0x1c]
 800a55c: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 800a55e: 69f8         	ldr	r0, [r7, #0x1c]
 800a560: f009 fa3f    	bl	0x80139e2 <should_queue_thread> @ imm = #0x947e
 800a564: 4603         	mov	r3, r0
 800a566: 2b00         	cmp	r3, #0x0
 800a568: d042         	beq	0x800a5f0 <move_thread_to_end_of_prio_q+0xf4> @ imm = #0x84
 800a56a: 69fb         	ldr	r3, [r7, #0x1c]
 800a56c: 61bb         	str	r3, [r7, #0x18]
 800a56e: 69bb         	ldr	r3, [r7, #0x18]
 800a570: 617b         	str	r3, [r7, #0x14]
; 	return &_kernel.ready_q.runq;
 800a572: 4b58         	ldr	r3, [pc, #0x160]        @ 0x800a6d4 <move_thread_to_end_of_prio_q+0x1d8>
 800a574: 613b         	str	r3, [r7, #0x10]
 800a576: 69bb         	ldr	r3, [r7, #0x18]
 800a578: 60fb         	str	r3, [r7, #0xc]
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 800a57a: 6938         	ldr	r0, [r7, #0x10]
 800a57c: f009 f807    	bl	0x801358e <sys_dlist_peek_head> @ imm = #0x900e
 800a580: 4603         	mov	r3, r0
 800a582: 2b00         	cmp	r3, #0x0
 800a584: d004         	beq	0x800a590 <move_thread_to_end_of_prio_q+0x94> @ imm = #0x8
 800a586: 6938         	ldr	r0, [r7, #0x10]
 800a588: f009 f801    	bl	0x801358e <sys_dlist_peek_head> @ imm = #0x9002
 800a58c: 4603         	mov	r3, r0
 800a58e: e000         	b	0x800a592 <move_thread_to_end_of_prio_q+0x96> @ imm = #0x0
 800a590: 2300         	movs	r3, #0x0
 800a592: 60bb         	str	r3, [r7, #0x8]
 800a594: e023         	b	0x800a5de <move_thread_to_end_of_prio_q+0xe2> @ imm = #0x46
; 		if (z_sched_prio_cmp(thread, t) > 0) {
 800a596: 68b9         	ldr	r1, [r7, #0x8]
 800a598: 68f8         	ldr	r0, [r7, #0xc]
 800a59a: f009 fa07    	bl	0x80139ac <z_sched_prio_cmp> @ imm = #0x940e
 800a59e: 4603         	mov	r3, r0
 800a5a0: 2b00         	cmp	r3, #0x0
 800a5a2: dd06         	ble	0x800a5b2 <move_thread_to_end_of_prio_q+0xb6> @ imm = #0xc
; 			sys_dlist_insert(&t->base.qnode_dlist,
 800a5a4: 68bb         	ldr	r3, [r7, #0x8]
 800a5a6: 68fa         	ldr	r2, [r7, #0xc]
 800a5a8: 4611         	mov	r1, r2
 800a5aa: 4618         	mov	r0, r3
 800a5ac: f009 f840    	bl	0x8013630 <sys_dlist_insert> @ imm = #0x9080
; 			return;
 800a5b0: e01d         	b	0x800a5ee <move_thread_to_end_of_prio_q+0xf2> @ imm = #0x3a
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 800a5b2: 68bb         	ldr	r3, [r7, #0x8]
 800a5b4: 2b00         	cmp	r3, #0x0
 800a5b6: d010         	beq	0x800a5da <move_thread_to_end_of_prio_q+0xde> @ imm = #0x20
 800a5b8: 68bb         	ldr	r3, [r7, #0x8]
 800a5ba: 4619         	mov	r1, r3
 800a5bc: 6938         	ldr	r0, [r7, #0x10]
 800a5be: f009 f80b    	bl	0x80135d8 <sys_dlist_peek_next> @ imm = #0x9016
 800a5c2: 4603         	mov	r3, r0
 800a5c4: 2b00         	cmp	r3, #0x0
 800a5c6: d006         	beq	0x800a5d6 <move_thread_to_end_of_prio_q+0xda> @ imm = #0xc
 800a5c8: 68bb         	ldr	r3, [r7, #0x8]
 800a5ca: 4619         	mov	r1, r3
 800a5cc: 6938         	ldr	r0, [r7, #0x10]
 800a5ce: f009 f803    	bl	0x80135d8 <sys_dlist_peek_next> @ imm = #0x9006
 800a5d2: 4603         	mov	r3, r0
 800a5d4: e002         	b	0x800a5dc <move_thread_to_end_of_prio_q+0xe0> @ imm = #0x4
 800a5d6: 2300         	movs	r3, #0x0
 800a5d8: e000         	b	0x800a5dc <move_thread_to_end_of_prio_q+0xe0> @ imm = #0x0
 800a5da: 2300         	movs	r3, #0x0
 800a5dc: 60bb         	str	r3, [r7, #0x8]
 800a5de: 68bb         	ldr	r3, [r7, #0x8]
 800a5e0: 2b00         	cmp	r3, #0x0
 800a5e2: d1d8         	bne	0x800a596 <move_thread_to_end_of_prio_q+0x9a> @ imm = #-0x50
; 	sys_dlist_append(pq, &thread->base.qnode_dlist);
 800a5e4: 68fb         	ldr	r3, [r7, #0xc]
 800a5e6: 4619         	mov	r1, r3
 800a5e8: 6938         	ldr	r0, [r7, #0x10]
 800a5ea: f009 f808    	bl	0x80135fe <sys_dlist_append> @ imm = #0x9010
; }
 800a5ee: bf00         	nop
; }
 800a5f0: bf00         	nop
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800a5f2: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x800a6d8 <move_thread_to_end_of_prio_q+0x1dc>
 800a5f4: 689b         	ldr	r3, [r3, #0x8]
 800a5f6: 623b         	str	r3, [r7, #0x20]
; 	return ret;
 800a5f8: 6a3b         	ldr	r3, [r7, #0x20]
; 	update_cache(thread == arch_current_thread());
 800a5fa: 687a         	ldr	r2, [r7, #0x4]
 800a5fc: 429a         	cmp	r2, r3
 800a5fe: bf0c         	ite	eq
 800a600: 2301         	moveq	r3, #0x1
 800a602: 2300         	movne	r3, #0x0
 800a604: b2db         	uxtb	r3, r3
 800a606: 653b         	str	r3, [r7, #0x50]
; 	return &_kernel.ready_q.runq;
 800a608: 4b32         	ldr	r3, [pc, #0xc8]         @ 0x800a6d4 <move_thread_to_end_of_prio_q+0x1d8>
 800a60a: 64fb         	str	r3, [r7, #0x4c]
; 	struct k_thread *thread = NULL;
 800a60c: 2300         	movs	r3, #0x0
 800a60e: 64bb         	str	r3, [r7, #0x48]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 800a610: 6cf8         	ldr	r0, [r7, #0x4c]
 800a612: f008 ffbc    	bl	0x801358e <sys_dlist_peek_head> @ imm = #0x8f78
 800a616: 6478         	str	r0, [r7, #0x44]
; 	if (n != NULL) {
 800a618: 6c7b         	ldr	r3, [r7, #0x44]
 800a61a: 2b00         	cmp	r3, #0x0
 800a61c: d001         	beq	0x800a622 <move_thread_to_end_of_prio_q+0x126> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 800a61e: 6c7b         	ldr	r3, [r7, #0x44]
 800a620: 64bb         	str	r3, [r7, #0x48]
; 	return thread;
 800a622: 6cbb         	ldr	r3, [r7, #0x48]
; 	return _priq_run_best(curr_cpu_runq());
 800a624: bf00         	nop
; 	struct k_thread *thread = runq_best();
 800a626: 643b         	str	r3, [r7, #0x40]
; 	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 800a628: 6c3b         	ldr	r3, [r7, #0x40]
 800a62a: 2b00         	cmp	r3, #0x0
 800a62c: d102         	bne	0x800a634 <move_thread_to_end_of_prio_q+0x138> @ imm = #0x4
 800a62e: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x800a6d8 <move_thread_to_end_of_prio_q+0x1dc>
 800a630: 68db         	ldr	r3, [r3, #0xc]
 800a632: e000         	b	0x800a636 <move_thread_to_end_of_prio_q+0x13a> @ imm = #0x0
 800a634: 6c3b         	ldr	r3, [r7, #0x40]
; 	struct k_thread *thread = next_up();
 800a636: 63fb         	str	r3, [r7, #0x3c]
 800a638: 6bfb         	ldr	r3, [r7, #0x3c]
 800a63a: 63bb         	str	r3, [r7, #0x38]
 800a63c: 6d3b         	ldr	r3, [r7, #0x50]
 800a63e: 637b         	str	r3, [r7, #0x34]
; 	if (preempt_ok != 0) {
 800a640: 6b7b         	ldr	r3, [r7, #0x34]
 800a642: 2b00         	cmp	r3, #0x0
 800a644: d001         	beq	0x800a64a <move_thread_to_end_of_prio_q+0x14e> @ imm = #0x2
; 		return true;
 800a646: 2301         	movs	r3, #0x1
 800a648: e026         	b	0x800a698 <move_thread_to_end_of_prio_q+0x19c> @ imm = #0x4c
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800a64a: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x800a6d8 <move_thread_to_end_of_prio_q+0x1dc>
 800a64c: 689b         	ldr	r3, [r3, #0x8]
 800a64e: 633b         	str	r3, [r7, #0x30]
; 	return ret;
 800a650: 6b3b         	ldr	r3, [r7, #0x30]
; 	if (z_is_thread_prevented_from_running(arch_current_thread())) {
 800a652: 4618         	mov	r0, r3
 800a654: f009 f87f    	bl	0x8013756 <z_is_thread_prevented_from_running> @ imm = #0x90fe
 800a658: 4603         	mov	r3, r0
 800a65a: 2b00         	cmp	r3, #0x0
 800a65c: d001         	beq	0x800a662 <move_thread_to_end_of_prio_q+0x166> @ imm = #0x2
; 		return true;
 800a65e: 2301         	movs	r3, #0x1
 800a660: e01a         	b	0x800a698 <move_thread_to_end_of_prio_q+0x19c> @ imm = #0x34
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800a662: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x800a6d8 <move_thread_to_end_of_prio_q+0x1dc>
 800a664: 689b         	ldr	r3, [r3, #0x8]
 800a666: 62fb         	str	r3, [r7, #0x2c]
; 	return ret;
 800a668: 6afb         	ldr	r3, [r7, #0x2c]
; 	if (thread_is_preemptible(arch_current_thread()) || thread_is_metairq(thread)) {
 800a66a: 4618         	mov	r0, r3
 800a66c: f009 f847    	bl	0x80136fe <thread_is_preemptible> @ imm = #0x908e
 800a670: 4603         	mov	r3, r0
 800a672: 2b00         	cmp	r3, #0x0
 800a674: d105         	bne	0x800a682 <move_thread_to_end_of_prio_q+0x186> @ imm = #0xa
 800a676: 6bb8         	ldr	r0, [r7, #0x38]
 800a678: f009 f851    	bl	0x801371e <thread_is_metairq> @ imm = #0x90a2
 800a67c: 4603         	mov	r3, r0
 800a67e: 2b00         	cmp	r3, #0x0
 800a680: d001         	beq	0x800a686 <move_thread_to_end_of_prio_q+0x18a> @ imm = #0x2
; 		return true;
 800a682: 2301         	movs	r3, #0x1
 800a684: e008         	b	0x800a698 <move_thread_to_end_of_prio_q+0x19c> @ imm = #0x10
; 	    && z_is_thread_timeout_active(thread)) {
 800a686: 6bb8         	ldr	r0, [r7, #0x38]
 800a688: f009 f879    	bl	0x801377e <z_is_thread_timeout_active> @ imm = #0x90f2
 800a68c: 4603         	mov	r3, r0
; 	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 800a68e: 2b00         	cmp	r3, #0x0
 800a690: d001         	beq	0x800a696 <move_thread_to_end_of_prio_q+0x19a> @ imm = #0x2
; 		return true;
 800a692: 2301         	movs	r3, #0x1
 800a694: e000         	b	0x800a698 <move_thread_to_end_of_prio_q+0x19c> @ imm = #0x0
; 	return false;
 800a696: 2300         	movs	r3, #0x0
; 	if (should_preempt(thread, preempt_ok)) {
 800a698: 2b00         	cmp	r3, #0x0
 800a69a: d010         	beq	0x800a6be <move_thread_to_end_of_prio_q+0x1c2> @ imm = #0x20
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800a69c: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800a6d8 <move_thread_to_end_of_prio_q+0x1dc>
 800a69e: 689b         	ldr	r3, [r3, #0x8]
 800a6a0: 62bb         	str	r3, [r7, #0x28]
; 	return ret;
 800a6a2: 6abb         	ldr	r3, [r7, #0x28]
; 		if (thread != arch_current_thread()) {
 800a6a4: 6bfa         	ldr	r2, [r7, #0x3c]
 800a6a6: 429a         	cmp	r2, r3
 800a6a8: d002         	beq	0x800a6b0 <move_thread_to_end_of_prio_q+0x1b4> @ imm = #0x4
; 			z_reset_time_slice(thread);
 800a6aa: 6bf8         	ldr	r0, [r7, #0x3c]
 800a6ac: f001 fb5e    	bl	0x800bd6c <z_reset_time_slice> @ imm = #0x16bc
; 		update_metairq_preempt(thread);
 800a6b0: 6bf8         	ldr	r0, [r7, #0x3c]
 800a6b2: f009 f9d9    	bl	0x8013a68 <update_metairq_preempt> @ imm = #0x93b2
; 		_kernel.ready_q.cache = thread;
 800a6b6: 4a08         	ldr	r2, [pc, #0x20]         @ 0x800a6d8 <move_thread_to_end_of_prio_q+0x1dc>
 800a6b8: 6bfb         	ldr	r3, [r7, #0x3c]
 800a6ba: 61d3         	str	r3, [r2, #0x1c]
; }
 800a6bc: e005         	b	0x800a6ca <move_thread_to_end_of_prio_q+0x1ce> @ imm = #0xa
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800a6be: 4b06         	ldr	r3, [pc, #0x18]         @ 0x800a6d8 <move_thread_to_end_of_prio_q+0x1dc>
 800a6c0: 689b         	ldr	r3, [r3, #0x8]
 800a6c2: 627b         	str	r3, [r7, #0x24]
; 	return ret;
 800a6c4: 6a7b         	ldr	r3, [r7, #0x24]
; 		_kernel.ready_q.cache = arch_current_thread();
 800a6c6: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800a6d8 <move_thread_to_end_of_prio_q+0x1dc>
 800a6c8: 61d3         	str	r3, [r2, #0x1c]
; }
 800a6ca: bf00         	nop
; }
 800a6cc: bf00         	nop
 800a6ce: 3768         	adds	r7, #0x68
 800a6d0: 46bd         	mov	sp, r7
 800a6d2: bd80         	pop	{r7, pc}

0800a6d4 <$d>:
 800a6d4: e0 02 00 20  	.word	0x200002e0
 800a6d8: c0 02 00 20  	.word	0x200002c0

0800a6dc <ready_thread>:
; {
 800a6dc: b580         	push	{r7, lr}
 800a6de: b094         	sub	sp, #0x50
 800a6e0: af00         	add	r7, sp, #0x0
 800a6e2: 6078         	str	r0, [r7, #0x4]
; 	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
 800a6e4: 6878         	ldr	r0, [r7, #0x4]
 800a6e6: f009 f897    	bl	0x8013818 <z_is_thread_queued> @ imm = #0x912e
 800a6ea: 4603         	mov	r3, r0
 800a6ec: f083 0301    	eor	r3, r3, #0x1
 800a6f0: b2db         	uxtb	r3, r3
 800a6f2: 2b00         	cmp	r3, #0x0
 800a6f4: f000 80be    	beq.w	0x800a874 <ready_thread+0x198> @ imm = #0x17c
 800a6f8: 6878         	ldr	r0, [r7, #0x4]
 800a6fa: f009 f859    	bl	0x80137b0 <z_is_thread_ready> @ imm = #0x90b2
 800a6fe: 4603         	mov	r3, r0
 800a700: 2b00         	cmp	r3, #0x0
 800a702: f000 80b7    	beq.w	0x800a874 <ready_thread+0x198> @ imm = #0x16e
 800a706: 687b         	ldr	r3, [r7, #0x4]
 800a708: 61fb         	str	r3, [r7, #0x1c]
; 	thread->base.thread_state |= _THREAD_QUEUED;
 800a70a: 69fb         	ldr	r3, [r7, #0x1c]
 800a70c: 7b5b         	ldrb	r3, [r3, #0xd]
 800a70e: f063 037f    	orn	r3, r3, #0x7f
 800a712: b2da         	uxtb	r2, r3
 800a714: 69fb         	ldr	r3, [r7, #0x1c]
 800a716: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 800a718: 69f8         	ldr	r0, [r7, #0x1c]
 800a71a: f009 f962    	bl	0x80139e2 <should_queue_thread> @ imm = #0x92c4
 800a71e: 4603         	mov	r3, r0
 800a720: 2b00         	cmp	r3, #0x0
 800a722: d042         	beq	0x800a7aa <ready_thread+0xce> @ imm = #0x84
 800a724: 69fb         	ldr	r3, [r7, #0x1c]
 800a726: 61bb         	str	r3, [r7, #0x18]
 800a728: 69bb         	ldr	r3, [r7, #0x18]
 800a72a: 617b         	str	r3, [r7, #0x14]
; 	return &_kernel.ready_q.runq;
 800a72c: 4b53         	ldr	r3, [pc, #0x14c]        @ 0x800a87c <ready_thread+0x1a0>
 800a72e: 613b         	str	r3, [r7, #0x10]
 800a730: 69bb         	ldr	r3, [r7, #0x18]
 800a732: 60fb         	str	r3, [r7, #0xc]
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 800a734: 6938         	ldr	r0, [r7, #0x10]
 800a736: f008 ff2a    	bl	0x801358e <sys_dlist_peek_head> @ imm = #0x8e54
 800a73a: 4603         	mov	r3, r0
 800a73c: 2b00         	cmp	r3, #0x0
 800a73e: d004         	beq	0x800a74a <ready_thread+0x6e> @ imm = #0x8
 800a740: 6938         	ldr	r0, [r7, #0x10]
 800a742: f008 ff24    	bl	0x801358e <sys_dlist_peek_head> @ imm = #0x8e48
 800a746: 4603         	mov	r3, r0
 800a748: e000         	b	0x800a74c <ready_thread+0x70> @ imm = #0x0
 800a74a: 2300         	movs	r3, #0x0
 800a74c: 60bb         	str	r3, [r7, #0x8]
 800a74e: e023         	b	0x800a798 <ready_thread+0xbc> @ imm = #0x46
; 		if (z_sched_prio_cmp(thread, t) > 0) {
 800a750: 68b9         	ldr	r1, [r7, #0x8]
 800a752: 68f8         	ldr	r0, [r7, #0xc]
 800a754: f009 f92a    	bl	0x80139ac <z_sched_prio_cmp> @ imm = #0x9254
 800a758: 4603         	mov	r3, r0
 800a75a: 2b00         	cmp	r3, #0x0
 800a75c: dd06         	ble	0x800a76c <ready_thread+0x90> @ imm = #0xc
; 			sys_dlist_insert(&t->base.qnode_dlist,
 800a75e: 68bb         	ldr	r3, [r7, #0x8]
 800a760: 68fa         	ldr	r2, [r7, #0xc]
 800a762: 4611         	mov	r1, r2
 800a764: 4618         	mov	r0, r3
 800a766: f008 ff63    	bl	0x8013630 <sys_dlist_insert> @ imm = #0x8ec6
; 			return;
 800a76a: e01d         	b	0x800a7a8 <ready_thread+0xcc> @ imm = #0x3a
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 800a76c: 68bb         	ldr	r3, [r7, #0x8]
 800a76e: 2b00         	cmp	r3, #0x0
 800a770: d010         	beq	0x800a794 <ready_thread+0xb8> @ imm = #0x20
 800a772: 68bb         	ldr	r3, [r7, #0x8]
 800a774: 4619         	mov	r1, r3
 800a776: 6938         	ldr	r0, [r7, #0x10]
 800a778: f008 ff2e    	bl	0x80135d8 <sys_dlist_peek_next> @ imm = #0x8e5c
 800a77c: 4603         	mov	r3, r0
 800a77e: 2b00         	cmp	r3, #0x0
 800a780: d006         	beq	0x800a790 <ready_thread+0xb4> @ imm = #0xc
 800a782: 68bb         	ldr	r3, [r7, #0x8]
 800a784: 4619         	mov	r1, r3
 800a786: 6938         	ldr	r0, [r7, #0x10]
 800a788: f008 ff26    	bl	0x80135d8 <sys_dlist_peek_next> @ imm = #0x8e4c
 800a78c: 4603         	mov	r3, r0
 800a78e: e002         	b	0x800a796 <ready_thread+0xba> @ imm = #0x4
 800a790: 2300         	movs	r3, #0x0
 800a792: e000         	b	0x800a796 <ready_thread+0xba> @ imm = #0x0
 800a794: 2300         	movs	r3, #0x0
 800a796: 60bb         	str	r3, [r7, #0x8]
 800a798: 68bb         	ldr	r3, [r7, #0x8]
 800a79a: 2b00         	cmp	r3, #0x0
 800a79c: d1d8         	bne	0x800a750 <ready_thread+0x74> @ imm = #-0x50
; 	sys_dlist_append(pq, &thread->base.qnode_dlist);
 800a79e: 68fb         	ldr	r3, [r7, #0xc]
 800a7a0: 4619         	mov	r1, r3
 800a7a2: 6938         	ldr	r0, [r7, #0x10]
 800a7a4: f008 ff2b    	bl	0x80135fe <sys_dlist_append> @ imm = #0x8e56
; }
 800a7a8: bf00         	nop
; }
 800a7aa: bf00         	nop
 800a7ac: 2300         	movs	r3, #0x0
 800a7ae: 64fb         	str	r3, [r7, #0x4c]
; 	return &_kernel.ready_q.runq;
 800a7b0: 4b32         	ldr	r3, [pc, #0xc8]         @ 0x800a87c <ready_thread+0x1a0>
 800a7b2: 64bb         	str	r3, [r7, #0x48]
; 	struct k_thread *thread = NULL;
 800a7b4: 2300         	movs	r3, #0x0
 800a7b6: 647b         	str	r3, [r7, #0x44]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 800a7b8: 6cb8         	ldr	r0, [r7, #0x48]
 800a7ba: f008 fee8    	bl	0x801358e <sys_dlist_peek_head> @ imm = #0x8dd0
 800a7be: 6438         	str	r0, [r7, #0x40]
; 	if (n != NULL) {
 800a7c0: 6c3b         	ldr	r3, [r7, #0x40]
 800a7c2: 2b00         	cmp	r3, #0x0
 800a7c4: d001         	beq	0x800a7ca <ready_thread+0xee> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 800a7c6: 6c3b         	ldr	r3, [r7, #0x40]
 800a7c8: 647b         	str	r3, [r7, #0x44]
; 	return thread;
 800a7ca: 6c7b         	ldr	r3, [r7, #0x44]
; 	return _priq_run_best(curr_cpu_runq());
 800a7cc: bf00         	nop
; 	struct k_thread *thread = runq_best();
 800a7ce: 63fb         	str	r3, [r7, #0x3c]
; 	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 800a7d0: 6bfb         	ldr	r3, [r7, #0x3c]
 800a7d2: 2b00         	cmp	r3, #0x0
 800a7d4: d102         	bne	0x800a7dc <ready_thread+0x100> @ imm = #0x4
 800a7d6: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x800a880 <ready_thread+0x1a4>
 800a7d8: 68db         	ldr	r3, [r3, #0xc]
 800a7da: e000         	b	0x800a7de <ready_thread+0x102> @ imm = #0x0
 800a7dc: 6bfb         	ldr	r3, [r7, #0x3c]
; 	struct k_thread *thread = next_up();
 800a7de: 63bb         	str	r3, [r7, #0x38]
 800a7e0: 6bbb         	ldr	r3, [r7, #0x38]
 800a7e2: 637b         	str	r3, [r7, #0x34]
 800a7e4: 6cfb         	ldr	r3, [r7, #0x4c]
 800a7e6: 633b         	str	r3, [r7, #0x30]
; 	if (preempt_ok != 0) {
 800a7e8: 6b3b         	ldr	r3, [r7, #0x30]
 800a7ea: 2b00         	cmp	r3, #0x0
 800a7ec: d001         	beq	0x800a7f2 <ready_thread+0x116> @ imm = #0x2
; 		return true;
 800a7ee: 2301         	movs	r3, #0x1
 800a7f0: e026         	b	0x800a840 <ready_thread+0x164> @ imm = #0x4c
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800a7f2: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x800a880 <ready_thread+0x1a4>
 800a7f4: 689b         	ldr	r3, [r3, #0x8]
 800a7f6: 62fb         	str	r3, [r7, #0x2c]
; 	return ret;
 800a7f8: 6afb         	ldr	r3, [r7, #0x2c]
; 	if (z_is_thread_prevented_from_running(arch_current_thread())) {
 800a7fa: 4618         	mov	r0, r3
 800a7fc: f008 ffab    	bl	0x8013756 <z_is_thread_prevented_from_running> @ imm = #0x8f56
 800a800: 4603         	mov	r3, r0
 800a802: 2b00         	cmp	r3, #0x0
 800a804: d001         	beq	0x800a80a <ready_thread+0x12e> @ imm = #0x2
; 		return true;
 800a806: 2301         	movs	r3, #0x1
 800a808: e01a         	b	0x800a840 <ready_thread+0x164> @ imm = #0x34
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800a80a: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x800a880 <ready_thread+0x1a4>
 800a80c: 689b         	ldr	r3, [r3, #0x8]
 800a80e: 62bb         	str	r3, [r7, #0x28]
; 	return ret;
 800a810: 6abb         	ldr	r3, [r7, #0x28]
; 	if (thread_is_preemptible(arch_current_thread()) || thread_is_metairq(thread)) {
 800a812: 4618         	mov	r0, r3
 800a814: f008 ff73    	bl	0x80136fe <thread_is_preemptible> @ imm = #0x8ee6
 800a818: 4603         	mov	r3, r0
 800a81a: 2b00         	cmp	r3, #0x0
 800a81c: d105         	bne	0x800a82a <ready_thread+0x14e> @ imm = #0xa
 800a81e: 6b78         	ldr	r0, [r7, #0x34]
 800a820: f008 ff7d    	bl	0x801371e <thread_is_metairq> @ imm = #0x8efa
 800a824: 4603         	mov	r3, r0
 800a826: 2b00         	cmp	r3, #0x0
 800a828: d001         	beq	0x800a82e <ready_thread+0x152> @ imm = #0x2
; 		return true;
 800a82a: 2301         	movs	r3, #0x1
 800a82c: e008         	b	0x800a840 <ready_thread+0x164> @ imm = #0x10
; 	    && z_is_thread_timeout_active(thread)) {
 800a82e: 6b78         	ldr	r0, [r7, #0x34]
 800a830: f008 ffa5    	bl	0x801377e <z_is_thread_timeout_active> @ imm = #0x8f4a
 800a834: 4603         	mov	r3, r0
; 	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 800a836: 2b00         	cmp	r3, #0x0
 800a838: d001         	beq	0x800a83e <ready_thread+0x162> @ imm = #0x2
; 		return true;
 800a83a: 2301         	movs	r3, #0x1
 800a83c: e000         	b	0x800a840 <ready_thread+0x164> @ imm = #0x0
; 	return false;
 800a83e: 2300         	movs	r3, #0x0
; 	if (should_preempt(thread, preempt_ok)) {
 800a840: 2b00         	cmp	r3, #0x0
 800a842: d010         	beq	0x800a866 <ready_thread+0x18a> @ imm = #0x20
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800a844: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800a880 <ready_thread+0x1a4>
 800a846: 689b         	ldr	r3, [r3, #0x8]
 800a848: 627b         	str	r3, [r7, #0x24]
; 	return ret;
 800a84a: 6a7b         	ldr	r3, [r7, #0x24]
; 		if (thread != arch_current_thread()) {
 800a84c: 6bba         	ldr	r2, [r7, #0x38]
 800a84e: 429a         	cmp	r2, r3
 800a850: d002         	beq	0x800a858 <ready_thread+0x17c> @ imm = #0x4
; 			z_reset_time_slice(thread);
 800a852: 6bb8         	ldr	r0, [r7, #0x38]
 800a854: f001 fa8a    	bl	0x800bd6c <z_reset_time_slice> @ imm = #0x1514
; 		update_metairq_preempt(thread);
 800a858: 6bb8         	ldr	r0, [r7, #0x38]
 800a85a: f009 f905    	bl	0x8013a68 <update_metairq_preempt> @ imm = #0x920a
; 		_kernel.ready_q.cache = thread;
 800a85e: 4a08         	ldr	r2, [pc, #0x20]         @ 0x800a880 <ready_thread+0x1a4>
 800a860: 6bbb         	ldr	r3, [r7, #0x38]
 800a862: 61d3         	str	r3, [r2, #0x1c]
; }
 800a864: e005         	b	0x800a872 <ready_thread+0x196> @ imm = #0xa
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800a866: 4b06         	ldr	r3, [pc, #0x18]         @ 0x800a880 <ready_thread+0x1a4>
 800a868: 689b         	ldr	r3, [r3, #0x8]
 800a86a: 623b         	str	r3, [r7, #0x20]
; 	return ret;
 800a86c: 6a3b         	ldr	r3, [r7, #0x20]
; 		_kernel.ready_q.cache = arch_current_thread();
 800a86e: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800a880 <ready_thread+0x1a4>
 800a870: 61d3         	str	r3, [r2, #0x1c]
; }
 800a872: bf00         	nop
; }
 800a874: bf00         	nop
 800a876: 3750         	adds	r7, #0x50
 800a878: 46bd         	mov	sp, r7
 800a87a: bd80         	pop	{r7, pc}

0800a87c <$d>:
 800a87c: e0 02 00 20  	.word	0x200002e0
 800a880: c0 02 00 20  	.word	0x200002c0

0800a884 <z_ready_thread>:
; {
 800a884: b580         	push	{r7, lr}
 800a886: b090         	sub	sp, #0x40
 800a888: af00         	add	r7, sp, #0x0
 800a88a: 6078         	str	r0, [r7, #0x4]
; 	K_SPINLOCK(&_sched_spinlock) {
 800a88c: 2300         	movs	r3, #0x0
 800a88e: 61bb         	str	r3, [r7, #0x18]
 800a890: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x800a910 <z_ready_thread+0x8c>
 800a892: 63fb         	str	r3, [r7, #0x3c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800a894: f3ef 8311    	mrs	r3, basepri
 800a898: 63bb         	str	r3, [r7, #0x38]
;   return(result);
 800a89a: 6bbb         	ldr	r3, [r7, #0x38]
; 	key = __get_BASEPRI();
 800a89c: 637b         	str	r3, [r7, #0x34]
 800a89e: 2310         	movs	r3, #0x10
 800a8a0: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800a8a2: 6b3b         	ldr	r3, [r7, #0x30]
 800a8a4: f383 8812    	msr	basepri_max, r3
; }
 800a8a8: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800a8aa: f3bf 8f6f    	isb	sy
; }
 800a8ae: bf00         	nop
; 	return key;
 800a8b0: 6b7b         	ldr	r3, [r7, #0x34]
; 	k.key = arch_irq_lock();
 800a8b2: 60fb         	str	r3, [r7, #0xc]
 800a8b4: 6bfb         	ldr	r3, [r7, #0x3c]
 800a8b6: 62fb         	str	r3, [r7, #0x2c]
; }
 800a8b8: bf00         	nop
 800a8ba: 6bfb         	ldr	r3, [r7, #0x3c]
 800a8bc: 62bb         	str	r3, [r7, #0x28]
; }
 800a8be: bf00         	nop
; 	return k;
 800a8c0: 68fb         	ldr	r3, [r7, #0xc]
 800a8c2: 617b         	str	r3, [r7, #0x14]
; 	K_SPINLOCK(&_sched_spinlock) {
 800a8c4: e01b         	b	0x800a8fe <z_ready_thread+0x7a> @ imm = #0x36
; 		if (thread_active_elsewhere(thread) == NULL) {
 800a8c6: 6878         	ldr	r0, [r7, #0x4]
 800a8c8: f009 f8d7    	bl	0x8013a7a <thread_active_elsewhere> @ imm = #0x91ae
 800a8cc: 4603         	mov	r3, r0
 800a8ce: 2b00         	cmp	r3, #0x0
 800a8d0: d102         	bne	0x800a8d8 <z_ready_thread+0x54> @ imm = #0x4
; 			ready_thread(thread);
 800a8d2: 6878         	ldr	r0, [r7, #0x4]
 800a8d4: f7ff ff02    	bl	0x800a6dc <ready_thread> @ imm = #-0x1fc
 800a8d8: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800a910 <z_ready_thread+0x8c>
 800a8da: 627b         	str	r3, [r7, #0x24]
 800a8dc: 697b         	ldr	r3, [r7, #0x14]
 800a8de: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 800a8e0: 693b         	ldr	r3, [r7, #0x10]
 800a8e2: 623b         	str	r3, [r7, #0x20]
 800a8e4: 6a3b         	ldr	r3, [r7, #0x20]
 800a8e6: 61fb         	str	r3, [r7, #0x1c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800a8e8: 69fb         	ldr	r3, [r7, #0x1c]
 800a8ea: f383 8811    	msr	basepri, r3
; }
 800a8ee: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800a8f0: f3bf 8f6f    	isb	sy
; }
 800a8f4: bf00         	nop
; }
 800a8f6: bf00         	nop
; }
 800a8f8: bf00         	nop
; 	K_SPINLOCK(&_sched_spinlock) {
 800a8fa: 2301         	movs	r3, #0x1
 800a8fc: 61bb         	str	r3, [r7, #0x18]
 800a8fe: 69bb         	ldr	r3, [r7, #0x18]
 800a900: 2b00         	cmp	r3, #0x0
 800a902: d0e0         	beq	0x800a8c6 <z_ready_thread+0x42> @ imm = #-0x40
; }
 800a904: bf00         	nop
 800a906: bf00         	nop
 800a908: 3740         	adds	r7, #0x40
 800a90a: 46bd         	mov	sp, r7
 800a90c: bd80         	pop	{r7, pc}
 800a90e: bf00         	nop

0800a910 <$d>:
 800a910: e0 09 00 20  	.word	0x200009e0

0800a914 <thread_halt_spin>:
; {
 800a914: b590         	push	{r4, r7, lr}
 800a916: b091         	sub	sp, #0x44
 800a918: af00         	add	r7, sp, #0x0
 800a91a: 6078         	str	r0, [r7, #0x4]
 800a91c: 6039         	str	r1, [r7]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800a91e: 4b2d         	ldr	r3, [pc, #0xb4]         @ 0x800a9d4 <thread_halt_spin+0xc0>
 800a920: 689b         	ldr	r3, [r3, #0x8]
 800a922: 63bb         	str	r3, [r7, #0x38]
; 	return ret;
 800a924: 6bbb         	ldr	r3, [r7, #0x38]
; 	if (is_halting(arch_current_thread())) {
 800a926: 4618         	mov	r0, r3
 800a928: f009 f877    	bl	0x8013a1a <is_halting>  @ imm = #0x90ee
 800a92c: 4603         	mov	r3, r0
 800a92e: 2b00         	cmp	r3, #0x0
 800a930: d014         	beq	0x800a95c <thread_halt_spin+0x48> @ imm = #0x28
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800a932: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x800a9d4 <thread_halt_spin+0xc0>
 800a934: 689b         	ldr	r3, [r3, #0x8]
 800a936: 633b         	str	r3, [r7, #0x30]
; 	return ret;
 800a938: 6b3c         	ldr	r4, [r7, #0x30]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800a93a: 4b26         	ldr	r3, [pc, #0x98]         @ 0x800a9d4 <thread_halt_spin+0xc0>
 800a93c: 689b         	ldr	r3, [r3, #0x8]
 800a93e: 637b         	str	r3, [r7, #0x34]
; 	return ret;
 800a940: 6b7b         	ldr	r3, [r7, #0x34]
; 			    is_aborting(arch_current_thread()) ? _THREAD_DEAD : _THREAD_SUSPENDED);
 800a942: 4618         	mov	r0, r3
 800a944: f009 f857    	bl	0x80139f6 <is_aborting> @ imm = #0x90ae
 800a948: 4603         	mov	r3, r0
; 		halt_thread(arch_current_thread(),
 800a94a: 2b00         	cmp	r3, #0x0
 800a94c: d001         	beq	0x800a952 <thread_halt_spin+0x3e> @ imm = #0x2
 800a94e: 2308         	movs	r3, #0x8
 800a950: e000         	b	0x800a954 <thread_halt_spin+0x40> @ imm = #0x0
 800a952: 2310         	movs	r3, #0x10
 800a954: 4619         	mov	r1, r3
 800a956: 4620         	mov	r0, r4
 800a958: f001 f83c    	bl	0x800b9d4 <halt_thread> @ imm = #0x1078
 800a95c: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x800a9d8 <thread_halt_spin+0xc4>
 800a95e: 62fb         	str	r3, [r7, #0x2c]
 800a960: 683b         	ldr	r3, [r7]
 800a962: 60fb         	str	r3, [r7, #0xc]
; 	arch_irq_unlock(key.key);
 800a964: 68fb         	ldr	r3, [r7, #0xc]
 800a966: 62bb         	str	r3, [r7, #0x28]
 800a968: 6abb         	ldr	r3, [r7, #0x28]
 800a96a: 627b         	str	r3, [r7, #0x24]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800a96c: 6a7b         	ldr	r3, [r7, #0x24]
 800a96e: f383 8811    	msr	basepri, r3
; }
 800a972: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800a974: f3bf 8f6f    	isb	sy
; }
 800a978: bf00         	nop
; }
 800a97a: bf00         	nop
; }
 800a97c: bf00         	nop
; 	while (is_halting(thread)) {
 800a97e: e01d         	b	0x800a9bc <thread_halt_spin+0xa8> @ imm = #0x3a
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800a980: f3ef 8311    	mrs	r3, basepri
 800a984: 61bb         	str	r3, [r7, #0x18]
;   return(result);
 800a986: 69bb         	ldr	r3, [r7, #0x18]
; 	key = __get_BASEPRI();
 800a988: 617b         	str	r3, [r7, #0x14]
 800a98a: 2310         	movs	r3, #0x10
 800a98c: 613b         	str	r3, [r7, #0x10]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800a98e: 693b         	ldr	r3, [r7, #0x10]
 800a990: f383 8812    	msr	basepri_max, r3
; }
 800a994: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800a996: f3bf 8f6f    	isb	sy
; }
 800a99a: bf00         	nop
; 	return key;
 800a99c: 697b         	ldr	r3, [r7, #0x14]
; 		unsigned int k = arch_irq_lock();
 800a99e: 63fb         	str	r3, [r7, #0x3c]
; 		arch_spin_relax(); /* Requires interrupts be masked */
 800a9a0: f008 fa0b    	bl	0x8012dba <arch_spin_relax> @ imm = #0x8416
 800a9a4: 6bfb         	ldr	r3, [r7, #0x3c]
 800a9a6: 623b         	str	r3, [r7, #0x20]
 800a9a8: 6a3b         	ldr	r3, [r7, #0x20]
 800a9aa: 61fb         	str	r3, [r7, #0x1c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800a9ac: 69fb         	ldr	r3, [r7, #0x1c]
 800a9ae: f383 8811    	msr	basepri, r3
; }
 800a9b2: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800a9b4: f3bf 8f6f    	isb	sy
; }
 800a9b8: bf00         	nop
; }
 800a9ba: bf00         	nop
; 	while (is_halting(thread)) {
 800a9bc: 6878         	ldr	r0, [r7, #0x4]
 800a9be: f009 f82c    	bl	0x8013a1a <is_halting>  @ imm = #0x9058
 800a9c2: 4603         	mov	r3, r0
 800a9c4: 2b00         	cmp	r3, #0x0
 800a9c6: d1db         	bne	0x800a980 <thread_halt_spin+0x6c> @ imm = #-0x4a
; }
 800a9c8: bf00         	nop
 800a9ca: bf00         	nop
 800a9cc: 3744         	adds	r7, #0x44
 800a9ce: 46bd         	mov	sp, r7
 800a9d0: bd90         	pop	{r4, r7, pc}
 800a9d2: bf00         	nop

0800a9d4 <$d>:
 800a9d4: c0 02 00 20  	.word	0x200002c0
 800a9d8: e0 09 00 20  	.word	0x200009e0

0800a9dc <z_thread_halt>:
; {
 800a9dc: b580         	push	{r7, lr}
 800a9de: b094         	sub	sp, #0x50
 800a9e0: af00         	add	r7, sp, #0x0
 800a9e2: 60f8         	str	r0, [r7, #0xc]
 800a9e4: 60b9         	str	r1, [r7, #0x8]
 800a9e6: 4613         	mov	r3, r2
 800a9e8: 71fb         	strb	r3, [r7, #0x7]
; 	_wait_q_t *wq = &thread->join_queue;
 800a9ea: 68fb         	ldr	r3, [r7, #0xc]
 800a9ec: 3368         	adds	r3, #0x68
 800a9ee: 64fb         	str	r3, [r7, #0x4c]
; 	struct _cpu *cpu = thread_active_elsewhere(thread);
 800a9f0: 68f8         	ldr	r0, [r7, #0xc]
 800a9f2: f009 f842    	bl	0x8013a7a <thread_active_elsewhere> @ imm = #0x9084
 800a9f6: 64b8         	str	r0, [r7, #0x48]
; 	if (cpu != NULL) {
 800a9f8: 6cbb         	ldr	r3, [r7, #0x48]
 800a9fa: 2b00         	cmp	r3, #0x0
 800a9fc: d02f         	beq	0x800aa5e <z_thread_halt+0x82> @ imm = #0x5e
; 		thread->base.thread_state |= (terminate ? _THREAD_ABORTING
 800a9fe: 68fb         	ldr	r3, [r7, #0xc]
 800aa00: 7b5b         	ldrb	r3, [r3, #0xd]
 800aa02: 79fa         	ldrb	r2, [r7, #0x7]
 800aa04: 2a00         	cmp	r2, #0x0
 800aa06: d001         	beq	0x800aa0c <z_thread_halt+0x30> @ imm = #0x2
 800aa08: 2220         	movs	r2, #0x20
 800aa0a: e000         	b	0x800aa0e <z_thread_halt+0x32> @ imm = #0x0
 800aa0c: 2240         	movs	r2, #0x40
 800aa0e: 4313         	orrs	r3, r2
 800aa10: b2da         	uxtb	r2, r3
 800aa12: 68fb         	ldr	r3, [r7, #0xc]
 800aa14: 735a         	strb	r2, [r3, #0xd]
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800aa16: f3ef 8305    	mrs	r3, ipsr
 800aa1a: 647b         	str	r3, [r7, #0x44]
;   return(result);
 800aa1c: 6c7b         	ldr	r3, [r7, #0x44]
; 	return (__get_IPSR()) ? (true) : (false);
 800aa1e: 2b00         	cmp	r3, #0x0
 800aa20: bf14         	ite	ne
 800aa22: 2301         	movne	r3, #0x1
 800aa24: 2300         	moveq	r3, #0x0
 800aa26: b2db         	uxtb	r3, r3
; 		if (arch_is_in_isr()) {
 800aa28: 2b00         	cmp	r3, #0x0
 800aa2a: d004         	beq	0x800aa36 <z_thread_halt+0x5a> @ imm = #0x8
; 			thread_halt_spin(thread, key);
 800aa2c: 68b9         	ldr	r1, [r7, #0x8]
 800aa2e: 68f8         	ldr	r0, [r7, #0xc]
 800aa30: f7ff ff70    	bl	0x800a914 <thread_halt_spin> @ imm = #-0x120
; }
 800aa34: e04f         	b	0x800aad6 <z_thread_halt+0xfa> @ imm = #0x9e
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800aa36: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x800aae0 <z_thread_halt+0x104>
 800aa38: 689b         	ldr	r3, [r3, #0x8]
 800aa3a: 63bb         	str	r3, [r7, #0x38]
; 	return ret;
 800aa3c: 6bbb         	ldr	r3, [r7, #0x38]
; 			add_to_waitq_locked(arch_current_thread(), wq);
 800aa3e: 6cf9         	ldr	r1, [r7, #0x4c]
 800aa40: 4618         	mov	r0, r3
 800aa42: f009 f824    	bl	0x8013a8e <add_to_waitq_locked> @ imm = #0x9048
 800aa46: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x800aae4 <z_thread_halt+0x108>
 800aa48: 643b         	str	r3, [r7, #0x40]
 800aa4a: 68bb         	ldr	r3, [r7, #0x8]
 800aa4c: 613b         	str	r3, [r7, #0x10]
 800aa4e: 6c3b         	ldr	r3, [r7, #0x40]
 800aa50: 63fb         	str	r3, [r7, #0x3c]
; }
 800aa52: bf00         	nop
; 	return z_swap_irqlock(key.key);
 800aa54: 693b         	ldr	r3, [r7, #0x10]
 800aa56: 4618         	mov	r0, r3
 800aa58: f008 ff7d    	bl	0x8013956 <z_swap_irqlock> @ imm = #0x8efa
 800aa5c: e03b         	b	0x800aad6 <z_thread_halt+0xfa> @ imm = #0x76
; 		halt_thread(thread, terminate ? _THREAD_DEAD : _THREAD_SUSPENDED);
 800aa5e: 79fb         	ldrb	r3, [r7, #0x7]
 800aa60: 2b00         	cmp	r3, #0x0
 800aa62: d001         	beq	0x800aa68 <z_thread_halt+0x8c> @ imm = #0x2
 800aa64: 2308         	movs	r3, #0x8
 800aa66: e000         	b	0x800aa6a <z_thread_halt+0x8e> @ imm = #0x0
 800aa68: 2310         	movs	r3, #0x10
 800aa6a: 4619         	mov	r1, r3
 800aa6c: 68f8         	ldr	r0, [r7, #0xc]
 800aa6e: f000 ffb1    	bl	0x800b9d4 <halt_thread> @ imm = #0xf62
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800aa72: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x800aae0 <z_thread_halt+0x104>
 800aa74: 689b         	ldr	r3, [r3, #0x8]
 800aa76: 637b         	str	r3, [r7, #0x34]
; 	return ret;
 800aa78: 6b7b         	ldr	r3, [r7, #0x34]
; 		if ((thread == arch_current_thread()) && !arch_is_in_isr()) {
 800aa7a: 68fa         	ldr	r2, [r7, #0xc]
 800aa7c: 429a         	cmp	r2, r3
 800aa7e: d119         	bne	0x800aab4 <z_thread_halt+0xd8> @ imm = #0x32
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800aa80: f3ef 8305    	mrs	r3, ipsr
 800aa84: 633b         	str	r3, [r7, #0x30]
;   return(result);
 800aa86: 6b3b         	ldr	r3, [r7, #0x30]
; 	return (__get_IPSR()) ? (true) : (false);
 800aa88: 2b00         	cmp	r3, #0x0
 800aa8a: bf14         	ite	ne
 800aa8c: 2301         	movne	r3, #0x1
 800aa8e: 2300         	moveq	r3, #0x0
 800aa90: b2db         	uxtb	r3, r3
; 		if ((thread == arch_current_thread()) && !arch_is_in_isr()) {
 800aa92: f083 0301    	eor	r3, r3, #0x1
 800aa96: b2db         	uxtb	r3, r3
 800aa98: 2b00         	cmp	r3, #0x0
 800aa9a: d00b         	beq	0x800aab4 <z_thread_halt+0xd8> @ imm = #0x16
 800aa9c: 4b11         	ldr	r3, [pc, #0x44]         @ 0x800aae4 <z_thread_halt+0x108>
 800aa9e: 62fb         	str	r3, [r7, #0x2c]
 800aaa0: 68bb         	ldr	r3, [r7, #0x8]
 800aaa2: 617b         	str	r3, [r7, #0x14]
 800aaa4: 6afb         	ldr	r3, [r7, #0x2c]
 800aaa6: 62bb         	str	r3, [r7, #0x28]
; }
 800aaa8: bf00         	nop
; 	return z_swap_irqlock(key.key);
 800aaaa: 697b         	ldr	r3, [r7, #0x14]
 800aaac: 4618         	mov	r0, r3
 800aaae: f008 ff52    	bl	0x8013956 <z_swap_irqlock> @ imm = #0x8ea4
; 			z_swap(&_sched_spinlock, key);
 800aab2: e010         	b	0x800aad6 <z_thread_halt+0xfa> @ imm = #0x20
 800aab4: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800aae4 <z_thread_halt+0x108>
 800aab6: 627b         	str	r3, [r7, #0x24]
 800aab8: 68bb         	ldr	r3, [r7, #0x8]
 800aaba: 61bb         	str	r3, [r7, #0x18]
; 	arch_irq_unlock(key.key);
 800aabc: 69bb         	ldr	r3, [r7, #0x18]
 800aabe: 623b         	str	r3, [r7, #0x20]
 800aac0: 6a3b         	ldr	r3, [r7, #0x20]
 800aac2: 61fb         	str	r3, [r7, #0x1c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800aac4: 69fb         	ldr	r3, [r7, #0x1c]
 800aac6: f383 8811    	msr	basepri, r3
; }
 800aaca: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800aacc: f3bf 8f6f    	isb	sy
; }
 800aad0: bf00         	nop
; }
 800aad2: bf00         	nop
; }
 800aad4: bf00         	nop
; }
 800aad6: bf00         	nop
 800aad8: 3750         	adds	r7, #0x50
 800aada: 46bd         	mov	sp, r7
 800aadc: bd80         	pop	{r7, pc}
 800aade: bf00         	nop

0800aae0 <$d>:
 800aae0: c0 02 00 20  	.word	0x200002c0
 800aae4: e0 09 00 20  	.word	0x200009e0

0800aae8 <z_impl_k_thread_suspend>:
; {
 800aae8: b580         	push	{r7, lr}
 800aaea: b0ac         	sub	sp, #0xb0
 800aaec: af00         	add	r7, sp, #0x0
 800aaee: 6078         	str	r0, [r7, #0x4]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800aaf0: 4b8e         	ldr	r3, [pc, #0x238]        @ 0x800ad2c <z_impl_k_thread_suspend+0x244>
 800aaf2: 689b         	ldr	r3, [r3, #0x8]
 800aaf4: f8c7 30ac    	str.w	r3, [r7, #0xac]
; 	return ret;
 800aaf8: f8d7 30ac    	ldr.w	r3, [r7, #0xac]
; 	if (thread == arch_current_thread() && !arch_is_in_isr() && !IS_ENABLED(CONFIG_SMP)) {
 800aafc: 687a         	ldr	r2, [r7, #0x4]
 800aafe: 429a         	cmp	r2, r3
 800ab00: f040 80d7    	bne.w	0x800acb2 <z_impl_k_thread_suspend+0x1ca> @ imm = #0x1ae
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800ab04: f3ef 8305    	mrs	r3, ipsr
 800ab08: f8c7 30a8    	str.w	r3, [r7, #0xa8]
;   return(result);
 800ab0c: f8d7 30a8    	ldr.w	r3, [r7, #0xa8]
; 	return (__get_IPSR()) ? (true) : (false);
 800ab10: 2b00         	cmp	r3, #0x0
 800ab12: bf14         	ite	ne
 800ab14: 2301         	movne	r3, #0x1
 800ab16: 2300         	moveq	r3, #0x0
 800ab18: b2db         	uxtb	r3, r3
; 	if (thread == arch_current_thread() && !arch_is_in_isr() && !IS_ENABLED(CONFIG_SMP)) {
 800ab1a: f083 0301    	eor	r3, r3, #0x1
 800ab1e: b2db         	uxtb	r3, r3
 800ab20: 2b00         	cmp	r3, #0x0
 800ab22: f000 80c6    	beq.w	0x800acb2 <z_impl_k_thread_suspend+0x1ca> @ imm = #0x18c
 800ab26: 4b82         	ldr	r3, [pc, #0x208]        @ 0x800ad30 <z_impl_k_thread_suspend+0x248>
 800ab28: 65bb         	str	r3, [r7, #0x58]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800ab2a: f3ef 8311    	mrs	r3, basepri
 800ab2e: 657b         	str	r3, [r7, #0x54]
;   return(result);
 800ab30: 6d7b         	ldr	r3, [r7, #0x54]
; 	key = __get_BASEPRI();
 800ab32: 653b         	str	r3, [r7, #0x50]
 800ab34: 2310         	movs	r3, #0x10
 800ab36: 64fb         	str	r3, [r7, #0x4c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800ab38: 6cfb         	ldr	r3, [r7, #0x4c]
 800ab3a: f383 8812    	msr	basepri_max, r3
; }
 800ab3e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800ab40: f3bf 8f6f    	isb	sy
; }
 800ab44: bf00         	nop
; 	return key;
 800ab46: 6d3b         	ldr	r3, [r7, #0x50]
; 	k.key = arch_irq_lock();
 800ab48: 60fb         	str	r3, [r7, #0xc]
 800ab4a: 6dbb         	ldr	r3, [r7, #0x58]
 800ab4c: 64bb         	str	r3, [r7, #0x48]
; }
 800ab4e: bf00         	nop
 800ab50: 6dbb         	ldr	r3, [r7, #0x58]
 800ab52: 647b         	str	r3, [r7, #0x44]
; }
 800ab54: bf00         	nop
; 	return k;
 800ab56: 68fb         	ldr	r3, [r7, #0xc]
 800ab58: 613b         	str	r3, [r7, #0x10]
; 		z_mark_thread_as_suspended(thread);
 800ab5a: 6878         	ldr	r0, [r7, #0x4]
 800ab5c: f008 fe69    	bl	0x8013832 <z_mark_thread_as_suspended> @ imm = #0x8cd2
 800ab60: 687b         	ldr	r3, [r7, #0x4]
 800ab62: 66fb         	str	r3, [r7, #0x6c]
; 	thread->base.thread_state &= ~_THREAD_QUEUED;
 800ab64: 6efb         	ldr	r3, [r7, #0x6c]
 800ab66: 7b5b         	ldrb	r3, [r3, #0xd]
 800ab68: f003 037f    	and	r3, r3, #0x7f
 800ab6c: b2da         	uxtb	r2, r3
 800ab6e: 6efb         	ldr	r3, [r7, #0x6c]
 800ab70: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 800ab72: 6ef8         	ldr	r0, [r7, #0x6c]
 800ab74: f008 ff35    	bl	0x80139e2 <should_queue_thread> @ imm = #0x8e6a
 800ab78: 4603         	mov	r3, r0
 800ab7a: 2b00         	cmp	r3, #0x0
 800ab7c: d00d         	beq	0x800ab9a <z_impl_k_thread_suspend+0xb2> @ imm = #0x1a
 800ab7e: 6efb         	ldr	r3, [r7, #0x6c]
 800ab80: 66bb         	str	r3, [r7, #0x68]
 800ab82: 6ebb         	ldr	r3, [r7, #0x68]
 800ab84: 667b         	str	r3, [r7, #0x64]
; 	return &_kernel.ready_q.runq;
 800ab86: 4b6b         	ldr	r3, [pc, #0x1ac]        @ 0x800ad34 <z_impl_k_thread_suspend+0x24c>
 800ab88: 663b         	str	r3, [r7, #0x60]
 800ab8a: 6ebb         	ldr	r3, [r7, #0x68]
 800ab8c: 65fb         	str	r3, [r7, #0x5c]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 800ab8e: 6dfb         	ldr	r3, [r7, #0x5c]
 800ab90: 4618         	mov	r0, r3
 800ab92: f008 fd66    	bl	0x8013662 <sys_dlist_remove> @ imm = #0x8acc
; }
 800ab96: bf00         	nop
; }
 800ab98: bf00         	nop
; }
 800ab9a: bf00         	nop
 800ab9c: 2301         	movs	r3, #0x1
 800ab9e: f8c7 309c    	str.w	r3, [r7, #0x9c]
; 	return &_kernel.ready_q.runq;
 800aba2: 4b64         	ldr	r3, [pc, #0x190]        @ 0x800ad34 <z_impl_k_thread_suspend+0x24c>
 800aba4: f8c7 3098    	str.w	r3, [r7, #0x98]
; 	struct k_thread *thread = NULL;
 800aba8: 2300         	movs	r3, #0x0
 800abaa: f8c7 3094    	str.w	r3, [r7, #0x94]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 800abae: f8d7 0098    	ldr.w	r0, [r7, #0x98]
 800abb2: f008 fcec    	bl	0x801358e <sys_dlist_peek_head> @ imm = #0x89d8
 800abb6: f8c7 0090    	str.w	r0, [r7, #0x90]
; 	if (n != NULL) {
 800abba: f8d7 3090    	ldr.w	r3, [r7, #0x90]
 800abbe: 2b00         	cmp	r3, #0x0
 800abc0: d003         	beq	0x800abca <z_impl_k_thread_suspend+0xe2> @ imm = #0x6
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 800abc2: f8d7 3090    	ldr.w	r3, [r7, #0x90]
 800abc6: f8c7 3094    	str.w	r3, [r7, #0x94]
; 	return thread;
 800abca: f8d7 3094    	ldr.w	r3, [r7, #0x94]
; 	return _priq_run_best(curr_cpu_runq());
 800abce: bf00         	nop
; 	struct k_thread *thread = runq_best();
 800abd0: f8c7 308c    	str.w	r3, [r7, #0x8c]
; 	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 800abd4: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 800abd8: 2b00         	cmp	r3, #0x0
 800abda: d102         	bne	0x800abe2 <z_impl_k_thread_suspend+0xfa> @ imm = #0x4
 800abdc: 4b53         	ldr	r3, [pc, #0x14c]        @ 0x800ad2c <z_impl_k_thread_suspend+0x244>
 800abde: 68db         	ldr	r3, [r3, #0xc]
 800abe0: e001         	b	0x800abe6 <z_impl_k_thread_suspend+0xfe> @ imm = #0x2
 800abe2: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
; 	struct k_thread *thread = next_up();
 800abe6: f8c7 3088    	str.w	r3, [r7, #0x88]
 800abea: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 800abee: f8c7 3084    	str.w	r3, [r7, #0x84]
 800abf2: f8d7 309c    	ldr.w	r3, [r7, #0x9c]
 800abf6: f8c7 3080    	str.w	r3, [r7, #0x80]
; 	if (preempt_ok != 0) {
 800abfa: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 800abfe: 2b00         	cmp	r3, #0x0
 800ac00: d001         	beq	0x800ac06 <z_impl_k_thread_suspend+0x11e> @ imm = #0x2
; 		return true;
 800ac02: 2301         	movs	r3, #0x1
 800ac04: e028         	b	0x800ac58 <z_impl_k_thread_suspend+0x170> @ imm = #0x50
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800ac06: 4b49         	ldr	r3, [pc, #0x124]        @ 0x800ad2c <z_impl_k_thread_suspend+0x244>
 800ac08: 689b         	ldr	r3, [r3, #0x8]
 800ac0a: 67fb         	str	r3, [r7, #0x7c]
; 	return ret;
 800ac0c: 6ffb         	ldr	r3, [r7, #0x7c]
; 	if (z_is_thread_prevented_from_running(arch_current_thread())) {
 800ac0e: 4618         	mov	r0, r3
 800ac10: f008 fda1    	bl	0x8013756 <z_is_thread_prevented_from_running> @ imm = #0x8b42
 800ac14: 4603         	mov	r3, r0
 800ac16: 2b00         	cmp	r3, #0x0
 800ac18: d001         	beq	0x800ac1e <z_impl_k_thread_suspend+0x136> @ imm = #0x2
; 		return true;
 800ac1a: 2301         	movs	r3, #0x1
 800ac1c: e01c         	b	0x800ac58 <z_impl_k_thread_suspend+0x170> @ imm = #0x38
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800ac1e: 4b43         	ldr	r3, [pc, #0x10c]        @ 0x800ad2c <z_impl_k_thread_suspend+0x244>
 800ac20: 689b         	ldr	r3, [r3, #0x8]
 800ac22: 67bb         	str	r3, [r7, #0x78]
; 	return ret;
 800ac24: 6fbb         	ldr	r3, [r7, #0x78]
; 	if (thread_is_preemptible(arch_current_thread()) || thread_is_metairq(thread)) {
 800ac26: 4618         	mov	r0, r3
 800ac28: f008 fd69    	bl	0x80136fe <thread_is_preemptible> @ imm = #0x8ad2
 800ac2c: 4603         	mov	r3, r0
 800ac2e: 2b00         	cmp	r3, #0x0
 800ac30: d106         	bne	0x800ac40 <z_impl_k_thread_suspend+0x158> @ imm = #0xc
 800ac32: f8d7 0084    	ldr.w	r0, [r7, #0x84]
 800ac36: f008 fd72    	bl	0x801371e <thread_is_metairq> @ imm = #0x8ae4
 800ac3a: 4603         	mov	r3, r0
 800ac3c: 2b00         	cmp	r3, #0x0
 800ac3e: d001         	beq	0x800ac44 <z_impl_k_thread_suspend+0x15c> @ imm = #0x2
; 		return true;
 800ac40: 2301         	movs	r3, #0x1
 800ac42: e009         	b	0x800ac58 <z_impl_k_thread_suspend+0x170> @ imm = #0x12
; 	    && z_is_thread_timeout_active(thread)) {
 800ac44: f8d7 0084    	ldr.w	r0, [r7, #0x84]
 800ac48: f008 fd99    	bl	0x801377e <z_is_thread_timeout_active> @ imm = #0x8b32
 800ac4c: 4603         	mov	r3, r0
; 	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 800ac4e: 2b00         	cmp	r3, #0x0
 800ac50: d001         	beq	0x800ac56 <z_impl_k_thread_suspend+0x16e> @ imm = #0x2
; 		return true;
 800ac52: 2301         	movs	r3, #0x1
 800ac54: e000         	b	0x800ac58 <z_impl_k_thread_suspend+0x170> @ imm = #0x0
; 	return false;
 800ac56: 2300         	movs	r3, #0x0
; 	if (should_preempt(thread, preempt_ok)) {
 800ac58: 2b00         	cmp	r3, #0x0
 800ac5a: d014         	beq	0x800ac86 <z_impl_k_thread_suspend+0x19e> @ imm = #0x28
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800ac5c: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x800ad2c <z_impl_k_thread_suspend+0x244>
 800ac5e: 689b         	ldr	r3, [r3, #0x8]
 800ac60: 677b         	str	r3, [r7, #0x74]
; 	return ret;
 800ac62: 6f7b         	ldr	r3, [r7, #0x74]
; 		if (thread != arch_current_thread()) {
 800ac64: f8d7 2088    	ldr.w	r2, [r7, #0x88]
 800ac68: 429a         	cmp	r2, r3
 800ac6a: d003         	beq	0x800ac74 <z_impl_k_thread_suspend+0x18c> @ imm = #0x6
; 			z_reset_time_slice(thread);
 800ac6c: f8d7 0088    	ldr.w	r0, [r7, #0x88]
 800ac70: f001 f87c    	bl	0x800bd6c <z_reset_time_slice> @ imm = #0x10f8
; 		update_metairq_preempt(thread);
 800ac74: f8d7 0088    	ldr.w	r0, [r7, #0x88]
 800ac78: f008 fef6    	bl	0x8013a68 <update_metairq_preempt> @ imm = #0x8dec
; 		_kernel.ready_q.cache = thread;
 800ac7c: 4a2b         	ldr	r2, [pc, #0xac]         @ 0x800ad2c <z_impl_k_thread_suspend+0x244>
 800ac7e: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 800ac82: 61d3         	str	r3, [r2, #0x1c]
; }
 800ac84: e005         	b	0x800ac92 <z_impl_k_thread_suspend+0x1aa> @ imm = #0xa
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800ac86: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x800ad2c <z_impl_k_thread_suspend+0x244>
 800ac88: 689b         	ldr	r3, [r3, #0x8]
 800ac8a: 673b         	str	r3, [r7, #0x70]
; 	return ret;
 800ac8c: 6f3b         	ldr	r3, [r7, #0x70]
; 		_kernel.ready_q.cache = arch_current_thread();
 800ac8e: 4a27         	ldr	r2, [pc, #0x9c]         @ 0x800ad2c <z_impl_k_thread_suspend+0x244>
 800ac90: 61d3         	str	r3, [r2, #0x1c]
; }
 800ac92: bf00         	nop
 800ac94: 4b26         	ldr	r3, [pc, #0x98]         @ 0x800ad30 <z_impl_k_thread_suspend+0x248>
 800ac96: f8c7 30a4    	str.w	r3, [r7, #0xa4]
 800ac9a: 693b         	ldr	r3, [r7, #0x10]
 800ac9c: 60bb         	str	r3, [r7, #0x8]
 800ac9e: f8d7 30a4    	ldr.w	r3, [r7, #0xa4]
 800aca2: f8c7 30a0    	str.w	r3, [r7, #0xa0]
; }
 800aca6: bf00         	nop
; 	return z_swap_irqlock(key.key);
 800aca8: 68bb         	ldr	r3, [r7, #0x8]
 800acaa: 4618         	mov	r0, r3
 800acac: f008 fe53    	bl	0x8013956 <z_swap_irqlock> @ imm = #0x8ca6
 800acb0: e039         	b	0x800ad26 <z_impl_k_thread_suspend+0x23e> @ imm = #0x72
; 	(void)z_abort_thread_timeout(thread);
 800acb2: 6878         	ldr	r0, [r7, #0x4]
 800acb4: f008 fd15    	bl	0x80136e2 <z_abort_thread_timeout> @ imm = #0x8a2a
 800acb8: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x800ad30 <z_impl_k_thread_suspend+0x248>
 800acba: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800acbc: f3ef 8311    	mrs	r3, basepri
 800acc0: 63fb         	str	r3, [r7, #0x3c]
;   return(result);
 800acc2: 6bfb         	ldr	r3, [r7, #0x3c]
; 	key = __get_BASEPRI();
 800acc4: 63bb         	str	r3, [r7, #0x38]
 800acc6: 2310         	movs	r3, #0x10
 800acc8: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800acca: 6b7b         	ldr	r3, [r7, #0x34]
 800accc: f383 8812    	msr	basepri_max, r3
; }
 800acd0: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800acd2: f3bf 8f6f    	isb	sy
; }
 800acd6: bf00         	nop
; 	return key;
 800acd8: 6bbb         	ldr	r3, [r7, #0x38]
; 	k.key = arch_irq_lock();
 800acda: 617b         	str	r3, [r7, #0x14]
 800acdc: 6c3b         	ldr	r3, [r7, #0x40]
 800acde: 633b         	str	r3, [r7, #0x30]
; }
 800ace0: bf00         	nop
 800ace2: 6c3b         	ldr	r3, [r7, #0x40]
 800ace4: 62fb         	str	r3, [r7, #0x2c]
; }
 800ace6: bf00         	nop
; 	return k;
 800ace8: 697b         	ldr	r3, [r7, #0x14]
 800acea: 61fb         	str	r3, [r7, #0x1c]
; 	if ((thread->base.thread_state & _THREAD_SUSPENDED) != 0U) {
 800acec: 687b         	ldr	r3, [r7, #0x4]
 800acee: 7b5b         	ldrb	r3, [r3, #0xd]
 800acf0: f003 0310    	and	r3, r3, #0x10
 800acf4: 2b00         	cmp	r3, #0x0
 800acf6: d011         	beq	0x800ad1c <z_impl_k_thread_suspend+0x234> @ imm = #0x22
 800acf8: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800ad30 <z_impl_k_thread_suspend+0x248>
 800acfa: 62bb         	str	r3, [r7, #0x28]
 800acfc: 69fb         	ldr	r3, [r7, #0x1c]
 800acfe: 61bb         	str	r3, [r7, #0x18]
; 	arch_irq_unlock(key.key);
 800ad00: 69bb         	ldr	r3, [r7, #0x18]
 800ad02: 627b         	str	r3, [r7, #0x24]
 800ad04: 6a7b         	ldr	r3, [r7, #0x24]
 800ad06: 623b         	str	r3, [r7, #0x20]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800ad08: 6a3b         	ldr	r3, [r7, #0x20]
 800ad0a: f383 8811    	msr	basepri, r3
; }
 800ad0e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800ad10: f3bf 8f6f    	isb	sy
; }
 800ad14: bf00         	nop
; }
 800ad16: bf00         	nop
; }
 800ad18: bf00         	nop
; 		return;
 800ad1a: e004         	b	0x800ad26 <z_impl_k_thread_suspend+0x23e> @ imm = #0x8
; 	z_thread_halt(thread, key, false);
 800ad1c: 2200         	movs	r2, #0x0
 800ad1e: 69f9         	ldr	r1, [r7, #0x1c]
 800ad20: 6878         	ldr	r0, [r7, #0x4]
 800ad22: f7ff fe5b    	bl	0x800a9dc <z_thread_halt> @ imm = #-0x34a
; }
 800ad26: 37b0         	adds	r7, #0xb0
 800ad28: 46bd         	mov	sp, r7
 800ad2a: bd80         	pop	{r7, pc}

0800ad2c <$d>:
 800ad2c: c0 02 00 20  	.word	0x200002c0
 800ad30: e0 09 00 20  	.word	0x200009e0
 800ad34: e0 02 00 20  	.word	0x200002e0

0800ad38 <z_impl_k_thread_resume>:
; {
 800ad38: b580         	push	{r7, lr}
 800ad3a: b08e         	sub	sp, #0x38
 800ad3c: af00         	add	r7, sp, #0x0
 800ad3e: 6078         	str	r0, [r7, #0x4]
 800ad40: 4b20         	ldr	r3, [pc, #0x80]         @ 0x800adc4 <z_impl_k_thread_resume+0x8c>
 800ad42: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800ad44: f3ef 8311    	mrs	r3, basepri
 800ad48: 633b         	str	r3, [r7, #0x30]
;   return(result);
 800ad4a: 6b3b         	ldr	r3, [r7, #0x30]
; 	key = __get_BASEPRI();
 800ad4c: 62fb         	str	r3, [r7, #0x2c]
 800ad4e: 2310         	movs	r3, #0x10
 800ad50: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800ad52: 6abb         	ldr	r3, [r7, #0x28]
 800ad54: f383 8812    	msr	basepri_max, r3
; }
 800ad58: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800ad5a: f3bf 8f6f    	isb	sy
; }
 800ad5e: bf00         	nop
; 	return key;
 800ad60: 6afb         	ldr	r3, [r7, #0x2c]
; 	k.key = arch_irq_lock();
 800ad62: 60bb         	str	r3, [r7, #0x8]
 800ad64: 6b7b         	ldr	r3, [r7, #0x34]
 800ad66: 627b         	str	r3, [r7, #0x24]
; }
 800ad68: bf00         	nop
 800ad6a: 6b7b         	ldr	r3, [r7, #0x34]
 800ad6c: 623b         	str	r3, [r7, #0x20]
; }
 800ad6e: bf00         	nop
; 	return k;
 800ad70: 68bb         	ldr	r3, [r7, #0x8]
 800ad72: 613b         	str	r3, [r7, #0x10]
; 	if (!z_is_thread_suspended(thread)) {
 800ad74: 6878         	ldr	r0, [r7, #0x4]
 800ad76: f008 fcdc    	bl	0x8013732 <z_is_thread_suspended> @ imm = #0x89b8
 800ad7a: 4603         	mov	r3, r0
 800ad7c: f083 0301    	eor	r3, r3, #0x1
 800ad80: b2db         	uxtb	r3, r3
 800ad82: 2b00         	cmp	r3, #0x0
 800ad84: d010         	beq	0x800ada8 <z_impl_k_thread_resume+0x70> @ imm = #0x20
 800ad86: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x800adc4 <z_impl_k_thread_resume+0x8c>
 800ad88: 61fb         	str	r3, [r7, #0x1c]
 800ad8a: 693b         	ldr	r3, [r7, #0x10]
 800ad8c: 60fb         	str	r3, [r7, #0xc]
; 	arch_irq_unlock(key.key);
 800ad8e: 68fb         	ldr	r3, [r7, #0xc]
 800ad90: 61bb         	str	r3, [r7, #0x18]
 800ad92: 69bb         	ldr	r3, [r7, #0x18]
 800ad94: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800ad96: 697b         	ldr	r3, [r7, #0x14]
 800ad98: f383 8811    	msr	basepri, r3
; }
 800ad9c: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800ad9e: f3bf 8f6f    	isb	sy
; }
 800ada2: bf00         	nop
; }
 800ada4: bf00         	nop
; }
 800ada6: e009         	b	0x800adbc <z_impl_k_thread_resume+0x84> @ imm = #0x12
; 	z_mark_thread_as_not_suspended(thread);
 800ada8: 6878         	ldr	r0, [r7, #0x4]
 800adaa: f008 fd52    	bl	0x8013852 <z_mark_thread_as_not_suspended> @ imm = #0x8aa4
; 	ready_thread(thread);
 800adae: 6878         	ldr	r0, [r7, #0x4]
 800adb0: f7ff fc94    	bl	0x800a6dc <ready_thread> @ imm = #-0x6d8
; 	z_reschedule(&_sched_spinlock, key);
 800adb4: 6939         	ldr	r1, [r7, #0x10]
 800adb6: 4803         	ldr	r0, [pc, #0xc]          @ 0x800adc4 <z_impl_k_thread_resume+0x8c>
 800adb8: f008 ff20    	bl	0x8013bfc <z_reschedule> @ imm = #0x8e40
; }
 800adbc: 3738         	adds	r7, #0x38
 800adbe: 46bd         	mov	sp, r7
 800adc0: bd80         	pop	{r7, pc}
 800adc2: bf00         	nop

0800adc4 <$d>:
 800adc4: e0 09 00 20  	.word	0x200009e0

0800adc8 <unready_thread>:
; {
 800adc8: b580         	push	{r7, lr}
 800adca: b094         	sub	sp, #0x50
 800adcc: af00         	add	r7, sp, #0x0
 800adce: 6078         	str	r0, [r7, #0x4]
; 	if (z_is_thread_queued(thread)) {
 800add0: 6878         	ldr	r0, [r7, #0x4]
 800add2: f008 fd21    	bl	0x8013818 <z_is_thread_queued> @ imm = #0x8a42
 800add6: 4603         	mov	r3, r0
 800add8: 2b00         	cmp	r3, #0x0
 800adda: d01d         	beq	0x800ae18 <unready_thread+0x50> @ imm = #0x3a
 800addc: 687b         	ldr	r3, [r7, #0x4]
 800adde: 64fb         	str	r3, [r7, #0x4c]
; 	thread->base.thread_state &= ~_THREAD_QUEUED;
 800ade0: 6cfb         	ldr	r3, [r7, #0x4c]
 800ade2: 7b5b         	ldrb	r3, [r3, #0xd]
 800ade4: f003 037f    	and	r3, r3, #0x7f
 800ade8: b2da         	uxtb	r2, r3
 800adea: 6cfb         	ldr	r3, [r7, #0x4c]
 800adec: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 800adee: 6cf8         	ldr	r0, [r7, #0x4c]
 800adf0: f008 fdf7    	bl	0x80139e2 <should_queue_thread> @ imm = #0x8bee
 800adf4: 4603         	mov	r3, r0
 800adf6: 2b00         	cmp	r3, #0x0
 800adf8: d00d         	beq	0x800ae16 <unready_thread+0x4e> @ imm = #0x1a
 800adfa: 6cfb         	ldr	r3, [r7, #0x4c]
 800adfc: 64bb         	str	r3, [r7, #0x48]
 800adfe: 6cbb         	ldr	r3, [r7, #0x48]
 800ae00: 647b         	str	r3, [r7, #0x44]
; 	return &_kernel.ready_q.runq;
 800ae02: 4b3e         	ldr	r3, [pc, #0xf8]         @ 0x800aefc <unready_thread+0x134>
 800ae04: 643b         	str	r3, [r7, #0x40]
 800ae06: 6cbb         	ldr	r3, [r7, #0x48]
 800ae08: 63fb         	str	r3, [r7, #0x3c]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 800ae0a: 6bfb         	ldr	r3, [r7, #0x3c]
 800ae0c: 4618         	mov	r0, r3
 800ae0e: f008 fc28    	bl	0x8013662 <sys_dlist_remove> @ imm = #0x8850
; }
 800ae12: bf00         	nop
; }
 800ae14: bf00         	nop
; }
 800ae16: bf00         	nop
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800ae18: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x800af00 <unready_thread+0x138>
 800ae1a: 689b         	ldr	r3, [r3, #0x8]
 800ae1c: 60bb         	str	r3, [r7, #0x8]
; 	return ret;
 800ae1e: 68bb         	ldr	r3, [r7, #0x8]
; 	update_cache(thread == arch_current_thread());
 800ae20: 687a         	ldr	r2, [r7, #0x4]
 800ae22: 429a         	cmp	r2, r3
 800ae24: bf0c         	ite	eq
 800ae26: 2301         	moveq	r3, #0x1
 800ae28: 2300         	movne	r3, #0x0
 800ae2a: b2db         	uxtb	r3, r3
 800ae2c: 63bb         	str	r3, [r7, #0x38]
; 	return &_kernel.ready_q.runq;
 800ae2e: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x800aefc <unready_thread+0x134>
 800ae30: 637b         	str	r3, [r7, #0x34]
; 	struct k_thread *thread = NULL;
 800ae32: 2300         	movs	r3, #0x0
 800ae34: 633b         	str	r3, [r7, #0x30]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 800ae36: 6b78         	ldr	r0, [r7, #0x34]
 800ae38: f008 fba9    	bl	0x801358e <sys_dlist_peek_head> @ imm = #0x8752
 800ae3c: 62f8         	str	r0, [r7, #0x2c]
; 	if (n != NULL) {
 800ae3e: 6afb         	ldr	r3, [r7, #0x2c]
 800ae40: 2b00         	cmp	r3, #0x0
 800ae42: d001         	beq	0x800ae48 <unready_thread+0x80> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 800ae44: 6afb         	ldr	r3, [r7, #0x2c]
 800ae46: 633b         	str	r3, [r7, #0x30]
; 	return thread;
 800ae48: 6b3b         	ldr	r3, [r7, #0x30]
; 	return _priq_run_best(curr_cpu_runq());
 800ae4a: bf00         	nop
; 	struct k_thread *thread = runq_best();
 800ae4c: 62bb         	str	r3, [r7, #0x28]
; 	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 800ae4e: 6abb         	ldr	r3, [r7, #0x28]
 800ae50: 2b00         	cmp	r3, #0x0
 800ae52: d102         	bne	0x800ae5a <unready_thread+0x92> @ imm = #0x4
 800ae54: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x800af00 <unready_thread+0x138>
 800ae56: 68db         	ldr	r3, [r3, #0xc]
 800ae58: e000         	b	0x800ae5c <unready_thread+0x94> @ imm = #0x0
 800ae5a: 6abb         	ldr	r3, [r7, #0x28]
; 	struct k_thread *thread = next_up();
 800ae5c: 627b         	str	r3, [r7, #0x24]
 800ae5e: 6a7b         	ldr	r3, [r7, #0x24]
 800ae60: 623b         	str	r3, [r7, #0x20]
 800ae62: 6bbb         	ldr	r3, [r7, #0x38]
 800ae64: 61fb         	str	r3, [r7, #0x1c]
; 	if (preempt_ok != 0) {
 800ae66: 69fb         	ldr	r3, [r7, #0x1c]
 800ae68: 2b00         	cmp	r3, #0x0
 800ae6a: d001         	beq	0x800ae70 <unready_thread+0xa8> @ imm = #0x2
; 		return true;
 800ae6c: 2301         	movs	r3, #0x1
 800ae6e: e026         	b	0x800aebe <unready_thread+0xf6> @ imm = #0x4c
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800ae70: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x800af00 <unready_thread+0x138>
 800ae72: 689b         	ldr	r3, [r3, #0x8]
 800ae74: 61bb         	str	r3, [r7, #0x18]
; 	return ret;
 800ae76: 69bb         	ldr	r3, [r7, #0x18]
; 	if (z_is_thread_prevented_from_running(arch_current_thread())) {
 800ae78: 4618         	mov	r0, r3
 800ae7a: f008 fc6c    	bl	0x8013756 <z_is_thread_prevented_from_running> @ imm = #0x88d8
 800ae7e: 4603         	mov	r3, r0
 800ae80: 2b00         	cmp	r3, #0x0
 800ae82: d001         	beq	0x800ae88 <unready_thread+0xc0> @ imm = #0x2
; 		return true;
 800ae84: 2301         	movs	r3, #0x1
 800ae86: e01a         	b	0x800aebe <unready_thread+0xf6> @ imm = #0x34
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800ae88: 4b1d         	ldr	r3, [pc, #0x74]         @ 0x800af00 <unready_thread+0x138>
 800ae8a: 689b         	ldr	r3, [r3, #0x8]
 800ae8c: 617b         	str	r3, [r7, #0x14]
; 	return ret;
 800ae8e: 697b         	ldr	r3, [r7, #0x14]
; 	if (thread_is_preemptible(arch_current_thread()) || thread_is_metairq(thread)) {
 800ae90: 4618         	mov	r0, r3
 800ae92: f008 fc34    	bl	0x80136fe <thread_is_preemptible> @ imm = #0x8868
 800ae96: 4603         	mov	r3, r0
 800ae98: 2b00         	cmp	r3, #0x0
 800ae9a: d105         	bne	0x800aea8 <unready_thread+0xe0> @ imm = #0xa
 800ae9c: 6a38         	ldr	r0, [r7, #0x20]
 800ae9e: f008 fc3e    	bl	0x801371e <thread_is_metairq> @ imm = #0x887c
 800aea2: 4603         	mov	r3, r0
 800aea4: 2b00         	cmp	r3, #0x0
 800aea6: d001         	beq	0x800aeac <unready_thread+0xe4> @ imm = #0x2
; 		return true;
 800aea8: 2301         	movs	r3, #0x1
 800aeaa: e008         	b	0x800aebe <unready_thread+0xf6> @ imm = #0x10
; 	    && z_is_thread_timeout_active(thread)) {
 800aeac: 6a38         	ldr	r0, [r7, #0x20]
 800aeae: f008 fc66    	bl	0x801377e <z_is_thread_timeout_active> @ imm = #0x88cc
 800aeb2: 4603         	mov	r3, r0
; 	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 800aeb4: 2b00         	cmp	r3, #0x0
 800aeb6: d001         	beq	0x800aebc <unready_thread+0xf4> @ imm = #0x2
; 		return true;
 800aeb8: 2301         	movs	r3, #0x1
 800aeba: e000         	b	0x800aebe <unready_thread+0xf6> @ imm = #0x0
; 	return false;
 800aebc: 2300         	movs	r3, #0x0
; 	if (should_preempt(thread, preempt_ok)) {
 800aebe: 2b00         	cmp	r3, #0x0
 800aec0: d010         	beq	0x800aee4 <unready_thread+0x11c> @ imm = #0x20
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800aec2: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x800af00 <unready_thread+0x138>
 800aec4: 689b         	ldr	r3, [r3, #0x8]
 800aec6: 613b         	str	r3, [r7, #0x10]
; 	return ret;
 800aec8: 693b         	ldr	r3, [r7, #0x10]
; 		if (thread != arch_current_thread()) {
 800aeca: 6a7a         	ldr	r2, [r7, #0x24]
 800aecc: 429a         	cmp	r2, r3
 800aece: d002         	beq	0x800aed6 <unready_thread+0x10e> @ imm = #0x4
; 			z_reset_time_slice(thread);
 800aed0: 6a78         	ldr	r0, [r7, #0x24]
 800aed2: f000 ff4b    	bl	0x800bd6c <z_reset_time_slice> @ imm = #0xe96
; 		update_metairq_preempt(thread);
 800aed6: 6a78         	ldr	r0, [r7, #0x24]
 800aed8: f008 fdc6    	bl	0x8013a68 <update_metairq_preempt> @ imm = #0x8b8c
; 		_kernel.ready_q.cache = thread;
 800aedc: 4a08         	ldr	r2, [pc, #0x20]         @ 0x800af00 <unready_thread+0x138>
 800aede: 6a7b         	ldr	r3, [r7, #0x24]
 800aee0: 61d3         	str	r3, [r2, #0x1c]
; }
 800aee2: e005         	b	0x800aef0 <unready_thread+0x128> @ imm = #0xa
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800aee4: 4b06         	ldr	r3, [pc, #0x18]         @ 0x800af00 <unready_thread+0x138>
 800aee6: 689b         	ldr	r3, [r3, #0x8]
 800aee8: 60fb         	str	r3, [r7, #0xc]
; 	return ret;
 800aeea: 68fb         	ldr	r3, [r7, #0xc]
; 		_kernel.ready_q.cache = arch_current_thread();
 800aeec: 4a04         	ldr	r2, [pc, #0x10]         @ 0x800af00 <unready_thread+0x138>
 800aeee: 61d3         	str	r3, [r2, #0x1c]
; }
 800aef0: bf00         	nop
; }
 800aef2: bf00         	nop
 800aef4: 3750         	adds	r7, #0x50
 800aef6: 46bd         	mov	sp, r7
 800aef8: bd80         	pop	{r7, pc}
 800aefa: bf00         	nop

0800aefc <$d>:
 800aefc: e0 02 00 20  	.word	0x200002e0
 800af00: c0 02 00 20  	.word	0x200002c0

0800af04 <z_sched_wake_thread>:
; {
 800af04: b580         	push	{r7, lr}
 800af06: b090         	sub	sp, #0x40
 800af08: af00         	add	r7, sp, #0x0
 800af0a: 6078         	str	r0, [r7, #0x4]
 800af0c: 460b         	mov	r3, r1
 800af0e: 70fb         	strb	r3, [r7, #0x3]
; 	K_SPINLOCK(&_sched_spinlock) {
 800af10: 2300         	movs	r3, #0x0
 800af12: 617b         	str	r3, [r7, #0x14]
 800af14: 4b38         	ldr	r3, [pc, #0xe0]         @ 0x800aff8 <z_sched_wake_thread+0xf4>
 800af16: 63bb         	str	r3, [r7, #0x38]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800af18: f3ef 8311    	mrs	r3, basepri
 800af1c: 637b         	str	r3, [r7, #0x34]
;   return(result);
 800af1e: 6b7b         	ldr	r3, [r7, #0x34]
; 	key = __get_BASEPRI();
 800af20: 633b         	str	r3, [r7, #0x30]
 800af22: 2310         	movs	r3, #0x10
 800af24: 62fb         	str	r3, [r7, #0x2c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800af26: 6afb         	ldr	r3, [r7, #0x2c]
 800af28: f383 8812    	msr	basepri_max, r3
; }
 800af2c: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800af2e: f3bf 8f6f    	isb	sy
; }
 800af32: bf00         	nop
; 	return key;
 800af34: 6b3b         	ldr	r3, [r7, #0x30]
; 	k.key = arch_irq_lock();
 800af36: 60bb         	str	r3, [r7, #0x8]
 800af38: 6bbb         	ldr	r3, [r7, #0x38]
 800af3a: 62bb         	str	r3, [r7, #0x28]
; }
 800af3c: bf00         	nop
 800af3e: 6bbb         	ldr	r3, [r7, #0x38]
 800af40: 627b         	str	r3, [r7, #0x24]
; }
 800af42: bf00         	nop
; 	return k;
 800af44: 68bb         	ldr	r3, [r7, #0x8]
 800af46: 613b         	str	r3, [r7, #0x10]
; 	K_SPINLOCK(&_sched_spinlock) {
 800af48: e04d         	b	0x800afe6 <z_sched_wake_thread+0xe2> @ imm = #0x9a
; 		bool killed = (thread->base.thread_state &
 800af4a: 687b         	ldr	r3, [r7, #0x4]
 800af4c: 7b5b         	ldrb	r3, [r3, #0xd]
 800af4e: f003 0328    	and	r3, r3, #0x28
 800af52: 2b00         	cmp	r3, #0x0
 800af54: bf14         	ite	ne
 800af56: 2301         	movne	r3, #0x1
 800af58: 2300         	moveq	r3, #0x0
 800af5a: f887 303f    	strb.w	r3, [r7, #0x3f]
; 		bool do_nothing = thread->no_wake_on_timeout && is_timeout;
 800af5e: 687b         	ldr	r3, [r7, #0x4]
 800af60: f893 307c    	ldrb.w	r3, [r3, #0x7c]
 800af64: 2b00         	cmp	r3, #0x0
 800af66: d004         	beq	0x800af72 <z_sched_wake_thread+0x6e> @ imm = #0x8
 800af68: 78fb         	ldrb	r3, [r7, #0x3]
 800af6a: 2b00         	cmp	r3, #0x0
 800af6c: d001         	beq	0x800af72 <z_sched_wake_thread+0x6e> @ imm = #0x2
 800af6e: 2301         	movs	r3, #0x1
 800af70: e000         	b	0x800af74 <z_sched_wake_thread+0x70> @ imm = #0x0
 800af72: 2300         	movs	r3, #0x0
 800af74: f887 303e    	strb.w	r3, [r7, #0x3e]
 800af78: f897 303e    	ldrb.w	r3, [r7, #0x3e]
 800af7c: f003 0301    	and	r3, r3, #0x1
 800af80: f887 303e    	strb.w	r3, [r7, #0x3e]
; 		thread->no_wake_on_timeout = false;
 800af84: 687b         	ldr	r3, [r7, #0x4]
 800af86: 2200         	movs	r2, #0x0
 800af88: f883 207c    	strb.w	r2, [r3, #0x7c]
; 		if (do_nothing) {
 800af8c: f897 303e    	ldrb.w	r3, [r7, #0x3e]
 800af90: 2b00         	cmp	r3, #0x0
 800af92: d114         	bne	0x800afbe <z_sched_wake_thread+0xba> @ imm = #0x28
; 		if (!killed) {
 800af94: f897 303f    	ldrb.w	r3, [r7, #0x3f]
 800af98: f083 0301    	eor	r3, r3, #0x1
 800af9c: b2db         	uxtb	r3, r3
 800af9e: 2b00         	cmp	r3, #0x0
 800afa0: d00e         	beq	0x800afc0 <z_sched_wake_thread+0xbc> @ imm = #0x1c
; 			if (thread->base.pended_on != NULL) {
 800afa2: 687b         	ldr	r3, [r7, #0x4]
 800afa4: 689b         	ldr	r3, [r3, #0x8]
 800afa6: 2b00         	cmp	r3, #0x0
 800afa8: d002         	beq	0x800afb0 <z_sched_wake_thread+0xac> @ imm = #0x4
; 				unpend_thread_no_timeout(thread);
 800afaa: 6878         	ldr	r0, [r7, #0x4]
 800afac: f008 fcac    	bl	0x8013908 <unpend_thread_no_timeout> @ imm = #0x8958
; 			z_mark_thread_as_not_suspended(thread);
 800afb0: 6878         	ldr	r0, [r7, #0x4]
 800afb2: f008 fc4e    	bl	0x8013852 <z_mark_thread_as_not_suspended> @ imm = #0x889c
; 			ready_thread(thread);
 800afb6: 6878         	ldr	r0, [r7, #0x4]
 800afb8: f7ff fb90    	bl	0x800a6dc <ready_thread> @ imm = #-0x8e0
 800afbc: e000         	b	0x800afc0 <z_sched_wake_thread+0xbc> @ imm = #0x0
; 			continue;
 800afbe: bf00         	nop
 800afc0: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800aff8 <z_sched_wake_thread+0xf4>
 800afc2: 623b         	str	r3, [r7, #0x20]
 800afc4: 693b         	ldr	r3, [r7, #0x10]
 800afc6: 60fb         	str	r3, [r7, #0xc]
; 	arch_irq_unlock(key.key);
 800afc8: 68fb         	ldr	r3, [r7, #0xc]
 800afca: 61fb         	str	r3, [r7, #0x1c]
 800afcc: 69fb         	ldr	r3, [r7, #0x1c]
 800afce: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800afd0: 69bb         	ldr	r3, [r7, #0x18]
 800afd2: f383 8811    	msr	basepri, r3
; }
 800afd6: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800afd8: f3bf 8f6f    	isb	sy
; }
 800afdc: bf00         	nop
; }
 800afde: bf00         	nop
; }
 800afe0: bf00         	nop
; 	K_SPINLOCK(&_sched_spinlock) {
 800afe2: 2301         	movs	r3, #0x1
 800afe4: 617b         	str	r3, [r7, #0x14]
 800afe6: 697b         	ldr	r3, [r7, #0x14]
 800afe8: 2b00         	cmp	r3, #0x0
 800afea: d0ae         	beq	0x800af4a <z_sched_wake_thread+0x46> @ imm = #-0xa4
; }
 800afec: bf00         	nop
 800afee: bf00         	nop
 800aff0: 3740         	adds	r7, #0x40
 800aff2: 46bd         	mov	sp, r7
 800aff4: bd80         	pop	{r7, pc}
 800aff6: bf00         	nop

0800aff8 <$d>:
 800aff8: e0 09 00 20  	.word	0x200009e0

0800affc <z_pend_curr>:
; {
 800affc: b580         	push	{r7, lr}
 800affe: b092         	sub	sp, #0x48
 800b000: af00         	add	r7, sp, #0x0
 800b002: 60f8         	str	r0, [r7, #0xc]
 800b004: 60b9         	str	r1, [r7, #0x8]
 800b006: 607a         	str	r2, [r7, #0x4]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800b008: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x800b07c <z_pend_curr+0x80>
 800b00a: 689b         	ldr	r3, [r3, #0x8]
 800b00c: 61fb         	str	r3, [r7, #0x1c]
; 	return ret;
 800b00e: 69fb         	ldr	r3, [r7, #0x1c]
; 	pending_current = arch_current_thread();
 800b010: 4a1b         	ldr	r2, [pc, #0x6c]         @ 0x800b080 <z_pend_curr+0x84>
 800b012: 6013         	str	r3, [r2]
 800b014: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x800b084 <z_pend_curr+0x88>
 800b016: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800b018: f3ef 8311    	mrs	r3, basepri
 800b01c: 633b         	str	r3, [r7, #0x30]
;   return(result);
 800b01e: 6b3b         	ldr	r3, [r7, #0x30]
; 	key = __get_BASEPRI();
 800b020: 62fb         	str	r3, [r7, #0x2c]
 800b022: 2310         	movs	r3, #0x10
 800b024: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800b026: 6abb         	ldr	r3, [r7, #0x28]
 800b028: f383 8812    	msr	basepri_max, r3
; }
 800b02c: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800b02e: f3bf 8f6f    	isb	sy
; }
 800b032: bf00         	nop
; 	return key;
 800b034: 6afb         	ldr	r3, [r7, #0x2c]
; 	k.key = arch_irq_lock();
 800b036: 61bb         	str	r3, [r7, #0x18]
 800b038: 6b7b         	ldr	r3, [r7, #0x34]
 800b03a: 627b         	str	r3, [r7, #0x24]
; }
 800b03c: bf00         	nop
 800b03e: 6b7b         	ldr	r3, [r7, #0x34]
 800b040: 623b         	str	r3, [r7, #0x20]
; }
 800b042: bf00         	nop
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800b044: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800b07c <z_pend_curr+0x80>
 800b046: 689b         	ldr	r3, [r3, #0x8]
 800b048: 63bb         	str	r3, [r7, #0x38]
; 	return ret;
 800b04a: 6bb8         	ldr	r0, [r7, #0x38]
; 	pend_locked(arch_current_thread(), wait_q, timeout);
 800b04c: e9d7 2314    	ldrd	r2, r3, [r7, #80]
 800b050: 6879         	ldr	r1, [r7, #0x4]
 800b052: f008 fd89    	bl	0x8013b68 <pend_locked> @ imm = #0x8b12
 800b056: 68fb         	ldr	r3, [r7, #0xc]
 800b058: 63fb         	str	r3, [r7, #0x3c]
; }
 800b05a: bf00         	nop
 800b05c: 4b09         	ldr	r3, [pc, #0x24]         @ 0x800b084 <z_pend_curr+0x88>
 800b05e: 647b         	str	r3, [r7, #0x44]
 800b060: 68bb         	ldr	r3, [r7, #0x8]
 800b062: 617b         	str	r3, [r7, #0x14]
 800b064: 6c7b         	ldr	r3, [r7, #0x44]
 800b066: 643b         	str	r3, [r7, #0x40]
 800b068: bf00         	nop
; 	return z_swap_irqlock(key.key);
 800b06a: 697b         	ldr	r3, [r7, #0x14]
 800b06c: 4618         	mov	r0, r3
 800b06e: f008 fc72    	bl	0x8013956 <z_swap_irqlock> @ imm = #0x88e4
 800b072: 4603         	mov	r3, r0
; }
 800b074: 4618         	mov	r0, r3
 800b076: 3748         	adds	r7, #0x48
 800b078: 46bd         	mov	sp, r7
 800b07a: bd80         	pop	{r7, pc}

0800b07c <$d>:
 800b07c: c0 02 00 20  	.word	0x200002c0
 800b080: ec 09 00 20  	.word	0x200009ec
 800b084: e0 09 00 20  	.word	0x200009e0

0800b088 <z_thread_prio_set>:
; {
 800b088: b580         	push	{r7, lr}
 800b08a: b0a8         	sub	sp, #0xa0
 800b08c: af00         	add	r7, sp, #0x0
 800b08e: 6078         	str	r0, [r7, #0x4]
 800b090: 6039         	str	r1, [r7]
; 	bool need_sched = 0;
 800b092: 2300         	movs	r3, #0x0
 800b094: f887 309f    	strb.w	r3, [r7, #0x9f]
; 	int old_prio = thread->base.prio;
 800b098: 687b         	ldr	r3, [r7, #0x4]
 800b09a: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 800b09e: f8c7 3098    	str.w	r3, [r7, #0x98]
; 	K_SPINLOCK(&_sched_spinlock) {
 800b0a2: 2300         	movs	r3, #0x0
 800b0a4: 617b         	str	r3, [r7, #0x14]
 800b0a6: 4b95         	ldr	r3, [pc, #0x254]        @ 0x800b2fc <z_thread_prio_set+0x274>
 800b0a8: f8c7 3094    	str.w	r3, [r7, #0x94]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800b0ac: f3ef 8311    	mrs	r3, basepri
 800b0b0: f8c7 3090    	str.w	r3, [r7, #0x90]
;   return(result);
 800b0b4: f8d7 3090    	ldr.w	r3, [r7, #0x90]
; 	key = __get_BASEPRI();
 800b0b8: f8c7 308c    	str.w	r3, [r7, #0x8c]
 800b0bc: 2310         	movs	r3, #0x10
 800b0be: f8c7 3088    	str.w	r3, [r7, #0x88]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800b0c2: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 800b0c6: f383 8812    	msr	basepri_max, r3
; }
 800b0ca: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800b0cc: f3bf 8f6f    	isb	sy
; }
 800b0d0: bf00         	nop
; 	return key;
 800b0d2: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
; 	k.key = arch_irq_lock();
 800b0d6: 60bb         	str	r3, [r7, #0x8]
 800b0d8: f8d7 3094    	ldr.w	r3, [r7, #0x94]
 800b0dc: f8c7 3084    	str.w	r3, [r7, #0x84]
; }
 800b0e0: bf00         	nop
 800b0e2: f8d7 3094    	ldr.w	r3, [r7, #0x94]
 800b0e6: f8c7 3080    	str.w	r3, [r7, #0x80]
; }
 800b0ea: bf00         	nop
; 	return k;
 800b0ec: 68bb         	ldr	r3, [r7, #0x8]
 800b0ee: 613b         	str	r3, [r7, #0x10]
; 	K_SPINLOCK(&_sched_spinlock) {
 800b0f0: e0fa         	b	0x800b2e8 <z_thread_prio_set+0x260> @ imm = #0x1f4
; 		need_sched = z_is_thread_ready(thread);
 800b0f2: 6878         	ldr	r0, [r7, #0x4]
 800b0f4: f008 fb5c    	bl	0x80137b0 <z_is_thread_ready> @ imm = #0x86b8
 800b0f8: 4603         	mov	r3, r0
 800b0fa: f887 309f    	strb.w	r3, [r7, #0x9f]
; 		if (need_sched) {
 800b0fe: f897 309f    	ldrb.w	r3, [r7, #0x9f]
 800b102: 2b00         	cmp	r3, #0x0
 800b104: f000 80d9    	beq.w	0x800b2ba <z_thread_prio_set+0x232> @ imm = #0x1b2
 800b108: 687b         	ldr	r3, [r7, #0x4]
 800b10a: 667b         	str	r3, [r7, #0x64]
; 	thread->base.thread_state &= ~_THREAD_QUEUED;
 800b10c: 6e7b         	ldr	r3, [r7, #0x64]
 800b10e: 7b5b         	ldrb	r3, [r3, #0xd]
 800b110: f003 037f    	and	r3, r3, #0x7f
 800b114: b2da         	uxtb	r2, r3
 800b116: 6e7b         	ldr	r3, [r7, #0x64]
 800b118: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 800b11a: 6e78         	ldr	r0, [r7, #0x64]
 800b11c: f008 fc61    	bl	0x80139e2 <should_queue_thread> @ imm = #0x88c2
 800b120: 4603         	mov	r3, r0
 800b122: 2b00         	cmp	r3, #0x0
 800b124: d00d         	beq	0x800b142 <z_thread_prio_set+0xba> @ imm = #0x1a
 800b126: 6e7b         	ldr	r3, [r7, #0x64]
 800b128: 663b         	str	r3, [r7, #0x60]
 800b12a: 6e3b         	ldr	r3, [r7, #0x60]
 800b12c: 65fb         	str	r3, [r7, #0x5c]
; 	return &_kernel.ready_q.runq;
 800b12e: 4b74         	ldr	r3, [pc, #0x1d0]        @ 0x800b300 <z_thread_prio_set+0x278>
 800b130: 65bb         	str	r3, [r7, #0x58]
 800b132: 6e3b         	ldr	r3, [r7, #0x60]
 800b134: 657b         	str	r3, [r7, #0x54]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 800b136: 6d7b         	ldr	r3, [r7, #0x54]
 800b138: 4618         	mov	r0, r3
 800b13a: f008 fa92    	bl	0x8013662 <sys_dlist_remove> @ imm = #0x8524
; }
 800b13e: bf00         	nop
; }
 800b140: bf00         	nop
; }
 800b142: bf00         	nop
; 				thread->base.prio = prio;
 800b144: 683b         	ldr	r3, [r7]
 800b146: b25a         	sxtb	r2, r3
 800b148: 687b         	ldr	r3, [r7, #0x4]
 800b14a: 739a         	strb	r2, [r3, #0xe]
 800b14c: 687b         	ldr	r3, [r7, #0x4]
 800b14e: 67fb         	str	r3, [r7, #0x7c]
; 	thread->base.thread_state |= _THREAD_QUEUED;
 800b150: 6ffb         	ldr	r3, [r7, #0x7c]
 800b152: 7b5b         	ldrb	r3, [r3, #0xd]
 800b154: f063 037f    	orn	r3, r3, #0x7f
 800b158: b2da         	uxtb	r2, r3
 800b15a: 6ffb         	ldr	r3, [r7, #0x7c]
 800b15c: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 800b15e: 6ff8         	ldr	r0, [r7, #0x7c]
 800b160: f008 fc3f    	bl	0x80139e2 <should_queue_thread> @ imm = #0x887e
 800b164: 4603         	mov	r3, r0
 800b166: 2b00         	cmp	r3, #0x0
 800b168: d042         	beq	0x800b1f0 <z_thread_prio_set+0x168> @ imm = #0x84
 800b16a: 6ffb         	ldr	r3, [r7, #0x7c]
 800b16c: 67bb         	str	r3, [r7, #0x78]
 800b16e: 6fbb         	ldr	r3, [r7, #0x78]
 800b170: 677b         	str	r3, [r7, #0x74]
; 	return &_kernel.ready_q.runq;
 800b172: 4b63         	ldr	r3, [pc, #0x18c]        @ 0x800b300 <z_thread_prio_set+0x278>
 800b174: 673b         	str	r3, [r7, #0x70]
 800b176: 6fbb         	ldr	r3, [r7, #0x78]
 800b178: 66fb         	str	r3, [r7, #0x6c]
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 800b17a: 6f38         	ldr	r0, [r7, #0x70]
 800b17c: f008 fa07    	bl	0x801358e <sys_dlist_peek_head> @ imm = #0x840e
 800b180: 4603         	mov	r3, r0
 800b182: 2b00         	cmp	r3, #0x0
 800b184: d004         	beq	0x800b190 <z_thread_prio_set+0x108> @ imm = #0x8
 800b186: 6f38         	ldr	r0, [r7, #0x70]
 800b188: f008 fa01    	bl	0x801358e <sys_dlist_peek_head> @ imm = #0x8402
 800b18c: 4603         	mov	r3, r0
 800b18e: e000         	b	0x800b192 <z_thread_prio_set+0x10a> @ imm = #0x0
 800b190: 2300         	movs	r3, #0x0
 800b192: 66bb         	str	r3, [r7, #0x68]
 800b194: e023         	b	0x800b1de <z_thread_prio_set+0x156> @ imm = #0x46
; 		if (z_sched_prio_cmp(thread, t) > 0) {
 800b196: 6eb9         	ldr	r1, [r7, #0x68]
 800b198: 6ef8         	ldr	r0, [r7, #0x6c]
 800b19a: f008 fc07    	bl	0x80139ac <z_sched_prio_cmp> @ imm = #0x880e
 800b19e: 4603         	mov	r3, r0
 800b1a0: 2b00         	cmp	r3, #0x0
 800b1a2: dd06         	ble	0x800b1b2 <z_thread_prio_set+0x12a> @ imm = #0xc
; 			sys_dlist_insert(&t->base.qnode_dlist,
 800b1a4: 6ebb         	ldr	r3, [r7, #0x68]
 800b1a6: 6efa         	ldr	r2, [r7, #0x6c]
 800b1a8: 4611         	mov	r1, r2
 800b1aa: 4618         	mov	r0, r3
 800b1ac: f008 fa40    	bl	0x8013630 <sys_dlist_insert> @ imm = #0x8480
; 			return;
 800b1b0: e01d         	b	0x800b1ee <z_thread_prio_set+0x166> @ imm = #0x3a
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 800b1b2: 6ebb         	ldr	r3, [r7, #0x68]
 800b1b4: 2b00         	cmp	r3, #0x0
 800b1b6: d010         	beq	0x800b1da <z_thread_prio_set+0x152> @ imm = #0x20
 800b1b8: 6ebb         	ldr	r3, [r7, #0x68]
 800b1ba: 4619         	mov	r1, r3
 800b1bc: 6f38         	ldr	r0, [r7, #0x70]
 800b1be: f008 fa0b    	bl	0x80135d8 <sys_dlist_peek_next> @ imm = #0x8416
 800b1c2: 4603         	mov	r3, r0
 800b1c4: 2b00         	cmp	r3, #0x0
 800b1c6: d006         	beq	0x800b1d6 <z_thread_prio_set+0x14e> @ imm = #0xc
 800b1c8: 6ebb         	ldr	r3, [r7, #0x68]
 800b1ca: 4619         	mov	r1, r3
 800b1cc: 6f38         	ldr	r0, [r7, #0x70]
 800b1ce: f008 fa03    	bl	0x80135d8 <sys_dlist_peek_next> @ imm = #0x8406
 800b1d2: 4603         	mov	r3, r0
 800b1d4: e002         	b	0x800b1dc <z_thread_prio_set+0x154> @ imm = #0x4
 800b1d6: 2300         	movs	r3, #0x0
 800b1d8: e000         	b	0x800b1dc <z_thread_prio_set+0x154> @ imm = #0x0
 800b1da: 2300         	movs	r3, #0x0
 800b1dc: 66bb         	str	r3, [r7, #0x68]
 800b1de: 6ebb         	ldr	r3, [r7, #0x68]
 800b1e0: 2b00         	cmp	r3, #0x0
 800b1e2: d1d8         	bne	0x800b196 <z_thread_prio_set+0x10e> @ imm = #-0x50
; 	sys_dlist_append(pq, &thread->base.qnode_dlist);
 800b1e4: 6efb         	ldr	r3, [r7, #0x6c]
 800b1e6: 4619         	mov	r1, r3
 800b1e8: 6f38         	ldr	r0, [r7, #0x70]
 800b1ea: f008 fa08    	bl	0x80135fe <sys_dlist_append> @ imm = #0x8410
; }
 800b1ee: bf00         	nop
; }
 800b1f0: bf00         	nop
 800b1f2: 2301         	movs	r3, #0x1
 800b1f4: 653b         	str	r3, [r7, #0x50]
; 	return &_kernel.ready_q.runq;
 800b1f6: 4b42         	ldr	r3, [pc, #0x108]        @ 0x800b300 <z_thread_prio_set+0x278>
 800b1f8: 64fb         	str	r3, [r7, #0x4c]
; 	struct k_thread *thread = NULL;
 800b1fa: 2300         	movs	r3, #0x0
 800b1fc: 64bb         	str	r3, [r7, #0x48]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 800b1fe: 6cf8         	ldr	r0, [r7, #0x4c]
 800b200: f008 f9c5    	bl	0x801358e <sys_dlist_peek_head> @ imm = #0x838a
 800b204: 6478         	str	r0, [r7, #0x44]
; 	if (n != NULL) {
 800b206: 6c7b         	ldr	r3, [r7, #0x44]
 800b208: 2b00         	cmp	r3, #0x0
 800b20a: d001         	beq	0x800b210 <z_thread_prio_set+0x188> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 800b20c: 6c7b         	ldr	r3, [r7, #0x44]
 800b20e: 64bb         	str	r3, [r7, #0x48]
; 	return thread;
 800b210: 6cbb         	ldr	r3, [r7, #0x48]
; 	return _priq_run_best(curr_cpu_runq());
 800b212: bf00         	nop
; 	struct k_thread *thread = runq_best();
 800b214: 643b         	str	r3, [r7, #0x40]
; 	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 800b216: 6c3b         	ldr	r3, [r7, #0x40]
 800b218: 2b00         	cmp	r3, #0x0
 800b21a: d102         	bne	0x800b222 <z_thread_prio_set+0x19a> @ imm = #0x4
 800b21c: 4b39         	ldr	r3, [pc, #0xe4]         @ 0x800b304 <z_thread_prio_set+0x27c>
 800b21e: 68db         	ldr	r3, [r3, #0xc]
 800b220: e000         	b	0x800b224 <z_thread_prio_set+0x19c> @ imm = #0x0
 800b222: 6c3b         	ldr	r3, [r7, #0x40]
; 	struct k_thread *thread = next_up();
 800b224: 63fb         	str	r3, [r7, #0x3c]
 800b226: 6bfb         	ldr	r3, [r7, #0x3c]
 800b228: 63bb         	str	r3, [r7, #0x38]
 800b22a: 6d3b         	ldr	r3, [r7, #0x50]
 800b22c: 637b         	str	r3, [r7, #0x34]
; 	if (preempt_ok != 0) {
 800b22e: 6b7b         	ldr	r3, [r7, #0x34]
 800b230: 2b00         	cmp	r3, #0x0
 800b232: d001         	beq	0x800b238 <z_thread_prio_set+0x1b0> @ imm = #0x2
; 		return true;
 800b234: 2301         	movs	r3, #0x1
 800b236: e026         	b	0x800b286 <z_thread_prio_set+0x1fe> @ imm = #0x4c
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800b238: 4b32         	ldr	r3, [pc, #0xc8]         @ 0x800b304 <z_thread_prio_set+0x27c>
 800b23a: 689b         	ldr	r3, [r3, #0x8]
 800b23c: 633b         	str	r3, [r7, #0x30]
; 	return ret;
 800b23e: 6b3b         	ldr	r3, [r7, #0x30]
; 	if (z_is_thread_prevented_from_running(arch_current_thread())) {
 800b240: 4618         	mov	r0, r3
 800b242: f008 fa88    	bl	0x8013756 <z_is_thread_prevented_from_running> @ imm = #0x8510
 800b246: 4603         	mov	r3, r0
 800b248: 2b00         	cmp	r3, #0x0
 800b24a: d001         	beq	0x800b250 <z_thread_prio_set+0x1c8> @ imm = #0x2
; 		return true;
 800b24c: 2301         	movs	r3, #0x1
 800b24e: e01a         	b	0x800b286 <z_thread_prio_set+0x1fe> @ imm = #0x34
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800b250: 4b2c         	ldr	r3, [pc, #0xb0]         @ 0x800b304 <z_thread_prio_set+0x27c>
 800b252: 689b         	ldr	r3, [r3, #0x8]
 800b254: 62fb         	str	r3, [r7, #0x2c]
; 	return ret;
 800b256: 6afb         	ldr	r3, [r7, #0x2c]
; 	if (thread_is_preemptible(arch_current_thread()) || thread_is_metairq(thread)) {
 800b258: 4618         	mov	r0, r3
 800b25a: f008 fa50    	bl	0x80136fe <thread_is_preemptible> @ imm = #0x84a0
 800b25e: 4603         	mov	r3, r0
 800b260: 2b00         	cmp	r3, #0x0
 800b262: d105         	bne	0x800b270 <z_thread_prio_set+0x1e8> @ imm = #0xa
 800b264: 6bb8         	ldr	r0, [r7, #0x38]
 800b266: f008 fa5a    	bl	0x801371e <thread_is_metairq> @ imm = #0x84b4
 800b26a: 4603         	mov	r3, r0
 800b26c: 2b00         	cmp	r3, #0x0
 800b26e: d001         	beq	0x800b274 <z_thread_prio_set+0x1ec> @ imm = #0x2
; 		return true;
 800b270: 2301         	movs	r3, #0x1
 800b272: e008         	b	0x800b286 <z_thread_prio_set+0x1fe> @ imm = #0x10
; 	    && z_is_thread_timeout_active(thread)) {
 800b274: 6bb8         	ldr	r0, [r7, #0x38]
 800b276: f008 fa82    	bl	0x801377e <z_is_thread_timeout_active> @ imm = #0x8504
 800b27a: 4603         	mov	r3, r0
; 	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 800b27c: 2b00         	cmp	r3, #0x0
 800b27e: d001         	beq	0x800b284 <z_thread_prio_set+0x1fc> @ imm = #0x2
; 		return true;
 800b280: 2301         	movs	r3, #0x1
 800b282: e000         	b	0x800b286 <z_thread_prio_set+0x1fe> @ imm = #0x0
; 	return false;
 800b284: 2300         	movs	r3, #0x0
; 	if (should_preempt(thread, preempt_ok)) {
 800b286: 2b00         	cmp	r3, #0x0
 800b288: d010         	beq	0x800b2ac <z_thread_prio_set+0x224> @ imm = #0x20
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800b28a: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x800b304 <z_thread_prio_set+0x27c>
 800b28c: 689b         	ldr	r3, [r3, #0x8]
 800b28e: 62bb         	str	r3, [r7, #0x28]
; 	return ret;
 800b290: 6abb         	ldr	r3, [r7, #0x28]
; 		if (thread != arch_current_thread()) {
 800b292: 6bfa         	ldr	r2, [r7, #0x3c]
 800b294: 429a         	cmp	r2, r3
 800b296: d002         	beq	0x800b29e <z_thread_prio_set+0x216> @ imm = #0x4
; 			z_reset_time_slice(thread);
 800b298: 6bf8         	ldr	r0, [r7, #0x3c]
 800b29a: f000 fd67    	bl	0x800bd6c <z_reset_time_slice> @ imm = #0xace
; 		update_metairq_preempt(thread);
 800b29e: 6bf8         	ldr	r0, [r7, #0x3c]
 800b2a0: f008 fbe2    	bl	0x8013a68 <update_metairq_preempt> @ imm = #0x87c4
; 		_kernel.ready_q.cache = thread;
 800b2a4: 4a17         	ldr	r2, [pc, #0x5c]         @ 0x800b304 <z_thread_prio_set+0x27c>
 800b2a6: 6bfb         	ldr	r3, [r7, #0x3c]
 800b2a8: 61d3         	str	r3, [r2, #0x1c]
; }
 800b2aa: e00a         	b	0x800b2c2 <z_thread_prio_set+0x23a> @ imm = #0x14
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800b2ac: 4b15         	ldr	r3, [pc, #0x54]         @ 0x800b304 <z_thread_prio_set+0x27c>
 800b2ae: 689b         	ldr	r3, [r3, #0x8]
 800b2b0: 627b         	str	r3, [r7, #0x24]
; 	return ret;
 800b2b2: 6a7b         	ldr	r3, [r7, #0x24]
; 		_kernel.ready_q.cache = arch_current_thread();
 800b2b4: 4a13         	ldr	r2, [pc, #0x4c]         @ 0x800b304 <z_thread_prio_set+0x27c>
 800b2b6: 61d3         	str	r3, [r2, #0x1c]
; }
 800b2b8: e003         	b	0x800b2c2 <z_thread_prio_set+0x23a> @ imm = #0x6
; 			thread->base.prio = prio;
 800b2ba: 683b         	ldr	r3, [r7]
 800b2bc: b25a         	sxtb	r2, r3
 800b2be: 687b         	ldr	r3, [r7, #0x4]
 800b2c0: 739a         	strb	r2, [r3, #0xe]
 800b2c2: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800b2fc <z_thread_prio_set+0x274>
 800b2c4: 623b         	str	r3, [r7, #0x20]
 800b2c6: 693b         	ldr	r3, [r7, #0x10]
 800b2c8: 60fb         	str	r3, [r7, #0xc]
; 	arch_irq_unlock(key.key);
 800b2ca: 68fb         	ldr	r3, [r7, #0xc]
 800b2cc: 61fb         	str	r3, [r7, #0x1c]
 800b2ce: 69fb         	ldr	r3, [r7, #0x1c]
 800b2d0: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800b2d2: 69bb         	ldr	r3, [r7, #0x18]
 800b2d4: f383 8811    	msr	basepri, r3
; }
 800b2d8: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800b2da: f3bf 8f6f    	isb	sy
; }
 800b2de: bf00         	nop
; }
 800b2e0: bf00         	nop
; }
 800b2e2: bf00         	nop
; 	K_SPINLOCK(&_sched_spinlock) {
 800b2e4: 2301         	movs	r3, #0x1
 800b2e6: 617b         	str	r3, [r7, #0x14]
 800b2e8: 697b         	ldr	r3, [r7, #0x14]
 800b2ea: 2b00         	cmp	r3, #0x0
 800b2ec: f43f af01    	beq.w	0x800b0f2 <z_thread_prio_set+0x6a> @ imm = #-0x1fe
; 	return need_sched;
 800b2f0: f897 309f    	ldrb.w	r3, [r7, #0x9f]
; }
 800b2f4: 4618         	mov	r0, r3
 800b2f6: 37a0         	adds	r7, #0xa0
 800b2f8: 46bd         	mov	sp, r7
 800b2fa: bd80         	pop	{r7, pc}

0800b2fc <$d>:
 800b2fc: e0 09 00 20  	.word	0x200009e0
 800b300: e0 02 00 20  	.word	0x200002e0
 800b304: c0 02 00 20  	.word	0x200002c0

0800b308 <need_swap>:
; {
 800b308: b480         	push	{r7}
 800b30a: b083         	sub	sp, #0xc
 800b30c: af00         	add	r7, sp, #0x0
; 	new_thread = _kernel.ready_q.cache;
 800b30e: 4b09         	ldr	r3, [pc, #0x24]         @ 0x800b334 <need_swap+0x2c>
 800b310: 69db         	ldr	r3, [r3, #0x1c]
 800b312: 607b         	str	r3, [r7, #0x4]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800b314: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800b334 <need_swap+0x2c>
 800b316: 689b         	ldr	r3, [r3, #0x8]
 800b318: 603b         	str	r3, [r7]
; 	return ret;
 800b31a: 683b         	ldr	r3, [r7]
; 	return new_thread != arch_current_thread();
 800b31c: 687a         	ldr	r2, [r7, #0x4]
 800b31e: 429a         	cmp	r2, r3
 800b320: bf14         	ite	ne
 800b322: 2301         	movne	r3, #0x1
 800b324: 2300         	moveq	r3, #0x0
 800b326: b2db         	uxtb	r3, r3
; }
 800b328: 4618         	mov	r0, r3
 800b32a: 370c         	adds	r7, #0xc
 800b32c: 46bd         	mov	sp, r7
 800b32e: bc80         	pop	{r7}
 800b330: 4770         	bx	lr
 800b332: bf00         	nop

0800b334 <$d>:
 800b334: c0 02 00 20  	.word	0x200002c0

0800b338 <k_sched_lock>:
; {
 800b338: b580         	push	{r7, lr}
 800b33a: b08e         	sub	sp, #0x38
 800b33c: af00         	add	r7, sp, #0x0
; 	K_SPINLOCK(&_sched_spinlock) {
 800b33e: 2300         	movs	r3, #0x0
 800b340: 613b         	str	r3, [r7, #0x10]
 800b342: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x800b3b4 <k_sched_lock+0x7c>
 800b344: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800b346: f3ef 8311    	mrs	r3, basepri
 800b34a: 633b         	str	r3, [r7, #0x30]
;   return(result);
 800b34c: 6b3b         	ldr	r3, [r7, #0x30]
; 	key = __get_BASEPRI();
 800b34e: 62fb         	str	r3, [r7, #0x2c]
 800b350: 2310         	movs	r3, #0x10
 800b352: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800b354: 6abb         	ldr	r3, [r7, #0x28]
 800b356: f383 8812    	msr	basepri_max, r3
; }
 800b35a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800b35c: f3bf 8f6f    	isb	sy
; }
 800b360: bf00         	nop
; 	return key;
 800b362: 6afb         	ldr	r3, [r7, #0x2c]
; 	k.key = arch_irq_lock();
 800b364: 607b         	str	r3, [r7, #0x4]
 800b366: 6b7b         	ldr	r3, [r7, #0x34]
 800b368: 627b         	str	r3, [r7, #0x24]
; }
 800b36a: bf00         	nop
 800b36c: 6b7b         	ldr	r3, [r7, #0x34]
 800b36e: 623b         	str	r3, [r7, #0x20]
; }
 800b370: bf00         	nop
; 	return k;
 800b372: 687b         	ldr	r3, [r7, #0x4]
 800b374: 60fb         	str	r3, [r7, #0xc]
; 	K_SPINLOCK(&_sched_spinlock) {
 800b376: e014         	b	0x800b3a2 <k_sched_lock+0x6a> @ imm = #0x28
; 		z_sched_lock();
 800b378: f7ff f88a    	bl	0x800a490 <z_sched_lock> @ imm = #-0xeec
 800b37c: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800b3b4 <k_sched_lock+0x7c>
 800b37e: 61fb         	str	r3, [r7, #0x1c]
 800b380: 68fb         	ldr	r3, [r7, #0xc]
 800b382: 60bb         	str	r3, [r7, #0x8]
; 	arch_irq_unlock(key.key);
 800b384: 68bb         	ldr	r3, [r7, #0x8]
 800b386: 61bb         	str	r3, [r7, #0x18]
 800b388: 69bb         	ldr	r3, [r7, #0x18]
 800b38a: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800b38c: 697b         	ldr	r3, [r7, #0x14]
 800b38e: f383 8811    	msr	basepri, r3
; }
 800b392: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800b394: f3bf 8f6f    	isb	sy
; }
 800b398: bf00         	nop
; }
 800b39a: bf00         	nop
; }
 800b39c: bf00         	nop
; 	K_SPINLOCK(&_sched_spinlock) {
 800b39e: 2301         	movs	r3, #0x1
 800b3a0: 613b         	str	r3, [r7, #0x10]
 800b3a2: 693b         	ldr	r3, [r7, #0x10]
 800b3a4: 2b00         	cmp	r3, #0x0
 800b3a6: d0e7         	beq	0x800b378 <k_sched_lock+0x40> @ imm = #-0x32
; }
 800b3a8: bf00         	nop
 800b3aa: bf00         	nop
 800b3ac: 3738         	adds	r7, #0x38
 800b3ae: 46bd         	mov	sp, r7
 800b3b0: bd80         	pop	{r7, pc}
 800b3b2: bf00         	nop

0800b3b4 <$d>:
 800b3b4: e0 09 00 20  	.word	0x200009e0

0800b3b8 <k_sched_unlock>:
; {
 800b3b8: b580         	push	{r7, lr}
 800b3ba: b0a4         	sub	sp, #0x90
 800b3bc: af06         	add	r7, sp, #0x18
; 	K_SPINLOCK(&_sched_spinlock) {
 800b3be: 2300         	movs	r3, #0x0
 800b3c0: 60fb         	str	r3, [r7, #0xc]
 800b3c2: 4b66         	ldr	r3, [pc, #0x198]        @ 0x800b55c <k_sched_unlock+0x1a4>
 800b3c4: 66fb         	str	r3, [r7, #0x6c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800b3c6: f3ef 8311    	mrs	r3, basepri
 800b3ca: 66bb         	str	r3, [r7, #0x68]
;   return(result);
 800b3cc: 6ebb         	ldr	r3, [r7, #0x68]
; 	key = __get_BASEPRI();
 800b3ce: 667b         	str	r3, [r7, #0x64]
 800b3d0: 2310         	movs	r3, #0x10
 800b3d2: 663b         	str	r3, [r7, #0x60]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800b3d4: 6e3b         	ldr	r3, [r7, #0x60]
 800b3d6: f383 8812    	msr	basepri_max, r3
; }
 800b3da: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800b3dc: f3bf 8f6f    	isb	sy
; }
 800b3e0: bf00         	nop
; 	return key;
 800b3e2: 6e7b         	ldr	r3, [r7, #0x64]
; 	k.key = arch_irq_lock();
 800b3e4: 603b         	str	r3, [r7]
 800b3e6: 6efb         	ldr	r3, [r7, #0x6c]
 800b3e8: 65fb         	str	r3, [r7, #0x5c]
; }
 800b3ea: bf00         	nop
 800b3ec: 6efb         	ldr	r3, [r7, #0x6c]
 800b3ee: 65bb         	str	r3, [r7, #0x58]
; }
 800b3f0: bf00         	nop
; 	return k;
 800b3f2: 683b         	ldr	r3, [r7]
 800b3f4: 60bb         	str	r3, [r7, #0x8]
; 	K_SPINLOCK(&_sched_spinlock) {
 800b3f6: e07e         	b	0x800b4f6 <k_sched_unlock+0x13e> @ imm = #0xfc
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800b3f8: 4b59         	ldr	r3, [pc, #0x164]        @ 0x800b560 <k_sched_unlock+0x1a8>
 800b3fa: 689b         	ldr	r3, [r3, #0x8]
 800b3fc: 61bb         	str	r3, [r7, #0x18]
; 	return ret;
 800b3fe: 69bb         	ldr	r3, [r7, #0x18]
; 		++arch_current_thread()->base.sched_locked;
 800b400: 7bda         	ldrb	r2, [r3, #0xf]
 800b402: 3201         	adds	r2, #0x1
 800b404: b2d2         	uxtb	r2, r2
 800b406: 73da         	strb	r2, [r3, #0xf]
 800b408: 2300         	movs	r3, #0x0
 800b40a: 64bb         	str	r3, [r7, #0x48]
; 	return &_kernel.ready_q.runq;
 800b40c: 4b55         	ldr	r3, [pc, #0x154]        @ 0x800b564 <k_sched_unlock+0x1ac>
 800b40e: 647b         	str	r3, [r7, #0x44]
; 	struct k_thread *thread = NULL;
 800b410: 2300         	movs	r3, #0x0
 800b412: 643b         	str	r3, [r7, #0x40]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 800b414: 6c78         	ldr	r0, [r7, #0x44]
 800b416: f008 f8ba    	bl	0x801358e <sys_dlist_peek_head> @ imm = #0x8174
 800b41a: 63f8         	str	r0, [r7, #0x3c]
; 	if (n != NULL) {
 800b41c: 6bfb         	ldr	r3, [r7, #0x3c]
 800b41e: 2b00         	cmp	r3, #0x0
 800b420: d001         	beq	0x800b426 <k_sched_unlock+0x6e> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 800b422: 6bfb         	ldr	r3, [r7, #0x3c]
 800b424: 643b         	str	r3, [r7, #0x40]
; 	return thread;
 800b426: 6c3b         	ldr	r3, [r7, #0x40]
; 	return _priq_run_best(curr_cpu_runq());
 800b428: bf00         	nop
; 	struct k_thread *thread = runq_best();
 800b42a: 63bb         	str	r3, [r7, #0x38]
; 	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 800b42c: 6bbb         	ldr	r3, [r7, #0x38]
 800b42e: 2b00         	cmp	r3, #0x0
 800b430: d102         	bne	0x800b438 <k_sched_unlock+0x80> @ imm = #0x4
 800b432: 4b4b         	ldr	r3, [pc, #0x12c]        @ 0x800b560 <k_sched_unlock+0x1a8>
 800b434: 68db         	ldr	r3, [r3, #0xc]
 800b436: e000         	b	0x800b43a <k_sched_unlock+0x82> @ imm = #0x0
 800b438: 6bbb         	ldr	r3, [r7, #0x38]
; 	struct k_thread *thread = next_up();
 800b43a: 637b         	str	r3, [r7, #0x34]
 800b43c: 6b7b         	ldr	r3, [r7, #0x34]
 800b43e: 633b         	str	r3, [r7, #0x30]
 800b440: 6cbb         	ldr	r3, [r7, #0x48]
 800b442: 62fb         	str	r3, [r7, #0x2c]
; 	if (preempt_ok != 0) {
 800b444: 6afb         	ldr	r3, [r7, #0x2c]
 800b446: 2b00         	cmp	r3, #0x0
 800b448: d001         	beq	0x800b44e <k_sched_unlock+0x96> @ imm = #0x2
; 		return true;
 800b44a: 2301         	movs	r3, #0x1
 800b44c: e026         	b	0x800b49c <k_sched_unlock+0xe4> @ imm = #0x4c
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800b44e: 4b44         	ldr	r3, [pc, #0x110]        @ 0x800b560 <k_sched_unlock+0x1a8>
 800b450: 689b         	ldr	r3, [r3, #0x8]
 800b452: 62bb         	str	r3, [r7, #0x28]
; 	return ret;
 800b454: 6abb         	ldr	r3, [r7, #0x28]
; 	if (z_is_thread_prevented_from_running(arch_current_thread())) {
 800b456: 4618         	mov	r0, r3
 800b458: f008 f97d    	bl	0x8013756 <z_is_thread_prevented_from_running> @ imm = #0x82fa
 800b45c: 4603         	mov	r3, r0
 800b45e: 2b00         	cmp	r3, #0x0
 800b460: d001         	beq	0x800b466 <k_sched_unlock+0xae> @ imm = #0x2
; 		return true;
 800b462: 2301         	movs	r3, #0x1
 800b464: e01a         	b	0x800b49c <k_sched_unlock+0xe4> @ imm = #0x34
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800b466: 4b3e         	ldr	r3, [pc, #0xf8]         @ 0x800b560 <k_sched_unlock+0x1a8>
 800b468: 689b         	ldr	r3, [r3, #0x8]
 800b46a: 627b         	str	r3, [r7, #0x24]
; 	return ret;
 800b46c: 6a7b         	ldr	r3, [r7, #0x24]
; 	if (thread_is_preemptible(arch_current_thread()) || thread_is_metairq(thread)) {
 800b46e: 4618         	mov	r0, r3
 800b470: f008 f945    	bl	0x80136fe <thread_is_preemptible> @ imm = #0x828a
 800b474: 4603         	mov	r3, r0
 800b476: 2b00         	cmp	r3, #0x0
 800b478: d105         	bne	0x800b486 <k_sched_unlock+0xce> @ imm = #0xa
 800b47a: 6b38         	ldr	r0, [r7, #0x30]
 800b47c: f008 f94f    	bl	0x801371e <thread_is_metairq> @ imm = #0x829e
 800b480: 4603         	mov	r3, r0
 800b482: 2b00         	cmp	r3, #0x0
 800b484: d001         	beq	0x800b48a <k_sched_unlock+0xd2> @ imm = #0x2
; 		return true;
 800b486: 2301         	movs	r3, #0x1
 800b488: e008         	b	0x800b49c <k_sched_unlock+0xe4> @ imm = #0x10
; 	    && z_is_thread_timeout_active(thread)) {
 800b48a: 6b38         	ldr	r0, [r7, #0x30]
 800b48c: f008 f977    	bl	0x801377e <z_is_thread_timeout_active> @ imm = #0x82ee
 800b490: 4603         	mov	r3, r0
; 	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 800b492: 2b00         	cmp	r3, #0x0
 800b494: d001         	beq	0x800b49a <k_sched_unlock+0xe2> @ imm = #0x2
; 		return true;
 800b496: 2301         	movs	r3, #0x1
 800b498: e000         	b	0x800b49c <k_sched_unlock+0xe4> @ imm = #0x0
; 	return false;
 800b49a: 2300         	movs	r3, #0x0
; 	if (should_preempt(thread, preempt_ok)) {
 800b49c: 2b00         	cmp	r3, #0x0
 800b49e: d010         	beq	0x800b4c2 <k_sched_unlock+0x10a> @ imm = #0x20
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800b4a0: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x800b560 <k_sched_unlock+0x1a8>
 800b4a2: 689b         	ldr	r3, [r3, #0x8]
 800b4a4: 623b         	str	r3, [r7, #0x20]
; 	return ret;
 800b4a6: 6a3b         	ldr	r3, [r7, #0x20]
; 		if (thread != arch_current_thread()) {
 800b4a8: 6b7a         	ldr	r2, [r7, #0x34]
 800b4aa: 429a         	cmp	r2, r3
 800b4ac: d002         	beq	0x800b4b4 <k_sched_unlock+0xfc> @ imm = #0x4
; 			z_reset_time_slice(thread);
 800b4ae: 6b78         	ldr	r0, [r7, #0x34]
 800b4b0: f000 fc5c    	bl	0x800bd6c <z_reset_time_slice> @ imm = #0x8b8
; 		update_metairq_preempt(thread);
 800b4b4: 6b78         	ldr	r0, [r7, #0x34]
 800b4b6: f008 fad7    	bl	0x8013a68 <update_metairq_preempt> @ imm = #0x85ae
; 		_kernel.ready_q.cache = thread;
 800b4ba: 4a29         	ldr	r2, [pc, #0xa4]         @ 0x800b560 <k_sched_unlock+0x1a8>
 800b4bc: 6b7b         	ldr	r3, [r7, #0x34]
 800b4be: 61d3         	str	r3, [r2, #0x1c]
; }
 800b4c0: e005         	b	0x800b4ce <k_sched_unlock+0x116> @ imm = #0xa
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800b4c2: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x800b560 <k_sched_unlock+0x1a8>
 800b4c4: 689b         	ldr	r3, [r3, #0x8]
 800b4c6: 61fb         	str	r3, [r7, #0x1c]
; 	return ret;
 800b4c8: 69fb         	ldr	r3, [r7, #0x1c]
; 		_kernel.ready_q.cache = arch_current_thread();
 800b4ca: 4a25         	ldr	r2, [pc, #0x94]         @ 0x800b560 <k_sched_unlock+0x1a8>
 800b4cc: 61d3         	str	r3, [r2, #0x1c]
; }
 800b4ce: bf00         	nop
 800b4d0: 4b22         	ldr	r3, [pc, #0x88]         @ 0x800b55c <k_sched_unlock+0x1a4>
 800b4d2: 657b         	str	r3, [r7, #0x54]
 800b4d4: 68bb         	ldr	r3, [r7, #0x8]
 800b4d6: 607b         	str	r3, [r7, #0x4]
; 	arch_irq_unlock(key.key);
 800b4d8: 687b         	ldr	r3, [r7, #0x4]
 800b4da: 653b         	str	r3, [r7, #0x50]
 800b4dc: 6d3b         	ldr	r3, [r7, #0x50]
 800b4de: 64fb         	str	r3, [r7, #0x4c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800b4e0: 6cfb         	ldr	r3, [r7, #0x4c]
 800b4e2: f383 8811    	msr	basepri, r3
; }
 800b4e6: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800b4e8: f3bf 8f6f    	isb	sy
; }
 800b4ec: bf00         	nop
; }
 800b4ee: bf00         	nop
; }
 800b4f0: bf00         	nop
; 	K_SPINLOCK(&_sched_spinlock) {
 800b4f2: 2301         	movs	r3, #0x1
 800b4f4: 60fb         	str	r3, [r7, #0xc]
 800b4f6: 68fb         	ldr	r3, [r7, #0xc]
 800b4f8: 2b00         	cmp	r3, #0x0
 800b4fa: f43f af7d    	beq.w	0x800b3f8 <k_sched_unlock+0x40> @ imm = #-0x106
; 	LOG_DBG("scheduler unlocked (%p:%d)",
 800b4fe: 2303         	movs	r3, #0x3
 800b500: 2b03         	cmp	r3, #0x3
 800b502: d925         	bls	0x800b550 <k_sched_unlock+0x198> @ imm = #0x4a
 800b504: 2301         	movs	r3, #0x1
 800b506: f887 3077    	strb.w	r3, [r7, #0x77]
 800b50a: f897 3077    	ldrb.w	r3, [r7, #0x77]
 800b50e: f083 0301    	eor	r3, r3, #0x1
 800b512: b2db         	uxtb	r3, r3
 800b514: 2b00         	cmp	r3, #0x0
 800b516: d11b         	bne	0x800b550 <k_sched_unlock+0x198> @ imm = #0x36
 800b518: 4b13         	ldr	r3, [pc, #0x4c]         @ 0x800b568 <k_sched_unlock+0x1b0>
 800b51a: 6819         	ldr	r1, [r3]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800b51c: 4b10         	ldr	r3, [pc, #0x40]         @ 0x800b560 <k_sched_unlock+0x1a8>
 800b51e: 689b         	ldr	r3, [r3, #0x8]
 800b520: 613b         	str	r3, [r7, #0x10]
; 	return ret;
 800b522: 693b         	ldr	r3, [r7, #0x10]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800b524: 4a0e         	ldr	r2, [pc, #0x38]         @ 0x800b560 <k_sched_unlock+0x1a8>
 800b526: 6892         	ldr	r2, [r2, #0x8]
 800b528: 617a         	str	r2, [r7, #0x14]
; 	return ret;
 800b52a: 697a         	ldr	r2, [r7, #0x14]
; 	LOG_DBG("scheduler unlocked (%p:%d)",
 800b52c: 7bd2         	ldrb	r2, [r2, #0xf]
 800b52e: 9205         	str	r2, [sp, #0x14]
 800b530: 9304         	str	r3, [sp, #0x10]
 800b532: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800b56c <k_sched_unlock+0x1b4>
 800b534: 9303         	str	r3, [sp, #0xc]
 800b536: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800b570 <k_sched_unlock+0x1b8>
 800b538: 9302         	str	r3, [sp, #0x8]
 800b53a: 2308         	movs	r3, #0x8
 800b53c: 9301         	str	r3, [sp, #0x4]
 800b53e: 2300         	movs	r3, #0x0
 800b540: 9300         	str	r3, [sp]
 800b542: 2300         	movs	r3, #0x0
 800b544: 2204         	movs	r2, #0x4
 800b546: 2000         	movs	r0, #0x0
 800b548: f008 fa12    	bl	0x8013970 <z_log_msg_runtime_create> @ imm = #0x8424
 800b54c: 2300         	movs	r3, #0x0
 800b54e: 673b         	str	r3, [r7, #0x70]
; 	z_reschedule_unlocked();
 800b550: f008 f9c1    	bl	0x80138d6 <z_reschedule_unlocked> @ imm = #0x8382
; }
 800b554: bf00         	nop
 800b556: 3778         	adds	r7, #0x78
 800b558: 46bd         	mov	sp, r7
 800b55a: bd80         	pop	{r7, pc}

0800b55c <$d>:
 800b55c: e0 09 00 20  	.word	0x200009e0
 800b560: c0 02 00 20  	.word	0x200002c0
 800b564: e0 02 00 20  	.word	0x200002e0
 800b568: 1c 01 00 20  	.word	0x2000011c
 800b56c: ec 67 01 08  	.word	0x080167ec
 800b570: 28 5f 01 08  	.word	0x08015f28

0800b574 <z_sched_init>:
; {
 800b574: b580         	push	{r7, lr}
 800b576: af00         	add	r7, sp, #0x0
; 	init_ready_q(&_kernel.ready_q);
 800b578: 4802         	ldr	r0, [pc, #0x8]          @ 0x800b584 <z_sched_init+0x10>
 800b57a: f008 fb94    	bl	0x8013ca6 <init_ready_q> @ imm = #0x8728
; }
 800b57e: bf00         	nop
 800b580: bd80         	pop	{r7, pc}
 800b582: bf00         	nop

0800b584 <$d>:
 800b584: dc 02 00 20  	.word	0x200002dc

0800b588 <z_impl_k_yield>:
; {
 800b588: b580         	push	{r7, lr}
 800b58a: b0a4         	sub	sp, #0x90
 800b58c: af00         	add	r7, sp, #0x0
 800b58e: 4b86         	ldr	r3, [pc, #0x218]        @ 0x800b7a8 <z_impl_k_yield+0x220>
 800b590: f8c7 308c    	str.w	r3, [r7, #0x8c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800b594: f3ef 8311    	mrs	r3, basepri
 800b598: f8c7 3088    	str.w	r3, [r7, #0x88]
;   return(result);
 800b59c: f8d7 3088    	ldr.w	r3, [r7, #0x88]
; 	key = __get_BASEPRI();
 800b5a0: f8c7 3084    	str.w	r3, [r7, #0x84]
 800b5a4: 2310         	movs	r3, #0x10
 800b5a6: f8c7 3080    	str.w	r3, [r7, #0x80]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800b5aa: f8d7 3080    	ldr.w	r3, [r7, #0x80]
 800b5ae: f383 8812    	msr	basepri_max, r3
; }
 800b5b2: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800b5b4: f3bf 8f6f    	isb	sy
; }
 800b5b8: bf00         	nop
; 	return key;
 800b5ba: f8d7 3084    	ldr.w	r3, [r7, #0x84]
; 	k.key = arch_irq_lock();
 800b5be: 603b         	str	r3, [r7]
 800b5c0: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 800b5c4: 67fb         	str	r3, [r7, #0x7c]
; }
 800b5c6: bf00         	nop
 800b5c8: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 800b5cc: 67bb         	str	r3, [r7, #0x78]
; }
 800b5ce: bf00         	nop
; 	return k;
 800b5d0: 683b         	ldr	r3, [r7]
 800b5d2: 60bb         	str	r3, [r7, #0x8]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800b5d4: 4b75         	ldr	r3, [pc, #0x1d4]        @ 0x800b7ac <z_impl_k_yield+0x224>
 800b5d6: 689b         	ldr	r3, [r3, #0x8]
 800b5d8: 60fb         	str	r3, [r7, #0xc]
; 	return ret;
 800b5da: 68fb         	ldr	r3, [r7, #0xc]
 800b5dc: 623b         	str	r3, [r7, #0x20]
; 	thread->base.thread_state &= ~_THREAD_QUEUED;
 800b5de: 6a3b         	ldr	r3, [r7, #0x20]
 800b5e0: 7b5b         	ldrb	r3, [r3, #0xd]
 800b5e2: f003 037f    	and	r3, r3, #0x7f
 800b5e6: b2da         	uxtb	r2, r3
 800b5e8: 6a3b         	ldr	r3, [r7, #0x20]
 800b5ea: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 800b5ec: 6a38         	ldr	r0, [r7, #0x20]
 800b5ee: f008 f9f8    	bl	0x80139e2 <should_queue_thread> @ imm = #0x83f0
 800b5f2: 4603         	mov	r3, r0
 800b5f4: 2b00         	cmp	r3, #0x0
 800b5f6: d00d         	beq	0x800b614 <z_impl_k_yield+0x8c> @ imm = #0x1a
 800b5f8: 6a3b         	ldr	r3, [r7, #0x20]
 800b5fa: 61fb         	str	r3, [r7, #0x1c]
 800b5fc: 69fb         	ldr	r3, [r7, #0x1c]
 800b5fe: 61bb         	str	r3, [r7, #0x18]
; 	return &_kernel.ready_q.runq;
 800b600: 4b6b         	ldr	r3, [pc, #0x1ac]        @ 0x800b7b0 <z_impl_k_yield+0x228>
 800b602: 617b         	str	r3, [r7, #0x14]
 800b604: 69fb         	ldr	r3, [r7, #0x1c]
 800b606: 613b         	str	r3, [r7, #0x10]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 800b608: 693b         	ldr	r3, [r7, #0x10]
 800b60a: 4618         	mov	r0, r3
 800b60c: f008 f829    	bl	0x8013662 <sys_dlist_remove> @ imm = #0x8052
; }
 800b610: bf00         	nop
; }
 800b612: bf00         	nop
; }
 800b614: bf00         	nop
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800b616: 4b65         	ldr	r3, [pc, #0x194]        @ 0x800b7ac <z_impl_k_yield+0x224>
 800b618: 689b         	ldr	r3, [r3, #0x8]
 800b61a: 627b         	str	r3, [r7, #0x24]
; 	return ret;
 800b61c: 6a7b         	ldr	r3, [r7, #0x24]
 800b61e: 63fb         	str	r3, [r7, #0x3c]
; 	thread->base.thread_state |= _THREAD_QUEUED;
 800b620: 6bfb         	ldr	r3, [r7, #0x3c]
 800b622: 7b5b         	ldrb	r3, [r3, #0xd]
 800b624: f063 037f    	orn	r3, r3, #0x7f
 800b628: b2da         	uxtb	r2, r3
 800b62a: 6bfb         	ldr	r3, [r7, #0x3c]
 800b62c: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 800b62e: 6bf8         	ldr	r0, [r7, #0x3c]
 800b630: f008 f9d7    	bl	0x80139e2 <should_queue_thread> @ imm = #0x83ae
 800b634: 4603         	mov	r3, r0
 800b636: 2b00         	cmp	r3, #0x0
 800b638: d042         	beq	0x800b6c0 <z_impl_k_yield+0x138> @ imm = #0x84
 800b63a: 6bfb         	ldr	r3, [r7, #0x3c]
 800b63c: 63bb         	str	r3, [r7, #0x38]
 800b63e: 6bbb         	ldr	r3, [r7, #0x38]
 800b640: 637b         	str	r3, [r7, #0x34]
; 	return &_kernel.ready_q.runq;
 800b642: 4b5b         	ldr	r3, [pc, #0x16c]        @ 0x800b7b0 <z_impl_k_yield+0x228>
 800b644: 633b         	str	r3, [r7, #0x30]
 800b646: 6bbb         	ldr	r3, [r7, #0x38]
 800b648: 62fb         	str	r3, [r7, #0x2c]
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 800b64a: 6b38         	ldr	r0, [r7, #0x30]
 800b64c: f007 ff9f    	bl	0x801358e <sys_dlist_peek_head> @ imm = #0x7f3e
 800b650: 4603         	mov	r3, r0
 800b652: 2b00         	cmp	r3, #0x0
 800b654: d004         	beq	0x800b660 <z_impl_k_yield+0xd8> @ imm = #0x8
 800b656: 6b38         	ldr	r0, [r7, #0x30]
 800b658: f007 ff99    	bl	0x801358e <sys_dlist_peek_head> @ imm = #0x7f32
 800b65c: 4603         	mov	r3, r0
 800b65e: e000         	b	0x800b662 <z_impl_k_yield+0xda> @ imm = #0x0
 800b660: 2300         	movs	r3, #0x0
 800b662: 62bb         	str	r3, [r7, #0x28]
 800b664: e023         	b	0x800b6ae <z_impl_k_yield+0x126> @ imm = #0x46
; 		if (z_sched_prio_cmp(thread, t) > 0) {
 800b666: 6ab9         	ldr	r1, [r7, #0x28]
 800b668: 6af8         	ldr	r0, [r7, #0x2c]
 800b66a: f008 f99f    	bl	0x80139ac <z_sched_prio_cmp> @ imm = #0x833e
 800b66e: 4603         	mov	r3, r0
 800b670: 2b00         	cmp	r3, #0x0
 800b672: dd06         	ble	0x800b682 <z_impl_k_yield+0xfa> @ imm = #0xc
; 			sys_dlist_insert(&t->base.qnode_dlist,
 800b674: 6abb         	ldr	r3, [r7, #0x28]
 800b676: 6afa         	ldr	r2, [r7, #0x2c]
 800b678: 4611         	mov	r1, r2
 800b67a: 4618         	mov	r0, r3
 800b67c: f007 ffd8    	bl	0x8013630 <sys_dlist_insert> @ imm = #0x7fb0
; 			return;
 800b680: e01d         	b	0x800b6be <z_impl_k_yield+0x136> @ imm = #0x3a
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 800b682: 6abb         	ldr	r3, [r7, #0x28]
 800b684: 2b00         	cmp	r3, #0x0
 800b686: d010         	beq	0x800b6aa <z_impl_k_yield+0x122> @ imm = #0x20
 800b688: 6abb         	ldr	r3, [r7, #0x28]
 800b68a: 4619         	mov	r1, r3
 800b68c: 6b38         	ldr	r0, [r7, #0x30]
 800b68e: f007 ffa3    	bl	0x80135d8 <sys_dlist_peek_next> @ imm = #0x7f46
 800b692: 4603         	mov	r3, r0
 800b694: 2b00         	cmp	r3, #0x0
 800b696: d006         	beq	0x800b6a6 <z_impl_k_yield+0x11e> @ imm = #0xc
 800b698: 6abb         	ldr	r3, [r7, #0x28]
 800b69a: 4619         	mov	r1, r3
 800b69c: 6b38         	ldr	r0, [r7, #0x30]
 800b69e: f007 ff9b    	bl	0x80135d8 <sys_dlist_peek_next> @ imm = #0x7f36
 800b6a2: 4603         	mov	r3, r0
 800b6a4: e002         	b	0x800b6ac <z_impl_k_yield+0x124> @ imm = #0x4
 800b6a6: 2300         	movs	r3, #0x0
 800b6a8: e000         	b	0x800b6ac <z_impl_k_yield+0x124> @ imm = #0x0
 800b6aa: 2300         	movs	r3, #0x0
 800b6ac: 62bb         	str	r3, [r7, #0x28]
 800b6ae: 6abb         	ldr	r3, [r7, #0x28]
 800b6b0: 2b00         	cmp	r3, #0x0
 800b6b2: d1d8         	bne	0x800b666 <z_impl_k_yield+0xde> @ imm = #-0x50
; 	sys_dlist_append(pq, &thread->base.qnode_dlist);
 800b6b4: 6afb         	ldr	r3, [r7, #0x2c]
 800b6b6: 4619         	mov	r1, r3
 800b6b8: 6b38         	ldr	r0, [r7, #0x30]
 800b6ba: f007 ffa0    	bl	0x80135fe <sys_dlist_append> @ imm = #0x7f40
; }
 800b6be: bf00         	nop
; }
 800b6c0: bf00         	nop
 800b6c2: 2301         	movs	r3, #0x1
 800b6c4: 66fb         	str	r3, [r7, #0x6c]
; 	return &_kernel.ready_q.runq;
 800b6c6: 4b3a         	ldr	r3, [pc, #0xe8]         @ 0x800b7b0 <z_impl_k_yield+0x228>
 800b6c8: 66bb         	str	r3, [r7, #0x68]
; 	struct k_thread *thread = NULL;
 800b6ca: 2300         	movs	r3, #0x0
 800b6cc: 667b         	str	r3, [r7, #0x64]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 800b6ce: 6eb8         	ldr	r0, [r7, #0x68]
 800b6d0: f007 ff5d    	bl	0x801358e <sys_dlist_peek_head> @ imm = #0x7eba
 800b6d4: 6638         	str	r0, [r7, #0x60]
; 	if (n != NULL) {
 800b6d6: 6e3b         	ldr	r3, [r7, #0x60]
 800b6d8: 2b00         	cmp	r3, #0x0
 800b6da: d001         	beq	0x800b6e0 <z_impl_k_yield+0x158> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 800b6dc: 6e3b         	ldr	r3, [r7, #0x60]
 800b6de: 667b         	str	r3, [r7, #0x64]
; 	return thread;
 800b6e0: 6e7b         	ldr	r3, [r7, #0x64]
; 	return _priq_run_best(curr_cpu_runq());
 800b6e2: bf00         	nop
; 	struct k_thread *thread = runq_best();
 800b6e4: 65fb         	str	r3, [r7, #0x5c]
; 	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 800b6e6: 6dfb         	ldr	r3, [r7, #0x5c]
 800b6e8: 2b00         	cmp	r3, #0x0
 800b6ea: d102         	bne	0x800b6f2 <z_impl_k_yield+0x16a> @ imm = #0x4
 800b6ec: 4b2f         	ldr	r3, [pc, #0xbc]         @ 0x800b7ac <z_impl_k_yield+0x224>
 800b6ee: 68db         	ldr	r3, [r3, #0xc]
 800b6f0: e000         	b	0x800b6f4 <z_impl_k_yield+0x16c> @ imm = #0x0
 800b6f2: 6dfb         	ldr	r3, [r7, #0x5c]
; 	struct k_thread *thread = next_up();
 800b6f4: 65bb         	str	r3, [r7, #0x58]
 800b6f6: 6dbb         	ldr	r3, [r7, #0x58]
 800b6f8: 657b         	str	r3, [r7, #0x54]
 800b6fa: 6efb         	ldr	r3, [r7, #0x6c]
 800b6fc: 653b         	str	r3, [r7, #0x50]
; 	if (preempt_ok != 0) {
 800b6fe: 6d3b         	ldr	r3, [r7, #0x50]
 800b700: 2b00         	cmp	r3, #0x0
 800b702: d001         	beq	0x800b708 <z_impl_k_yield+0x180> @ imm = #0x2
; 		return true;
 800b704: 2301         	movs	r3, #0x1
 800b706: e026         	b	0x800b756 <z_impl_k_yield+0x1ce> @ imm = #0x4c
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800b708: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x800b7ac <z_impl_k_yield+0x224>
 800b70a: 689b         	ldr	r3, [r3, #0x8]
 800b70c: 64fb         	str	r3, [r7, #0x4c]
; 	return ret;
 800b70e: 6cfb         	ldr	r3, [r7, #0x4c]
; 	if (z_is_thread_prevented_from_running(arch_current_thread())) {
 800b710: 4618         	mov	r0, r3
 800b712: f008 f820    	bl	0x8013756 <z_is_thread_prevented_from_running> @ imm = #0x8040
 800b716: 4603         	mov	r3, r0
 800b718: 2b00         	cmp	r3, #0x0
 800b71a: d001         	beq	0x800b720 <z_impl_k_yield+0x198> @ imm = #0x2
; 		return true;
 800b71c: 2301         	movs	r3, #0x1
 800b71e: e01a         	b	0x800b756 <z_impl_k_yield+0x1ce> @ imm = #0x34
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800b720: 4b22         	ldr	r3, [pc, #0x88]         @ 0x800b7ac <z_impl_k_yield+0x224>
 800b722: 689b         	ldr	r3, [r3, #0x8]
 800b724: 64bb         	str	r3, [r7, #0x48]
; 	return ret;
 800b726: 6cbb         	ldr	r3, [r7, #0x48]
; 	if (thread_is_preemptible(arch_current_thread()) || thread_is_metairq(thread)) {
 800b728: 4618         	mov	r0, r3
 800b72a: f007 ffe8    	bl	0x80136fe <thread_is_preemptible> @ imm = #0x7fd0
 800b72e: 4603         	mov	r3, r0
 800b730: 2b00         	cmp	r3, #0x0
 800b732: d105         	bne	0x800b740 <z_impl_k_yield+0x1b8> @ imm = #0xa
 800b734: 6d78         	ldr	r0, [r7, #0x54]
 800b736: f007 fff2    	bl	0x801371e <thread_is_metairq> @ imm = #0x7fe4
 800b73a: 4603         	mov	r3, r0
 800b73c: 2b00         	cmp	r3, #0x0
 800b73e: d001         	beq	0x800b744 <z_impl_k_yield+0x1bc> @ imm = #0x2
; 		return true;
 800b740: 2301         	movs	r3, #0x1
 800b742: e008         	b	0x800b756 <z_impl_k_yield+0x1ce> @ imm = #0x10
; 	    && z_is_thread_timeout_active(thread)) {
 800b744: 6d78         	ldr	r0, [r7, #0x54]
 800b746: f008 f81a    	bl	0x801377e <z_is_thread_timeout_active> @ imm = #0x8034
 800b74a: 4603         	mov	r3, r0
; 	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 800b74c: 2b00         	cmp	r3, #0x0
 800b74e: d001         	beq	0x800b754 <z_impl_k_yield+0x1cc> @ imm = #0x2
; 		return true;
 800b750: 2301         	movs	r3, #0x1
 800b752: e000         	b	0x800b756 <z_impl_k_yield+0x1ce> @ imm = #0x0
; 	return false;
 800b754: 2300         	movs	r3, #0x0
; 	if (should_preempt(thread, preempt_ok)) {
 800b756: 2b00         	cmp	r3, #0x0
 800b758: d010         	beq	0x800b77c <z_impl_k_yield+0x1f4> @ imm = #0x20
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800b75a: 4b14         	ldr	r3, [pc, #0x50]         @ 0x800b7ac <z_impl_k_yield+0x224>
 800b75c: 689b         	ldr	r3, [r3, #0x8]
 800b75e: 647b         	str	r3, [r7, #0x44]
; 	return ret;
 800b760: 6c7b         	ldr	r3, [r7, #0x44]
; 		if (thread != arch_current_thread()) {
 800b762: 6dba         	ldr	r2, [r7, #0x58]
 800b764: 429a         	cmp	r2, r3
 800b766: d002         	beq	0x800b76e <z_impl_k_yield+0x1e6> @ imm = #0x4
; 			z_reset_time_slice(thread);
 800b768: 6db8         	ldr	r0, [r7, #0x58]
 800b76a: f000 faff    	bl	0x800bd6c <z_reset_time_slice> @ imm = #0x5fe
; 		update_metairq_preempt(thread);
 800b76e: 6db8         	ldr	r0, [r7, #0x58]
 800b770: f008 f97a    	bl	0x8013a68 <update_metairq_preempt> @ imm = #0x82f4
; 		_kernel.ready_q.cache = thread;
 800b774: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x800b7ac <z_impl_k_yield+0x224>
 800b776: 6dbb         	ldr	r3, [r7, #0x58]
 800b778: 61d3         	str	r3, [r2, #0x1c]
; }
 800b77a: e005         	b	0x800b788 <z_impl_k_yield+0x200> @ imm = #0xa
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800b77c: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800b7ac <z_impl_k_yield+0x224>
 800b77e: 689b         	ldr	r3, [r3, #0x8]
 800b780: 643b         	str	r3, [r7, #0x40]
; 	return ret;
 800b782: 6c3b         	ldr	r3, [r7, #0x40]
; 		_kernel.ready_q.cache = arch_current_thread();
 800b784: 4a09         	ldr	r2, [pc, #0x24]         @ 0x800b7ac <z_impl_k_yield+0x224>
 800b786: 61d3         	str	r3, [r2, #0x1c]
; }
 800b788: bf00         	nop
 800b78a: 4b07         	ldr	r3, [pc, #0x1c]         @ 0x800b7a8 <z_impl_k_yield+0x220>
 800b78c: 677b         	str	r3, [r7, #0x74]
 800b78e: 68bb         	ldr	r3, [r7, #0x8]
 800b790: 607b         	str	r3, [r7, #0x4]
 800b792: 6f7b         	ldr	r3, [r7, #0x74]
 800b794: 673b         	str	r3, [r7, #0x70]
; }
 800b796: bf00         	nop
; 	return z_swap_irqlock(key.key);
 800b798: 687b         	ldr	r3, [r7, #0x4]
 800b79a: 4618         	mov	r0, r3
 800b79c: f008 f8db    	bl	0x8013956 <z_swap_irqlock> @ imm = #0x81b6
; }
 800b7a0: bf00         	nop
 800b7a2: 3790         	adds	r7, #0x90
 800b7a4: 46bd         	mov	sp, r7
 800b7a6: bd80         	pop	{r7, pc}

0800b7a8 <$d>:
 800b7a8: e0 09 00 20  	.word	0x200009e0
 800b7ac: c0 02 00 20  	.word	0x200002c0
 800b7b0: e0 02 00 20  	.word	0x200002e0

0800b7b4 <z_tick_sleep>:
; {
 800b7b4: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 800b7b8: b0a0         	sub	sp, #0x80
 800b7ba: af06         	add	r7, sp, #0x18
 800b7bc: e9c7 0102    	strd	r0, r1, [r7, #8]
; 	LOG_DBG("thread %p for %lu ticks", arch_current_thread(), (unsigned long)ticks);
 800b7c0: 2303         	movs	r3, #0x3
 800b7c2: 2b03         	cmp	r3, #0x3
 800b7c4: d921         	bls	0x800b80a <z_tick_sleep+0x56> @ imm = #0x42
 800b7c6: 2301         	movs	r3, #0x1
 800b7c8: f887 3067    	strb.w	r3, [r7, #0x67]
 800b7cc: f897 3067    	ldrb.w	r3, [r7, #0x67]
 800b7d0: f083 0301    	eor	r3, r3, #0x1
 800b7d4: b2db         	uxtb	r3, r3
 800b7d6: 2b00         	cmp	r3, #0x0
 800b7d8: d117         	bne	0x800b80a <z_tick_sleep+0x56> @ imm = #0x2e
 800b7da: 4b50         	ldr	r3, [pc, #0x140]        @ 0x800b91c <z_tick_sleep+0x168>
 800b7dc: 6819         	ldr	r1, [r3]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800b7de: 4b50         	ldr	r3, [pc, #0x140]        @ 0x800b920 <z_tick_sleep+0x16c>
 800b7e0: 689b         	ldr	r3, [r3, #0x8]
 800b7e2: 65bb         	str	r3, [r7, #0x58]
; 	return ret;
 800b7e4: 6dbb         	ldr	r3, [r7, #0x58]
; 	LOG_DBG("thread %p for %lu ticks", arch_current_thread(), (unsigned long)ticks);
 800b7e6: 68ba         	ldr	r2, [r7, #0x8]
 800b7e8: 9205         	str	r2, [sp, #0x14]
 800b7ea: 9304         	str	r3, [sp, #0x10]
 800b7ec: 4b4d         	ldr	r3, [pc, #0x134]        @ 0x800b924 <z_tick_sleep+0x170>
 800b7ee: 9303         	str	r3, [sp, #0xc]
 800b7f0: 4b4d         	ldr	r3, [pc, #0x134]        @ 0x800b928 <z_tick_sleep+0x174>
 800b7f2: 9302         	str	r3, [sp, #0x8]
 800b7f4: 2308         	movs	r3, #0x8
 800b7f6: 9301         	str	r3, [sp, #0x4]
 800b7f8: 2300         	movs	r3, #0x0
 800b7fa: 9300         	str	r3, [sp]
 800b7fc: 2300         	movs	r3, #0x0
 800b7fe: 2204         	movs	r2, #0x4
 800b800: 2000         	movs	r0, #0x0
 800b802: f008 f8b5    	bl	0x8013970 <z_log_msg_runtime_create> @ imm = #0x816a
 800b806: 2300         	movs	r3, #0x0
 800b808: 65fb         	str	r3, [r7, #0x5c]
; 	if (ticks == 0) {
 800b80a: e9d7 2302    	ldrd	r2, r3, [r7, #8]
 800b80e: 4313         	orrs	r3, r2
 800b810: d103         	bne	0x800b81a <z_tick_sleep+0x66> @ imm = #0x6
; 		k_yield();
 800b812: f007 ff3d    	bl	0x8013690 <k_yield>     @ imm = #0x7e7a
; 		return 0;
 800b816: 2300         	movs	r3, #0x0
 800b818: e07b         	b	0x800b912 <z_tick_sleep+0x15e> @ imm = #0xf6
; 	if (Z_TICK_ABS(ticks) <= 0) {
 800b81a: e9d7 2302    	ldrd	r2, r3, [r7, #8]
 800b81e: f06f 0001    	mvn	r0, #0x1
 800b822: f04f 31ff    	mov.w	r1, #0xffffffff
 800b826: 1a84         	subs	r4, r0, r2
 800b828: eb61 0503    	sbc.w	r5, r1, r3
 800b82c: 2c01         	cmp	r4, #0x1
 800b82e: f175 0300    	sbcs	r3, r5, #0x0
 800b832: da06         	bge	0x800b842 <z_tick_sleep+0x8e> @ imm = #0xc
; 		expected_wakeup_ticks = ticks + sys_clock_tick_get_32();
 800b834: f008 fbbf    	bl	0x8013fb6 <sys_clock_tick_get_32> @ imm = #0x877e
 800b838: 4602         	mov	r2, r0
 800b83a: 68bb         	ldr	r3, [r7, #0x8]
 800b83c: 4413         	add	r3, r2
 800b83e: 663b         	str	r3, [r7, #0x60]
 800b840: e004         	b	0x800b84c <z_tick_sleep+0x98> @ imm = #0x8
; 		expected_wakeup_ticks = Z_TICK_ABS(ticks);
 800b842: 68ba         	ldr	r2, [r7, #0x8]
 800b844: f06f 0301    	mvn	r3, #0x1
 800b848: 1a9b         	subs	r3, r3, r2
 800b84a: 663b         	str	r3, [r7, #0x60]
; 	k_timeout_t timeout = Z_TIMEOUT_TICKS(ticks);
 800b84c: e9d7 2302    	ldrd	r2, r3, [r7, #8]
 800b850: e9c7 2308    	strd	r2, r3, [r7, #32]
 800b854: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x800b92c <z_tick_sleep+0x178>
 800b856: 63fb         	str	r3, [r7, #0x3c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800b858: f3ef 8311    	mrs	r3, basepri
 800b85c: 63bb         	str	r3, [r7, #0x38]
;   return(result);
 800b85e: 6bbb         	ldr	r3, [r7, #0x38]
; 	key = __get_BASEPRI();
 800b860: 637b         	str	r3, [r7, #0x34]
 800b862: 2310         	movs	r3, #0x10
 800b864: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800b866: 6b3b         	ldr	r3, [r7, #0x30]
 800b868: f383 8812    	msr	basepri_max, r3
; }
 800b86c: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800b86e: f3bf 8f6f    	isb	sy
; }
 800b872: bf00         	nop
; 	return key;
 800b874: 6b7b         	ldr	r3, [r7, #0x34]
; 	k.key = arch_irq_lock();
 800b876: 61bb         	str	r3, [r7, #0x18]
 800b878: 6bfb         	ldr	r3, [r7, #0x3c]
 800b87a: 62fb         	str	r3, [r7, #0x2c]
; }
 800b87c: bf00         	nop
 800b87e: 6bfb         	ldr	r3, [r7, #0x3c]
 800b880: 62bb         	str	r3, [r7, #0x28]
; }
 800b882: bf00         	nop
; 	return k;
 800b884: 69bb         	ldr	r3, [r7, #0x18]
 800b886: 61fb         	str	r3, [r7, #0x1c]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800b888: 4b25         	ldr	r3, [pc, #0x94]         @ 0x800b920 <z_tick_sleep+0x16c>
 800b88a: 689b         	ldr	r3, [r3, #0x8]
 800b88c: 643b         	str	r3, [r7, #0x40]
; 	return ret;
 800b88e: 6c3b         	ldr	r3, [r7, #0x40]
; 	pending_current = arch_current_thread();
 800b890: 4a27         	ldr	r2, [pc, #0x9c]         @ 0x800b930 <z_tick_sleep+0x17c>
 800b892: 6013         	str	r3, [r2]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800b894: 4b22         	ldr	r3, [pc, #0x88]         @ 0x800b920 <z_tick_sleep+0x16c>
 800b896: 689b         	ldr	r3, [r3, #0x8]
 800b898: 647b         	str	r3, [r7, #0x44]
; 	return ret;
 800b89a: 6c7b         	ldr	r3, [r7, #0x44]
; 	unready_thread(arch_current_thread());
 800b89c: 4618         	mov	r0, r3
 800b89e: f7ff fa93    	bl	0x800adc8 <unready_thread> @ imm = #-0xada
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800b8a2: 4b1f         	ldr	r3, [pc, #0x7c]         @ 0x800b920 <z_tick_sleep+0x16c>
 800b8a4: 689b         	ldr	r3, [r3, #0x8]
 800b8a6: 64bb         	str	r3, [r7, #0x48]
; 	return ret;
 800b8a8: 6cb9         	ldr	r1, [r7, #0x48]
; 	z_add_thread_timeout(arch_current_thread(), timeout);
 800b8aa: e9d7 2308    	ldrd	r2, r3, [r7, #32]
 800b8ae: 4608         	mov	r0, r1
 800b8b0: f7fe fdda    	bl	0x800a468 <z_add_thread_timeout> @ imm = #-0x144c
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800b8b4: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x800b920 <z_tick_sleep+0x16c>
 800b8b6: 689b         	ldr	r3, [r3, #0x8]
 800b8b8: 64fb         	str	r3, [r7, #0x4c]
; 	return ret;
 800b8ba: 6cfb         	ldr	r3, [r7, #0x4c]
; 	z_mark_thread_as_suspended(arch_current_thread());
 800b8bc: 4618         	mov	r0, r3
 800b8be: f007 ffb8    	bl	0x8013832 <z_mark_thread_as_suspended> @ imm = #0x7f70
 800b8c2: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x800b92c <z_tick_sleep+0x178>
 800b8c4: 657b         	str	r3, [r7, #0x54]
 800b8c6: 69fb         	ldr	r3, [r7, #0x1c]
 800b8c8: 617b         	str	r3, [r7, #0x14]
 800b8ca: 6d7b         	ldr	r3, [r7, #0x54]
 800b8cc: 653b         	str	r3, [r7, #0x50]
; }
 800b8ce: bf00         	nop
; 	return z_swap_irqlock(key.key);
 800b8d0: 697b         	ldr	r3, [r7, #0x14]
 800b8d2: 4618         	mov	r0, r3
 800b8d4: f008 f83f    	bl	0x8013956 <z_swap_irqlock> @ imm = #0x807e
; 	ticks = (k_ticks_t)expected_wakeup_ticks - sys_clock_tick_get_32();
 800b8d8: 6e3b         	ldr	r3, [r7, #0x60]
 800b8da: 2200         	movs	r2, #0x0
 800b8dc: 469a         	mov	r10, r3
 800b8de: 4693         	mov	r11, r2
 800b8e0: f008 fb69    	bl	0x8013fb6 <sys_clock_tick_get_32> @ imm = #0x86d2
 800b8e4: 4603         	mov	r3, r0
 800b8e6: 2200         	movs	r2, #0x0
 800b8e8: 4698         	mov	r8, r3
 800b8ea: 4691         	mov	r9, r2
 800b8ec: ebba 0308    	subs.w	r3, r10, r8
 800b8f0: 603b         	str	r3, [r7]
 800b8f2: eb6b 0309    	sbc.w	r3, r11, r9
 800b8f6: 607b         	str	r3, [r7, #0x4]
 800b8f8: e9d7 3400    	ldrd	r3, r4, [r7]
 800b8fc: e9c7 3402    	strd	r3, r4, [r7, #8]
; 	if (ticks > 0) {
 800b900: e9d7 2302    	ldrd	r2, r3, [r7, #8]
 800b904: 2a01         	cmp	r2, #0x1
 800b906: f173 0300    	sbcs	r3, r3, #0x0
 800b90a: db01         	blt	0x800b910 <z_tick_sleep+0x15c> @ imm = #0x2
; 		return ticks;
 800b90c: 68bb         	ldr	r3, [r7, #0x8]
 800b90e: e000         	b	0x800b912 <z_tick_sleep+0x15e> @ imm = #0x0
; 	return 0;
 800b910: 2300         	movs	r3, #0x0
; }
 800b912: 4618         	mov	r0, r3
 800b914: 3768         	adds	r7, #0x68
 800b916: 46bd         	mov	sp, r7
 800b918: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

0800b91c <$d>:
 800b91c: 1c 01 00 20  	.word	0x2000011c
 800b920: c0 02 00 20  	.word	0x200002c0
 800b924: fc 67 01 08  	.word	0x080167fc
 800b928: 48 5f 01 08  	.word	0x08015f48
 800b92c: e0 09 00 20  	.word	0x200009e0
 800b930: ec 09 00 20  	.word	0x200009ec

0800b934 <z_impl_k_sleep>:
; {
 800b934: e92d 43b0    	push.w	{r4, r5, r7, r8, r9, lr}
 800b938: b086         	sub	sp, #0x18
 800b93a: af00         	add	r7, sp, #0x0
 800b93c: e9c7 0100    	strd	r0, r1, [r7]
; 	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 800b940: e9d7 2300    	ldrd	r2, r3, [r7]
 800b944: f04f 30ff    	mov.w	r0, #0xffffffff
 800b948: f04f 31ff    	mov.w	r1, #0xffffffff
 800b94c: 428b         	cmp	r3, r1
 800b94e: bf08         	it	eq
 800b950: 4282         	cmpeq	r2, r0
 800b952: d109         	bne	0x800b968 <z_impl_k_sleep+0x34> @ imm = #0x12
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800b954: 4b17         	ldr	r3, [pc, #0x5c]         @ 0x800b9b4 <z_impl_k_sleep+0x80>
 800b956: 689b         	ldr	r3, [r3, #0x8]
 800b958: 60bb         	str	r3, [r7, #0x8]
; 	return ret;
 800b95a: 68bb         	ldr	r3, [r7, #0x8]
; 		k_thread_suspend(arch_current_thread());
 800b95c: 4618         	mov	r0, r3
 800b95e: f007 fe9d    	bl	0x801369c <k_thread_suspend> @ imm = #0x7d3a
; 		return (int32_t) K_TICKS_FOREVER;
 800b962: f04f 33ff    	mov.w	r3, #0xffffffff
 800b966: e020         	b	0x800b9aa <z_impl_k_sleep+0x76> @ imm = #0x40
; 	ticks = timeout.ticks;
 800b968: e9d7 2300    	ldrd	r2, r3, [r7]
 800b96c: e9c7 2304    	strd	r2, r3, [r7, #16]
; 	ticks = z_tick_sleep(ticks);
 800b970: e9d7 0104    	ldrd	r0, r1, [r7, #16]
 800b974: f7ff ff1e    	bl	0x800b7b4 <z_tick_sleep> @ imm = #-0x1c4
 800b978: 4603         	mov	r3, r0
 800b97a: 17da         	asrs	r2, r3, #0x1f
 800b97c: 4698         	mov	r8, r3
 800b97e: 4691         	mov	r9, r2
 800b980: e9c7 8904    	strd	r8, r9, [r7, #16]
; 	int32_t ret = k_ticks_to_ms_ceil64(ticks);
 800b984: e9d7 2304    	ldrd	r2, r3, [r7, #16]
 800b988: f112 0409    	adds.w	r4, r2, #0x9
 800b98c: f143 0500    	adc	r5, r3, #0x0
 800b990: f04f 020a    	mov.w	r2, #0xa
 800b994: f04f 0300    	mov.w	r3, #0x0
 800b998: 4620         	mov	r0, r4
 800b99a: 4629         	mov	r1, r5
 800b99c: f7f4 feee    	bl	0x800077c <__aeabi_uldivmod> @ imm = #-0xb224
 800b9a0: 4602         	mov	r2, r0
 800b9a2: 460b         	mov	r3, r1
 800b9a4: 4613         	mov	r3, r2
 800b9a6: 60fb         	str	r3, [r7, #0xc]
; 	return ret;
 800b9a8: 68fb         	ldr	r3, [r7, #0xc]
; }
 800b9aa: 4618         	mov	r0, r3
 800b9ac: 3718         	adds	r7, #0x18
 800b9ae: 46bd         	mov	sp, r7
 800b9b0: e8bd 83b0    	pop.w	{r4, r5, r7, r8, r9, pc}

0800b9b4 <$d>:
 800b9b4: c0 02 00 20  	.word	0x200002c0

0800b9b8 <z_impl_k_sched_current_thread_query>:
; {
 800b9b8: b480         	push	{r7}
 800b9ba: b083         	sub	sp, #0xc
 800b9bc: af00         	add	r7, sp, #0x0
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800b9be: 4b04         	ldr	r3, [pc, #0x10]         @ 0x800b9d0 <z_impl_k_sched_current_thread_query+0x18>
 800b9c0: 689b         	ldr	r3, [r3, #0x8]
 800b9c2: 607b         	str	r3, [r7, #0x4]
; 	return ret;
 800b9c4: 687b         	ldr	r3, [r7, #0x4]
; }
 800b9c6: 4618         	mov	r0, r3
 800b9c8: 370c         	adds	r7, #0xc
 800b9ca: 46bd         	mov	sp, r7
 800b9cc: bc80         	pop	{r7}
 800b9ce: 4770         	bx	lr

0800b9d0 <$d>:
 800b9d0: c0 02 00 20  	.word	0x200002c0

0800b9d4 <halt_thread>:
; {
 800b9d4: b580         	push	{r7, lr}
 800b9d6: b096         	sub	sp, #0x58
 800b9d8: af00         	add	r7, sp, #0x0
 800b9da: 6078         	str	r0, [r7, #0x4]
 800b9dc: 460b         	mov	r3, r1
 800b9de: 70fb         	strb	r3, [r7, #0x3]
; 	bool dummify = false;
 800b9e0: 2300         	movs	r3, #0x0
 800b9e2: f887 3057    	strb.w	r3, [r7, #0x57]
; 	if ((thread->base.thread_state & new_state) == 0U) {
 800b9e6: 687b         	ldr	r3, [r7, #0x4]
 800b9e8: 7b5a         	ldrb	r2, [r3, #0xd]
 800b9ea: 78fb         	ldrb	r3, [r7, #0x3]
 800b9ec: 4013         	ands	r3, r2
 800b9ee: b2db         	uxtb	r3, r3
 800b9f0: 2b00         	cmp	r3, #0x0
 800b9f2: f040 80ca    	bne.w	0x800bb8a <halt_thread+0x1b6> @ imm = #0x194
; 		thread->base.thread_state |= new_state;
 800b9f6: 687b         	ldr	r3, [r7, #0x4]
 800b9f8: 7b5a         	ldrb	r2, [r3, #0xd]
 800b9fa: 78fb         	ldrb	r3, [r7, #0x3]
 800b9fc: 4313         	orrs	r3, r2
 800b9fe: b2da         	uxtb	r2, r3
 800ba00: 687b         	ldr	r3, [r7, #0x4]
 800ba02: 735a         	strb	r2, [r3, #0xd]
; 		if (z_is_thread_queued(thread)) {
 800ba04: 6878         	ldr	r0, [r7, #0x4]
 800ba06: f007 ff07    	bl	0x8013818 <z_is_thread_queued> @ imm = #0x7e0e
 800ba0a: 4603         	mov	r3, r0
 800ba0c: 2b00         	cmp	r3, #0x0
 800ba0e: d01d         	beq	0x800ba4c <halt_thread+0x78> @ imm = #0x3a
 800ba10: 687b         	ldr	r3, [r7, #0x4]
 800ba12: 653b         	str	r3, [r7, #0x50]
; 	thread->base.thread_state &= ~_THREAD_QUEUED;
 800ba14: 6d3b         	ldr	r3, [r7, #0x50]
 800ba16: 7b5b         	ldrb	r3, [r3, #0xd]
 800ba18: f003 037f    	and	r3, r3, #0x7f
 800ba1c: b2da         	uxtb	r2, r3
 800ba1e: 6d3b         	ldr	r3, [r7, #0x50]
 800ba20: 735a         	strb	r2, [r3, #0xd]
; 	if (should_queue_thread(thread)) {
 800ba22: 6d38         	ldr	r0, [r7, #0x50]
 800ba24: f007 ffdd    	bl	0x80139e2 <should_queue_thread> @ imm = #0x7fba
 800ba28: 4603         	mov	r3, r0
 800ba2a: 2b00         	cmp	r3, #0x0
 800ba2c: d00d         	beq	0x800ba4a <halt_thread+0x76> @ imm = #0x1a
 800ba2e: 6d3b         	ldr	r3, [r7, #0x50]
 800ba30: 64fb         	str	r3, [r7, #0x4c]
 800ba32: 6cfb         	ldr	r3, [r7, #0x4c]
 800ba34: 64bb         	str	r3, [r7, #0x48]
; 	return &_kernel.ready_q.runq;
 800ba36: 4b56         	ldr	r3, [pc, #0x158]        @ 0x800bb90 <halt_thread+0x1bc>
 800ba38: 647b         	str	r3, [r7, #0x44]
 800ba3a: 6cfb         	ldr	r3, [r7, #0x4c]
 800ba3c: 643b         	str	r3, [r7, #0x40]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 800ba3e: 6c3b         	ldr	r3, [r7, #0x40]
 800ba40: 4618         	mov	r0, r3
 800ba42: f007 fe0e    	bl	0x8013662 <sys_dlist_remove> @ imm = #0x7c1c
; }
 800ba46: bf00         	nop
; }
 800ba48: bf00         	nop
; }
 800ba4a: bf00         	nop
; 		if (new_state == _THREAD_DEAD) {
 800ba4c: 78fb         	ldrb	r3, [r7, #0x3]
 800ba4e: 2b08         	cmp	r3, #0x8
 800ba50: d123         	bne	0x800ba9a <halt_thread+0xc6> @ imm = #0x46
; 			if (thread->base.pended_on != NULL) {
 800ba52: 687b         	ldr	r3, [r7, #0x4]
 800ba54: 689b         	ldr	r3, [r3, #0x8]
 800ba56: 2b00         	cmp	r3, #0x0
 800ba58: d002         	beq	0x800ba60 <halt_thread+0x8c> @ imm = #0x4
; 				unpend_thread_no_timeout(thread);
 800ba5a: 6878         	ldr	r0, [r7, #0x4]
 800ba5c: f007 ff54    	bl	0x8013908 <unpend_thread_no_timeout> @ imm = #0x7ea8
; 			(void)z_abort_thread_timeout(thread);
 800ba60: 6878         	ldr	r0, [r7, #0x4]
 800ba62: f007 fe3e    	bl	0x80136e2 <z_abort_thread_timeout> @ imm = #0x7c7c
; 			unpend_all(&thread->join_queue);
 800ba66: 687b         	ldr	r3, [r7, #0x4]
 800ba68: 3368         	adds	r3, #0x68
 800ba6a: 4618         	mov	r0, r3
 800ba6c: f008 f92a    	bl	0x8013cc4 <unpend_all>  @ imm = #0x8254
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800ba70: 4b48         	ldr	r3, [pc, #0x120]        @ 0x800bb94 <halt_thread+0x1c0>
 800ba72: 689b         	ldr	r3, [r3, #0x8]
 800ba74: 63fb         	str	r3, [r7, #0x3c]
; 	return ret;
 800ba76: 6bfb         	ldr	r3, [r7, #0x3c]
; 			if (thread == arch_current_thread() && arch_is_in_isr()) {
 800ba78: 687a         	ldr	r2, [r7, #0x4]
 800ba7a: 429a         	cmp	r2, r3
 800ba7c: d10d         	bne	0x800ba9a <halt_thread+0xc6> @ imm = #0x1a
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 800ba7e: f3ef 8305    	mrs	r3, ipsr
 800ba82: 63bb         	str	r3, [r7, #0x38]
;   return(result);
 800ba84: 6bbb         	ldr	r3, [r7, #0x38]
; 	return (__get_IPSR()) ? (true) : (false);
 800ba86: 2b00         	cmp	r3, #0x0
 800ba88: bf14         	ite	ne
 800ba8a: 2301         	movne	r3, #0x1
 800ba8c: 2300         	moveq	r3, #0x0
 800ba8e: b2db         	uxtb	r3, r3
; 			if (thread == arch_current_thread() && arch_is_in_isr()) {
 800ba90: 2b00         	cmp	r3, #0x0
 800ba92: d002         	beq	0x800ba9a <halt_thread+0xc6> @ imm = #0x4
; 				dummify = true;
 800ba94: 2301         	movs	r3, #0x1
 800ba96: f887 3057    	strb.w	r3, [r7, #0x57]
 800ba9a: 2301         	movs	r3, #0x1
 800ba9c: 637b         	str	r3, [r7, #0x34]
; 	return &_kernel.ready_q.runq;
 800ba9e: 4b3c         	ldr	r3, [pc, #0xf0]         @ 0x800bb90 <halt_thread+0x1bc>
 800baa0: 633b         	str	r3, [r7, #0x30]
; 	struct k_thread *thread = NULL;
 800baa2: 2300         	movs	r3, #0x0
 800baa4: 62fb         	str	r3, [r7, #0x2c]
; 	sys_dnode_t *n = sys_dlist_peek_head(pq);
 800baa6: 6b38         	ldr	r0, [r7, #0x30]
 800baa8: f007 fd71    	bl	0x801358e <sys_dlist_peek_head> @ imm = #0x7ae2
 800baac: 62b8         	str	r0, [r7, #0x28]
; 	if (n != NULL) {
 800baae: 6abb         	ldr	r3, [r7, #0x28]
 800bab0: 2b00         	cmp	r3, #0x0
 800bab2: d001         	beq	0x800bab8 <halt_thread+0xe4> @ imm = #0x2
; 		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
 800bab4: 6abb         	ldr	r3, [r7, #0x28]
 800bab6: 62fb         	str	r3, [r7, #0x2c]
; 	return thread;
 800bab8: 6afb         	ldr	r3, [r7, #0x2c]
; 	return _priq_run_best(curr_cpu_runq());
 800baba: bf00         	nop
; 	struct k_thread *thread = runq_best();
 800babc: 627b         	str	r3, [r7, #0x24]
; 	return (thread != NULL) ? thread : _current_cpu->idle_thread;
 800babe: 6a7b         	ldr	r3, [r7, #0x24]
 800bac0: 2b00         	cmp	r3, #0x0
 800bac2: d102         	bne	0x800baca <halt_thread+0xf6> @ imm = #0x4
 800bac4: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x800bb94 <halt_thread+0x1c0>
 800bac6: 68db         	ldr	r3, [r3, #0xc]
 800bac8: e000         	b	0x800bacc <halt_thread+0xf8> @ imm = #0x0
 800baca: 6a7b         	ldr	r3, [r7, #0x24]
; 	struct k_thread *thread = next_up();
 800bacc: 623b         	str	r3, [r7, #0x20]
 800bace: 6a3b         	ldr	r3, [r7, #0x20]
 800bad0: 61fb         	str	r3, [r7, #0x1c]
 800bad2: 6b7b         	ldr	r3, [r7, #0x34]
 800bad4: 61bb         	str	r3, [r7, #0x18]
; 	if (preempt_ok != 0) {
 800bad6: 69bb         	ldr	r3, [r7, #0x18]
 800bad8: 2b00         	cmp	r3, #0x0
 800bada: d001         	beq	0x800bae0 <halt_thread+0x10c> @ imm = #0x2
; 		return true;
 800badc: 2301         	movs	r3, #0x1
 800bade: e026         	b	0x800bb2e <halt_thread+0x15a> @ imm = #0x4c
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800bae0: 4b2c         	ldr	r3, [pc, #0xb0]         @ 0x800bb94 <halt_thread+0x1c0>
 800bae2: 689b         	ldr	r3, [r3, #0x8]
 800bae4: 617b         	str	r3, [r7, #0x14]
; 	return ret;
 800bae6: 697b         	ldr	r3, [r7, #0x14]
; 	if (z_is_thread_prevented_from_running(arch_current_thread())) {
 800bae8: 4618         	mov	r0, r3
 800baea: f007 fe34    	bl	0x8013756 <z_is_thread_prevented_from_running> @ imm = #0x7c68
 800baee: 4603         	mov	r3, r0
 800baf0: 2b00         	cmp	r3, #0x0
 800baf2: d001         	beq	0x800baf8 <halt_thread+0x124> @ imm = #0x2
; 		return true;
 800baf4: 2301         	movs	r3, #0x1
 800baf6: e01a         	b	0x800bb2e <halt_thread+0x15a> @ imm = #0x34
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800baf8: 4b26         	ldr	r3, [pc, #0x98]         @ 0x800bb94 <halt_thread+0x1c0>
 800bafa: 689b         	ldr	r3, [r3, #0x8]
 800bafc: 613b         	str	r3, [r7, #0x10]
; 	return ret;
 800bafe: 693b         	ldr	r3, [r7, #0x10]
; 	if (thread_is_preemptible(arch_current_thread()) || thread_is_metairq(thread)) {
 800bb00: 4618         	mov	r0, r3
 800bb02: f007 fdfc    	bl	0x80136fe <thread_is_preemptible> @ imm = #0x7bf8
 800bb06: 4603         	mov	r3, r0
 800bb08: 2b00         	cmp	r3, #0x0
 800bb0a: d105         	bne	0x800bb18 <halt_thread+0x144> @ imm = #0xa
 800bb0c: 69f8         	ldr	r0, [r7, #0x1c]
 800bb0e: f007 fe06    	bl	0x801371e <thread_is_metairq> @ imm = #0x7c0c
 800bb12: 4603         	mov	r3, r0
 800bb14: 2b00         	cmp	r3, #0x0
 800bb16: d001         	beq	0x800bb1c <halt_thread+0x148> @ imm = #0x2
; 		return true;
 800bb18: 2301         	movs	r3, #0x1
 800bb1a: e008         	b	0x800bb2e <halt_thread+0x15a> @ imm = #0x10
; 	    && z_is_thread_timeout_active(thread)) {
 800bb1c: 69f8         	ldr	r0, [r7, #0x1c]
 800bb1e: f007 fe2e    	bl	0x801377e <z_is_thread_timeout_active> @ imm = #0x7c5c
 800bb22: 4603         	mov	r3, r0
; 	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 800bb24: 2b00         	cmp	r3, #0x0
 800bb26: d001         	beq	0x800bb2c <halt_thread+0x158> @ imm = #0x2
; 		return true;
 800bb28: 2301         	movs	r3, #0x1
 800bb2a: e000         	b	0x800bb2e <halt_thread+0x15a> @ imm = #0x0
; 	return false;
 800bb2c: 2300         	movs	r3, #0x0
; 	if (should_preempt(thread, preempt_ok)) {
 800bb2e: 2b00         	cmp	r3, #0x0
 800bb30: d010         	beq	0x800bb54 <halt_thread+0x180> @ imm = #0x20
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800bb32: 4b18         	ldr	r3, [pc, #0x60]         @ 0x800bb94 <halt_thread+0x1c0>
 800bb34: 689b         	ldr	r3, [r3, #0x8]
 800bb36: 60fb         	str	r3, [r7, #0xc]
; 	return ret;
 800bb38: 68fb         	ldr	r3, [r7, #0xc]
; 		if (thread != arch_current_thread()) {
 800bb3a: 6a3a         	ldr	r2, [r7, #0x20]
 800bb3c: 429a         	cmp	r2, r3
 800bb3e: d002         	beq	0x800bb46 <halt_thread+0x172> @ imm = #0x4
; 			z_reset_time_slice(thread);
 800bb40: 6a38         	ldr	r0, [r7, #0x20]
 800bb42: f000 f913    	bl	0x800bd6c <z_reset_time_slice> @ imm = #0x226
; 		update_metairq_preempt(thread);
 800bb46: 6a38         	ldr	r0, [r7, #0x20]
 800bb48: f007 ff8e    	bl	0x8013a68 <update_metairq_preempt> @ imm = #0x7f1c
; 		_kernel.ready_q.cache = thread;
 800bb4c: 4a11         	ldr	r2, [pc, #0x44]         @ 0x800bb94 <halt_thread+0x1c0>
 800bb4e: 6a3b         	ldr	r3, [r7, #0x20]
 800bb50: 61d3         	str	r3, [r2, #0x1c]
; }
 800bb52: e005         	b	0x800bb60 <halt_thread+0x18c> @ imm = #0xa
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800bb54: 4b0f         	ldr	r3, [pc, #0x3c]         @ 0x800bb94 <halt_thread+0x1c0>
 800bb56: 689b         	ldr	r3, [r3, #0x8]
 800bb58: 60bb         	str	r3, [r7, #0x8]
; 	return ret;
 800bb5a: 68bb         	ldr	r3, [r7, #0x8]
; 		_kernel.ready_q.cache = arch_current_thread();
 800bb5c: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x800bb94 <halt_thread+0x1c0>
 800bb5e: 61d3         	str	r3, [r2, #0x1c]
; }
 800bb60: bf00         	nop
; 		if (new_state == _THREAD_SUSPENDED) {
 800bb62: 78fb         	ldrb	r3, [r7, #0x3]
 800bb64: 2b10         	cmp	r3, #0x10
 800bb66: d103         	bne	0x800bb70 <halt_thread+0x19c> @ imm = #0x6
; 			clear_halting(thread);
 800bb68: 6878         	ldr	r0, [r7, #0x4]
 800bb6a: f007 ff68    	bl	0x8013a3e <clear_halting> @ imm = #0x7ed0
; 			return;
 800bb6e: e00c         	b	0x800bb8a <halt_thread+0x1b6> @ imm = #0x18
; 		z_thread_monitor_exit(thread);
 800bb70: 6878         	ldr	r0, [r7, #0x4]
 800bb72: f000 f9b1    	bl	0x800bed8 <z_thread_monitor_exit> @ imm = #0x362
; 		if (dummify && !IS_ENABLED(CONFIG_ARCH_POSIX)) {
 800bb76: f897 3057    	ldrb.w	r3, [r7, #0x57]
 800bb7a: 2b00         	cmp	r3, #0x0
 800bb7c: d002         	beq	0x800bb84 <halt_thread+0x1b0> @ imm = #0x4
; 			z_dummy_thread_init(&_thread_dummy);
 800bb7e: 4806         	ldr	r0, [pc, #0x18]         @ 0x800bb98 <halt_thread+0x1c4>
 800bb80: f7fe fc98    	bl	0x800a4b4 <z_dummy_thread_init> @ imm = #-0x16d0
; 		clear_halting(thread);
 800bb84: 6878         	ldr	r0, [r7, #0x4]
 800bb86: f007 ff5a    	bl	0x8013a3e <clear_halting> @ imm = #0x7eb4
; }
 800bb8a: 3758         	adds	r7, #0x58
 800bb8c: 46bd         	mov	sp, r7
 800bb8e: bd80         	pop	{r7, pc}

0800bb90 <$d>:
 800bb90: e0 02 00 20  	.word	0x200002e0
 800bb94: c0 02 00 20  	.word	0x200002c0
 800bb98: a0 04 00 20  	.word	0x200004a0

0800bb9c <z_thread_abort>:
; {
 800bb9c: b580         	push	{r7, lr}
 800bb9e: b094         	sub	sp, #0x50
 800bba0: af00         	add	r7, sp, #0x0
 800bba2: 6078         	str	r0, [r7, #0x4]
 800bba4: 4b30         	ldr	r3, [pc, #0xc0]         @ 0x800bc68 <z_thread_abort+0xcc>
 800bba6: 64fb         	str	r3, [r7, #0x4c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800bba8: f3ef 8311    	mrs	r3, basepri
 800bbac: 64bb         	str	r3, [r7, #0x48]
;   return(result);
 800bbae: 6cbb         	ldr	r3, [r7, #0x48]
; 	key = __get_BASEPRI();
 800bbb0: 647b         	str	r3, [r7, #0x44]
 800bbb2: 2310         	movs	r3, #0x10
 800bbb4: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800bbb6: 6c3b         	ldr	r3, [r7, #0x40]
 800bbb8: f383 8812    	msr	basepri_max, r3
; }
 800bbbc: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800bbbe: f3bf 8f6f    	isb	sy
; }
 800bbc2: bf00         	nop
; 	return key;
 800bbc4: 6c7b         	ldr	r3, [r7, #0x44]
; 	k.key = arch_irq_lock();
 800bbc6: 60bb         	str	r3, [r7, #0x8]
 800bbc8: 6cfb         	ldr	r3, [r7, #0x4c]
 800bbca: 63fb         	str	r3, [r7, #0x3c]
; }
 800bbcc: bf00         	nop
 800bbce: 6cfb         	ldr	r3, [r7, #0x4c]
 800bbd0: 63bb         	str	r3, [r7, #0x38]
; }
 800bbd2: bf00         	nop
; 	return k;
 800bbd4: 68bb         	ldr	r3, [r7, #0x8]
 800bbd6: 617b         	str	r3, [r7, #0x14]
; 	if (z_is_thread_essential(thread)) {
 800bbd8: 6878         	ldr	r0, [r7, #0x4]
 800bbda: f007 fe6a    	bl	0x80138b2 <z_is_thread_essential> @ imm = #0x7cd4
 800bbde: 4603         	mov	r3, r0
 800bbe0: 2b00         	cmp	r3, #0x0
 800bbe2: d020         	beq	0x800bc26 <z_thread_abort+0x8a> @ imm = #0x40
 800bbe4: 4b20         	ldr	r3, [pc, #0x80]         @ 0x800bc68 <z_thread_abort+0xcc>
 800bbe6: 62fb         	str	r3, [r7, #0x2c]
 800bbe8: 697b         	ldr	r3, [r7, #0x14]
 800bbea: 60fb         	str	r3, [r7, #0xc]
; 	arch_irq_unlock(key.key);
 800bbec: 68fb         	ldr	r3, [r7, #0xc]
 800bbee: 62bb         	str	r3, [r7, #0x28]
 800bbf0: 6abb         	ldr	r3, [r7, #0x28]
 800bbf2: 627b         	str	r3, [r7, #0x24]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800bbf4: 6a7b         	ldr	r3, [r7, #0x24]
 800bbf6: f383 8811    	msr	basepri, r3
; }
 800bbfa: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800bbfc: f3bf 8f6f    	isb	sy
; }
 800bc00: bf00         	nop
; }
 800bc02: bf00         	nop
; }
 800bc04: bf00         	nop
 800bc06: 2300         	movs	r3, #0x0
 800bc08: 637b         	str	r3, [r7, #0x34]
 800bc0a: 6b7b         	ldr	r3, [r7, #0x34]
 800bc0c: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800bc0e: 6b3b         	ldr	r3, [r7, #0x30]
 800bc10: f383 8811    	msr	basepri, r3
; }
 800bc14: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800bc16: f3bf 8f6f    	isb	sy
; }
 800bc1a: bf00         	nop
; }
 800bc1c: bf00         	nop
; 		k_panic();
 800bc1e: 2304         	movs	r3, #0x4
 800bc20: 4618         	mov	r0, r3
 800bc22: df02         	svc	#0x2
; 		return;
 800bc24: e01c         	b	0x800bc60 <z_thread_abort+0xc4> @ imm = #0x38
; 	if ((thread->base.thread_state & _THREAD_DEAD) != 0U) {
 800bc26: 687b         	ldr	r3, [r7, #0x4]
 800bc28: 7b5b         	ldrb	r3, [r3, #0xd]
 800bc2a: f003 0308    	and	r3, r3, #0x8
 800bc2e: 2b00         	cmp	r3, #0x0
 800bc30: d011         	beq	0x800bc56 <z_thread_abort+0xba> @ imm = #0x22
 800bc32: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800bc68 <z_thread_abort+0xcc>
 800bc34: 623b         	str	r3, [r7, #0x20]
 800bc36: 697b         	ldr	r3, [r7, #0x14]
 800bc38: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 800bc3a: 693b         	ldr	r3, [r7, #0x10]
 800bc3c: 61fb         	str	r3, [r7, #0x1c]
 800bc3e: 69fb         	ldr	r3, [r7, #0x1c]
 800bc40: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800bc42: 69bb         	ldr	r3, [r7, #0x18]
 800bc44: f383 8811    	msr	basepri, r3
; }
 800bc48: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800bc4a: f3bf 8f6f    	isb	sy
; }
 800bc4e: bf00         	nop
; }
 800bc50: bf00         	nop
; }
 800bc52: bf00         	nop
; 		return;
 800bc54: e004         	b	0x800bc60 <z_thread_abort+0xc4> @ imm = #0x8
; 	z_thread_halt(thread, key, true);
 800bc56: 2201         	movs	r2, #0x1
 800bc58: 6979         	ldr	r1, [r7, #0x14]
 800bc5a: 6878         	ldr	r0, [r7, #0x4]
 800bc5c: f7fe febe    	bl	0x800a9dc <z_thread_halt> @ imm = #-0x1284
; }
 800bc60: 3750         	adds	r7, #0x50
 800bc62: 46bd         	mov	sp, r7
 800bc64: bd80         	pop	{r7, pc}
 800bc66: bf00         	nop

0800bc68 <$d>:
 800bc68: e0 09 00 20  	.word	0x200009e0

0800bc6c <z_is_idle_thread_object>:
; {
 800bc6c: b480         	push	{r7}
 800bc6e: b083         	sub	sp, #0xc
 800bc70: af00         	add	r7, sp, #0x0
 800bc72: 6078         	str	r0, [r7, #0x4]
; 	return thread == &z_idle_threads[0];
 800bc74: 687b         	ldr	r3, [r7, #0x4]
 800bc76: 4a05         	ldr	r2, [pc, #0x14]         @ 0x800bc8c <z_is_idle_thread_object+0x20>
 800bc78: 4293         	cmp	r3, r2
 800bc7a: bf0c         	ite	eq
 800bc7c: 2301         	moveq	r3, #0x1
 800bc7e: 2300         	movne	r3, #0x0
 800bc80: b2db         	uxtb	r3, r3
; }
 800bc82: 4618         	mov	r0, r3
 800bc84: 370c         	adds	r7, #0xc
 800bc86: 46bd         	mov	sp, r7
 800bc88: bc80         	pop	{r7}
 800bc8a: 4770         	bx	lr

0800bc8c <$d>:
 800bc8c: d0 03 00 20  	.word	0x200003d0

0800bc90 <slice_time>:
; {
 800bc90: b480         	push	{r7}
 800bc92: b085         	sub	sp, #0x14
 800bc94: af00         	add	r7, sp, #0x0
 800bc96: 6078         	str	r0, [r7, #0x4]
; 	int ret = slice_ticks;
 800bc98: 4b04         	ldr	r3, [pc, #0x10]         @ 0x800bcac <slice_time+0x1c>
 800bc9a: 681b         	ldr	r3, [r3]
 800bc9c: 60fb         	str	r3, [r7, #0xc]
; 	return ret;
 800bc9e: 68fb         	ldr	r3, [r7, #0xc]
; }
 800bca0: 4618         	mov	r0, r3
 800bca2: 3714         	adds	r7, #0x14
 800bca4: 46bd         	mov	sp, r7
 800bca6: bc80         	pop	{r7}
 800bca8: 4770         	bx	lr
 800bcaa: bf00         	nop

0800bcac <$d>:
 800bcac: e0 09 00 20  	.word	0x200009e0

0800bcb0 <thread_is_sliceable>:
; {
 800bcb0: b580         	push	{r7, lr}
 800bcb2: b084         	sub	sp, #0x10
 800bcb4: af00         	add	r7, sp, #0x0
 800bcb6: 6078         	str	r0, [r7, #0x4]
; 	bool ret = thread_is_preemptible(thread)
 800bcb8: 6878         	ldr	r0, [r7, #0x4]
 800bcba: f008 f82a    	bl	0x8013d12 <thread_is_preemptible> @ imm = #0x8054
 800bcbe: 4603         	mov	r3, r0
; 		&& !z_is_idle_thread_object(thread);
 800bcc0: 2b00         	cmp	r3, #0x0
 800bcc2: d029         	beq	0x800bd18 <thread_is_sliceable+0x68> @ imm = #0x52
; 		&& slice_time(thread) != 0
 800bcc4: 6878         	ldr	r0, [r7, #0x4]
 800bcc6: f7ff ffe3    	bl	0x800bc90 <slice_time>  @ imm = #-0x3a
 800bcca: 4603         	mov	r3, r0
 800bccc: 2b00         	cmp	r3, #0x0
 800bcce: d023         	beq	0x800bd18 <thread_is_sliceable+0x68> @ imm = #0x46
; 		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
 800bcd0: 687b         	ldr	r3, [r7, #0x4]
 800bcd2: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 800bcd6: 461a         	mov	r2, r3
 800bcd8: 4b15         	ldr	r3, [pc, #0x54]         @ 0x800bd30 <thread_is_sliceable+0x80>
 800bcda: 681b         	ldr	r3, [r3]
 800bcdc: 4619         	mov	r1, r3
 800bcde: 4610         	mov	r0, r2
 800bce0: f008 f84c    	bl	0x8013d7c <z_is_prio_higher> @ imm = #0x8098
 800bce4: 4603         	mov	r3, r0
 800bce6: f083 0301    	eor	r3, r3, #0x1
 800bcea: b2db         	uxtb	r3, r3
 800bcec: 2b00         	cmp	r3, #0x0
 800bcee: d013         	beq	0x800bd18 <thread_is_sliceable+0x68> @ imm = #0x26
; 		&& !z_is_thread_prevented_from_running(thread)
 800bcf0: 6878         	ldr	r0, [r7, #0x4]
 800bcf2: f008 f81e    	bl	0x8013d32 <z_is_thread_prevented_from_running> @ imm = #0x803c
 800bcf6: 4603         	mov	r3, r0
 800bcf8: f083 0301    	eor	r3, r3, #0x1
 800bcfc: b2db         	uxtb	r3, r3
 800bcfe: 2b00         	cmp	r3, #0x0
 800bd00: d00a         	beq	0x800bd18 <thread_is_sliceable+0x68> @ imm = #0x14
; 		&& !z_is_idle_thread_object(thread);
 800bd02: 6878         	ldr	r0, [r7, #0x4]
 800bd04: f7ff ffb2    	bl	0x800bc6c <z_is_idle_thread_object> @ imm = #-0x9c
 800bd08: 4603         	mov	r3, r0
 800bd0a: f083 0301    	eor	r3, r3, #0x1
 800bd0e: b2db         	uxtb	r3, r3
 800bd10: 2b00         	cmp	r3, #0x0
 800bd12: d001         	beq	0x800bd18 <thread_is_sliceable+0x68> @ imm = #0x2
 800bd14: 2301         	movs	r3, #0x1
 800bd16: e000         	b	0x800bd1a <thread_is_sliceable+0x6a> @ imm = #0x0
 800bd18: 2300         	movs	r3, #0x0
; 	bool ret = thread_is_preemptible(thread)
 800bd1a: 73fb         	strb	r3, [r7, #0xf]
 800bd1c: 7bfb         	ldrb	r3, [r7, #0xf]
 800bd1e: f003 0301    	and	r3, r3, #0x1
 800bd22: 73fb         	strb	r3, [r7, #0xf]
; 	return ret;
 800bd24: 7bfb         	ldrb	r3, [r7, #0xf]
; }
 800bd26: 4618         	mov	r0, r3
 800bd28: 3710         	adds	r7, #0x10
 800bd2a: 46bd         	mov	sp, r7
 800bd2c: bd80         	pop	{r7, pc}
 800bd2e: bf00         	nop

0800bd30 <$d>:
 800bd30: e4 09 00 20  	.word	0x200009e4

0800bd34 <slice_timeout>:
; {
 800bd34: b480         	push	{r7}
 800bd36: b085         	sub	sp, #0x14
 800bd38: af00         	add	r7, sp, #0x0
 800bd3a: 6078         	str	r0, [r7, #0x4]
; 	int cpu = ARRAY_INDEX(slice_timeouts, timeout);
 800bd3c: 687b         	ldr	r3, [r7, #0x4]
 800bd3e: 4a08         	ldr	r2, [pc, #0x20]         @ 0x800bd60 <slice_timeout+0x2c>
 800bd40: 1a9b         	subs	r3, r3, r2
 800bd42: 10db         	asrs	r3, r3, #0x3
 800bd44: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x800bd64 <slice_timeout+0x30>
 800bd46: fb02 f303    	mul	r3, r2, r3
 800bd4a: 60fb         	str	r3, [r7, #0xc]
; 	slice_expired[cpu] = true;
 800bd4c: 4a06         	ldr	r2, [pc, #0x18]         @ 0x800bd68 <slice_timeout+0x34>
 800bd4e: 68fb         	ldr	r3, [r7, #0xc]
 800bd50: 4413         	add	r3, r2
 800bd52: 2201         	movs	r2, #0x1
 800bd54: 701a         	strb	r2, [r3]
; }
 800bd56: bf00         	nop
 800bd58: 3714         	adds	r7, #0x14
 800bd5a: 46bd         	mov	sp, r7
 800bd5c: bc80         	pop	{r7}
 800bd5e: 4770         	bx	lr

0800bd60 <$d>:
 800bd60: 70 05 00 20  	.word	0x20000570
 800bd64: ab aa aa aa  	.word	0xaaaaaaab
 800bd68: e8 09 00 20  	.word	0x200009e8

0800bd6c <z_reset_time_slice>:
; {
 800bd6c: e92d 4390    	push.w	{r4, r7, r8, r9, lr}
 800bd70: b085         	sub	sp, #0x14
 800bd72: af00         	add	r7, sp, #0x0
 800bd74: 6078         	str	r0, [r7, #0x4]
; 	int cpu = _current_cpu->id;
 800bd76: 4b19         	ldr	r3, [pc, #0x64]         @ 0x800bddc <z_reset_time_slice+0x70>
 800bd78: 7c1b         	ldrb	r3, [r3, #0x10]
 800bd7a: 60fb         	str	r3, [r7, #0xc]
; 	z_abort_timeout(&slice_timeouts[cpu]);
 800bd7c: 68fa         	ldr	r2, [r7, #0xc]
 800bd7e: 4613         	mov	r3, r2
 800bd80: 005b         	lsls	r3, r3, #0x1
 800bd82: 4413         	add	r3, r2
 800bd84: 00db         	lsls	r3, r3, #0x3
 800bd86: 4a16         	ldr	r2, [pc, #0x58]         @ 0x800bde0 <z_reset_time_slice+0x74>
 800bd88: 4413         	add	r3, r2
 800bd8a: 4618         	mov	r0, r3
 800bd8c: f000 fa4a    	bl	0x800c224 <z_abort_timeout> @ imm = #0x494
; 	slice_expired[cpu] = false;
 800bd90: 4a14         	ldr	r2, [pc, #0x50]         @ 0x800bde4 <z_reset_time_slice+0x78>
 800bd92: 68fb         	ldr	r3, [r7, #0xc]
 800bd94: 4413         	add	r3, r2
 800bd96: 2200         	movs	r2, #0x0
 800bd98: 701a         	strb	r2, [r3]
; 	if (thread_is_sliceable(thread)) {
 800bd9a: 6878         	ldr	r0, [r7, #0x4]
 800bd9c: f7ff ff88    	bl	0x800bcb0 <thread_is_sliceable> @ imm = #-0xf0
 800bda0: 4603         	mov	r3, r0
 800bda2: 2b00         	cmp	r3, #0x0
 800bda4: d014         	beq	0x800bdd0 <z_reset_time_slice+0x64> @ imm = #0x28
; 		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
 800bda6: 68fa         	ldr	r2, [r7, #0xc]
 800bda8: 4613         	mov	r3, r2
 800bdaa: 005b         	lsls	r3, r3, #0x1
 800bdac: 4413         	add	r3, r2
 800bdae: 00db         	lsls	r3, r3, #0x3
 800bdb0: 4a0b         	ldr	r2, [pc, #0x2c]         @ 0x800bde0 <z_reset_time_slice+0x74>
 800bdb2: 189c         	adds	r4, r3, r2
; 			      K_TICKS(slice_time(thread) - 1));
 800bdb4: 6878         	ldr	r0, [r7, #0x4]
 800bdb6: f7ff ff6b    	bl	0x800bc90 <slice_time>  @ imm = #-0x12a
 800bdba: 4603         	mov	r3, r0
 800bdbc: 3b01         	subs	r3, #0x1
 800bdbe: 17da         	asrs	r2, r3, #0x1f
 800bdc0: 4698         	mov	r8, r3
 800bdc2: 4691         	mov	r9, r2
 800bdc4: 4642         	mov	r2, r8
 800bdc6: 464b         	mov	r3, r9
; 		z_add_timeout(&slice_timeouts[cpu], slice_timeout,
 800bdc8: 4907         	ldr	r1, [pc, #0x1c]         @ 0x800bde8 <z_reset_time_slice+0x7c>
 800bdca: 4620         	mov	r0, r4
 800bdcc: f000 f932    	bl	0x800c034 <z_add_timeout> @ imm = #0x264
; }
 800bdd0: bf00         	nop
 800bdd2: 3714         	adds	r7, #0x14
 800bdd4: 46bd         	mov	sp, r7
 800bdd6: e8bd 8390    	pop.w	{r4, r7, r8, r9, pc}
 800bdda: bf00         	nop

0800bddc <$d>:
 800bddc: c0 02 00 20  	.word	0x200002c0
 800bde0: 70 05 00 20  	.word	0x20000570
 800bde4: e8 09 00 20  	.word	0x200009e8
 800bde8: 35 bd 00 08  	.word	0x0800bd35

0800bdec <z_time_slice>:
; {
 800bdec: b580         	push	{r7, lr}
 800bdee: b092         	sub	sp, #0x48
 800bdf0: af00         	add	r7, sp, #0x0
 800bdf2: 4b35         	ldr	r3, [pc, #0xd4]         @ 0x800bec8 <z_time_slice+0xdc>
 800bdf4: 63fb         	str	r3, [r7, #0x3c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800bdf6: f3ef 8311    	mrs	r3, basepri
 800bdfa: 63bb         	str	r3, [r7, #0x38]
;   return(result);
 800bdfc: 6bbb         	ldr	r3, [r7, #0x38]
; 	key = __get_BASEPRI();
 800bdfe: 637b         	str	r3, [r7, #0x34]
 800be00: 2310         	movs	r3, #0x10
 800be02: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800be04: 6b3b         	ldr	r3, [r7, #0x30]
 800be06: f383 8812    	msr	basepri_max, r3
; }
 800be0a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800be0c: f3bf 8f6f    	isb	sy
; }
 800be10: bf00         	nop
; 	return key;
 800be12: 6b7b         	ldr	r3, [r7, #0x34]
; 	k.key = arch_irq_lock();
 800be14: 603b         	str	r3, [r7]
 800be16: 6bfb         	ldr	r3, [r7, #0x3c]
 800be18: 62fb         	str	r3, [r7, #0x2c]
; }
 800be1a: bf00         	nop
 800be1c: 6bfb         	ldr	r3, [r7, #0x3c]
 800be1e: 62bb         	str	r3, [r7, #0x28]
; }
 800be20: bf00         	nop
; 	return k;
 800be22: 683b         	ldr	r3, [r7]
 800be24: 60fb         	str	r3, [r7, #0xc]
; 	struct k_thread *ret = _kernel.cpus[0].current;
 800be26: 4b29         	ldr	r3, [pc, #0xa4]         @ 0x800becc <z_time_slice+0xe0>
 800be28: 689b         	ldr	r3, [r3, #0x8]
 800be2a: 643b         	str	r3, [r7, #0x40]
; 	return ret;
 800be2c: 6c3b         	ldr	r3, [r7, #0x40]
; 	struct k_thread *curr = arch_current_thread();
 800be2e: 647b         	str	r3, [r7, #0x44]
; 	if (pending_current == curr) {
 800be30: 4b27         	ldr	r3, [pc, #0x9c]         @ 0x800bed0 <z_time_slice+0xe4>
 800be32: 681b         	ldr	r3, [r3]
 800be34: 6c7a         	ldr	r2, [r7, #0x44]
 800be36: 429a         	cmp	r2, r3
 800be38: d113         	bne	0x800be62 <z_time_slice+0x76> @ imm = #0x26
; 		z_reset_time_slice(curr);
 800be3a: 6c78         	ldr	r0, [r7, #0x44]
 800be3c: f7ff ff96    	bl	0x800bd6c <z_reset_time_slice> @ imm = #-0xd4
 800be40: 4b21         	ldr	r3, [pc, #0x84]         @ 0x800bec8 <z_time_slice+0xdc>
 800be42: 627b         	str	r3, [r7, #0x24]
 800be44: 68fb         	ldr	r3, [r7, #0xc]
 800be46: 607b         	str	r3, [r7, #0x4]
; 	arch_irq_unlock(key.key);
 800be48: 687b         	ldr	r3, [r7, #0x4]
 800be4a: 623b         	str	r3, [r7, #0x20]
 800be4c: 6a3b         	ldr	r3, [r7, #0x20]
 800be4e: 61fb         	str	r3, [r7, #0x1c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800be50: 69fb         	ldr	r3, [r7, #0x1c]
 800be52: f383 8811    	msr	basepri, r3
; }
 800be56: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800be58: f3bf 8f6f    	isb	sy
; }
 800be5c: bf00         	nop
; }
 800be5e: bf00         	nop
; }
 800be60: e02f         	b	0x800bec2 <z_time_slice+0xd6> @ imm = #0x5e
; 	pending_current = NULL;
 800be62: 4b1b         	ldr	r3, [pc, #0x6c]         @ 0x800bed0 <z_time_slice+0xe4>
 800be64: 2200         	movs	r2, #0x0
 800be66: 601a         	str	r2, [r3]
; 	if (slice_expired[_current_cpu->id] && thread_is_sliceable(curr)) {
 800be68: 4b18         	ldr	r3, [pc, #0x60]         @ 0x800becc <z_time_slice+0xe0>
 800be6a: 7c1b         	ldrb	r3, [r3, #0x10]
 800be6c: 461a         	mov	r2, r3
 800be6e: 4b19         	ldr	r3, [pc, #0x64]         @ 0x800bed4 <z_time_slice+0xe8>
 800be70: 5c9b         	ldrb	r3, [r3, r2]
 800be72: 2b00         	cmp	r3, #0x0
 800be74: d014         	beq	0x800bea0 <z_time_slice+0xb4> @ imm = #0x28
 800be76: 6c78         	ldr	r0, [r7, #0x44]
 800be78: f7ff ff1a    	bl	0x800bcb0 <thread_is_sliceable> @ imm = #-0x1cc
 800be7c: 4603         	mov	r3, r0
 800be7e: 2b00         	cmp	r3, #0x0
 800be80: d00e         	beq	0x800bea0 <z_time_slice+0xb4> @ imm = #0x1c
; 		if (!z_is_thread_prevented_from_running(curr)) {
 800be82: 6c78         	ldr	r0, [r7, #0x44]
 800be84: f007 ff55    	bl	0x8013d32 <z_is_thread_prevented_from_running> @ imm = #0x7eaa
 800be88: 4603         	mov	r3, r0
 800be8a: f083 0301    	eor	r3, r3, #0x1
 800be8e: b2db         	uxtb	r3, r3
 800be90: 2b00         	cmp	r3, #0x0
 800be92: d002         	beq	0x800be9a <z_time_slice+0xae> @ imm = #0x4
; 			move_thread_to_end_of_prio_q(curr);
 800be94: 6c78         	ldr	r0, [r7, #0x44]
 800be96: f7fe fb31    	bl	0x800a4fc <move_thread_to_end_of_prio_q> @ imm = #-0x199e
; 		z_reset_time_slice(curr);
 800be9a: 6c78         	ldr	r0, [r7, #0x44]
 800be9c: f7ff ff66    	bl	0x800bd6c <z_reset_time_slice> @ imm = #-0x134
 800bea0: 4b09         	ldr	r3, [pc, #0x24]         @ 0x800bec8 <z_time_slice+0xdc>
 800bea2: 61bb         	str	r3, [r7, #0x18]
 800bea4: 68fb         	ldr	r3, [r7, #0xc]
 800bea6: 60bb         	str	r3, [r7, #0x8]
; 	arch_irq_unlock(key.key);
 800bea8: 68bb         	ldr	r3, [r7, #0x8]
 800beaa: 617b         	str	r3, [r7, #0x14]
 800beac: 697b         	ldr	r3, [r7, #0x14]
 800beae: 613b         	str	r3, [r7, #0x10]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800beb0: 693b         	ldr	r3, [r7, #0x10]
 800beb2: f383 8811    	msr	basepri, r3
; }
 800beb6: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800beb8: f3bf 8f6f    	isb	sy
; }
 800bebc: bf00         	nop
; }
 800bebe: bf00         	nop
; }
 800bec0: bf00         	nop
; }
 800bec2: 3748         	adds	r7, #0x48
 800bec4: 46bd         	mov	sp, r7
 800bec6: bd80         	pop	{r7, pc}

0800bec8 <$d>:
 800bec8: e0 09 00 20  	.word	0x200009e0
 800becc: c0 02 00 20  	.word	0x200002c0
 800bed0: ec 09 00 20  	.word	0x200009ec
 800bed4: e8 09 00 20  	.word	0x200009e8

0800bed8 <z_thread_monitor_exit>:
; {
 800bed8: b480         	push	{r7}
 800beda: b091         	sub	sp, #0x44
 800bedc: af00         	add	r7, sp, #0x0
 800bede: 6078         	str	r0, [r7, #0x4]
 800bee0: 4b2a         	ldr	r3, [pc, #0xa8]         @ 0x800bf8c <z_thread_monitor_exit+0xb4>
 800bee2: 63bb         	str	r3, [r7, #0x38]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800bee4: f3ef 8311    	mrs	r3, basepri
 800bee8: 637b         	str	r3, [r7, #0x34]
;   return(result);
 800beea: 6b7b         	ldr	r3, [r7, #0x34]
; 	key = __get_BASEPRI();
 800beec: 633b         	str	r3, [r7, #0x30]
 800beee: 2310         	movs	r3, #0x10
 800bef0: 62fb         	str	r3, [r7, #0x2c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800bef2: 6afb         	ldr	r3, [r7, #0x2c]
 800bef4: f383 8812    	msr	basepri_max, r3
; }
 800bef8: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800befa: f3bf 8f6f    	isb	sy
; }
 800befe: bf00         	nop
; 	return key;
 800bf00: 6b3b         	ldr	r3, [r7, #0x30]
; 	k.key = arch_irq_lock();
 800bf02: 60fb         	str	r3, [r7, #0xc]
 800bf04: 6bbb         	ldr	r3, [r7, #0x38]
 800bf06: 62bb         	str	r3, [r7, #0x28]
; }
 800bf08: bf00         	nop
 800bf0a: 6bbb         	ldr	r3, [r7, #0x38]
 800bf0c: 627b         	str	r3, [r7, #0x24]
; }
 800bf0e: bf00         	nop
; 	return k;
 800bf10: 68fb         	ldr	r3, [r7, #0xc]
 800bf12: 617b         	str	r3, [r7, #0x14]
; 	if (thread == _kernel.threads) {
 800bf14: 4b1e         	ldr	r3, [pc, #0x78]         @ 0x800bf90 <z_thread_monitor_exit+0xb8>
 800bf16: 6a9b         	ldr	r3, [r3, #0x28]
 800bf18: 687a         	ldr	r2, [r7, #0x4]
 800bf1a: 429a         	cmp	r2, r3
 800bf1c: d106         	bne	0x800bf2c <z_thread_monitor_exit+0x54> @ imm = #0xc
; 		_kernel.threads = _kernel.threads->next_thread;
 800bf1e: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x800bf90 <z_thread_monitor_exit+0xb8>
 800bf20: 6a9b         	ldr	r3, [r3, #0x28]
 800bf22: f8d3 3090    	ldr.w	r3, [r3, #0x90]
 800bf26: 4a1a         	ldr	r2, [pc, #0x68]         @ 0x800bf90 <z_thread_monitor_exit+0xb8>
 800bf28: 6293         	str	r3, [r2, #0x28]
 800bf2a: e019         	b	0x800bf60 <z_thread_monitor_exit+0x88> @ imm = #0x32
; 		prev_thread = _kernel.threads;
 800bf2c: 4b18         	ldr	r3, [pc, #0x60]         @ 0x800bf90 <z_thread_monitor_exit+0xb8>
 800bf2e: 6a9b         	ldr	r3, [r3, #0x28]
 800bf30: 63fb         	str	r3, [r7, #0x3c]
; 		while ((prev_thread != NULL) &&
 800bf32: e003         	b	0x800bf3c <z_thread_monitor_exit+0x64> @ imm = #0x6
; 			prev_thread = prev_thread->next_thread;
 800bf34: 6bfb         	ldr	r3, [r7, #0x3c]
 800bf36: f8d3 3090    	ldr.w	r3, [r3, #0x90]
 800bf3a: 63fb         	str	r3, [r7, #0x3c]
; 		while ((prev_thread != NULL) &&
 800bf3c: 6bfb         	ldr	r3, [r7, #0x3c]
 800bf3e: 2b00         	cmp	r3, #0x0
 800bf40: d005         	beq	0x800bf4e <z_thread_monitor_exit+0x76> @ imm = #0xa
; 			(thread != prev_thread->next_thread)) {
 800bf42: 6bfb         	ldr	r3, [r7, #0x3c]
 800bf44: f8d3 3090    	ldr.w	r3, [r3, #0x90]
; 		while ((prev_thread != NULL) &&
 800bf48: 687a         	ldr	r2, [r7, #0x4]
 800bf4a: 429a         	cmp	r2, r3
 800bf4c: d1f2         	bne	0x800bf34 <z_thread_monitor_exit+0x5c> @ imm = #-0x1c
; 		if (prev_thread != NULL) {
 800bf4e: 6bfb         	ldr	r3, [r7, #0x3c]
 800bf50: 2b00         	cmp	r3, #0x0
 800bf52: d005         	beq	0x800bf60 <z_thread_monitor_exit+0x88> @ imm = #0xa
; 			prev_thread->next_thread = thread->next_thread;
 800bf54: 687b         	ldr	r3, [r7, #0x4]
 800bf56: f8d3 2090    	ldr.w	r2, [r3, #0x90]
 800bf5a: 6bfb         	ldr	r3, [r7, #0x3c]
 800bf5c: f8c3 2090    	str.w	r2, [r3, #0x90]
 800bf60: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800bf8c <z_thread_monitor_exit+0xb4>
 800bf62: 623b         	str	r3, [r7, #0x20]
 800bf64: 697b         	ldr	r3, [r7, #0x14]
 800bf66: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 800bf68: 693b         	ldr	r3, [r7, #0x10]
 800bf6a: 61fb         	str	r3, [r7, #0x1c]
 800bf6c: 69fb         	ldr	r3, [r7, #0x1c]
 800bf6e: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800bf70: 69bb         	ldr	r3, [r7, #0x18]
 800bf72: f383 8811    	msr	basepri, r3
; }
 800bf76: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800bf78: f3bf 8f6f    	isb	sy
; }
 800bf7c: bf00         	nop
; }
 800bf7e: bf00         	nop
; }
 800bf80: bf00         	nop
; }
 800bf82: bf00         	nop
 800bf84: 3744         	adds	r7, #0x44
 800bf86: 46bd         	mov	sp, r7
 800bf88: bc80         	pop	{r7}
 800bf8a: 4770         	bx	lr

0800bf8c <$d>:
 800bf8c: f0 09 00 20  	.word	0x200009f0
 800bf90: c0 02 00 20  	.word	0x200002c0

0800bf94 <z_data_copy>:
; {
 800bf94: b580         	push	{r7, lr}
 800bf96: af00         	add	r7, sp, #0x0
; 		       __data_region_end - __data_region_start);
 800bf98: 4a08         	ldr	r2, [pc, #0x20]         @ 0x800bfbc <z_data_copy+0x28>
 800bf9a: 4b09         	ldr	r3, [pc, #0x24]         @ 0x800bfc0 <z_data_copy+0x2c>
 800bf9c: 1ad3         	subs	r3, r2, r3
; 	z_early_memcpy(&__data_region_start, &__data_region_load_start,
 800bf9e: 461a         	mov	r2, r3
 800bfa0: 4908         	ldr	r1, [pc, #0x20]         @ 0x800bfc4 <z_data_copy+0x30>
 800bfa2: 4807         	ldr	r0, [pc, #0x1c]         @ 0x800bfc0 <z_data_copy+0x2c>
 800bfa4: f006 fea0    	bl	0x8012ce8 <z_early_memcpy> @ imm = #0x6d40
; 		       __ramfunc_end - __ramfunc_region_start);
 800bfa8: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x800bfc8 <z_data_copy+0x34>
 800bfaa: 4b08         	ldr	r3, [pc, #0x20]         @ 0x800bfcc <z_data_copy+0x38>
 800bfac: 1ad3         	subs	r3, r2, r3
; 	z_early_memcpy(&__ramfunc_region_start, &__ramfunc_load_start,
 800bfae: 461a         	mov	r2, r3
 800bfb0: 4907         	ldr	r1, [pc, #0x1c]         @ 0x800bfd0 <z_data_copy+0x3c>
 800bfb2: 4806         	ldr	r0, [pc, #0x18]         @ 0x800bfcc <z_data_copy+0x38>
 800bfb4: f006 fe98    	bl	0x8012ce8 <z_early_memcpy> @ imm = #0x6d30
; }
 800bfb8: bf00         	nop
 800bfba: bd80         	pop	{r7, pc}

0800bfbc <$d>:
 800bfbc: dc 01 00 20  	.word	0x200001dc
 800bfc0: 00 00 00 20  	.word	0x20000000
 800bfc4: c4 69 01 08  	.word	0x080169c4
 800bfc8: 00 00 00 20  	.word	0x20000000
 800bfcc: 00 00 00 20  	.word	0x20000000
 800bfd0: c4 69 01 08  	.word	0x080169c4

0800bfd4 <first>:
; {
 800bfd4: b580         	push	{r7, lr}
 800bfd6: b082         	sub	sp, #0x8
 800bfd8: af00         	add	r7, sp, #0x0
; 	sys_dnode_t *t = sys_dlist_peek_head(&timeout_list);
 800bfda: 4804         	ldr	r0, [pc, #0x10]         @ 0x800bfec <first+0x18>
 800bfdc: f007 ff0c    	bl	0x8013df8 <sys_dlist_peek_head> @ imm = #0x7e18
 800bfe0: 6078         	str	r0, [r7, #0x4]
; 	return (t == NULL) ? NULL : CONTAINER_OF(t, struct _timeout, node);
 800bfe2: 687b         	ldr	r3, [r7, #0x4]
; }
 800bfe4: 4618         	mov	r0, r3
 800bfe6: 3708         	adds	r7, #0x8
 800bfe8: 46bd         	mov	sp, r7
 800bfea: bd80         	pop	{r7, pc}

0800bfec <$d>:
 800bfec: 20 01 00 20  	.word	0x20000120

0800bff0 <next>:
; {
 800bff0: b580         	push	{r7, lr}
 800bff2: b084         	sub	sp, #0x10
 800bff4: af00         	add	r7, sp, #0x0
 800bff6: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_t *n = sys_dlist_peek_next(&timeout_list, &t->node);
 800bff8: 687b         	ldr	r3, [r7, #0x4]
 800bffa: 4619         	mov	r1, r3
 800bffc: 4804         	ldr	r0, [pc, #0x10]         @ 0x800c010 <next+0x20>
 800bffe: f007 ff20    	bl	0x8013e42 <sys_dlist_peek_next> @ imm = #0x7e40
 800c002: 60f8         	str	r0, [r7, #0xc]
; 	return (n == NULL) ? NULL : CONTAINER_OF(n, struct _timeout, node);
 800c004: 68fb         	ldr	r3, [r7, #0xc]
; }
 800c006: 4618         	mov	r0, r3
 800c008: 3710         	adds	r7, #0x10
 800c00a: 46bd         	mov	sp, r7
 800c00c: bd80         	pop	{r7, pc}
 800c00e: bf00         	nop

0800c010 <$d>:
 800c010: 20 01 00 20  	.word	0x20000120

0800c014 <elapsed>:
; {
 800c014: b580         	push	{r7, lr}
 800c016: af00         	add	r7, sp, #0x0
; 	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
 800c018: 4b05         	ldr	r3, [pc, #0x14]         @ 0x800c030 <elapsed+0x1c>
 800c01a: 681b         	ldr	r3, [r3]
 800c01c: 2b00         	cmp	r3, #0x0
 800c01e: d103         	bne	0x800c028 <elapsed+0x14> @ imm = #0x6
 800c020: f7fb fcf2    	bl	0x8007a08 <sys_clock_elapsed> @ imm = #-0x461c
 800c024: 4603         	mov	r3, r0
 800c026: e000         	b	0x800c02a <elapsed+0x16> @ imm = #0x0
 800c028: 2300         	movs	r3, #0x0
; }
 800c02a: 4618         	mov	r0, r3
 800c02c: bd80         	pop	{r7, pc}
 800c02e: bf00         	nop

0800c030 <$d>:
 800c030: f0 09 00 20  	.word	0x200009f0

0800c034 <z_add_timeout>:
; {
 800c034: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 800c038: b0a0         	sub	sp, #0x80
 800c03a: af00         	add	r7, sp, #0x0
 800c03c: 6378         	str	r0, [r7, #0x34]
 800c03e: 6339         	str	r1, [r7, #0x30]
 800c040: e9c7 230a    	strd	r2, r3, [r7, #40]
; 	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 800c044: e9d7 010a    	ldrd	r0, r1, [r7, #40]
 800c048: f04f 32ff    	mov.w	r2, #0xffffffff
 800c04c: f04f 33ff    	mov.w	r3, #0xffffffff
 800c050: 4299         	cmp	r1, r3
 800c052: bf08         	it	eq
 800c054: 4290         	cmpeq	r0, r2
 800c056: d100         	bne	0x800c05a <z_add_timeout+0x26> @ imm = #0x0
 800c058: e0d8         	b	0x800c20c <z_add_timeout+0x1d8> @ imm = #0x1b0
; 	to->fn = fn;
 800c05a: 6b7a         	ldr	r2, [r7, #0x34]
 800c05c: 6b3b         	ldr	r3, [r7, #0x30]
 800c05e: 6093         	str	r3, [r2, #0x8]
; 	K_SPINLOCK(&timeout_lock) {
 800c060: 2300         	movs	r3, #0x0
 800c062: 64bb         	str	r3, [r7, #0x48]
 800c064: 4b6b         	ldr	r3, [pc, #0x1ac]        @ 0x800c214 <z_add_timeout+0x1e0>
 800c066: 66fb         	str	r3, [r7, #0x6c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800c068: f3ef 8311    	mrs	r3, basepri
 800c06c: 66bb         	str	r3, [r7, #0x68]
;   return(result);
 800c06e: 6ebb         	ldr	r3, [r7, #0x68]
; 	key = __get_BASEPRI();
 800c070: 667b         	str	r3, [r7, #0x64]
 800c072: 2310         	movs	r3, #0x10
 800c074: 663b         	str	r3, [r7, #0x60]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800c076: 6e3b         	ldr	r3, [r7, #0x60]
 800c078: f383 8812    	msr	basepri_max, r3
; }
 800c07c: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800c07e: f3bf 8f6f    	isb	sy
; }
 800c082: bf00         	nop
; 	return key;
 800c084: 6e7b         	ldr	r3, [r7, #0x64]
; 	k.key = arch_irq_lock();
 800c086: 63fb         	str	r3, [r7, #0x3c]
 800c088: 6efb         	ldr	r3, [r7, #0x6c]
 800c08a: 65fb         	str	r3, [r7, #0x5c]
; }
 800c08c: bf00         	nop
 800c08e: 6efb         	ldr	r3, [r7, #0x6c]
 800c090: 65bb         	str	r3, [r7, #0x58]
; }
 800c092: bf00         	nop
; 	return k;
 800c094: 6bfb         	ldr	r3, [r7, #0x3c]
 800c096: 647b         	str	r3, [r7, #0x44]
; 	K_SPINLOCK(&timeout_lock) {
 800c098: e0b4         	b	0x800c204 <z_add_timeout+0x1d0> @ imm = #0x168
; 		    (Z_TICK_ABS(timeout.ticks) >= 0)) {
 800c09a: e9d7 230a    	ldrd	r2, r3, [r7, #40]
 800c09e: f06f 0001    	mvn	r0, #0x1
 800c0a2: f04f 31ff    	mov.w	r1, #0xffffffff
 800c0a6: 1a80         	subs	r0, r0, r2
 800c0a8: 6238         	str	r0, [r7, #0x20]
 800c0aa: eb61 0303    	sbc.w	r3, r1, r3
 800c0ae: 627b         	str	r3, [r7, #0x24]
; 		if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) &&
 800c0b0: 6a7b         	ldr	r3, [r7, #0x24]
 800c0b2: 2b00         	cmp	r3, #0x0
 800c0b4: db24         	blt	0x800c100 <z_add_timeout+0xcc> @ imm = #0x48
; 			k_ticks_t ticks = Z_TICK_ABS(timeout.ticks) - curr_tick;
 800c0b6: e9d7 230a    	ldrd	r2, r3, [r7, #40]
 800c0ba: 4610         	mov	r0, r2
 800c0bc: 4619         	mov	r1, r3
 800c0be: 4b56         	ldr	r3, [pc, #0x158]        @ 0x800c218 <z_add_timeout+0x1e4>
 800c0c0: e9d3 2300    	ldrd	r2, r3, [r3]
 800c0c4: 1884         	adds	r4, r0, r2
 800c0c6: eb41 0503    	adc.w	r5, r1, r3
 800c0ca: f06f 0201    	mvn	r2, #0x1
 800c0ce: f04f 33ff    	mov.w	r3, #0xffffffff
 800c0d2: 1b12         	subs	r2, r2, r4
 800c0d4: 61ba         	str	r2, [r7, #0x18]
 800c0d6: eb63 0305    	sbc.w	r3, r3, r5
 800c0da: 61fb         	str	r3, [r7, #0x1c]
 800c0dc: e9d7 2306    	ldrd	r2, r3, [r7, #24]
 800c0e0: e9c7 231c    	strd	r2, r3, [r7, #112]
; 			to->dticks = MAX(1, ticks);
 800c0e4: e9d7 231c    	ldrd	r2, r3, [r7, #112]
 800c0e8: 2a01         	cmp	r2, #0x1
 800c0ea: f173 0100    	sbcs	r1, r3, #0x0
 800c0ee: da03         	bge	0x800c0f8 <z_add_timeout+0xc4> @ imm = #0x6
 800c0f0: f04f 0201    	mov.w	r2, #0x1
 800c0f4: f04f 0300    	mov.w	r3, #0x0
 800c0f8: 6b79         	ldr	r1, [r7, #0x34]
 800c0fa: e9c1 2304    	strd	r2, r3, [r1, #16]
 800c0fe: e016         	b	0x800c12e <z_add_timeout+0xfa> @ imm = #0x2c
; 			to->dticks = timeout.ticks + 1 + elapsed();
 800c100: e9d7 230a    	ldrd	r2, r3, [r7, #40]
 800c104: f112 0801    	adds.w	r8, r2, #0x1
 800c108: f143 0900    	adc	r9, r3, #0x0
 800c10c: f7ff ff82    	bl	0x800c014 <elapsed>     @ imm = #-0xfc
 800c110: 4603         	mov	r3, r0
 800c112: 17da         	asrs	r2, r3, #0x1f
 800c114: 469a         	mov	r10, r3
 800c116: 4693         	mov	r11, r2
 800c118: eb18 030a    	adds.w	r3, r8, r10
 800c11c: 613b         	str	r3, [r7, #0x10]
 800c11e: eb49 030b    	adc.w	r3, r9, r11
 800c122: 617b         	str	r3, [r7, #0x14]
 800c124: 6b7b         	ldr	r3, [r7, #0x34]
 800c126: e9d7 1204    	ldrd	r1, r2, [r7, #16]
 800c12a: e9c3 1204    	strd	r1, r2, [r3, #16]
; 		for (t = first(); t != NULL; t = next(t)) {
 800c12e: f7ff ff51    	bl	0x800bfd4 <first>       @ imm = #-0x15e
 800c132: 67f8         	str	r0, [r7, #0x7c]
 800c134: e037         	b	0x800c1a6 <z_add_timeout+0x172> @ imm = #0x6e
; 			if (t->dticks > to->dticks) {
 800c136: 6ffb         	ldr	r3, [r7, #0x7c]
 800c138: e9d3 0104    	ldrd	r0, r1, [r3, #16]
 800c13c: 6b7b         	ldr	r3, [r7, #0x34]
 800c13e: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 800c142: 4282         	cmp	r2, r0
 800c144: 418b         	sbcs	r3, r1
 800c146: da18         	bge	0x800c17a <z_add_timeout+0x146> @ imm = #0x30
; 				t->dticks -= to->dticks;
 800c148: 6ffb         	ldr	r3, [r7, #0x7c]
 800c14a: e9d3 0104    	ldrd	r0, r1, [r3, #16]
 800c14e: 6b7b         	ldr	r3, [r7, #0x34]
 800c150: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 800c154: ebb0 0c02    	subs.w	r12, r0, r2
 800c158: f8c7 c008    	str.w	r12, [r7, #0x8]
 800c15c: eb61 0303    	sbc.w	r3, r1, r3
 800c160: 60fb         	str	r3, [r7, #0xc]
 800c162: 6ffb         	ldr	r3, [r7, #0x7c]
 800c164: e9d7 1202    	ldrd	r1, r2, [r7, #8]
 800c168: e9c3 1204    	strd	r1, r2, [r3, #16]
; 				sys_dlist_insert(&t->node, &to->node);
 800c16c: 6ffa         	ldr	r2, [r7, #0x7c]
 800c16e: 6b7b         	ldr	r3, [r7, #0x34]
 800c170: 4619         	mov	r1, r3
 800c172: 4610         	mov	r0, r2
 800c174: f007 fe91    	bl	0x8013e9a <sys_dlist_insert> @ imm = #0x7d22
; 				break;
 800c178: e018         	b	0x800c1ac <z_add_timeout+0x178> @ imm = #0x30
; 			to->dticks -= t->dticks;
 800c17a: 6b7b         	ldr	r3, [r7, #0x34]
 800c17c: e9d3 0104    	ldrd	r0, r1, [r3, #16]
 800c180: 6ffb         	ldr	r3, [r7, #0x7c]
 800c182: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 800c186: ebb0 0c02    	subs.w	r12, r0, r2
 800c18a: f8c7 c000    	str.w	r12, [r7]
 800c18e: eb61 0303    	sbc.w	r3, r1, r3
 800c192: 607b         	str	r3, [r7, #0x4]
 800c194: 6b7b         	ldr	r3, [r7, #0x34]
 800c196: e9d7 1200    	ldrd	r1, r2, [r7]
 800c19a: e9c3 1204    	strd	r1, r2, [r3, #16]
; 		for (t = first(); t != NULL; t = next(t)) {
 800c19e: 6ff8         	ldr	r0, [r7, #0x7c]
 800c1a0: f7ff ff26    	bl	0x800bff0 <next>        @ imm = #-0x1b4
 800c1a4: 67f8         	str	r0, [r7, #0x7c]
 800c1a6: 6ffb         	ldr	r3, [r7, #0x7c]
 800c1a8: 2b00         	cmp	r3, #0x0
 800c1aa: d1c4         	bne	0x800c136 <z_add_timeout+0x102> @ imm = #-0x78
; 		if (t == NULL) {
 800c1ac: 6ffb         	ldr	r3, [r7, #0x7c]
 800c1ae: 2b00         	cmp	r3, #0x0
 800c1b0: d104         	bne	0x800c1bc <z_add_timeout+0x188> @ imm = #0x8
; 			sys_dlist_append(&timeout_list, &to->node);
 800c1b2: 6b7b         	ldr	r3, [r7, #0x34]
 800c1b4: 4619         	mov	r1, r3
 800c1b6: 4819         	ldr	r0, [pc, #0x64]         @ 0x800c21c <z_add_timeout+0x1e8>
 800c1b8: f007 fe56    	bl	0x8013e68 <sys_dlist_append> @ imm = #0x7cac
; 		if (to == first() && announce_remaining == 0) {
 800c1bc: f7ff ff0a    	bl	0x800bfd4 <first>       @ imm = #-0x1ec
 800c1c0: 4602         	mov	r2, r0
 800c1c2: 6b7b         	ldr	r3, [r7, #0x34]
 800c1c4: 4293         	cmp	r3, r2
 800c1c6: d10a         	bne	0x800c1de <z_add_timeout+0x1aa> @ imm = #0x14
 800c1c8: 4b15         	ldr	r3, [pc, #0x54]         @ 0x800c220 <z_add_timeout+0x1ec>
 800c1ca: 681b         	ldr	r3, [r3]
 800c1cc: 2b00         	cmp	r3, #0x0
 800c1ce: d106         	bne	0x800c1de <z_add_timeout+0x1aa> @ imm = #0xc
; 			sys_clock_set_timeout(next_timeout(), false);
 800c1d0: f007 feb3    	bl	0x8013f3a <next_timeout> @ imm = #0x7d66
 800c1d4: 4603         	mov	r3, r0
 800c1d6: 2100         	movs	r1, #0x0
 800c1d8: 4618         	mov	r0, r3
 800c1da: f7fb fb11    	bl	0x8007800 <sys_clock_set_timeout> @ imm = #-0x49de
 800c1de: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800c214 <z_add_timeout+0x1e0>
 800c1e0: 657b         	str	r3, [r7, #0x54]
 800c1e2: 6c7b         	ldr	r3, [r7, #0x44]
 800c1e4: 643b         	str	r3, [r7, #0x40]
; 	arch_irq_unlock(key.key);
 800c1e6: 6c3b         	ldr	r3, [r7, #0x40]
 800c1e8: 653b         	str	r3, [r7, #0x50]
 800c1ea: 6d3b         	ldr	r3, [r7, #0x50]
 800c1ec: 64fb         	str	r3, [r7, #0x4c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800c1ee: 6cfb         	ldr	r3, [r7, #0x4c]
 800c1f0: f383 8811    	msr	basepri, r3
; }
 800c1f4: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800c1f6: f3bf 8f6f    	isb	sy
; }
 800c1fa: bf00         	nop
; }
 800c1fc: bf00         	nop
; }
 800c1fe: bf00         	nop
; 	K_SPINLOCK(&timeout_lock) {
 800c200: 2301         	movs	r3, #0x1
 800c202: 64bb         	str	r3, [r7, #0x48]
 800c204: 6cbb         	ldr	r3, [r7, #0x48]
 800c206: 2b00         	cmp	r3, #0x0
 800c208: f43f af47    	beq.w	0x800c09a <z_add_timeout+0x66> @ imm = #-0x172
; }
 800c20c: 3780         	adds	r7, #0x80
 800c20e: 46bd         	mov	sp, r7
 800c210: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

0800c214 <$d>:
 800c214: f0 09 00 20  	.word	0x200009f0
 800c218: 88 05 00 20  	.word	0x20000588
 800c21c: 20 01 00 20  	.word	0x20000120
 800c220: f0 09 00 20  	.word	0x200009f0

0800c224 <z_abort_timeout>:
; {
 800c224: b580         	push	{r7, lr}
 800c226: b090         	sub	sp, #0x40
 800c228: af00         	add	r7, sp, #0x0
 800c22a: 6078         	str	r0, [r7, #0x4]
; 	int ret = -EINVAL;
 800c22c: f06f 0315    	mvn	r3, #0x15
 800c230: 63fb         	str	r3, [r7, #0x3c]
; 	K_SPINLOCK(&timeout_lock) {
 800c232: 2300         	movs	r3, #0x0
 800c234: 617b         	str	r3, [r7, #0x14]
 800c236: 4b21         	ldr	r3, [pc, #0x84]         @ 0x800c2bc <z_abort_timeout+0x98>
 800c238: 63bb         	str	r3, [r7, #0x38]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800c23a: f3ef 8311    	mrs	r3, basepri
 800c23e: 637b         	str	r3, [r7, #0x34]
;   return(result);
 800c240: 6b7b         	ldr	r3, [r7, #0x34]
; 	key = __get_BASEPRI();
 800c242: 633b         	str	r3, [r7, #0x30]
 800c244: 2310         	movs	r3, #0x10
 800c246: 62fb         	str	r3, [r7, #0x2c]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800c248: 6afb         	ldr	r3, [r7, #0x2c]
 800c24a: f383 8812    	msr	basepri_max, r3
; }
 800c24e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800c250: f3bf 8f6f    	isb	sy
; }
 800c254: bf00         	nop
; 	return key;
 800c256: 6b3b         	ldr	r3, [r7, #0x30]
; 	k.key = arch_irq_lock();
 800c258: 60bb         	str	r3, [r7, #0x8]
 800c25a: 6bbb         	ldr	r3, [r7, #0x38]
 800c25c: 62bb         	str	r3, [r7, #0x28]
; }
 800c25e: bf00         	nop
 800c260: 6bbb         	ldr	r3, [r7, #0x38]
 800c262: 627b         	str	r3, [r7, #0x24]
; }
 800c264: bf00         	nop
; 	return k;
 800c266: 68bb         	ldr	r3, [r7, #0x8]
 800c268: 613b         	str	r3, [r7, #0x10]
; 	K_SPINLOCK(&timeout_lock) {
 800c26a: e01e         	b	0x800c2aa <z_abort_timeout+0x86> @ imm = #0x3c
; 		if (sys_dnode_is_linked(&to->node)) {
 800c26c: 687b         	ldr	r3, [r7, #0x4]
 800c26e: 4618         	mov	r0, r3
 800c270: f007 fda1    	bl	0x8013db6 <sys_dnode_is_linked> @ imm = #0x7b42
 800c274: 4603         	mov	r3, r0
 800c276: 2b00         	cmp	r3, #0x0
 800c278: d004         	beq	0x800c284 <z_abort_timeout+0x60> @ imm = #0x8
; 			remove_timeout(to);
 800c27a: 6878         	ldr	r0, [r7, #0x4]
 800c27c: f007 fe3d    	bl	0x8013efa <remove_timeout> @ imm = #0x7c7a
; 			ret = 0;
 800c280: 2300         	movs	r3, #0x0
 800c282: 63fb         	str	r3, [r7, #0x3c]
 800c284: 4b0d         	ldr	r3, [pc, #0x34]         @ 0x800c2bc <z_abort_timeout+0x98>
 800c286: 623b         	str	r3, [r7, #0x20]
 800c288: 693b         	ldr	r3, [r7, #0x10]
 800c28a: 60fb         	str	r3, [r7, #0xc]
; 	arch_irq_unlock(key.key);
 800c28c: 68fb         	ldr	r3, [r7, #0xc]
 800c28e: 61fb         	str	r3, [r7, #0x1c]
 800c290: 69fb         	ldr	r3, [r7, #0x1c]
 800c292: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800c294: 69bb         	ldr	r3, [r7, #0x18]
 800c296: f383 8811    	msr	basepri, r3
; }
 800c29a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800c29c: f3bf 8f6f    	isb	sy
; }
 800c2a0: bf00         	nop
; }
 800c2a2: bf00         	nop
; }
 800c2a4: bf00         	nop
; 	K_SPINLOCK(&timeout_lock) {
 800c2a6: 2301         	movs	r3, #0x1
 800c2a8: 617b         	str	r3, [r7, #0x14]
 800c2aa: 697b         	ldr	r3, [r7, #0x14]
 800c2ac: 2b00         	cmp	r3, #0x0
 800c2ae: d0dd         	beq	0x800c26c <z_abort_timeout+0x48> @ imm = #-0x46
; 	return ret;
 800c2b0: 6bfb         	ldr	r3, [r7, #0x3c]
; }
 800c2b2: 4618         	mov	r0, r3
 800c2b4: 3740         	adds	r7, #0x40
 800c2b6: 46bd         	mov	sp, r7
 800c2b8: bd80         	pop	{r7, pc}
 800c2ba: bf00         	nop

0800c2bc <$d>:
 800c2bc: f0 09 00 20  	.word	0x200009f0

0800c2c0 <sys_clock_announce>:
; {
 800c2c0: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 800c2c4: b0a4         	sub	sp, #0x90
 800c2c6: af00         	add	r7, sp, #0x0
 800c2c8: 6278         	str	r0, [r7, #0x24]
 800c2ca: 4b74         	ldr	r3, [pc, #0x1d0]        @ 0x800c49c <sys_clock_announce+0x1dc>
 800c2cc: f8c7 3084    	str.w	r3, [r7, #0x84]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800c2d0: f3ef 8311    	mrs	r3, basepri
 800c2d4: f8c7 3080    	str.w	r3, [r7, #0x80]
;   return(result);
 800c2d8: f8d7 3080    	ldr.w	r3, [r7, #0x80]
; 	key = __get_BASEPRI();
 800c2dc: 67fb         	str	r3, [r7, #0x7c]
 800c2de: 2310         	movs	r3, #0x10
 800c2e0: 67bb         	str	r3, [r7, #0x78]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800c2e2: 6fbb         	ldr	r3, [r7, #0x78]
 800c2e4: f383 8812    	msr	basepri_max, r3
; }
 800c2e8: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800c2ea: f3bf 8f6f    	isb	sy
; }
 800c2ee: bf00         	nop
; 	return key;
 800c2f0: 6ffb         	ldr	r3, [r7, #0x7c]
; 	k.key = arch_irq_lock();
 800c2f2: 637b         	str	r3, [r7, #0x34]
 800c2f4: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 800c2f8: 677b         	str	r3, [r7, #0x74]
; }
 800c2fa: bf00         	nop
 800c2fc: f8d7 3084    	ldr.w	r3, [r7, #0x84]
 800c300: 673b         	str	r3, [r7, #0x70]
; }
 800c302: bf00         	nop
; 	return k;
 800c304: 6b7b         	ldr	r3, [r7, #0x34]
 800c306: 63fb         	str	r3, [r7, #0x3c]
; 	announce_remaining = ticks;
 800c308: 4a65         	ldr	r2, [pc, #0x194]        @ 0x800c4a0 <sys_clock_announce+0x1e0>
 800c30a: 6a7b         	ldr	r3, [r7, #0x24]
 800c30c: 6013         	str	r3, [r2]
; 	for (t = first();
 800c30e: f7ff fe61    	bl	0x800bfd4 <first>       @ imm = #-0x33e
 800c312: f8c7 008c    	str.w	r0, [r7, #0x8c]
 800c316: e061         	b	0x800c3dc <sys_clock_announce+0x11c> @ imm = #0xc2
; 		int dt = t->dticks;
 800c318: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 800c31c: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 800c320: 4613         	mov	r3, r2
 800c322: f8c7 3088    	str.w	r3, [r7, #0x88]
; 		curr_tick += dt;
 800c326: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 800c32a: 17da         	asrs	r2, r3, #0x1f
 800c32c: 469a         	mov	r10, r3
 800c32e: 4693         	mov	r11, r2
 800c330: 4b5c         	ldr	r3, [pc, #0x170]        @ 0x800c4a4 <sys_clock_announce+0x1e4>
 800c332: e9d3 2300    	ldrd	r2, r3, [r3]
 800c336: eb1a 0102    	adds.w	r1, r10, r2
 800c33a: 61b9         	str	r1, [r7, #0x18]
 800c33c: eb4b 0303    	adc.w	r3, r11, r3
 800c340: 61fb         	str	r3, [r7, #0x1c]
 800c342: 4b58         	ldr	r3, [pc, #0x160]        @ 0x800c4a4 <sys_clock_announce+0x1e4>
 800c344: e9d7 1206    	ldrd	r1, r2, [r7, #24]
 800c348: e9c3 1200    	strd	r1, r2, [r3]
; 		t->dticks = 0;
 800c34c: f8d7 108c    	ldr.w	r1, [r7, #0x8c]
 800c350: f04f 0200    	mov.w	r2, #0x0
 800c354: f04f 0300    	mov.w	r3, #0x0
 800c358: e9c1 2304    	strd	r2, r3, [r1, #16]
; 		remove_timeout(t);
 800c35c: f8d7 008c    	ldr.w	r0, [r7, #0x8c]
 800c360: f007 fdcb    	bl	0x8013efa <remove_timeout> @ imm = #0x7b96
 800c364: 4b4d         	ldr	r3, [pc, #0x134]        @ 0x800c49c <sys_clock_announce+0x1dc>
 800c366: 657b         	str	r3, [r7, #0x54]
 800c368: 6bfb         	ldr	r3, [r7, #0x3c]
 800c36a: 633b         	str	r3, [r7, #0x30]
; 	arch_irq_unlock(key.key);
 800c36c: 6b3b         	ldr	r3, [r7, #0x30]
 800c36e: 653b         	str	r3, [r7, #0x50]
 800c370: 6d3b         	ldr	r3, [r7, #0x50]
 800c372: 64fb         	str	r3, [r7, #0x4c]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800c374: 6cfb         	ldr	r3, [r7, #0x4c]
 800c376: f383 8811    	msr	basepri, r3
; }
 800c37a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800c37c: f3bf 8f6f    	isb	sy
; }
 800c380: bf00         	nop
; }
 800c382: bf00         	nop
; }
 800c384: bf00         	nop
; 		t->fn(t);
 800c386: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 800c38a: 689b         	ldr	r3, [r3, #0x8]
 800c38c: f8d7 008c    	ldr.w	r0, [r7, #0x8c]
 800c390: 4798         	blx	r3
 800c392: 4b42         	ldr	r3, [pc, #0x108]        @ 0x800c49c <sys_clock_announce+0x1dc>
 800c394: 66fb         	str	r3, [r7, #0x6c]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800c396: f3ef 8311    	mrs	r3, basepri
 800c39a: 66bb         	str	r3, [r7, #0x68]
;   return(result);
 800c39c: 6ebb         	ldr	r3, [r7, #0x68]
; 	key = __get_BASEPRI();
 800c39e: 667b         	str	r3, [r7, #0x64]
 800c3a0: 2310         	movs	r3, #0x10
 800c3a2: 663b         	str	r3, [r7, #0x60]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800c3a4: 6e3b         	ldr	r3, [r7, #0x60]
 800c3a6: f383 8812    	msr	basepri_max, r3
; }
 800c3aa: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800c3ac: f3bf 8f6f    	isb	sy
; }
 800c3b0: bf00         	nop
; 	return key;
 800c3b2: 6e7b         	ldr	r3, [r7, #0x64]
; 	k.key = arch_irq_lock();
 800c3b4: 62fb         	str	r3, [r7, #0x2c]
 800c3b6: 6efb         	ldr	r3, [r7, #0x6c]
 800c3b8: 65fb         	str	r3, [r7, #0x5c]
; }
 800c3ba: bf00         	nop
 800c3bc: 6efb         	ldr	r3, [r7, #0x6c]
 800c3be: 65bb         	str	r3, [r7, #0x58]
; }
 800c3c0: bf00         	nop
; 	return k;
 800c3c2: 6afb         	ldr	r3, [r7, #0x2c]
 800c3c4: 63fb         	str	r3, [r7, #0x3c]
; 		announce_remaining -= dt;
 800c3c6: 4b36         	ldr	r3, [pc, #0xd8]         @ 0x800c4a0 <sys_clock_announce+0x1e0>
 800c3c8: 681a         	ldr	r2, [r3]
 800c3ca: f8d7 3088    	ldr.w	r3, [r7, #0x88]
 800c3ce: 1ad2         	subs	r2, r2, r3
 800c3d0: 4b33         	ldr	r3, [pc, #0xcc]         @ 0x800c4a0 <sys_clock_announce+0x1e0>
 800c3d2: 601a         	str	r2, [r3]
; 	     t = first()) {
 800c3d4: f7ff fdfe    	bl	0x800bfd4 <first>       @ imm = #-0x404
 800c3d8: f8c7 008c    	str.w	r0, [r7, #0x8c]
; 	     (t != NULL) && (t->dticks <= announce_remaining);
 800c3dc: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 800c3e0: 2b00         	cmp	r3, #0x0
 800c3e2: d00e         	beq	0x800c402 <sys_clock_announce+0x142> @ imm = #0x1c
 800c3e4: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 800c3e8: e9d3 0104    	ldrd	r0, r1, [r3, #16]
 800c3ec: 4b2c         	ldr	r3, [pc, #0xb0]         @ 0x800c4a0 <sys_clock_announce+0x1e0>
 800c3ee: 681b         	ldr	r3, [r3]
 800c3f0: 17da         	asrs	r2, r3, #0x1f
 800c3f2: 613b         	str	r3, [r7, #0x10]
 800c3f4: 617a         	str	r2, [r7, #0x14]
 800c3f6: e9d7 2304    	ldrd	r2, r3, [r7, #16]
 800c3fa: 4694         	mov	r12, r2
 800c3fc: 4584         	cmp	r12, r0
 800c3fe: 418b         	sbcs	r3, r1
 800c400: da8a         	bge	0x800c318 <sys_clock_announce+0x58> @ imm = #-0xec
; 	if (t != NULL) {
 800c402: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 800c406: 2b00         	cmp	r3, #0x0
 800c408: d014         	beq	0x800c434 <sys_clock_announce+0x174> @ imm = #0x28
; 		t->dticks -= announce_remaining;
 800c40a: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 800c40e: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 800c412: 4923         	ldr	r1, [pc, #0x8c]         @ 0x800c4a0 <sys_clock_announce+0x1e0>
 800c414: 6809         	ldr	r1, [r1]
 800c416: 17c8         	asrs	r0, r1, #0x1f
 800c418: 4688         	mov	r8, r1
 800c41a: 4681         	mov	r9, r0
 800c41c: ebb2 0108    	subs.w	r1, r2, r8
 800c420: 60b9         	str	r1, [r7, #0x8]
 800c422: eb63 0309    	sbc.w	r3, r3, r9
 800c426: 60fb         	str	r3, [r7, #0xc]
 800c428: f8d7 308c    	ldr.w	r3, [r7, #0x8c]
 800c42c: e9d7 1202    	ldrd	r1, r2, [r7, #8]
 800c430: e9c3 1204    	strd	r1, r2, [r3, #16]
; 	curr_tick += announce_remaining;
 800c434: 4b1a         	ldr	r3, [pc, #0x68]         @ 0x800c4a0 <sys_clock_announce+0x1e0>
 800c436: 681b         	ldr	r3, [r3]
 800c438: 17da         	asrs	r2, r3, #0x1f
 800c43a: 461c         	mov	r4, r3
 800c43c: 4615         	mov	r5, r2
 800c43e: 4b19         	ldr	r3, [pc, #0x64]         @ 0x800c4a4 <sys_clock_announce+0x1e4>
 800c440: e9d3 2300    	ldrd	r2, r3, [r3]
 800c444: 18a1         	adds	r1, r4, r2
 800c446: 6039         	str	r1, [r7]
 800c448: eb45 0303    	adc.w	r3, r5, r3
 800c44c: 607b         	str	r3, [r7, #0x4]
 800c44e: 4b15         	ldr	r3, [pc, #0x54]         @ 0x800c4a4 <sys_clock_announce+0x1e4>
 800c450: e9d7 1200    	ldrd	r1, r2, [r7]
 800c454: e9c3 1200    	strd	r1, r2, [r3]
; 	announce_remaining = 0;
 800c458: 4b11         	ldr	r3, [pc, #0x44]         @ 0x800c4a0 <sys_clock_announce+0x1e0>
 800c45a: 2200         	movs	r2, #0x0
 800c45c: 601a         	str	r2, [r3]
; 	sys_clock_set_timeout(next_timeout(), false);
 800c45e: f007 fd6c    	bl	0x8013f3a <next_timeout> @ imm = #0x7ad8
 800c462: 4603         	mov	r3, r0
 800c464: 2100         	movs	r1, #0x0
 800c466: 4618         	mov	r0, r3
 800c468: f7fb f9ca    	bl	0x8007800 <sys_clock_set_timeout> @ imm = #-0x4c6c
 800c46c: 4b0b         	ldr	r3, [pc, #0x2c]         @ 0x800c49c <sys_clock_announce+0x1dc>
 800c46e: 64bb         	str	r3, [r7, #0x48]
 800c470: 6bfb         	ldr	r3, [r7, #0x3c]
 800c472: 63bb         	str	r3, [r7, #0x38]
; 	arch_irq_unlock(key.key);
 800c474: 6bbb         	ldr	r3, [r7, #0x38]
 800c476: 647b         	str	r3, [r7, #0x44]
 800c478: 6c7b         	ldr	r3, [r7, #0x44]
 800c47a: 643b         	str	r3, [r7, #0x40]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800c47c: 6c3b         	ldr	r3, [r7, #0x40]
 800c47e: f383 8811    	msr	basepri, r3
; }
 800c482: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800c484: f3bf 8f6f    	isb	sy
; }
 800c488: bf00         	nop
; }
 800c48a: bf00         	nop
; }
 800c48c: bf00         	nop
; 	z_time_slice();
 800c48e: f7ff fcad    	bl	0x800bdec <z_time_slice> @ imm = #-0x6a6
; }
 800c492: 3790         	adds	r7, #0x90
 800c494: 46bd         	mov	sp, r7
 800c496: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}
 800c49a: bf00         	nop

0800c49c <$d>:
 800c49c: f0 09 00 20  	.word	0x200009f0
 800c4a0: f0 09 00 20  	.word	0x200009f0
 800c4a4: 88 05 00 20  	.word	0x20000588

0800c4a8 <sys_clock_tick_get>:
; {
 800c4a8: e92d 43b0    	push.w	{r4, r5, r7, r8, r9, lr}
 800c4ac: b090         	sub	sp, #0x40
 800c4ae: af00         	add	r7, sp, #0x0
; 	uint64_t t = 0U;
 800c4b0: f04f 0200    	mov.w	r2, #0x0
 800c4b4: f04f 0300    	mov.w	r3, #0x0
 800c4b8: e9c7 230e    	strd	r2, r3, [r7, #56]
; 	K_SPINLOCK(&timeout_lock) {
 800c4bc: 2300         	movs	r3, #0x0
 800c4be: 613b         	str	r3, [r7, #0x10]
 800c4c0: 4b23         	ldr	r3, [pc, #0x8c]         @ 0x800c550 <sys_clock_tick_get+0xa8>
 800c4c2: 637b         	str	r3, [r7, #0x34]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800c4c4: f3ef 8311    	mrs	r3, basepri
 800c4c8: 633b         	str	r3, [r7, #0x30]
;   return(result);
 800c4ca: 6b3b         	ldr	r3, [r7, #0x30]
; 	key = __get_BASEPRI();
 800c4cc: 62fb         	str	r3, [r7, #0x2c]
 800c4ce: 2310         	movs	r3, #0x10
 800c4d0: 62bb         	str	r3, [r7, #0x28]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800c4d2: 6abb         	ldr	r3, [r7, #0x28]
 800c4d4: f383 8812    	msr	basepri_max, r3
; }
 800c4d8: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800c4da: f3bf 8f6f    	isb	sy
; }
 800c4de: bf00         	nop
; 	return key;
 800c4e0: 6afb         	ldr	r3, [r7, #0x2c]
; 	k.key = arch_irq_lock();
 800c4e2: 607b         	str	r3, [r7, #0x4]
 800c4e4: 6b7b         	ldr	r3, [r7, #0x34]
 800c4e6: 627b         	str	r3, [r7, #0x24]
; }
 800c4e8: bf00         	nop
 800c4ea: 6b7b         	ldr	r3, [r7, #0x34]
 800c4ec: 623b         	str	r3, [r7, #0x20]
; }
 800c4ee: bf00         	nop
; 	return k;
 800c4f0: 687b         	ldr	r3, [r7, #0x4]
 800c4f2: 60fb         	str	r3, [r7, #0xc]
; 	K_SPINLOCK(&timeout_lock) {
 800c4f4: e021         	b	0x800c53a <sys_clock_tick_get+0x92> @ imm = #0x42
; 		t = curr_tick + elapsed();
 800c4f6: f7ff fd8d    	bl	0x800c014 <elapsed>     @ imm = #-0x4e6
 800c4fa: 4603         	mov	r3, r0
 800c4fc: 17da         	asrs	r2, r3, #0x1f
 800c4fe: 461c         	mov	r4, r3
 800c500: 4615         	mov	r5, r2
 800c502: 4b14         	ldr	r3, [pc, #0x50]         @ 0x800c554 <sys_clock_tick_get+0xac>
 800c504: e9d3 2300    	ldrd	r2, r3, [r3]
 800c508: eb14 0802    	adds.w	r8, r4, r2
 800c50c: eb45 0903    	adc.w	r9, r5, r3
 800c510: e9c7 890e    	strd	r8, r9, [r7, #56]
 800c514: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800c550 <sys_clock_tick_get+0xa8>
 800c516: 61fb         	str	r3, [r7, #0x1c]
 800c518: 68fb         	ldr	r3, [r7, #0xc]
 800c51a: 60bb         	str	r3, [r7, #0x8]
; 	arch_irq_unlock(key.key);
 800c51c: 68bb         	ldr	r3, [r7, #0x8]
 800c51e: 61bb         	str	r3, [r7, #0x18]
 800c520: 69bb         	ldr	r3, [r7, #0x18]
 800c522: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800c524: 697b         	ldr	r3, [r7, #0x14]
 800c526: f383 8811    	msr	basepri, r3
; }
 800c52a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800c52c: f3bf 8f6f    	isb	sy
; }
 800c530: bf00         	nop
; }
 800c532: bf00         	nop
; }
 800c534: bf00         	nop
; 	K_SPINLOCK(&timeout_lock) {
 800c536: 2301         	movs	r3, #0x1
 800c538: 613b         	str	r3, [r7, #0x10]
 800c53a: 693b         	ldr	r3, [r7, #0x10]
 800c53c: 2b00         	cmp	r3, #0x0
 800c53e: d0da         	beq	0x800c4f6 <sys_clock_tick_get+0x4e> @ imm = #-0x4c
; 	return t;
 800c540: e9d7 230e    	ldrd	r2, r3, [r7, #56]
; }
 800c544: 4610         	mov	r0, r2
 800c546: 4619         	mov	r1, r3
 800c548: 3740         	adds	r7, #0x40
 800c54a: 46bd         	mov	sp, r7
 800c54c: e8bd 83b0    	pop.w	{r4, r5, r7, r8, r9, pc}

0800c550 <$d>:
 800c550: f0 09 00 20  	.word	0x200009f0
 800c554: 88 05 00 20  	.word	0x20000588

0800c558 <z_sched_usage_start>:
; {
 800c558: b580         	push	{r7, lr}
 800c55a: b082         	sub	sp, #0x8
 800c55c: af00         	add	r7, sp, #0x0
 800c55e: 6078         	str	r0, [r7, #0x4]
; 	_current_cpu->usage0 = usage_now();
 800c560: f007 fd49    	bl	0x8013ff6 <usage_now>   @ imm = #0x7a92
 800c564: 4603         	mov	r3, r0
 800c566: 4a03         	ldr	r2, [pc, #0xc]          @ 0x800c574 <z_sched_usage_start+0x1c>
 800c568: 6153         	str	r3, [r2, #0x14]
; }
 800c56a: bf00         	nop
 800c56c: 3708         	adds	r7, #0x8
 800c56e: 46bd         	mov	sp, r7
 800c570: bd80         	pop	{r7, pc}
 800c572: bf00         	nop

0800c574 <$d>:
 800c574: c0 02 00 20  	.word	0x200002c0

0800c578 <z_sched_usage_stop>:
; {
 800c578: b580         	push	{r7, lr}
 800c57a: b090         	sub	sp, #0x40
 800c57c: af00         	add	r7, sp, #0x0
 800c57e: 4b28         	ldr	r3, [pc, #0xa0]         @ 0x800c620 <z_sched_usage_stop+0xa8>
 800c580: 633b         	str	r3, [r7, #0x30]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800c582: f3ef 8311    	mrs	r3, basepri
 800c586: 62fb         	str	r3, [r7, #0x2c]
;   return(result);
 800c588: 6afb         	ldr	r3, [r7, #0x2c]
; 	key = __get_BASEPRI();
 800c58a: 62bb         	str	r3, [r7, #0x28]
 800c58c: 2310         	movs	r3, #0x10
 800c58e: 627b         	str	r3, [r7, #0x24]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 800c590: 6a7b         	ldr	r3, [r7, #0x24]
 800c592: f383 8812    	msr	basepri_max, r3
; }
 800c596: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800c598: f3bf 8f6f    	isb	sy
; }
 800c59c: bf00         	nop
; 	return key;
 800c59e: 6abb         	ldr	r3, [r7, #0x28]
; 	k.key = arch_irq_lock();
 800c5a0: 607b         	str	r3, [r7, #0x4]
 800c5a2: 6b3b         	ldr	r3, [r7, #0x30]
 800c5a4: 623b         	str	r3, [r7, #0x20]
; }
 800c5a6: bf00         	nop
 800c5a8: 6b3b         	ldr	r3, [r7, #0x30]
 800c5aa: 61fb         	str	r3, [r7, #0x1c]
; }
 800c5ac: bf00         	nop
; 	return k;
 800c5ae: 687b         	ldr	r3, [r7, #0x4]
 800c5b0: 60fb         	str	r3, [r7, #0xc]
; 	struct _cpu     *cpu = _current_cpu;
 800c5b2: 4b1c         	ldr	r3, [pc, #0x70]         @ 0x800c624 <z_sched_usage_stop+0xac>
 800c5b4: 63fb         	str	r3, [r7, #0x3c]
; 	uint32_t u0 = cpu->usage0;
 800c5b6: 6bfb         	ldr	r3, [r7, #0x3c]
 800c5b8: 695b         	ldr	r3, [r3, #0x14]
 800c5ba: 63bb         	str	r3, [r7, #0x38]
; 	if (u0 != 0) {
 800c5bc: 6bbb         	ldr	r3, [r7, #0x38]
 800c5be: 2b00         	cmp	r3, #0x0
 800c5c0: d015         	beq	0x800c5ee <z_sched_usage_stop+0x76> @ imm = #0x2a
; 		uint32_t cycles = usage_now() - u0;
 800c5c2: f007 fd18    	bl	0x8013ff6 <usage_now>   @ imm = #0x7a30
 800c5c6: 4602         	mov	r2, r0
 800c5c8: 6bbb         	ldr	r3, [r7, #0x38]
 800c5ca: 1ad3         	subs	r3, r2, r3
 800c5cc: 637b         	str	r3, [r7, #0x34]
; 		if (cpu->current->base.usage.track_usage) {
 800c5ce: 6bfb         	ldr	r3, [r7, #0x3c]
 800c5d0: 689b         	ldr	r3, [r3, #0x8]
 800c5d2: f893 3038    	ldrb.w	r3, [r3, #0x38]
 800c5d6: 2b00         	cmp	r3, #0x0
 800c5d8: d005         	beq	0x800c5e6 <z_sched_usage_stop+0x6e> @ imm = #0xa
; 			sched_thread_update_usage(cpu->current, cycles);
 800c5da: 6bfb         	ldr	r3, [r7, #0x3c]
 800c5dc: 689b         	ldr	r3, [r3, #0x8]
 800c5de: 6b79         	ldr	r1, [r7, #0x34]
 800c5e0: 4618         	mov	r0, r3
 800c5e2: f007 fd43    	bl	0x801406c <sched_thread_update_usage> @ imm = #0x7a86
; 		sched_cpu_update_usage(cpu, cycles);
 800c5e6: 6b79         	ldr	r1, [r7, #0x34]
 800c5e8: 6bf8         	ldr	r0, [r7, #0x3c]
 800c5ea: f007 fd14    	bl	0x8014016 <sched_cpu_update_usage> @ imm = #0x7a28
; 	cpu->usage0 = 0;
 800c5ee: 6bfb         	ldr	r3, [r7, #0x3c]
 800c5f0: 2200         	movs	r2, #0x0
 800c5f2: 615a         	str	r2, [r3, #0x14]
 800c5f4: 4b0a         	ldr	r3, [pc, #0x28]         @ 0x800c620 <z_sched_usage_stop+0xa8>
 800c5f6: 61bb         	str	r3, [r7, #0x18]
 800c5f8: 68fb         	ldr	r3, [r7, #0xc]
 800c5fa: 60bb         	str	r3, [r7, #0x8]
; 	arch_irq_unlock(key.key);
 800c5fc: 68bb         	ldr	r3, [r7, #0x8]
 800c5fe: 617b         	str	r3, [r7, #0x14]
 800c600: 697b         	ldr	r3, [r7, #0x14]
 800c602: 613b         	str	r3, [r7, #0x10]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800c604: 693b         	ldr	r3, [r7, #0x10]
 800c606: f383 8811    	msr	basepri, r3
; }
 800c60a: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800c60c: f3bf 8f6f    	isb	sy
; }
 800c610: bf00         	nop
; }
 800c612: bf00         	nop
; }
 800c614: bf00         	nop
; }
 800c616: bf00         	nop
 800c618: 3740         	adds	r7, #0x40
 800c61a: 46bd         	mov	sp, r7
 800c61c: bd80         	pop	{r7, pc}
 800c61e: bf00         	nop

0800c620 <$d>:
 800c620: f4 09 00 20  	.word	0x200009f4
 800c624: c0 02 00 20  	.word	0x200002c0

0800c628 <boot_banner>:
; {
 800c628: b580         	push	{r7, lr}
 800c62a: af00         	add	r7, sp, #0x0
; 	printk("*** " CONFIG_BOOT_BANNER_STRING " " BANNER_VERSION BANNER_POSTFIX " ***\n");
 800c62c: 4802         	ldr	r0, [pc, #0x8]          @ 0x800c638 <boot_banner+0x10>
 800c62e: f001 fc83    	bl	0x800df38 <printk>      @ imm = #0x1906
; }
 800c632: bf00         	nop
 800c634: bd80         	pop	{r7, pc}
 800c636: bf00         	nop

0800c638 <$d>:
 800c638: 64 5f 01 08  	.word	0x08015f64

0800c63c <statics_init>:
; {
 800c63c: b580         	push	{r7, lr}
 800c63e: b082         	sub	sp, #0x8
 800c640: af00         	add	r7, sp, #0x0
; 	STRUCT_SECTION_FOREACH(k_heap, heap) {
 800c642: 4b0e         	ldr	r3, [pc, #0x38]         @ 0x800c67c <statics_init+0x40>
 800c644: 607b         	str	r3, [r7, #0x4]
 800c646: e00a         	b	0x800c65e <statics_init+0x22> @ imm = #0x14
; 			k_heap_init(heap, heap->heap.init_mem, heap->heap.init_bytes);
 800c648: 687b         	ldr	r3, [r7, #0x4]
 800c64a: 6859         	ldr	r1, [r3, #0x4]
 800c64c: 687b         	ldr	r3, [r7, #0x4]
 800c64e: 689b         	ldr	r3, [r3, #0x8]
 800c650: 461a         	mov	r2, r3
 800c652: 6878         	ldr	r0, [r7, #0x4]
 800c654: f007 fd3f    	bl	0x80140d6 <k_heap_init> @ imm = #0x7a7e
; 	STRUCT_SECTION_FOREACH(k_heap, heap) {
 800c658: 687b         	ldr	r3, [r7, #0x4]
 800c65a: 3314         	adds	r3, #0x14
 800c65c: 607b         	str	r3, [r7, #0x4]
 800c65e: 687b         	ldr	r3, [r7, #0x4]
 800c660: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x800c680 <statics_init+0x44>
 800c662: 4293         	cmp	r3, r2
 800c664: bf34         	ite	lo
 800c666: 2301         	movlo	r3, #0x1
 800c668: 2300         	movhs	r3, #0x0
 800c66a: b2db         	uxtb	r3, r3
 800c66c: 2b00         	cmp	r3, #0x0
 800c66e: d1eb         	bne	0x800c648 <statics_init+0xc> @ imm = #-0x2a
; 	return 0;
 800c670: 2300         	movs	r3, #0x0
; }
 800c672: 4618         	mov	r0, r3
 800c674: 3708         	adds	r7, #0x8
 800c676: 46bd         	mov	sp, r7
 800c678: bd80         	pop	{r7, pc}
 800c67a: bf00         	nop

0800c67c <$d>:
 800c67c: 8c 01 00 20  	.word	0x2000018c
 800c680: 8c 01 00 20  	.word	0x2000018c

0800c684 <skip_to_arg>:
 800c684: e92d 41f0    	push.w	{r4, r5, r6, r7, r8, lr}
 800c688: 2601         	movs	r6, #0x1
 800c68a: 4607         	mov	r7, r0
 800c68c: 42b2         	cmp	r2, r6
 800c68e: dc01         	bgt	0x800c694 <skip_to_arg+0x10> @ imm = #0x2
 800c690: e8bd 81f0    	pop.w	{r4, r5, r6, r7, r8, pc}
 800c694: 463b         	mov	r3, r7
 800c696: 461f         	mov	r7, r3
 800c698: f813 4b01    	ldrb	r4, [r3], #1
 800c69c: 2c00         	cmp	r4, #0x0
 800c69e: d0f7         	beq	0x800c690 <skip_to_arg+0xc> @ imm = #-0x12
 800c6a0: 2c25         	cmp	r4, #0x25
 800c6a2: d1f8         	bne	0x800c696 <skip_to_arg+0x12> @ imm = #-0x10
 800c6a4: 781c         	ldrb	r4, [r3]
 800c6a6: 2c25         	cmp	r4, #0x25
 800c6a8: f107 0702    	add.w	r7, r7, #0x2
 800c6ac: d0f2         	beq	0x800c694 <skip_to_arg+0x10> @ imm = #-0x1c
 800c6ae: 2300         	movs	r3, #0x0
 800c6b0: f8df 8104    	ldr.w	r8, [pc, #0x104]        @ 0x800c7b8 <skip_to_arg+0x134>
 800c6b4: 469c         	mov	r12, r3
 800c6b6: 461d         	mov	r5, r3
 800c6b8: 2d1f         	cmp	r5, #0x1f
 800c6ba: d818         	bhi	0x800c6ee <skip_to_arg+0x6a> @ imm = #0x30
 800c6bc: f1a4 0e20    	sub.w	lr, r4, #0x20
 800c6c0: f1be 0f10    	cmp.w	lr, #0x10
 800c6c4: d909         	bls	0x800c6da <skip_to_arg+0x56> @ imm = #0x12
 800c6c6: f1a4 0e30    	sub.w	lr, r4, #0x30
 800c6ca: f1be 0f09    	cmp.w	lr, #0x9
 800c6ce: d81e         	bhi	0x800c70e <skip_to_arg+0x8a> @ imm = #0x3c
 800c6d0: 240a         	movs	r4, #0xa
 800c6d2: fb04 e303    	mla	r3, r4, r3, lr
 800c6d6: 2520         	movs	r5, #0x20
 800c6d8: e004         	b	0x800c6e4 <skip_to_arg+0x60> @ imm = #0x8
 800c6da: fa28 fe0e    	lsr.w	lr, r8, lr
 800c6de: f01e 0f01    	tst.w	lr, #0x1
 800c6e2: d006         	beq	0x800c6f2 <skip_to_arg+0x6e> @ imm = #0xc
 800c6e4: f817 4b01    	ldrb	r4, [r7], #1
 800c6e8: 2c00         	cmp	r4, #0x0
 800c6ea: d1e5         	bne	0x800c6b8 <skip_to_arg+0x34> @ imm = #-0x36
 800c6ec: e028         	b	0x800c740 <skip_to_arg+0xbc> @ imm = #0x50
 800c6ee: 2d7f         	cmp	r5, #0x7f
 800c6f0: d81c         	bhi	0x800c72c <skip_to_arg+0xa8> @ imm = #0x38
 800c6f2: f1a4 0e30    	sub.w	lr, r4, #0x30
 800c6f6: f1be 0f09    	cmp.w	lr, #0x9
 800c6fa: d9e9         	bls	0x800c6d0 <skip_to_arg+0x4c> @ imm = #-0x2e
 800c6fc: 2c24         	cmp	r4, #0x24
 800c6fe: d110         	bne	0x800c722 <skip_to_arg+0x9e> @ imm = #0x20
 800c700: f1bc 0f00    	cmp.w	r12, #0x0
 800c704: d046         	beq	0x800c794 <skip_to_arg+0x110> @ imm = #0x8c
 800c706: 42b3         	cmp	r3, r6
 800c708: d046         	beq	0x800c798 <skip_to_arg+0x114> @ imm = #0x8c
 800c70a: 2300         	movs	r3, #0x0
 800c70c: e7ea         	b	0x800c6e4 <skip_to_arg+0x60> @ imm = #-0x2c
 800c70e: f024 0e04    	bic	lr, r4, #0x4
 800c712: f1be 0f2a    	cmp.w	lr, #0x2a
 800c716: d0f8         	beq	0x800c70a <skip_to_arg+0x86> @ imm = #-0x10
 800c718: 2c6c         	cmp	r4, #0x6c
 800c71a: d109         	bne	0x800c730 <skip_to_arg+0xac> @ imm = #0x12
 800c71c: f045 0580    	orr	r5, r5, #0x80
 800c720: e7e0         	b	0x800c6e4 <skip_to_arg+0x60> @ imm = #-0x40
 800c722: f024 0e04    	bic	lr, r4, #0x4
 800c726: f1be 0f2a    	cmp.w	lr, #0x2a
 800c72a: d0ee         	beq	0x800c70a <skip_to_arg+0x86> @ imm = #-0x24
 800c72c: 2c6c         	cmp	r4, #0x6c
 800c72e: d022         	beq	0x800c776 <skip_to_arg+0xf2> @ imm = #0x44
 800c730: 2c6c         	cmp	r4, #0x6c
 800c732: d81b         	bhi	0x800c76c <skip_to_arg+0xe8> @ imm = #0x36
 800c734: 2c68         	cmp	r4, #0x68
 800c736: d023         	beq	0x800c780 <skip_to_arg+0xfc> @ imm = #0x46
 800c738: 2c6a         	cmp	r4, #0x6a
 800c73a: d028         	beq	0x800c78e <skip_to_arg+0x10a> @ imm = #0x50
 800c73c: 2c4c         	cmp	r4, #0x4c
 800c73e: d026         	beq	0x800c78e <skip_to_arg+0x10a> @ imm = #0x4c
 800c740: f1bc 0f00    	cmp.w	r12, #0x0
 800c744: d0a4         	beq	0x800c690 <skip_to_arg+0xc> @ imm = #-0xb8
 800c746: 45b4         	cmp	r12, r6
 800c748: d1a0         	bne	0x800c68c <skip_to_arg+0x8> @ imm = #-0xc0
 800c74a: f044 0720    	orr	r7, r4, #0x20
 800c74e: f1a7 0c65    	sub.w	r12, r7, #0x65
 800c752: f1bc 0f02    	cmp.w	r12, #0x2
 800c756: 680b         	ldr	r3, [r1]
 800c758: d901         	bls	0x800c75e <skip_to_arg+0xda> @ imm = #0x2
 800c75a: 2f61         	cmp	r7, #0x61
 800c75c: d11e         	bne	0x800c79c <skip_to_arg+0x118> @ imm = #0x3c
 800c75e: 3307         	adds	r3, #0x7
 800c760: f023 0307    	bic	r3, r3, #0x7
 800c764: 3308         	adds	r3, #0x8
 800c766: 600b         	str	r3, [r1]
 800c768: 3601         	adds	r6, #0x1
 800c76a: e78e         	b	0x800c68a <skip_to_arg+0x6> @ imm = #-0xe4
 800c76c: 2c74         	cmp	r4, #0x74
 800c76e: d0b9         	beq	0x800c6e4 <skip_to_arg+0x60> @ imm = #-0x8e
 800c770: 2c7a         	cmp	r4, #0x7a
 800c772: d0b7         	beq	0x800c6e4 <skip_to_arg+0x60> @ imm = #-0x92
 800c774: e7e4         	b	0x800c740 <skip_to_arg+0xbc> @ imm = #-0x38
 800c776: 062c         	lsls	r4, r5, #0x18
 800c778: bf48         	it	mi
 800c77a: f445 7500    	orrmi	r5, r5, #0x200
 800c77e: e7cd         	b	0x800c71c <skip_to_arg+0x98> @ imm = #-0x66
 800c780: 05ec         	lsls	r4, r5, #0x17
 800c782: bf48         	it	mi
 800c784: f445 7500    	orrmi	r5, r5, #0x200
 800c788: f445 7580    	orr	r5, r5, #0x100
 800c78c: e7aa         	b	0x800c6e4 <skip_to_arg+0x60> @ imm = #-0xac
 800c78e: f445 7520    	orr	r5, r5, #0x280
 800c792: e7a7         	b	0x800c6e4 <skip_to_arg+0x60> @ imm = #-0xb2
 800c794: 469c         	mov	r12, r3
 800c796: e7b8         	b	0x800c70a <skip_to_arg+0x86> @ imm = #-0x90
 800c798: 2463         	movs	r4, #0x63
 800c79a: e7d6         	b	0x800c74a <skip_to_arg+0xc6> @ imm = #-0x54
 800c79c: 2c69         	cmp	r4, #0x69
 800c79e: d002         	beq	0x800c7a6 <skip_to_arg+0x122> @ imm = #0x4
 800c7a0: d807         	bhi	0x800c7b2 <skip_to_arg+0x12e> @ imm = #0xe
 800c7a2: 2c63         	cmp	r4, #0x63
 800c7a4: d003         	beq	0x800c7ae <skip_to_arg+0x12a> @ imm = #0x6
 800c7a6: 062f         	lsls	r7, r5, #0x18
 800c7a8: d501         	bpl	0x800c7ae <skip_to_arg+0x12a> @ imm = #0x2
 800c7aa: 05ac         	lsls	r4, r5, #0x16
 800c7ac: d4d7         	bmi	0x800c75e <skip_to_arg+0xda> @ imm = #-0x52
 800c7ae: 3304         	adds	r3, #0x4
 800c7b0: e7d9         	b	0x800c766 <skip_to_arg+0xe2> @ imm = #-0x4e
 800c7b2: 2c73         	cmp	r4, #0x73
 800c7b4: e7f6         	b	0x800c7a4 <skip_to_arg+0x120> @ imm = #-0x14
 800c7b6: bf00         	nop

0800c7b8 <$d>:
 800c7b8: 89 28 01 00  	.word	0x00012889

0800c7bc <vfprintf>:
 800c7bc: e92d 4ff0    	push.w	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
 800c7c0: b095         	sub	sp, #0x54
 800c7c2: 6843         	ldr	r3, [r0, #0x4]
 800c7c4: 9303         	str	r3, [sp, #0xc]
 800c7c6: 7883         	ldrb	r3, [r0, #0x2]
 800c7c8: 4680         	mov	r8, r0
 800c7ca: 0798         	lsls	r0, r3, #0x1e
 800c7cc: e9cd 1208    	strd	r1, r2, [sp, #32]
 800c7d0: d517         	bpl	0x800c802 <vfprintf+0x46> @ imm = #0x2e
 800c7d2: 920d         	str	r2, [sp, #0x34]
 800c7d4: 460b         	mov	r3, r1
 800c7d6: 2500         	movs	r5, #0x0
 800c7d8: 781f         	ldrb	r7, [r3]
 800c7da: b1a7         	cbz	r7, 0x800c806 <vfprintf+0x4a> @ imm = #0x28
 800c7dc: 2f25         	cmp	r7, #0x25
 800c7de: d016         	beq	0x800c80e <vfprintf+0x52> @ imm = #0x2c
 800c7e0: 3301         	adds	r3, #0x1
 800c7e2: 9307         	str	r3, [sp, #0x1c]
 800c7e4: 9b03         	ldr	r3, [sp, #0xc]
 800c7e6: 4641         	mov	r1, r8
 800c7e8: 4638         	mov	r0, r7
 800c7ea: 4798         	blx	r3
 800c7ec: 2800         	cmp	r0, #0x0
 800c7ee: f105 0501    	add.w	r5, r5, #0x1
 800c7f2: f280 8439    	bge.w	0x800d068 <vfprintf+0x8ac> @ imm = #0x872
 800c7f6: f898 3002    	ldrb.w	r3, [r8, #0x2]
 800c7fa: f043 0304    	orr	r3, r3, #0x4
 800c7fe: f888 3002    	strb.w	r3, [r8, #0x2]
 800c802: f04f 35ff    	mov.w	r5, #0xffffffff
 800c806: 4628         	mov	r0, r5
 800c808: b015         	add	sp, #0x54
 800c80a: e8bd 8ff0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, r11, pc}
 800c80e: 785f         	ldrb	r7, [r3, #0x1]
 800c810: 1c9a         	adds	r2, r3, #0x2
 800c812: 2f25         	cmp	r7, #0x25
 800c814: 9207         	str	r2, [sp, #0x1c]
 800c816: d0e5         	beq	0x800c7e4 <vfprintf+0x28> @ imm = #-0x36
 800c818: 2400         	movs	r4, #0x0
 800c81a: 4626         	mov	r6, r4
 800c81c: 46a2         	mov	r10, r4
 800c81e: 46a3         	mov	r11, r4
 800c820: f1bb 0f1f    	cmp.w	r11, #0x1f
 800c824: d832         	bhi	0x800c88c <vfprintf+0xd0> @ imm = #0x64
 800c826: f1a7 0320    	sub.w	r3, r7, #0x20
 800c82a: 2b10         	cmp	r3, #0x10
 800c82c: d80a         	bhi	0x800c844 <vfprintf+0x88> @ imm = #0x14
 800c82e: e8df f003    	tbb	[pc, r3]

0800c832 <$d>:
 800c832: 24 09 09 2a  	.word	0x2a090924
 800c836: 09 09 09 1b  	.word	0x1b090909
 800c83a: 09 09 09 22  	.word	0x22090909
 800c83e: 09 27 09 09  	.word	0x09092709
 800c842: 19           	.byte	0x19

0800c843 <$d>:
 800c843: 00           	.byte	0x00

0800c844 <$t>:
 800c844: f1a7 0330    	sub.w	r3, r7, #0x30
 800c848: 2b09         	cmp	r3, #0x9
 800c84a: d92d         	bls	0x800c8a8 <vfprintf+0xec> @ imm = #0x5a
 800c84c: 2f2a         	cmp	r7, #0x2a
 800c84e: d139         	bne	0x800c8c4 <vfprintf+0x108> @ imm = #0x72
 800c850: b954         	cbnz	r4, 0x800c868 <vfprintf+0xac> @ imm = #0x14
 800c852: 9b0d         	ldr	r3, [sp, #0x34]
 800c854: f01b 0f40    	tst.w	r11, #0x40
 800c858: f853 2b04    	ldr	r2, [r3], #4
 800c85c: 930d         	str	r3, [sp, #0x34]
 800c85e: d029         	beq	0x800c8b4 <vfprintf+0xf8> @ imm = #0x52
 800c860: 4616         	mov	r6, r2
 800c862: e001         	b	0x800c868 <vfprintf+0xac> @ imm = #0x2
 800c864: f04b 0b01    	orr	r11, r11, #0x1
 800c868: 9b07         	ldr	r3, [sp, #0x1c]
 800c86a: f813 7b01    	ldrb	r7, [r3], #1
 800c86e: 9307         	str	r3, [sp, #0x1c]
 800c870: 2f00         	cmp	r7, #0x0
 800c872: d1d5         	bne	0x800c820 <vfprintf+0x64> @ imm = #-0x56
 800c874: e05b         	b	0x800c92e <vfprintf+0x172> @ imm = #0xb6
 800c876: f04b 0b02    	orr	r11, r11, #0x2
 800c87a: f04b 0b04    	orr	r11, r11, #0x4
 800c87e: e7f3         	b	0x800c868 <vfprintf+0xac> @ imm = #-0x1a
 800c880: f04b 0b08    	orr	r11, r11, #0x8
 800c884: e7f0         	b	0x800c868 <vfprintf+0xac> @ imm = #-0x20
 800c886: f04b 0b10    	orr	r11, r11, #0x10
 800c88a: e7ed         	b	0x800c868 <vfprintf+0xac> @ imm = #-0x26
 800c88c: f1bb 0f7f    	cmp.w	r11, #0x7f
 800c890: d83f         	bhi	0x800c912 <vfprintf+0x156> @ imm = #0x7e
 800c892: f1a7 0330    	sub.w	r3, r7, #0x30
 800c896: 2b09         	cmp	r3, #0x9
 800c898: d8d8         	bhi	0x800c84c <vfprintf+0x90> @ imm = #-0x50
 800c89a: f01b 0f40    	tst.w	r11, #0x40
 800c89e: d003         	beq	0x800c8a8 <vfprintf+0xec> @ imm = #0x6
 800c8a0: 220a         	movs	r2, #0xa
 800c8a2: fb02 3606    	mla	r6, r2, r6, r3
 800c8a6: e7df         	b	0x800c868 <vfprintf+0xac> @ imm = #-0x42
 800c8a8: 220a         	movs	r2, #0xa
 800c8aa: fb02 3a0a    	mla	r10, r2, r10, r3
 800c8ae: f04b 0b20    	orr	r11, r11, #0x20
 800c8b2: e7d9         	b	0x800c868 <vfprintf+0xac> @ imm = #-0x4e
 800c8b4: f1b2 0a00    	subs.w	r10, r2, #0x0
 800c8b8: daf9         	bge	0x800c8ae <vfprintf+0xf2> @ imm = #-0xe
 800c8ba: f1ca 0a00    	rsb.w	r10, r10, #0x0
 800c8be: f04b 0b28    	orr	r11, r11, #0x28
 800c8c2: e7d1         	b	0x800c868 <vfprintf+0xac> @ imm = #-0x5e
 800c8c4: 2f2e         	cmp	r7, #0x2e
 800c8c6: d105         	bne	0x800c8d4 <vfprintf+0x118> @ imm = #0xa
 800c8c8: f01b 0f40    	tst.w	r11, #0x40
 800c8cc: d19b         	bne	0x800c806 <vfprintf+0x4a> @ imm = #-0xca
 800c8ce: f04b 0b40    	orr	r11, r11, #0x40
 800c8d2: e7c9         	b	0x800c868 <vfprintf+0xac> @ imm = #-0x6e
 800c8d4: 2f24         	cmp	r7, #0x24
 800c8d6: d11c         	bne	0x800c912 <vfprintf+0x156> @ imm = #0x38
 800c8d8: 2c00         	cmp	r4, #0x0
 800c8da: f000 8142    	beq.w	0x800cb62 <vfprintf+0x3a6> @ imm = #0x284
 800c8de: 9b09         	ldr	r3, [sp, #0x24]
 800c8e0: 930d         	str	r3, [sp, #0x34]
 800c8e2: f01b 0f40    	tst.w	r11, #0x40
 800c8e6: d10a         	bne	0x800c8fe <vfprintf+0x142> @ imm = #0x14
 800c8e8: 4652         	mov	r2, r10
 800c8ea: 9808         	ldr	r0, [sp, #0x20]
 800c8ec: a90d         	add	r1, sp, #0x34
 800c8ee: f7ff fec9    	bl	0x800c684 <skip_to_arg> @ imm = #-0x26e
 800c8f2: 9b0d         	ldr	r3, [sp, #0x34]
 800c8f4: 1d1a         	adds	r2, r3, #0x4
 800c8f6: f8d3 a000    	ldr.w	r10, [r3]
 800c8fa: 920d         	str	r2, [sp, #0x34]
 800c8fc: e7b4         	b	0x800c868 <vfprintf+0xac> @ imm = #-0x98
 800c8fe: 4632         	mov	r2, r6
 800c900: 9808         	ldr	r0, [sp, #0x20]
 800c902: a90d         	add	r1, sp, #0x34
 800c904: f7ff febe    	bl	0x800c684 <skip_to_arg> @ imm = #-0x284
 800c908: 9b0d         	ldr	r3, [sp, #0x34]
 800c90a: 1d1a         	adds	r2, r3, #0x4
 800c90c: 681e         	ldr	r6, [r3]
 800c90e: 920d         	str	r2, [sp, #0x34]
 800c910: e7aa         	b	0x800c868 <vfprintf+0xac> @ imm = #-0xac
 800c912: 2f6c         	cmp	r7, #0x6c
 800c914: f000 8112    	beq.w	0x800cb3c <vfprintf+0x380> @ imm = #0x224
 800c918: f200 8109    	bhi.w	0x800cb2e <vfprintf+0x372> @ imm = #0x212
 800c91c: 2f68         	cmp	r7, #0x68
 800c91e: f000 8115    	beq.w	0x800cb4c <vfprintf+0x390> @ imm = #0x22a
 800c922: 2f6a         	cmp	r7, #0x6a
 800c924: f000 811a    	beq.w	0x800cb5c <vfprintf+0x3a0> @ imm = #0x234
 800c928: 2f4c         	cmp	r7, #0x4c
 800c92a: f000 8117    	beq.w	0x800cb5c <vfprintf+0x3a0> @ imm = #0x22e
 800c92e: b134         	cbz	r4, 0x800c93e <vfprintf+0x182> @ imm = #0xc
 800c930: 9b09         	ldr	r3, [sp, #0x24]
 800c932: 9808         	ldr	r0, [sp, #0x20]
 800c934: 930d         	str	r3, [sp, #0x34]
 800c936: 4622         	mov	r2, r4
 800c938: a90d         	add	r1, sp, #0x34
 800c93a: f7ff fea3    	bl	0x800c684 <skip_to_arg> @ imm = #-0x2ba
 800c93e: 2e00         	cmp	r6, #0x0
 800c940: f047 0920    	orr	r9, r7, #0x20
 800c944: bfb8         	it	lt
 800c946: f02b 0b40    	biclt	r11, r11, #0x40
 800c94a: f1a9 0365    	sub.w	r3, r9, #0x65
 800c94e: bfbc         	itt	lt
 800c950: fa1f fb8b    	uxthlt.w	r11, r11
 800c954: 2600         	movlt	r6, #0x0
 800c956: 2b02         	cmp	r3, #0x2
 800c958: f240 8108    	bls.w	0x800cb6c <vfprintf+0x3b0> @ imm = #0x210
 800c95c: f1b9 0f61    	cmp.w	r9, #0x61
 800c960: f040 8267    	bne.w	0x800ce32 <vfprintf+0x676> @ imm = #0x4ce
 800c964: 43ff         	mvns	r7, r7
 800c966: f007 0320    	and	r3, r7, #0x20
 800c96a: 9306         	str	r3, [sp, #0x18]
 800c96c: 9b0d         	ldr	r3, [sp, #0x34]
 800c96e: 3307         	adds	r3, #0x7
 800c970: f023 0307    	bic	r3, r3, #0x7
 800c974: f01b 0f40    	tst.w	r11, #0x40
 800c978: e9d3 0100    	ldrd	r0, r1, [r3]
 800c97c: f103 0208    	add.w	r2, r3, #0x8
 800c980: bf08         	it	eq
 800c982: f04f 36ff    	moveq.w	r6, #0xffffffff
 800c986: 9b06         	ldr	r3, [sp, #0x18]
 800c988: 920d         	str	r2, [sp, #0x34]
 800c98a: 9300         	str	r3, [sp]
 800c98c: aa0e         	add	r2, sp, #0x38
 800c98e: 4633         	mov	r3, r6
 800c990: f007 fd05    	bl	0x801439e <__dtox_engine> @ imm = #0x7a0a
 800c994: 3001         	adds	r0, #0x1
 800c996: b2c3         	uxtb	r3, r0
 800c998: 42b3         	cmp	r3, r6
 800c99a: f44b 54c0    	orr	r4, r11, #0x1800
 800c99e: 9304         	str	r3, [sp, #0x10]
 800c9a0: db01         	blt	0x800c9a6 <vfprintf+0x1ea> @ imm = #0x2
 800c9a2: 9b04         	ldr	r3, [sp, #0x10]
 800c9a4: 1e5e         	subs	r6, r3, #0x1
 800c9a6: 2301         	movs	r3, #0x1
 800c9a8: 9f0e         	ldr	r7, [sp, #0x38]
 800c9aa: 9305         	str	r3, [sp, #0x14]
 800c9ac: 46a3         	mov	r11, r4
 800c9ae: f04f 0970    	mov.w	r9, #0x70
 800c9b2: f107 0309    	add.w	r3, r7, #0x9
 800c9b6: 2b12         	cmp	r3, #0x12
 800c9b8: d90d         	bls	0x800c9d6 <vfprintf+0x21a> @ imm = #0x1a
 800c9ba: f107 0363    	add.w	r3, r7, #0x63
 800c9be: 2bc6         	cmp	r3, #0xc6
 800c9c0: f240 810f    	bls.w	0x800cbe2 <vfprintf+0x426> @ imm = #0x21e
 800c9c4: f207 33e7    	addw	r3, r7, #0x3e7
 800c9c8: f240 72ce    	movw	r2, #0x7ce
 800c9cc: 4293         	cmp	r3, r2
 800c9ce: bf94         	ite	ls
 800c9d0: 2303         	movls	r3, #0x3
 800c9d2: 2304         	movhi	r3, #0x4
 800c9d4: 9305         	str	r3, [sp, #0x14]
 800c9d6: f89d 203c    	ldrb.w	r2, [sp, #0x3c]
 800c9da: f002 030c    	and	r3, r2, #0xc
 800c9de: f012 0201    	ands	r2, r2, #0x1
 800c9e2: f040 8119    	bne.w	0x800cc18 <vfprintf+0x45c> @ imm = #0x232
 800c9e6: f01b 0f02    	tst.w	r11, #0x2
 800c9ea: f040 8112    	bne.w	0x800cc12 <vfprintf+0x456> @ imm = #0x224
 800c9ee: f01b 0404    	ands	r4, r11, #0x4
 800c9f2: f000 80f8    	beq.w	0x800cbe6 <vfprintf+0x42a> @ imm = #0x1f0
 800c9f6: 2b00         	cmp	r3, #0x0
 800c9f8: f040 8111    	bne.w	0x800cc1e <vfprintf+0x462> @ imm = #0x222
 800c9fc: 2320         	movs	r3, #0x20
 800c9fe: f41b 5f40    	tst.w	r11, #0x3000
 800ca02: d11f         	bne	0x800ca44 <vfprintf+0x288> @ imm = #0x3e
 800ca04: 9a04         	ldr	r2, [sp, #0x10]
 800ca06: 3250         	adds	r2, #0x50
 800ca08: 2e00         	cmp	r6, #0x0
 800ca0a: 446a         	add	r2, sp, r2
 800ca0c: bf08         	it	eq
 800ca0e: 2601         	moveq	r6, #0x1
 800ca10: 3a13         	subs	r2, #0x13
 800ca12: 9904         	ldr	r1, [sp, #0x10]
 800ca14: b121         	cbz	r1, 0x800ca20 <vfprintf+0x264> @ imm = #0x8
 800ca16: f812 1d01    	ldrb	r1, [r2, #-1]!
 800ca1a: 2930         	cmp	r1, #0x30
 800ca1c: f000 8136    	beq.w	0x800cc8c <vfprintf+0x4d0> @ imm = #0x26c
 800ca20: f01b 0f10    	tst.w	r11, #0x10
 800ca24: 9a04         	ldr	r2, [sp, #0x10]
 800ca26: bf18         	it	ne
 800ca28: 4632         	movne	r2, r6
 800ca2a: 1d39         	adds	r1, r7, #0x4
 800ca2c: f2c0 8133    	blt.w	0x800cc96 <vfprintf+0x4da> @ imm = #0x266
 800ca30: 42b7         	cmp	r7, r6
 800ca32: f280 8130    	bge.w	0x800cc96 <vfprintf+0x4da> @ imm = #0x260
 800ca36: 42ba         	cmp	r2, r7
 800ca38: f44b 5b00    	orr	r11, r11, #0x2000
 800ca3c: f340 812d    	ble.w	0x800cc9a <vfprintf+0x4de> @ imm = #0x25a
 800ca40: 1c7e         	adds	r6, r7, #0x1
 800ca42: 1b96         	subs	r6, r2, r6
 800ca44: f41b 5200    	ands	r2, r11, #0x2000
 800ca48: 920a         	str	r2, [sp, #0x28]
 800ca4a: f000 8128    	beq.w	0x800cc9e <vfprintf+0x4e2> @ imm = #0x250
 800ca4e: ea27 74e7    	bic.w	r4, r7, r7, asr #31
 800ca52: 3401         	adds	r4, #0x1
 800ca54: b103         	cbz	r3, 0x800ca58 <vfprintf+0x29c> @ imm = #0x0
 800ca56: 3401         	adds	r4, #0x1
 800ca58: 2e00         	cmp	r6, #0x0
 800ca5a: f000 8128    	beq.w	0x800ccae <vfprintf+0x4f2> @ imm = #0x250
 800ca5e: 1c72         	adds	r2, r6, #0x1
 800ca60: 4414         	add	r4, r2
 800ca62: 45a2         	cmp	r10, r4
 800ca64: bfcc         	ite	gt
 800ca66: ebaa 0404    	subgt.w	r4, r10, r4
 800ca6a: 2400         	movle	r4, #0x0
 800ca6c: f01b 0f09    	tst.w	r11, #0x9
 800ca70: d104         	bne	0x800ca7c <vfprintf+0x2c0> @ imm = #0x8
 800ca72: 442c         	add	r4, r5
 800ca74: 42a5         	cmp	r5, r4
 800ca76: f040 811f    	bne.w	0x800ccb8 <vfprintf+0x4fc> @ imm = #0x23e
 800ca7a: 2400         	movs	r4, #0x0
 800ca7c: b143         	cbz	r3, 0x800ca90 <vfprintf+0x2d4> @ imm = #0x10
 800ca7e: 4618         	mov	r0, r3
 800ca80: 4641         	mov	r1, r8
 800ca82: 9b03         	ldr	r3, [sp, #0xc]
 800ca84: 4798         	blx	r3
 800ca86: 2800         	cmp	r0, #0x0
 800ca88: f105 0501    	add.w	r5, r5, #0x1
 800ca8c: f6ff aeb3    	blt.w	0x800c7f6 <vfprintf+0x3a> @ imm = #-0x29a
 800ca90: f41b 6f00    	tst.w	r11, #0x800
 800ca94: d013         	beq	0x800cabe <vfprintf+0x302> @ imm = #0x26
 800ca96: 9b03         	ldr	r3, [sp, #0xc]
 800ca98: 4641         	mov	r1, r8
 800ca9a: 2030         	movs	r0, #0x30
 800ca9c: 4798         	blx	r3
 800ca9e: 2800         	cmp	r0, #0x0
 800caa0: f6ff aea9    	blt.w	0x800c7f6 <vfprintf+0x3a> @ imm = #-0x2ae
 800caa4: 9b06         	ldr	r3, [sp, #0x18]
 800caa6: f1c3 0078    	rsb.w	r0, r3, #0x78
 800caaa: 4641         	mov	r1, r8
 800caac: 9b03         	ldr	r3, [sp, #0xc]
 800caae: f000 00f8    	and	r0, r0, #0xf8
 800cab2: 4798         	blx	r3
 800cab4: 2800         	cmp	r0, #0x0
 800cab6: f105 0502    	add.w	r5, r5, #0x2
 800caba: f6ff ae9c    	blt.w	0x800c7f6 <vfprintf+0x3a> @ imm = #-0x2c8
 800cabe: f01b 0f08    	tst.w	r11, #0x8
 800cac2: d105         	bne	0x800cad0 <vfprintf+0x314> @ imm = #0xa
 800cac4: 442c         	add	r4, r5
 800cac6: 42ac         	cmp	r4, r5
 800cac8: f040 8102    	bne.w	0x800ccd0 <vfprintf+0x514> @ imm = #0x204
 800cacc: 4625         	mov	r5, r4
 800cace: 2400         	movs	r4, #0x0
 800cad0: 9b0a         	ldr	r3, [sp, #0x28]
 800cad2: 2b00         	cmp	r3, #0x0
 800cad4: f000 811c    	beq.w	0x800cd10 <vfprintf+0x554> @ imm = #0x238
 800cad8: ea27 7ae7    	bic.w	r10, r7, r7, asr #31
 800cadc: eba7 070a    	sub.w	r7, r7, r10
 800cae0: 4276         	rsbs	r6, r6, #0
 800cae2: 9b04         	ldr	r3, [sp, #0x10]
 800cae4: 42bb         	cmp	r3, r7
 800cae6: bf84         	itt	hi
 800cae8: ab0e         	addhi	r3, sp, #0x38
 800caea: 18fb         	addhi	r3, r7, r3
 800caec: f10a 3aff    	add.w	r10, r10, #0xffffffff
 800caf0: bf88         	it	hi
 800caf2: 7958         	ldrbhi	r0, [r3, #0x5]
 800caf4: 9b03         	ldr	r3, [sp, #0xc]
 800caf6: bf98         	it	ls
 800caf8: 2030         	movls	r0, #0x30
 800cafa: 4556         	cmp	r6, r10
 800cafc: f105 0901    	add.w	r9, r5, #0x1
 800cb00: 4641         	mov	r1, r8
 800cb02: f300 80ef    	bgt.w	0x800cce4 <vfprintf+0x528> @ imm = #0x1de
 800cb06: 4798         	blx	r3
 800cb08: 2800         	cmp	r0, #0x0
 800cb0a: f107 0701    	add.w	r7, r7, #0x1
 800cb0e: f6ff ae72    	blt.w	0x800c7f6 <vfprintf+0x3a> @ imm = #-0x31c
 800cb12: f1ba 3fff    	cmp.w	r10, #0xffffffff
 800cb16: d108         	bne	0x800cb2a <vfprintf+0x36e> @ imm = #0x10
 800cb18: 9b03         	ldr	r3, [sp, #0xc]
 800cb1a: 4641         	mov	r1, r8
 800cb1c: 202e         	movs	r0, #0x2e
 800cb1e: 4798         	blx	r3
 800cb20: 2800         	cmp	r0, #0x0
 800cb22: f6ff ae68    	blt.w	0x800c7f6 <vfprintf+0x3a> @ imm = #-0x330
 800cb26: f105 0902    	add.w	r9, r5, #0x2
 800cb2a: 464d         	mov	r5, r9
 800cb2c: e7d9         	b	0x800cae2 <vfprintf+0x326> @ imm = #-0x4e
 800cb2e: 2f74         	cmp	r7, #0x74
 800cb30: f43f ae9a    	beq.w	0x800c868 <vfprintf+0xac> @ imm = #-0x2cc
 800cb34: 2f7a         	cmp	r7, #0x7a
 800cb36: f43f ae97    	beq.w	0x800c868 <vfprintf+0xac> @ imm = #-0x2d2
 800cb3a: e6f8         	b	0x800c92e <vfprintf+0x172> @ imm = #-0x210
 800cb3c: f01b 0f80    	tst.w	r11, #0x80
 800cb40: bf18         	it	ne
 800cb42: f44b 7b00    	orrne	r11, r11, #0x200
 800cb46: f04b 0b80    	orr	r11, r11, #0x80
 800cb4a: e68d         	b	0x800c868 <vfprintf+0xac> @ imm = #-0x2e6
 800cb4c: f41b 7f80    	tst.w	r11, #0x100
 800cb50: bf18         	it	ne
 800cb52: f44b 7b00    	orrne	r11, r11, #0x200
 800cb56: f44b 7b80    	orr	r11, r11, #0x100
 800cb5a: e685         	b	0x800c868 <vfprintf+0xac> @ imm = #-0x2f6
 800cb5c: f44b 7b20    	orr	r11, r11, #0x280
 800cb60: e682         	b	0x800c868 <vfprintf+0xac> @ imm = #-0x2fc
 800cb62: 4626         	mov	r6, r4
 800cb64: 46b3         	mov	r11, r6
 800cb66: 4654         	mov	r4, r10
 800cb68: 46b2         	mov	r10, r6
 800cb6a: e67d         	b	0x800c868 <vfprintf+0xac> @ imm = #-0x306
 800cb6c: 43ff         	mvns	r7, r7
 800cb6e: f007 0320    	and	r3, r7, #0x20
 800cb72: 9306         	str	r3, [sp, #0x18]
 800cb74: 9b0d         	ldr	r3, [sp, #0x34]
 800cb76: 3307         	adds	r3, #0x7
 800cb78: f023 0307    	bic	r3, r3, #0x7
 800cb7c: f01b 0f40    	tst.w	r11, #0x40
 800cb80: f103 0208    	add.w	r2, r3, #0x8
 800cb84: bf08         	it	eq
 800cb86: 2606         	moveq	r6, #0x6
 800cb88: f1b9 0f65    	cmp.w	r9, #0x65
 800cb8c: e9d3 0100    	ldrd	r0, r1, [r3]
 800cb90: 920d         	str	r2, [sp, #0x34]
 800cb92: d113         	bne	0x800cbbc <vfprintf+0x400> @ imm = #0x26
 800cb94: 1c73         	adds	r3, r6, #0x1
 800cb96: 2200         	movs	r2, #0x0
 800cb98: b2db         	uxtb	r3, r3
 800cb9a: f44b 5b80    	orr	r11, r11, #0x1000
 800cb9e: 4614         	mov	r4, r2
 800cba0: 2b11         	cmp	r3, #0x11
 800cba2: e9cd 2400    	strd	r2, r4, [sp]
 800cba6: bf28         	it	hs
 800cba8: 2311         	movhs	r3, #0x11
 800cbaa: aa0e         	add	r2, sp, #0x38
 800cbac: f000 fafc    	bl	0x800d1a8 <__dtoa_engine> @ imm = #0x5f8
 800cbb0: b2c3         	uxtb	r3, r0
 800cbb2: 9304         	str	r3, [sp, #0x10]
 800cbb4: 2302         	movs	r3, #0x2
 800cbb6: 9f0e         	ldr	r7, [sp, #0x38]
 800cbb8: 9305         	str	r3, [sp, #0x14]
 800cbba: e6fa         	b	0x800c9b2 <vfprintf+0x1f6> @ imm = #-0x20c
 800cbbc: f1b9 0f66    	cmp.w	r9, #0x66
 800cbc0: d105         	bne	0x800cbce <vfprintf+0x412> @ imm = #0xa
 800cbc2: f44b 5b00    	orr	r11, r11, #0x2000
 800cbc6: 4634         	mov	r4, r6
 800cbc8: 2201         	movs	r2, #0x1
 800cbca: 2311         	movs	r3, #0x11
 800cbcc: e7e8         	b	0x800cba0 <vfprintf+0x3e4> @ imm = #-0x30
 800cbce: b2f3         	uxtb	r3, r6
 800cbd0: 2b01         	cmp	r3, #0x1
 800cbd2: f04f 0200    	mov.w	r2, #0x0
 800cbd6: bf38         	it	lo
 800cbd8: 2301         	movlo	r3, #0x1
 800cbda: 4614         	mov	r4, r2
 800cbdc: f04f 0965    	mov.w	r9, #0x65
 800cbe0: e7de         	b	0x800cba0 <vfprintf+0x3e4> @ imm = #-0x44
 800cbe2: 2302         	movs	r3, #0x2
 800cbe4: e6f6         	b	0x800c9d4 <vfprintf+0x218> @ imm = #-0x214
 800cbe6: 2b00         	cmp	r3, #0x0
 800cbe8: f43f af09    	beq.w	0x800c9fe <vfprintf+0x242> @ imm = #-0x1ee
 800cbec: f1ba 0f03    	cmp.w	r10, #0x3
 800cbf0: dc3b         	bgt	0x800cc6a <vfprintf+0x4ae> @ imm = #0x76
 800cbf2: f89d 303c    	ldrb.w	r3, [sp, #0x3c]
 800cbf6: 4ea6         	ldr	r6, [pc, #0x298]        @ 0x800ce90 <vfprintf+0x6d4>
 800cbf8: f013 0f08    	tst.w	r3, #0x8
 800cbfc: 4ba5         	ldr	r3, [pc, #0x294]        @ 0x800ce94 <vfprintf+0x6d8>
 800cbfe: bf08         	it	eq
 800cc00: 461e         	moveq	r6, r3
 800cc02: 4637         	mov	r7, r6
 800cc04: 46b9         	mov	r9, r7
 800cc06: f817 0b01    	ldrb	r0, [r7], #1
 800cc0a: bbb0         	cbnz	r0, 0x800cc7a <vfprintf+0x4be> @ imm = #0x6c
 800cc0c: 1bae         	subs	r6, r5, r6
 800cc0e: 44b1         	add	r9, r6
 800cc10: e07b         	b	0x800cd0a <vfprintf+0x54e> @ imm = #0xf6
 800cc12: bb33         	cbnz	r3, 0x800cc62 <vfprintf+0x4a6> @ imm = #0x4c
 800cc14: 232b         	movs	r3, #0x2b
 800cc16: e6f2         	b	0x800c9fe <vfprintf+0x242> @ imm = #-0x21c
 800cc18: bb2b         	cbnz	r3, 0x800cc66 <vfprintf+0x4aa> @ imm = #0x4a
 800cc1a: 232d         	movs	r3, #0x2d
 800cc1c: e6ef         	b	0x800c9fe <vfprintf+0x242> @ imm = #-0x222
 800cc1e: 2220         	movs	r2, #0x20
 800cc20: f1ba 0f04    	cmp.w	r10, #0x4
 800cc24: dd13         	ble	0x800cc4e <vfprintf+0x492> @ imm = #0x26
 800cc26: f01b 0f08    	tst.w	r11, #0x8
 800cc2a: f1aa 0404    	sub.w	r4, r10, #0x4
 800cc2e: d10f         	bne	0x800cc50 <vfprintf+0x494> @ imm = #0x1e
 800cc30: 442c         	add	r4, r5
 800cc32: 9b03         	ldr	r3, [sp, #0xc]
 800cc34: 9204         	str	r2, [sp, #0x10]
 800cc36: 4641         	mov	r1, r8
 800cc38: 2020         	movs	r0, #0x20
 800cc3a: 4798         	blx	r3
 800cc3c: 2800         	cmp	r0, #0x0
 800cc3e: f105 0501    	add.w	r5, r5, #0x1
 800cc42: f6ff add8    	blt.w	0x800c7f6 <vfprintf+0x3a> @ imm = #-0x450
 800cc46: 42a5         	cmp	r5, r4
 800cc48: 9a04         	ldr	r2, [sp, #0x10]
 800cc4a: d1f2         	bne	0x800cc32 <vfprintf+0x476> @ imm = #-0x1c
 800cc4c: b19a         	cbz	r2, 0x800cc76 <vfprintf+0x4ba> @ imm = #0x26
 800cc4e: 2400         	movs	r4, #0x0
 800cc50: 9b03         	ldr	r3, [sp, #0xc]
 800cc52: 4641         	mov	r1, r8
 800cc54: 4610         	mov	r0, r2
 800cc56: 4798         	blx	r3
 800cc58: 2800         	cmp	r0, #0x0
 800cc5a: f105 0501    	add.w	r5, r5, #0x1
 800cc5e: dac8         	bge	0x800cbf2 <vfprintf+0x436> @ imm = #-0x70
 800cc60: e5c9         	b	0x800c7f6 <vfprintf+0x3a> @ imm = #-0x46e
 800cc62: 222b         	movs	r2, #0x2b
 800cc64: e7dc         	b	0x800cc20 <vfprintf+0x464> @ imm = #-0x48
 800cc66: 222d         	movs	r2, #0x2d
 800cc68: e7da         	b	0x800cc20 <vfprintf+0x464> @ imm = #-0x4c
 800cc6a: f01b 0f08    	tst.w	r11, #0x8
 800cc6e: f1aa 0403    	sub.w	r4, r10, #0x3
 800cc72: d1be         	bne	0x800cbf2 <vfprintf+0x436> @ imm = #-0x84
 800cc74: e7dc         	b	0x800cc30 <vfprintf+0x474> @ imm = #-0x48
 800cc76: 4614         	mov	r4, r2
 800cc78: e7bb         	b	0x800cbf2 <vfprintf+0x436> @ imm = #-0x8a
 800cc7a: 9b06         	ldr	r3, [sp, #0x18]
 800cc7c: 1ac0         	subs	r0, r0, r3
 800cc7e: 4641         	mov	r1, r8
 800cc80: 9b03         	ldr	r3, [sp, #0xc]
 800cc82: b2c0         	uxtb	r0, r0
 800cc84: 4798         	blx	r3
 800cc86: 2800         	cmp	r0, #0x0
 800cc88: dabc         	bge	0x800cc04 <vfprintf+0x448> @ imm = #-0x88
 800cc8a: e5b4         	b	0x800c7f6 <vfprintf+0x3a> @ imm = #-0x498
 800cc8c: 9904         	ldr	r1, [sp, #0x10]
 800cc8e: 3901         	subs	r1, #0x1
 800cc90: b2c9         	uxtb	r1, r1
 800cc92: 9104         	str	r1, [sp, #0x10]
 800cc94: e6bd         	b	0x800ca12 <vfprintf+0x256> @ imm = #-0x286
 800cc96: 1e56         	subs	r6, r2, #0x1
 800cc98: e6d4         	b	0x800ca44 <vfprintf+0x288> @ imm = #-0x258
 800cc9a: 2600         	movs	r6, #0x0
 800cc9c: e6d2         	b	0x800ca44 <vfprintf+0x288> @ imm = #-0x25c
 800cc9e: f41b 6f00    	tst.w	r11, #0x800
 800cca2: 9a05         	ldr	r2, [sp, #0x14]
 800cca4: bf0c         	ite	eq
 800cca6: 2403         	moveq	r4, #0x3
 800cca8: 2405         	movne	r4, #0x5
 800ccaa: 4414         	add	r4, r2
 800ccac: e6d2         	b	0x800ca54 <vfprintf+0x298> @ imm = #-0x25c
 800ccae: f01b 0f10    	tst.w	r11, #0x10
 800ccb2: bf18         	it	ne
 800ccb4: 3401         	addne	r4, #0x1
 800ccb6: e6d4         	b	0x800ca62 <vfprintf+0x2a6> @ imm = #-0x258
 800ccb8: 930b         	str	r3, [sp, #0x2c]
 800ccba: 4641         	mov	r1, r8
 800ccbc: 9b03         	ldr	r3, [sp, #0xc]
 800ccbe: 2020         	movs	r0, #0x20
 800ccc0: 4798         	blx	r3
 800ccc2: 2800         	cmp	r0, #0x0
 800ccc4: 9b0b         	ldr	r3, [sp, #0x2c]
 800ccc6: f105 0501    	add.w	r5, r5, #0x1
 800ccca: f6bf aed3    	bge.w	0x800ca74 <vfprintf+0x2b8> @ imm = #-0x25a
 800ccce: e592         	b	0x800c7f6 <vfprintf+0x3a> @ imm = #-0x4dc
 800ccd0: 9b03         	ldr	r3, [sp, #0xc]
 800ccd2: 4641         	mov	r1, r8
 800ccd4: 2030         	movs	r0, #0x30
 800ccd6: 4798         	blx	r3
 800ccd8: 2800         	cmp	r0, #0x0
 800ccda: f105 0501    	add.w	r5, r5, #0x1
 800ccde: f6bf aef2    	bge.w	0x800cac6 <vfprintf+0x30a> @ imm = #-0x21c
 800cce2: e588         	b	0x800c7f6 <vfprintf+0x3a> @ imm = #-0x4f0
 800cce4: 4798         	blx	r3
 800cce6: 2800         	cmp	r0, #0x0
 800cce8: f6ff ad85    	blt.w	0x800c7f6 <vfprintf+0x3a> @ imm = #-0x4f6
 800ccec: f01b 0f10    	tst.w	r11, #0x10
 800ccf0: d00b         	beq	0x800cd0a <vfprintf+0x54e> @ imm = #0x16
 800ccf2: f1ba 3fff    	cmp.w	r10, #0xffffffff
 800ccf6: d108         	bne	0x800cd0a <vfprintf+0x54e> @ imm = #0x10
 800ccf8: f105 0902    	add.w	r9, r5, #0x2
 800ccfc: 4641         	mov	r1, r8
 800ccfe: 202e         	movs	r0, #0x2e
 800cd00: 9b03         	ldr	r3, [sp, #0xc]
 800cd02: 4798         	blx	r3
 800cd04: 2800         	cmp	r0, #0x0
 800cd06: f6ff ad76    	blt.w	0x800c7f6 <vfprintf+0x3a> @ imm = #-0x514
 800cd0a: 464d         	mov	r5, r9
 800cd0c: 444c         	add	r4, r9
 800cd0e: e233         	b	0x800d178 <vfprintf+0x9bc> @ imm = #0x466
 800cd10: f89d 003d    	ldrb.w	r0, [sp, #0x3d]
 800cd14: 9b03         	ldr	r3, [sp, #0xc]
 800cd16: 4641         	mov	r1, r8
 800cd18: 4798         	blx	r3
 800cd1a: 2800         	cmp	r0, #0x0
 800cd1c: f6ff ad6b    	blt.w	0x800c7f6 <vfprintf+0x3a> @ imm = #-0x52a
 800cd20: 2e00         	cmp	r6, #0x0
 800cd22: dd69         	ble	0x800cdf8 <vfprintf+0x63c> @ imm = #0xd2
 800cd24: 9b03         	ldr	r3, [sp, #0xc]
 800cd26: 4641         	mov	r1, r8
 800cd28: 202e         	movs	r0, #0x2e
 800cd2a: 4798         	blx	r3
 800cd2c: 2800         	cmp	r0, #0x0
 800cd2e: f6ff ad62    	blt.w	0x800c7f6 <vfprintf+0x3a> @ imm = #-0x53c
 800cd32: f04f 0a01    	mov.w	r10, #0x1
 800cd36: 9b04         	ldr	r3, [sp, #0x10]
 800cd38: 459a         	cmp	r10, r3
 800cd3a: bfbb         	ittet	lt
 800cd3c: ab0e         	addlt	r3, sp, #0x38
 800cd3e: 4453         	addlt	r3, r10
 800cd40: 2030         	movge	r0, #0x30
 800cd42: 7958         	ldrblt	r0, [r3, #0x5]
 800cd44: 9b03         	ldr	r3, [sp, #0xc]
 800cd46: 4641         	mov	r1, r8
 800cd48: 4798         	blx	r3
 800cd4a: 2800         	cmp	r0, #0x0
 800cd4c: 46d3         	mov	r11, r10
 800cd4e: f6ff ad52    	blt.w	0x800c7f6 <vfprintf+0x3a> @ imm = #-0x55c
 800cd52: f10a 0a01    	add.w	r10, r10, #0x1
 800cd56: 4556         	cmp	r6, r10
 800cd58: daed         	bge	0x800cd36 <vfprintf+0x57a> @ imm = #-0x26
 800cd5a: 3502         	adds	r5, #0x2
 800cd5c: 445d         	add	r5, r11
 800cd5e: 9b06         	ldr	r3, [sp, #0x18]
 800cd60: eba9 0003    	sub.w	r0, r9, r3
 800cd64: 4641         	mov	r1, r8
 800cd66: 9b03         	ldr	r3, [sp, #0xc]
 800cd68: b2c0         	uxtb	r0, r0
 800cd6a: 4798         	blx	r3
 800cd6c: 2800         	cmp	r0, #0x0
 800cd6e: f6ff ad42    	blt.w	0x800c7f6 <vfprintf+0x3a> @ imm = #-0x57c
 800cd72: 2f00         	cmp	r7, #0x0
 800cd74: bfb4         	ite	lt
 800cd76: 202d         	movlt	r0, #0x2d
 800cd78: 202b         	movge	r0, #0x2b
 800cd7a: 9b03         	ldr	r3, [sp, #0xc]
 800cd7c: 4641         	mov	r1, r8
 800cd7e: bfb8         	it	lt
 800cd80: 427f         	rsblt	r7, r7, #0
 800cd82: 4798         	blx	r3
 800cd84: 2800         	cmp	r0, #0x0
 800cd86: f6ff ad36    	blt.w	0x800c7f6 <vfprintf+0x3a> @ imm = #-0x594
 800cd8a: 9b05         	ldr	r3, [sp, #0x14]
 800cd8c: 2b04         	cmp	r3, #0x4
 800cd8e: d141         	bne	0x800ce14 <vfprintf+0x658> @ imm = #0x82
 800cd90: f44f 797a    	mov.w	r9, #0x3e8
 800cd94: fbb7 f6f9    	udiv	r6, r7, r9
 800cd98: f106 0030    	add.w	r0, r6, #0x30
 800cd9c: 9b03         	ldr	r3, [sp, #0xc]
 800cd9e: 4641         	mov	r1, r8
 800cda0: b2c0         	uxtb	r0, r0
 800cda2: 4798         	blx	r3
 800cda4: 2800         	cmp	r0, #0x0
 800cda6: f105 0503    	add.w	r5, r5, #0x3
 800cdaa: f6ff ad24    	blt.w	0x800c7f6 <vfprintf+0x3a> @ imm = #-0x5b8
 800cdae: fb09 7716    	mls	r7, r9, r6, r7
 800cdb2: f04f 0964    	mov.w	r9, #0x64
 800cdb6: fbb7 f6f9    	udiv	r6, r7, r9
 800cdba: f106 0030    	add.w	r0, r6, #0x30
 800cdbe: 9b03         	ldr	r3, [sp, #0xc]
 800cdc0: 4641         	mov	r1, r8
 800cdc2: b2c0         	uxtb	r0, r0
 800cdc4: 4798         	blx	r3
 800cdc6: 2800         	cmp	r0, #0x0
 800cdc8: f105 0501    	add.w	r5, r5, #0x1
 800cdcc: f6ff ad13    	blt.w	0x800c7f6 <vfprintf+0x3a> @ imm = #-0x5da
 800cdd0: fb09 7716    	mls	r7, r9, r6, r7
 800cdd4: f04f 090a    	mov.w	r9, #0xa
 800cdd8: fbb7 f6f9    	udiv	r6, r7, r9
 800cddc: f106 0030    	add.w	r0, r6, #0x30
 800cde0: 9b03         	ldr	r3, [sp, #0xc]
 800cde2: 4641         	mov	r1, r8
 800cde4: b2c0         	uxtb	r0, r0
 800cde6: 4798         	blx	r3
 800cde8: 2800         	cmp	r0, #0x0
 800cdea: f105 0501    	add.w	r5, r5, #0x1
 800cdee: f6ff ad02    	blt.w	0x800c7f6 <vfprintf+0x3a> @ imm = #-0x5fc
 800cdf2: fb09 7716    	mls	r7, r9, r6, r7
 800cdf6: e015         	b	0x800ce24 <vfprintf+0x668> @ imm = #0x2a
 800cdf8: f01b 0f10    	tst.w	r11, #0x10
 800cdfc: d101         	bne	0x800ce02 <vfprintf+0x646> @ imm = #0x2
 800cdfe: 3501         	adds	r5, #0x1
 800ce00: e7ad         	b	0x800cd5e <vfprintf+0x5a2> @ imm = #-0xa6
 800ce02: 9b03         	ldr	r3, [sp, #0xc]
 800ce04: 4641         	mov	r1, r8
 800ce06: 202e         	movs	r0, #0x2e
 800ce08: 4798         	blx	r3
 800ce0a: 2800         	cmp	r0, #0x0
 800ce0c: f105 0502    	add.w	r5, r5, #0x2
 800ce10: daa5         	bge	0x800cd5e <vfprintf+0x5a2> @ imm = #-0xb6
 800ce12: e4f0         	b	0x800c7f6 <vfprintf+0x3a> @ imm = #-0x620
 800ce14: 9b05         	ldr	r3, [sp, #0x14]
 800ce16: 2b03         	cmp	r3, #0x3
 800ce18: f105 0502    	add.w	r5, r5, #0x2
 800ce1c: d0c9         	beq	0x800cdb2 <vfprintf+0x5f6> @ imm = #-0x6e
 800ce1e: 9b05         	ldr	r3, [sp, #0x14]
 800ce20: 2b01         	cmp	r3, #0x1
 800ce22: d1d7         	bne	0x800cdd4 <vfprintf+0x618> @ imm = #-0x52
 800ce24: f107 0030    	add.w	r0, r7, #0x30
 800ce28: f105 0901    	add.w	r9, r5, #0x1
 800ce2c: 4641         	mov	r1, r8
 800ce2e: b2c0         	uxtb	r0, r0
 800ce30: e766         	b	0x800cd00 <vfprintf+0x544> @ imm = #-0x134
 800ce32: f1a7 0363    	sub.w	r3, r7, #0x63
 800ce36: 2b12         	cmp	r3, #0x12
 800ce38: f200 80ff    	bhi.w	0x800d03a <vfprintf+0x87e> @ imm = #0x1fe
 800ce3c: e8df f013    	tbh	[pc, r3, lsl #1]

0800ce40 <$d>:
 800ce40: 13 00 57 00  	.word	0x00570013
 800ce44: fd 00 fd 00  	.word	0x00fd00fd
 800ce48: fd 00 fd 00  	.word	0x00fd00fd
 800ce4c: 57 00 fd 00  	.word	0x00fd0057
 800ce50: fd 00 fd 00  	.word	0x00fd00fd
 800ce54: fd 00 fd 00  	.word	0x00fd00fd
 800ce58: 17 01 f8 00  	.word	0x00f80117
 800ce5c: fd 00 fd 00  	.word	0x00fd00fd
 800ce60: 2c 00 fd 00  	.word	0x00fd002c
 800ce64: b9 00        	.short	0x00b9

0800ce66 <$t>:
 800ce66: 9b0d         	ldr	r3, [sp, #0x34]
 800ce68: 1d1a         	adds	r2, r3, #0x4
 800ce6a: 681b         	ldr	r3, [r3]
 800ce6c: 920d         	str	r2, [sp, #0x34]
 800ce6e: f88d 3038    	strb.w	r3, [sp, #0x38]
 800ce72: 2401         	movs	r4, #0x1
 800ce74: af0e         	add	r7, sp, #0x38
 800ce76: f01b 0f08    	tst.w	r11, #0x8
 800ce7a: d02e         	beq	0x800ceda <vfprintf+0x71e> @ imm = #0x5c
 800ce7c: 193e         	adds	r6, r7, r4
 800ce7e: 46b9         	mov	r9, r7
 800ce80: 45b1         	cmp	r9, r6
 800ce82: d12c         	bne	0x800cede <vfprintf+0x722> @ imm = #0x58
 800ce84: 1bef         	subs	r7, r5, r7
 800ce86: 44b9         	add	r9, r7
 800ce88: ebaa 0404    	sub.w	r4, r10, r4
 800ce8c: e73d         	b	0x800cd0a <vfprintf+0x54e> @ imm = #-0x186
 800ce8e: bf00         	nop

0800ce90 <$d>:
 800ce90: b9 69 01 08  	.word	0x080169b9
 800ce94: b5 69 01 08  	.word	0x080169b5

0800ce98 <$t>:
 800ce98: 9b0d         	ldr	r3, [sp, #0x34]
 800ce9a: 1d1a         	adds	r2, r3, #0x4
 800ce9c: 920d         	str	r2, [sp, #0x34]
 800ce9e: 681f         	ldr	r7, [r3]
 800cea0: 4bab         	ldr	r3, [pc, #0x2ac]        @ 0x800d150 <vfprintf+0x994>
 800cea2: 2f00         	cmp	r7, #0x0
 800cea4: bf08         	it	eq
 800cea6: 461f         	moveq	r7, r3
 800cea8: f01b 0f40    	tst.w	r11, #0x40
 800ceac: bf14         	ite	ne
 800ceae: 4631         	movne	r1, r6
 800ceb0: f04f 31ff    	moveq.w	r1, #0xffffffff
 800ceb4: 4638         	mov	r0, r7
 800ceb6: f007 f949    	bl	0x801414c <strnlen>     @ imm = #0x7292
 800ceba: 4604         	mov	r4, r0
 800cebc: e7db         	b	0x800ce76 <vfprintf+0x6ba> @ imm = #-0x4a
 800cebe: 9b03         	ldr	r3, [sp, #0xc]
 800cec0: 4641         	mov	r1, r8
 800cec2: 2020         	movs	r0, #0x20
 800cec4: 4798         	blx	r3
 800cec6: 2800         	cmp	r0, #0x0
 800cec8: f6ff ac95    	blt.w	0x800c7f6 <vfprintf+0x3a> @ imm = #-0x6d6
 800cecc: 3e01         	subs	r6, #0x1
 800cece: 42b4         	cmp	r4, r6
 800ced0: d3f5         	blo	0x800cebe <vfprintf+0x702> @ imm = #-0x16
 800ced2: 4455         	add	r5, r10
 800ced4: 1bad         	subs	r5, r5, r6
 800ced6: 46b2         	mov	r10, r6
 800ced8: e7d0         	b	0x800ce7c <vfprintf+0x6c0> @ imm = #-0x60
 800ceda: 4656         	mov	r6, r10
 800cedc: e7f7         	b	0x800cece <vfprintf+0x712> @ imm = #-0x12
 800cede: f819 0b01    	ldrb	r0, [r9], #1
 800cee2: 9b03         	ldr	r3, [sp, #0xc]
 800cee4: 4641         	mov	r1, r8
 800cee6: 4798         	blx	r3
 800cee8: 2800         	cmp	r0, #0x0
 800ceea: dac9         	bge	0x800ce80 <vfprintf+0x6c4> @ imm = #-0x6e
 800ceec: e483         	b	0x800c7f6 <vfprintf+0x3a> @ imm = #-0x6fa
 800ceee: f01b 0f80    	tst.w	r11, #0x80
 800cef2: 9b0d         	ldr	r3, [sp, #0x34]
 800cef4: d035         	beq	0x800cf62 <vfprintf+0x7a6> @ imm = #0x6a
 800cef6: f41b 7f00    	tst.w	r11, #0x200
 800cefa: d02d         	beq	0x800cf58 <vfprintf+0x79c> @ imm = #0x5a
 800cefc: 3307         	adds	r3, #0x7
 800cefe: f023 0307    	bic	r3, r3, #0x7
 800cf02: e9d3 0100    	ldrd	r0, r1, [r3]
 800cf06: f103 0208    	add.w	r2, r3, #0x8
 800cf0a: 920d         	str	r2, [sp, #0x34]
 800cf0c: f02b 0910    	bic	r9, r11, #0x10
 800cf10: 2900         	cmp	r1, #0x0
 800cf12: fa1f f989    	uxth.w	r9, r9
 800cf16: da36         	bge	0x800cf86 <vfprintf+0x7ca> @ imm = #0x6c
 800cf18: 4240         	rsbs	r0, r0, #0
 800cf1a: eb61 0141    	sbc.w	r1, r1, r1, lsl #1
 800cf1e: f449 6980    	orr	r9, r9, #0x400
 800cf22: f10d 0b38    	add.w	r11, sp, #0x38
 800cf26: 230a         	movs	r3, #0xa
 800cf28: 465a         	mov	r2, r11
 800cf2a: f007 f91b    	bl	0x8014164 <__ultoa_invert> @ imm = #0x7236
 800cf2e: f019 0f40    	tst.w	r9, #0x40
 800cf32: eba0 0b0b    	sub.w	r11, r0, r11
 800cf36: d065         	beq	0x800d004 <vfprintf+0x848> @ imm = #0xca
 800cf38: f029 0201    	bic	r2, r9, #0x1
 800cf3c: 455e         	cmp	r6, r11
 800cf3e: b292         	uxth	r2, r2
 800cf40: f340 80b2    	ble.w	0x800d0a8 <vfprintf+0x8ec> @ imm = #0x164
 800cf44: 2f00         	cmp	r7, #0x0
 800cf46: f000 80a9    	beq.w	0x800d09c <vfprintf+0x8e0> @ imm = #0x152
 800cf4a: f019 0310    	ands	r3, r9, #0x10
 800cf4e: 4634         	mov	r4, r6
 800cf50: 4691         	mov	r9, r2
 800cf52: d026         	beq	0x800cfa2 <vfprintf+0x7e6> @ imm = #0x4c
 800cf54: 3402         	adds	r4, #0x2
 800cf56: e05c         	b	0x800d012 <vfprintf+0x856> @ imm = #0xb8
 800cf58: 1d1a         	adds	r2, r3, #0x4
 800cf5a: 6818         	ldr	r0, [r3]
 800cf5c: 920d         	str	r2, [sp, #0x34]
 800cf5e: 17c1         	asrs	r1, r0, #0x1f
 800cf60: e7d4         	b	0x800cf0c <vfprintf+0x750> @ imm = #-0x58
 800cf62: 1d1a         	adds	r2, r3, #0x4
 800cf64: f41b 7f80    	tst.w	r11, #0x100
 800cf68: 6819         	ldr	r1, [r3]
 800cf6a: 920d         	str	r2, [sp, #0x34]
 800cf6c: d101         	bne	0x800cf72 <vfprintf+0x7b6> @ imm = #0x2
 800cf6e: 4608         	mov	r0, r1
 800cf70: e7f5         	b	0x800cf5e <vfprintf+0x7a2> @ imm = #-0x16
 800cf72: f41b 7f00    	tst.w	r11, #0x200
 800cf76: bf15         	itete	ne
 800cf78: b248         	sxtbne	r0, r1
 800cf7a: b208         	sxtheq	r0, r1
 800cf7c: f341 11c0    	sbfxne	r1, r1, #0x7, #0x1
 800cf80: f341 31c0    	sbfxeq	r1, r1, #0xf, #0x1
 800cf84: e7c2         	b	0x800cf0c <vfprintf+0x750> @ imm = #-0x7c
 800cf86: ea50 0301    	orrs.w	r3, r0, r1
 800cf8a: d1ca         	bne	0x800cf22 <vfprintf+0x766> @ imm = #-0x6c
 800cf8c: f01b 0f40    	tst.w	r11, #0x40
 800cf90: d0c7         	beq	0x800cf22 <vfprintf+0x766> @ imm = #-0x72
 800cf92: 2e00         	cmp	r6, #0x0
 800cf94: d1c5         	bne	0x800cf22 <vfprintf+0x766> @ imm = #-0x76
 800cf96: f02b 0b11    	bic	r11, r11, #0x11
 800cf9a: fa1f f98b    	uxth.w	r9, r11
 800cf9e: 4634         	mov	r4, r6
 800cfa0: 46b3         	mov	r11, r6
 800cfa2: f240 4306    	movw	r3, #0x406
 800cfa6: ea19 0303    	ands.w	r3, r9, r3
 800cfaa: bf1c         	itt	ne
 800cfac: 3401         	addne	r4, #0x1
 800cfae: 2300         	movne	r3, #0x0
 800cfb0: e02f         	b	0x800d012 <vfprintf+0x856> @ imm = #0x5e
 800cfb2: f02b 0b10    	bic	r11, r11, #0x10
 800cfb6: fa1f fb8b    	uxth.w	r11, r11
 800cfba: 230a         	movs	r3, #0xa
 800cfbc: f01b 0480    	ands	r4, r11, #0x80
 800cfc0: 9a0d         	ldr	r2, [sp, #0x34]
 800cfc2: d057         	beq	0x800d074 <vfprintf+0x8b8> @ imm = #0xae
 800cfc4: f41b 7100    	ands	r1, r11, #0x200
 800cfc8: bf1d         	ittte	ne
 800cfca: 3207         	addne	r2, #0x7
 800cfcc: f022 0207    	bicne	r2, r2, #0x7
 800cfd0: f102 0108    	addne.w	r1, r2, #0x8
 800cfd4: 1d10         	addeq	r0, r2, #0x4
 800cfd6: bf19         	ittee	ne
 800cfd8: 910d         	strne	r1, [sp, #0x34]
 800cfda: e9d2 0100    	ldrdne	r0, r1, [r2]
 800cfde: 900d         	streq	r0, [sp, #0x34]
 800cfe0: 6810         	ldreq	r0, [r2]
 800cfe2: ea50 0201    	orrs.w	r2, r0, r1
 800cfe6: d152         	bne	0x800d08e <vfprintf+0x8d2> @ imm = #0xa4
 800cfe8: f02b 0916    	bic	r9, r11, #0x16
 800cfec: f01b 0f40    	tst.w	r11, #0x40
 800cff0: fa1f f989    	uxth.w	r9, r9
 800cff4: d04f         	beq	0x800d096 <vfprintf+0x8da> @ imm = #0x9e
 800cff6: 2e00         	cmp	r6, #0x0
 800cff8: d14d         	bne	0x800d096 <vfprintf+0x8da> @ imm = #0x9a
 800cffa: f02b 0b17    	bic	r11, r11, #0x17
 800cffe: fa1f f98b    	uxth.w	r9, r11
 800d002: 46b3         	mov	r11, r6
 800d004: f019 0310    	ands	r3, r9, #0x10
 800d008: d052         	beq	0x800d0b0 <vfprintf+0x8f4> @ imm = #0xa4
 800d00a: 2f00         	cmp	r7, #0x0
 800d00c: d14e         	bne	0x800d0ac <vfprintf+0x8f0> @ imm = #0x9c
 800d00e: f10b 0401    	add.w	r4, r11, #0x1
 800d012: f019 0f08    	tst.w	r9, #0x8
 800d016: d15e         	bne	0x800d0d6 <vfprintf+0x91a> @ imm = #0xbc
 800d018: f019 0f01    	tst.w	r9, #0x1
 800d01c: d006         	beq	0x800d02c <vfprintf+0x870> @ imm = #0xc
 800d01e: 45a2         	cmp	r10, r4
 800d020: dd6e         	ble	0x800d100 <vfprintf+0x944> @ imm = #0xdc
 800d022: ebaa 0404    	sub.w	r4, r10, r4
 800d026: eb04 060b    	add.w	r6, r4, r11
 800d02a: 4654         	mov	r4, r10
 800d02c: 4622         	mov	r2, r4
 800d02e: e04d         	b	0x800d0cc <vfprintf+0x910> @ imm = #0x9a
 800d030: f04b 0b10    	orr	r11, r11, #0x10
 800d034: 2310         	movs	r3, #0x10
 800d036: 2778         	movs	r7, #0x78
 800d038: e7c0         	b	0x800cfbc <vfprintf+0x800> @ imm = #-0x80
 800d03a: f1b9 0f78    	cmp.w	r9, #0x78
 800d03e: d104         	bne	0x800d04a <vfprintf+0x88e> @ imm = #0x8
 800d040: f1c7 0378    	rsb.w	r3, r7, #0x78
 800d044: f043 0310    	orr	r3, r3, #0x10
 800d048: e7b8         	b	0x800cfbc <vfprintf+0x800> @ imm = #-0x90
 800d04a: 9b03         	ldr	r3, [sp, #0xc]
 800d04c: 4641         	mov	r1, r8
 800d04e: 2025         	movs	r0, #0x25
 800d050: 4798         	blx	r3
 800d052: 2800         	cmp	r0, #0x0
 800d054: f6ff abcf    	blt.w	0x800c7f6 <vfprintf+0x3a> @ imm = #-0x862
 800d058: 9b03         	ldr	r3, [sp, #0xc]
 800d05a: 4641         	mov	r1, r8
 800d05c: 4638         	mov	r0, r7
 800d05e: 4798         	blx	r3
 800d060: 2800         	cmp	r0, #0x0
 800d062: f6ff abc8    	blt.w	0x800c7f6 <vfprintf+0x3a> @ imm = #-0x870
 800d066: 3502         	adds	r5, #0x2
 800d068: 9b07         	ldr	r3, [sp, #0x1c]
 800d06a: f7ff bbb5    	b.w	0x800c7d8 <vfprintf+0x1c> @ imm = #-0x896
 800d06e: 2308         	movs	r3, #0x8
 800d070: 2700         	movs	r7, #0x0
 800d072: e7a3         	b	0x800cfbc <vfprintf+0x800> @ imm = #-0xba
 800d074: 1d11         	adds	r1, r2, #0x4
 800d076: 910d         	str	r1, [sp, #0x34]
 800d078: f41b 7180    	ands	r1, r11, #0x100
 800d07c: 6810         	ldr	r0, [r2]
 800d07e: d0b0         	beq	0x800cfe2 <vfprintf+0x826> @ imm = #-0xa0
 800d080: f41b 7100    	ands	r1, r11, #0x200
 800d084: bf1a         	itte	ne
 800d086: b2c0         	uxtbne	r0, r0
 800d088: 4621         	movne	r1, r4
 800d08a: b280         	uxtheq	r0, r0
 800d08c: e7a9         	b	0x800cfe2 <vfprintf+0x826> @ imm = #-0xae
 800d08e: f02b 0b06    	bic	r11, r11, #0x6
 800d092: fa1f f98b    	uxth.w	r9, r11
 800d096: f10d 0b38    	add.w	r11, sp, #0x38
 800d09a: e745         	b	0x800cf28 <vfprintf+0x76c> @ imm = #-0x176
 800d09c: f029 0911    	bic	r9, r9, #0x11
 800d0a0: fa1f f989    	uxth.w	r9, r9
 800d0a4: 4634         	mov	r4, r6
 800d0a6: e77c         	b	0x800cfa2 <vfprintf+0x7e6> @ imm = #-0x108
 800d0a8: 4691         	mov	r9, r2
 800d0aa: e7ab         	b	0x800d004 <vfprintf+0x848> @ imm = #-0xaa
 800d0ac: 465c         	mov	r4, r11
 800d0ae: e751         	b	0x800cf54 <vfprintf+0x798> @ imm = #-0x15e
 800d0b0: 465c         	mov	r4, r11
 800d0b2: e776         	b	0x800cfa2 <vfprintf+0x7e6> @ imm = #-0x114
 800d0b4: e9cd 2304    	strd	r2, r3, [sp, #16]
 800d0b8: 4641         	mov	r1, r8
 800d0ba: 9b03         	ldr	r3, [sp, #0xc]
 800d0bc: 2020         	movs	r0, #0x20
 800d0be: 4798         	blx	r3
 800d0c0: 2800         	cmp	r0, #0x0
 800d0c2: f6ff ab98    	blt.w	0x800c7f6 <vfprintf+0x3a> @ imm = #-0x8d0
 800d0c6: 9a04         	ldr	r2, [sp, #0x10]
 800d0c8: 9b05         	ldr	r3, [sp, #0x14]
 800d0ca: 3201         	adds	r2, #0x1
 800d0cc: 4592         	cmp	r10, r2
 800d0ce: dcf1         	bgt	0x800d0b4 <vfprintf+0x8f8> @ imm = #-0x1e
 800d0d0: 1b2c         	subs	r4, r5, r4
 800d0d2: 18a5         	adds	r5, r4, r2
 800d0d4: 4614         	mov	r4, r2
 800d0d6: b1f3         	cbz	r3, 0x800d116 <vfprintf+0x95a> @ imm = #0x3c
 800d0d8: 9b03         	ldr	r3, [sp, #0xc]
 800d0da: 4641         	mov	r1, r8
 800d0dc: 2030         	movs	r0, #0x30
 800d0de: 4798         	blx	r3
 800d0e0: 2800         	cmp	r0, #0x0
 800d0e2: f6ff ab88    	blt.w	0x800c7f6 <vfprintf+0x3a> @ imm = #-0x8f0
 800d0e6: b96f         	cbnz	r7, 0x800d104 <vfprintf+0x948> @ imm = #0x1a
 800d0e8: 3501         	adds	r5, #0x1
 800d0ea: 46a9         	mov	r9, r5
 800d0ec: 442e         	add	r6, r5
 800d0ee: eba6 0309    	sub.w	r3, r6, r9
 800d0f2: 455b         	cmp	r3, r11
 800d0f4: dc21         	bgt	0x800d13a <vfprintf+0x97e> @ imm = #0x42
 800d0f6: 465d         	mov	r5, r11
 800d0f8: ae0e         	add	r6, sp, #0x38
 800d0fa: bb5d         	cbnz	r5, 0x800d154 <vfprintf+0x998> @ imm = #0x56
 800d0fc: 44d9         	add	r9, r11
 800d0fe: e6c3         	b	0x800ce88 <vfprintf+0x6cc> @ imm = #-0x27a
 800d100: 465e         	mov	r6, r11
 800d102: e793         	b	0x800d02c <vfprintf+0x870> @ imm = #-0xda
 800d104: 3502         	adds	r5, #0x2
 800d106: 4641         	mov	r1, r8
 800d108: 4638         	mov	r0, r7
 800d10a: 9b03         	ldr	r3, [sp, #0xc]
 800d10c: 4798         	blx	r3
 800d10e: 2800         	cmp	r0, #0x0
 800d110: daeb         	bge	0x800d0ea <vfprintf+0x92e> @ imm = #-0x2a
 800d112: f7ff bb70    	b.w	0x800c7f6 <vfprintf+0x3a> @ imm = #-0x920
 800d116: f240 4306    	movw	r3, #0x406
 800d11a: ea19 0f03    	tst.w	r9, r3
 800d11e: d0e4         	beq	0x800d0ea <vfprintf+0x92e> @ imm = #-0x38
 800d120: f019 0f02    	tst.w	r9, #0x2
 800d124: bf14         	ite	ne
 800d126: 202b         	movne	r0, #0x2b
 800d128: 2020         	moveq	r0, #0x20
 800d12a: f419 6f80    	tst.w	r9, #0x400
 800d12e: f105 0501    	add.w	r5, r5, #0x1
 800d132: 4641         	mov	r1, r8
 800d134: bf18         	it	ne
 800d136: 202d         	movne	r0, #0x2d
 800d138: e7e7         	b	0x800d10a <vfprintf+0x94e> @ imm = #-0x32
 800d13a: 9b03         	ldr	r3, [sp, #0xc]
 800d13c: 4641         	mov	r1, r8
 800d13e: 2030         	movs	r0, #0x30
 800d140: 4798         	blx	r3
 800d142: 2800         	cmp	r0, #0x0
 800d144: f109 0901    	add.w	r9, r9, #0x1
 800d148: dad1         	bge	0x800d0ee <vfprintf+0x932> @ imm = #-0x5e
 800d14a: f7ff bb54    	b.w	0x800c7f6 <vfprintf+0x3a> @ imm = #-0x958
 800d14e: bf00         	nop

0800d150 <$d>:
 800d150: bd 69 01 08  	.word	0x080169bd

0800d154 <$t>:
 800d154: 3d01         	subs	r5, #0x1
 800d156: 9b03         	ldr	r3, [sp, #0xc]
 800d158: 5d70         	ldrb	r0, [r6, r5]
 800d15a: 4641         	mov	r1, r8
 800d15c: 4798         	blx	r3
 800d15e: 2800         	cmp	r0, #0x0
 800d160: dacb         	bge	0x800d0fa <vfprintf+0x93e> @ imm = #-0x6a
 800d162: f7ff bb48    	b.w	0x800c7f6 <vfprintf+0x3a> @ imm = #-0x970
 800d166: 9b03         	ldr	r3, [sp, #0xc]
 800d168: 4641         	mov	r1, r8
 800d16a: 2020         	movs	r0, #0x20
 800d16c: 4798         	blx	r3
 800d16e: 2800         	cmp	r0, #0x0
 800d170: f105 0501    	add.w	r5, r5, #0x1
 800d174: f6ff ab3f    	blt.w	0x800c7f6 <vfprintf+0x3a> @ imm = #-0x982
 800d178: 1b63         	subs	r3, r4, r5
 800d17a: 2b00         	cmp	r3, #0x0
 800d17c: dcf3         	bgt	0x800d166 <vfprintf+0x9aa> @ imm = #-0x1a
 800d17e: e773         	b	0x800d068 <vfprintf+0x8ac> @ imm = #-0x11a

0800d180 <div10>:
 800d180: b51f         	push	{r0, r1, r2, r3, r4, lr}
 800d182: ab02         	add	r3, sp, #0x8
 800d184: 9300         	str	r3, [sp]
 800d186: 4a07         	ldr	r2, [pc, #0x1c]         @ 0x800d1a4 <div10+0x24>
 800d188: f04f 33cc    	mov.w	r3, #0xcccccccc
 800d18c: f007 f8cd    	bl	0x801432a <__umul128>   @ imm = #0x719a
 800d190: e9dd 0102    	ldrd	r0, r1, [sp, #8]
 800d194: 08c0         	lsrs	r0, r0, #0x3
 800d196: ea40 7041    	orr.w	r0, r0, r1, lsl #29
 800d19a: 08c9         	lsrs	r1, r1, #0x3
 800d19c: b005         	add	sp, #0x14
 800d19e: f85d fb04    	ldr	pc, [sp], #4
 800d1a2: bf00         	nop

0800d1a4 <$d>:
 800d1a4: cd cc cc cc  	.word	0xcccccccd

0800d1a8 <__dtoa_engine>:
 800d1a8: e92d 4ff0    	push.w	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
 800d1ac: b09b         	sub	sp, #0x6c
 800d1ae: 4604         	mov	r4, r0
 800d1b0: 9205         	str	r2, [sp, #0x14]
 800d1b2: 460a         	mov	r2, r1
 800d1b4: 930a         	str	r3, [sp, #0x28]
 800d1b6: f3c2 550a    	ubfx	r5, r2, #0x14, #0xb
 800d1ba: f89d 3090    	ldrb.w	r3, [sp, #0x90]
 800d1be: 930b         	str	r3, [sp, #0x2c]
 800d1c0: 0fd2         	lsrs	r2, r2, #0x1f
 800d1c2: f3c1 0313    	ubfx	r3, r1, #0x0, #0x14
 800d1c6: 9209         	str	r2, [sp, #0x24]
 800d1c8: 0d09         	lsrs	r1, r1, #0x14
 800d1ca: b97d         	cbnz	r5, 0x800d1ec <__dtoa_engine+0x44> @ imm = #0x1e
 800d1cc: ea50 0203    	orrs.w	r2, r0, r3
 800d1d0: d11b         	bne	0x800d20a <__dtoa_engine+0x62> @ imm = #0x36
 800d1d2: 9a05         	ldr	r2, [sp, #0x14]
 800d1d4: 2330         	movs	r3, #0x30
 800d1d6: 7153         	strb	r3, [r2, #0x5]
 800d1d8: 9b09         	ldr	r3, [sp, #0x24]
 800d1da: 6015         	str	r5, [r2]
 800d1dc: f043 0302    	orr	r3, r3, #0x2
 800d1e0: 7113         	strb	r3, [r2, #0x4]
 800d1e2: 2701         	movs	r7, #0x1
 800d1e4: 4638         	mov	r0, r7
 800d1e6: b01b         	add	sp, #0x6c
 800d1e8: e8bd 8ff0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, r11, pc}
 800d1ec: f240 72ff    	movw	r2, #0x7ff
 800d1f0: 4295         	cmp	r5, r2
 800d1f2: d14a         	bne	0x800d28a <__dtoa_engine+0xe2> @ imm = #0x94
 800d1f4: 4303         	orrs	r3, r0
 800d1f6: 9b09         	ldr	r3, [sp, #0x24]
 800d1f8: 9a05         	ldr	r2, [sp, #0x14]
 800d1fa: bf14         	ite	ne
 800d1fc: f043 0308    	orrne	r3, r3, #0x8
 800d200: f043 0304    	orreq	r3, r3, #0x4
 800d204: 7113         	strb	r3, [r2, #0x4]
 800d206: 2700         	movs	r7, #0x0
 800d208: e7ec         	b	0x800d1e4 <__dtoa_engine+0x3c> @ imm = #-0x28
 800d20a: f000 0201    	and	r2, r0, #0x1
 800d20e: 9208         	str	r2, [sp, #0x20]
 800d210: ea4f 0883    	lsl.w	r8, r3, #0x2
 800d214: 2201         	movs	r2, #0x1
 800d216: 4dac         	ldr	r5, [pc, #0x2b0]        @ 0x800d4c8 <__dtoa_engine+0x320>
 800d218: ea48 7890    	orr.w	r8, r8, r0, lsr #30
 800d21c: 0087         	lsls	r7, r0, #0x2
 800d21e: 469a         	mov	r10, r3
 800d220: 4616         	mov	r6, r2
 800d222: f1c5 0b00    	rsb.w	r11, r5, #0x0
 800d226: 4658         	mov	r0, r11
 800d228: 9206         	str	r2, [sp, #0x18]
 800d22a: f000 fa11    	bl	0x800d650 <__log10Pow5> @ imm = #0x422
 800d22e: f1b5 3fff    	cmp.w	r5, #0xffffffff
 800d232: bfac         	ite	ge
 800d234: 4681         	movge	r9, r0
 800d236: f1a0 0901    	sublt.w	r9, r0, #0x1
 800d23a: ebab 0b09    	sub.w	r11, r11, r9
 800d23e: eb09 0305    	add.w	r3, r9, r5
 800d242: 4658         	mov	r0, r11
 800d244: 9304         	str	r3, [sp, #0x10]
 800d246: f000 fa09    	bl	0x800d65c <__pow5bits>  @ imm = #0x412
 800d24a: a916         	add	r1, sp, #0x58
 800d24c: f1a0 057d    	sub.w	r5, r0, #0x7d
 800d250: 4658         	mov	r0, r11
 800d252: f000 fa23    	bl	0x800d69c <__double_computePow5> @ imm = #0x446
 800d256: ab12         	add	r3, sp, #0x48
 800d258: 9a06         	ldr	r2, [sp, #0x18]
 800d25a: 9301         	str	r3, [sp, #0x4]
 800d25c: eba9 0505    	sub.w	r5, r9, r5
 800d260: ab10         	add	r3, sp, #0x40
 800d262: 9202         	str	r2, [sp, #0x8]
 800d264: 9300         	str	r3, [sp]
 800d266: 4620         	mov	r0, r4
 800d268: 462b         	mov	r3, r5
 800d26a: aa16         	add	r2, sp, #0x58
 800d26c: 4651         	mov	r1, r10
 800d26e: f006 ffa1    	bl	0x80141b4 <mulShiftAll64> @ imm = #0x6f42
 800d272: f1b9 0f01    	cmp.w	r9, #0x1
 800d276: 4604         	mov	r4, r0
 800d278: 460d         	mov	r5, r1
 800d27a: f200 80d2    	bhi.w	0x800d422 <__dtoa_engine+0x27a> @ imm = #0x1a4
 800d27e: 9b08         	ldr	r3, [sp, #0x20]
 800d280: 2b00         	cmp	r3, #0x0
 800d282: f040 80c5    	bne.w	0x800d410 <__dtoa_engine+0x268> @ imm = #0x18a
 800d286: 2701         	movs	r7, #0x1
 800d288: e06b         	b	0x800d362 <__dtoa_engine+0x1ba> @ imm = #0xd6
 800d28a: f443 1a80    	orr	r10, r3, #0x100000
 800d28e: f000 0201    	and	r2, r0, #0x1
 800d292: ea4f 088a    	lsl.w	r8, r10, #0x2
 800d296: 4303         	orrs	r3, r0
 800d298: f2a5 4535    	subw	r5, r5, #0x435
 800d29c: 9208         	str	r2, [sp, #0x20]
 800d29e: ea48 7890    	orr.w	r8, r8, r0, lsr #30
 800d2a2: ea4f 0780    	lsl.w	r7, r0, #0x2
 800d2a6: d149         	bne	0x800d33c <__dtoa_engine+0x194> @ imm = #0x92
 800d2a8: f240 73fe    	movw	r3, #0x7fe
 800d2ac: 4219         	tst	r1, r3
 800d2ae: bf0c         	ite	eq
 800d2b0: 2601         	moveq	r6, #0x1
 800d2b2: 2600         	movne	r6, #0x0
 800d2b4: 2d00         	cmp	r5, #0x0
 800d2b6: 4632         	mov	r2, r6
 800d2b8: dbb3         	blt	0x800d222 <__dtoa_engine+0x7a> @ imm = #-0x9a
 800d2ba: 4628         	mov	r0, r5
 800d2bc: f000 f9c2    	bl	0x800d644 <__log10Pow2> @ imm = #0x384
 800d2c0: 2d03         	cmp	r5, #0x3
 800d2c2: bfc8         	it	gt
 800d2c4: 3801         	subgt	r0, #0x1
 800d2c6: 9004         	str	r0, [sp, #0x10]
 800d2c8: f000 f9c8    	bl	0x800d65c <__pow5bits>  @ imm = #0x390
 800d2cc: 9b04         	ldr	r3, [sp, #0x10]
 800d2ce: 307c         	adds	r0, #0x7c
 800d2d0: 1b5d         	subs	r5, r3, r5
 800d2d2: 4405         	add	r5, r0
 800d2d4: a916         	add	r1, sp, #0x58
 800d2d6: 4618         	mov	r0, r3
 800d2d8: f000 fa54    	bl	0x800d784 <__double_computeInvPow5> @ imm = #0x4a8
 800d2dc: ab12         	add	r3, sp, #0x48
 800d2de: 9301         	str	r3, [sp, #0x4]
 800d2e0: ab10         	add	r3, sp, #0x40
 800d2e2: 9300         	str	r3, [sp]
 800d2e4: 4620         	mov	r0, r4
 800d2e6: 462b         	mov	r3, r5
 800d2e8: 9602         	str	r6, [sp, #0x8]
 800d2ea: aa16         	add	r2, sp, #0x58
 800d2ec: 4651         	mov	r1, r10
 800d2ee: f006 ff61    	bl	0x80141b4 <mulShiftAll64> @ imm = #0x6ec2
 800d2f2: 9b04         	ldr	r3, [sp, #0x10]
 800d2f4: 2b15         	cmp	r3, #0x15
 800d2f6: 4604         	mov	r4, r0
 800d2f8: 460d         	mov	r5, r1
 800d2fa: f200 8086    	bhi.w	0x800d40a <__dtoa_engine+0x262> @ imm = #0x10c
 800d2fe: ab14         	add	r3, sp, #0x50
 800d300: 4a72         	ldr	r2, [pc, #0x1c8]        @ 0x800d4cc <__dtoa_engine+0x324>
 800d302: 9300         	str	r3, [sp]
 800d304: 4638         	mov	r0, r7
 800d306: f04f 33cc    	mov.w	r3, #0xcccccccc
 800d30a: 4641         	mov	r1, r8
 800d30c: f007 f80d    	bl	0x801432a <__umul128>   @ imm = #0x701a
 800d310: 9b14         	ldr	r3, [sp, #0x50]
 800d312: 9a15         	ldr	r2, [sp, #0x54]
 800d314: 089b         	lsrs	r3, r3, #0x2
 800d316: ea43 7382    	orr.w	r3, r3, r2, lsl #30
 800d31a: eb03 0383    	add.w	r3, r3, r3, lsl #2
 800d31e: 42bb         	cmp	r3, r7
 800d320: e9dd 9a10    	ldrd	r9, r10, [sp, #64]
 800d324: d10c         	bne	0x800d340 <__dtoa_engine+0x198> @ imm = #0x18
 800d326: 4638         	mov	r0, r7
 800d328: 4641         	mov	r1, r8
 800d32a: f000 f99f    	bl	0x800d66c <__pow5Factor> @ imm = #0x33e
 800d32e: 9b04         	ldr	r3, [sp, #0x10]
 800d330: 4283         	cmp	r3, r0
 800d332: bf8c         	ite	hi
 800d334: 2700         	movhi	r7, #0x0
 800d336: 2701         	movls	r7, #0x1
 800d338: 2600         	movs	r6, #0x0
 800d33a: e012         	b	0x800d362 <__dtoa_engine+0x1ba> @ imm = #0x24
 800d33c: 2601         	movs	r6, #0x1
 800d33e: e7b9         	b	0x800d2b4 <__dtoa_engine+0x10c> @ imm = #-0x8e
 800d340: 9b08         	ldr	r3, [sp, #0x20]
 800d342: 2b00         	cmp	r3, #0x0
 800d344: d151         	bne	0x800d3ea <__dtoa_engine+0x242> @ imm = #0xa2
 800d346: 3f01         	subs	r7, #0x1
 800d348: f148 31ff    	adc	r1, r8, #0xffffffff
 800d34c: 1bb8         	subs	r0, r7, r6
 800d34e: f161 0100    	sbc	r1, r1, #0x0
 800d352: f000 f98b    	bl	0x800d66c <__pow5Factor> @ imm = #0x316
 800d356: 9b04         	ldr	r3, [sp, #0x10]
 800d358: 9f08         	ldr	r7, [sp, #0x20]
 800d35a: 4283         	cmp	r3, r0
 800d35c: bf8c         	ite	hi
 800d35e: 2600         	movhi	r6, #0x0
 800d360: 2601         	movls	r6, #0x1
 800d362: 9b0b         	ldr	r3, [sp, #0x2c]
 800d364: 2b00         	cmp	r3, #0x0
 800d366: f040 8091    	bne.w	0x800d48c <__dtoa_engine+0x2e4> @ imm = #0x122
 800d36a: f8dd b028    	ldr.w	r11, [sp, #0x28]
 800d36e: f04f 0800    	mov.w	r8, #0x0
 800d372: e9cd 8806    	strd	r8, r8, [sp, #24]
 800d376: f04f 0a0a    	mov.w	r10, #0xa
 800d37a: e9dd 0110    	ldrd	r0, r1, [sp, #64]
 800d37e: f7ff feff    	bl	0x800d180 <div10>       @ imm = #-0x202
 800d382: 9b12         	ldr	r3, [sp, #0x48]
 800d384: 930e         	str	r3, [sp, #0x38]
 800d386: e9cd 010c    	strd	r0, r1, [sp, #48]
 800d38a: 4618         	mov	r0, r3
 800d38c: 9913         	ldr	r1, [sp, #0x4c]
 800d38e: f7ff fef7    	bl	0x800d180 <div10>       @ imm = #-0x212
 800d392: 9b0c         	ldr	r3, [sp, #0x30]
 800d394: 9a0d         	ldr	r2, [sp, #0x34]
 800d396: 910f         	str	r1, [sp, #0x3c]
 800d398: 4298         	cmp	r0, r3
 800d39a: 460b         	mov	r3, r1
 800d39c: 4193         	sbcs	r3, r2
 800d39e: 4681         	mov	r9, r0
 800d3a0: f080 808e    	bhs.w	0x800d4c0 <__dtoa_engine+0x318> @ imm = #0x11c
 800d3a4: 4620         	mov	r0, r4
 800d3a6: 4629         	mov	r1, r5
 800d3a8: f7ff feea    	bl	0x800d180 <div10>       @ imm = #-0x22c
 800d3ac: 9a0e         	ldr	r2, [sp, #0x38]
 800d3ae: fb0a f309    	mul	r3, r10, r9
 800d3b2: 4293         	cmp	r3, r2
 800d3b4: bf14         	ite	ne
 800d3b6: 2600         	movne	r6, #0x0
 800d3b8: f006 0601    	andeq	r6, r6, #0x1
 800d3bc: 9b0c         	ldr	r3, [sp, #0x30]
 800d3be: 9310         	str	r3, [sp, #0x40]
 800d3c0: 9b0d         	ldr	r3, [sp, #0x34]
 800d3c2: e9cd 3911    	strd	r3, r9, [sp, #68]
 800d3c6: 9b0f         	ldr	r3, [sp, #0x3c]
 800d3c8: 9313         	str	r3, [sp, #0x4c]
 800d3ca: 9b07         	ldr	r3, [sp, #0x1c]
 800d3cc: f1b8 0f00    	cmp.w	r8, #0x0
 800d3d0: bf14         	ite	ne
 800d3d2: 2700         	movne	r7, #0x0
 800d3d4: f007 0701    	andeq	r7, r7, #0x1
 800d3d8: 3301         	adds	r3, #0x1
 800d3da: fb0a 4810    	mls	r8, r10, r0, r4
 800d3de: fa5f f888    	uxtb.w	r8, r8
 800d3e2: 9307         	str	r3, [sp, #0x1c]
 800d3e4: 4604         	mov	r4, r0
 800d3e6: 460d         	mov	r5, r1
 800d3e8: e7c7         	b	0x800d37a <__dtoa_engine+0x1d2> @ imm = #-0x72
 800d3ea: 1cb8         	adds	r0, r7, #0x2
 800d3ec: f148 0100    	adc	r1, r8, #0x0
 800d3f0: f000 f93c    	bl	0x800d66c <__pow5Factor> @ imm = #0x278
 800d3f4: 9b04         	ldr	r3, [sp, #0x10]
 800d3f6: 4283         	cmp	r3, r0
 800d3f8: bf8c         	ite	hi
 800d3fa: 2000         	movhi	r0, #0x0
 800d3fc: 2001         	movls	r0, #0x1
 800d3fe: ebb9 0000    	subs.w	r0, r9, r0
 800d402: f16a 0200    	sbc	r2, r10, #0x0
 800d406: e9cd 0210    	strd	r0, r2, [sp, #64]
 800d40a: 2700         	movs	r7, #0x0
 800d40c: 463e         	mov	r6, r7
 800d40e: e7a8         	b	0x800d362 <__dtoa_engine+0x1ba> @ imm = #-0xb0
 800d410: 9b10         	ldr	r3, [sp, #0x40]
 800d412: 9a11         	ldr	r2, [sp, #0x44]
 800d414: 3b01         	subs	r3, #0x1
 800d416: f142 32ff    	adc	r2, r2, #0xffffffff
 800d41a: e9cd 3210    	strd	r3, r2, [sp, #64]
 800d41e: 2701         	movs	r7, #0x1
 800d420: e78a         	b	0x800d338 <__dtoa_engine+0x190> @ imm = #-0xec
 800d422: f1b9 0f3e    	cmp.w	r9, #0x3e
 800d426: d8f0         	bhi	0x800d40a <__dtoa_engine+0x262> @ imm = #-0x20
 800d428: f04f 33ff    	mov.w	r3, #0xffffffff
 800d42c: f1a9 0020    	sub.w	r0, r9, #0x20
 800d430: fa03 f209    	lsl.w	r2, r3, r9
 800d434: fa03 f000    	lsl.w	r0, r3, r0
 800d438: f1c9 0120    	rsb.w	r1, r9, #0x20
 800d43c: fa23 f101    	lsr.w	r1, r3, r1
 800d440: 4302         	orrs	r2, r0
 800d442: 430a         	orrs	r2, r1
 800d444: fa03 f309    	lsl.w	r3, r3, r9
 800d448: ea27 0703    	bic.w	r7, r7, r3
 800d44c: ea28 0802    	bic.w	r8, r8, r2
 800d450: ea57 0708    	orrs.w	r7, r7, r8
 800d454: bf0c         	ite	eq
 800d456: 2701         	moveq	r7, #0x1
 800d458: 2700         	movne	r7, #0x0
 800d45a: e76d         	b	0x800d338 <__dtoa_engine+0x190> @ imm = #-0x126
 800d45c: fb00 fc02    	mul	r12, r0, r2
 800d460: fba1 1200    	umull	r1, r2, r1, r0
 800d464: 3301         	adds	r3, #0x1
 800d466: 4462         	add	r2, r12
 800d468: 428c         	cmp	r4, r1
 800d46a: eb75 0c02    	sbcs.w	r12, r5, r2
 800d46e: d2f5         	bhs	0x800d45c <__dtoa_engine+0x2b4> @ imm = #-0x16
 800d470: 9a04         	ldr	r2, [sp, #0x10]
 800d472: f8dd b028    	ldr.w	r11, [sp, #0x28]
 800d476: 4413         	add	r3, r2
 800d478: 9a25         	ldr	r2, [sp, #0x94]
 800d47a: 4413         	add	r3, r2
 800d47c: 0fd2         	lsrs	r2, r2, #0x1f
 800d47e: 4293         	cmp	r3, r2
 800d480: bfb8         	it	lt
 800d482: 4613         	movlt	r3, r2
 800d484: 459b         	cmp	r11, r3
 800d486: bfa8         	it	ge
 800d488: 469b         	movge	r11, r3
 800d48a: e770         	b	0x800d36e <__dtoa_engine+0x1c6> @ imm = #-0x120
 800d48c: 210a         	movs	r1, #0xa
 800d48e: 2200         	movs	r2, #0x0
 800d490: 2301         	movs	r3, #0x1
 800d492: 4608         	mov	r0, r1
 800d494: e7e8         	b	0x800d468 <__dtoa_engine+0x2c0> @ imm = #-0x30
 800d496: fb0a f003    	mul	r0, r10, r3
 800d49a: fba2 230a    	umull	r2, r3, r2, r10
 800d49e: 3101         	adds	r1, #0x1
 800d4a0: 4403         	add	r3, r0
 800d4a2: 4294         	cmp	r4, r2
 800d4a4: eb75 0003    	sbcs.w	r0, r5, r3
 800d4a8: d2f5         	bhs	0x800d496 <__dtoa_engine+0x2ee> @ imm = #-0x16
 800d4aa: 4559         	cmp	r1, r11
 800d4ac: dd10         	ble	0x800d4d0 <__dtoa_engine+0x328> @ imm = #0x20
 800d4ae: f1bb 0f00    	cmp.w	r11, #0x0
 800d4b2: d102         	bne	0x800d4ba <__dtoa_engine+0x312> @ imm = #0x4
 800d4b4: ea54 0305    	orrs.w	r3, r4, r5
 800d4b8: d00a         	beq	0x800d4d0 <__dtoa_engine+0x328> @ imm = #0x14
 800d4ba: 2301         	movs	r3, #0x1
 800d4bc: 9306         	str	r3, [sp, #0x18]
 800d4be: e771         	b	0x800d3a4 <__dtoa_engine+0x1fc> @ imm = #-0x11e
 800d4c0: 220a         	movs	r2, #0xa
 800d4c2: 2300         	movs	r3, #0x0
 800d4c4: 2101         	movs	r1, #0x1
 800d4c6: e7ec         	b	0x800d4a2 <__dtoa_engine+0x2fa> @ imm = #-0x28

0800d4c8 <$d>:
 800d4c8: cc fb ff ff  	.word	0xfffffbcc
 800d4cc: cd cc cc cc  	.word	0xcccccccd

0800d4d0 <$t>:
 800d4d0: 2e00         	cmp	r6, #0x0
 800d4d2: d02f         	beq	0x800d534 <__dtoa_engine+0x38c> @ imm = #0x5e
 800d4d4: f04f 0a0a    	mov.w	r10, #0xa
 800d4d8: 9b12         	ldr	r3, [sp, #0x48]
 800d4da: 9913         	ldr	r1, [sp, #0x4c]
 800d4dc: 930d         	str	r3, [sp, #0x34]
 800d4de: 4618         	mov	r0, r3
 800d4e0: f7ff fe4e    	bl	0x800d180 <div10>       @ imm = #-0x364
 800d4e4: 9b0d         	ldr	r3, [sp, #0x34]
 800d4e6: 910c         	str	r1, [sp, #0x30]
 800d4e8: fb0a f200    	mul	r2, r10, r0
 800d4ec: 429a         	cmp	r2, r3
 800d4ee: 4681         	mov	r9, r0
 800d4f0: d120         	bne	0x800d534 <__dtoa_engine+0x38c> @ imm = #0x40
 800d4f2: e9dd 0110    	ldrd	r0, r1, [sp, #64]
 800d4f6: f7ff fe43    	bl	0x800d180 <div10>       @ imm = #-0x37a
 800d4fa: 900e         	str	r0, [sp, #0x38]
 800d4fc: 910d         	str	r1, [sp, #0x34]
 800d4fe: 4620         	mov	r0, r4
 800d500: 4629         	mov	r1, r5
 800d502: f7ff fe3d    	bl	0x800d180 <div10>       @ imm = #-0x386
 800d506: 9b0d         	ldr	r3, [sp, #0x34]
 800d508: 9a0e         	ldr	r2, [sp, #0x38]
 800d50a: 9210         	str	r2, [sp, #0x40]
 800d50c: e9cd 3911    	strd	r3, r9, [sp, #68]
 800d510: 9b0c         	ldr	r3, [sp, #0x30]
 800d512: 9313         	str	r3, [sp, #0x4c]
 800d514: 9b07         	ldr	r3, [sp, #0x1c]
 800d516: f1b8 0f00    	cmp.w	r8, #0x0
 800d51a: bf14         	ite	ne
 800d51c: 2700         	movne	r7, #0x0
 800d51e: f007 0701    	andeq	r7, r7, #0x1
 800d522: 3301         	adds	r3, #0x1
 800d524: fb0a 4810    	mls	r8, r10, r0, r4
 800d528: fa5f f888    	uxtb.w	r8, r8
 800d52c: 9307         	str	r3, [sp, #0x1c]
 800d52e: 4604         	mov	r4, r0
 800d530: 460d         	mov	r5, r1
 800d532: e7d1         	b	0x800d4d8 <__dtoa_engine+0x330> @ imm = #-0x5e
 800d534: f8dd 9010    	ldr.w	r9, [sp, #0x10]
 800d538: 9b07         	ldr	r3, [sp, #0x1c]
 800d53a: 4499         	add	r9, r3
 800d53c: 2f00         	cmp	r7, #0x0
 800d53e: d05a         	beq	0x800d5f6 <__dtoa_engine+0x44e> @ imm = #0xb4
 800d540: f1b8 0f05    	cmp.w	r8, #0x5
 800d544: d157         	bne	0x800d5f6 <__dtoa_engine+0x44e> @ imm = #0xae
 800d546: f014 0301    	ands	r3, r4, #0x1
 800d54a: d14a         	bne	0x800d5e2 <__dtoa_engine+0x43a> @ imm = #0x94
 800d54c: 9a06         	ldr	r2, [sp, #0x18]
 800d54e: b932         	cbnz	r2, 0x800d55e <__dtoa_engine+0x3b6> @ imm = #0xc
 800d550: e9dd 2312    	ldrd	r2, r3, [sp, #72]
 800d554: 429d         	cmp	r5, r3
 800d556: bf08         	it	eq
 800d558: 4294         	cmpeq	r4, r2
 800d55a: d05f         	beq	0x800d61c <__dtoa_engine+0x474> @ imm = #0xbe
 800d55c: 9b06         	ldr	r3, [sp, #0x18]
 800d55e: 1918         	adds	r0, r3, r4
 800d560: f04f 040a    	mov.w	r4, #0xa
 800d564: f145 0100    	adc	r1, r5, #0x0
 800d568: 2200         	movs	r2, #0x0
 800d56a: 2601         	movs	r6, #0x1
 800d56c: 4625         	mov	r5, r4
 800d56e: 42a0         	cmp	r0, r4
 800d570: eb71 0702    	sbcs.w	r7, r1, r2
 800d574: d255         	bhs	0x800d622 <__dtoa_engine+0x47a> @ imm = #0xaa
 800d576: b1eb         	cbz	r3, 0x800d5b4 <__dtoa_engine+0x40c> @ imm = #0x3a
 800d578: 45b3         	cmp	r11, r6
 800d57a: da1b         	bge	0x800d5b4 <__dtoa_engine+0x40c> @ imm = #0x36
 800d57c: 9b0b         	ldr	r3, [sp, #0x2c]
 800d57e: b16b         	cbz	r3, 0x800d59c <__dtoa_engine+0x3f4> @ imm = #0x1a
 800d580: 9a25         	ldr	r2, [sp, #0x94]
 800d582: f8dd b028    	ldr.w	r11, [sp, #0x28]
 800d586: eb06 0309    	add.w	r3, r6, r9
 800d58a: 4413         	add	r3, r2
 800d58c: 2b01         	cmp	r3, #0x1
 800d58e: bfb8         	it	lt
 800d590: 2301         	movlt	r3, #0x1
 800d592: 459b         	cmp	r11, r3
 800d594: bfa8         	it	ge
 800d596: 469b         	movge	r11, r3
 800d598: 455e         	cmp	r6, r11
 800d59a: dd0b         	ble	0x800d5b4 <__dtoa_engine+0x40c> @ imm = #0x16
 800d59c: 3005         	adds	r0, #0x5
 800d59e: f04f 020a    	mov.w	r2, #0xa
 800d5a2: f04f 0300    	mov.w	r3, #0x0
 800d5a6: f141 0100    	adc	r1, r1, #0x0
 800d5aa: f7f3 f8e7    	bl	0x800077c <__aeabi_uldivmod> @ imm = #-0xce32
 800d5ae: f109 0901    	add.w	r9, r9, #0x1
 800d5b2: 3e01         	subs	r6, #0x1
 800d5b4: 455e         	cmp	r6, r11
 800d5b6: bfa8         	it	ge
 800d5b8: 465e         	movge	r6, r11
 800d5ba: b237         	sxth	r7, r6
 800d5bc: fa0f f989    	sxth.w	r9, r9
 800d5c0: 9b05         	ldr	r3, [sp, #0x14]
 800d5c2: fa09 f686    	sxtah	r6, r9, r6
 800d5c6: f107 0805    	add.w	r8, r7, #0x5
 800d5ca: 3e01         	subs	r6, #0x1
 800d5cc: 4498         	add	r8, r3
 800d5ce: f04f 0900    	mov.w	r9, #0x0
 800d5d2: 45b9         	cmp	r9, r7
 800d5d4: db2c         	blt	0x800d630 <__dtoa_engine+0x488> @ imm = #0x58
 800d5d6: 9b05         	ldr	r3, [sp, #0x14]
 800d5d8: 461a         	mov	r2, r3
 800d5da: 601e         	str	r6, [r3]
 800d5dc: 9b09         	ldr	r3, [sp, #0x24]
 800d5de: 7113         	strb	r3, [r2, #0x4]
 800d5e0: e600         	b	0x800d1e4 <__dtoa_engine+0x3c> @ imm = #-0x400
 800d5e2: 9b06         	ldr	r3, [sp, #0x18]
 800d5e4: b92b         	cbnz	r3, 0x800d5f2 <__dtoa_engine+0x44a> @ imm = #0xa
 800d5e6: e9dd 2312    	ldrd	r2, r3, [sp, #72]
 800d5ea: 429d         	cmp	r5, r3
 800d5ec: bf08         	it	eq
 800d5ee: 4294         	cmpeq	r4, r2
 800d5f0: d009         	beq	0x800d606 <__dtoa_engine+0x45e> @ imm = #0x12
 800d5f2: 2301         	movs	r3, #0x1
 800d5f4: e7b3         	b	0x800d55e <__dtoa_engine+0x3b6> @ imm = #-0x9a
 800d5f6: 9b06         	ldr	r3, [sp, #0x18]
 800d5f8: b953         	cbnz	r3, 0x800d610 <__dtoa_engine+0x468> @ imm = #0x14
 800d5fa: e9dd 2312    	ldrd	r2, r3, [sp, #72]
 800d5fe: 429d         	cmp	r5, r3
 800d600: bf08         	it	eq
 800d602: 4294         	cmpeq	r4, r2
 800d604: d104         	bne	0x800d610 <__dtoa_engine+0x468> @ imm = #0x8
 800d606: 9b08         	ldr	r3, [sp, #0x20]
 800d608: 2b00         	cmp	r3, #0x0
 800d60a: d1f2         	bne	0x800d5f2 <__dtoa_engine+0x44a> @ imm = #-0x1c
 800d60c: 2e00         	cmp	r6, #0x0
 800d60e: d0f0         	beq	0x800d5f2 <__dtoa_engine+0x44a> @ imm = #-0x20
 800d610: f1b8 0f04    	cmp.w	r8, #0x4
 800d614: bf94         	ite	ls
 800d616: 2300         	movls	r3, #0x0
 800d618: 2301         	movhi	r3, #0x1
 800d61a: e7a0         	b	0x800d55e <__dtoa_engine+0x3b6> @ imm = #-0xc0
 800d61c: f04f 0804    	mov.w	r8, #0x4
 800d620: e7f1         	b	0x800d606 <__dtoa_engine+0x45e> @ imm = #-0x1e
 800d622: fb05 f702    	mul	r7, r5, r2
 800d626: fba4 4205    	umull	r4, r2, r4, r5
 800d62a: 3601         	adds	r6, #0x1
 800d62c: 443a         	add	r2, r7
 800d62e: e79e         	b	0x800d56e <__dtoa_engine+0x3c6> @ imm = #-0xc4
 800d630: 220a         	movs	r2, #0xa
 800d632: 2300         	movs	r3, #0x0
 800d634: f7f3 f8a2    	bl	0x800077c <__aeabi_uldivmod> @ imm = #-0xcebc
 800d638: 3230         	adds	r2, #0x30
 800d63a: f808 2d01    	strb	r2, [r8, #-1]!
 800d63e: f109 0901    	add.w	r9, r9, #0x1
 800d642: e7c6         	b	0x800d5d2 <__dtoa_engine+0x42a> @ imm = #-0x74

0800d644 <__log10Pow2>:
 800d644: 4b01         	ldr	r3, [pc, #0x4]          @ 0x800d64c <__log10Pow2+0x8>
 800d646: 4358         	muls	r0, r3, r0
 800d648: 0c80         	lsrs	r0, r0, #0x12
 800d64a: 4770         	bx	lr

0800d64c <$d>:
 800d64c: 41 34 01 00  	.word	0x00013441

0800d650 <__log10Pow5>:
 800d650: 4b01         	ldr	r3, [pc, #0x4]          @ 0x800d658 <__log10Pow5+0x8>
 800d652: 4358         	muls	r0, r3, r0
 800d654: 0d00         	lsrs	r0, r0, #0x14
 800d656: 4770         	bx	lr

0800d658 <$d>:
 800d658: fb 2e 0b 00  	.word	0x000b2efb

0800d65c <__pow5bits>:
 800d65c: 4b02         	ldr	r3, [pc, #0x8]          @ 0x800d668 <__pow5bits+0xc>
 800d65e: 4358         	muls	r0, r3, r0
 800d660: 0cc0         	lsrs	r0, r0, #0x13
 800d662: 3001         	adds	r0, #0x1
 800d664: 4770         	bx	lr
 800d666: bf00         	nop

0800d668 <$d>:
 800d668: 4f 93 12 00  	.word	0x0012934f

0800d66c <__pow5Factor>:
 800d66c: 4a0a         	ldr	r2, [pc, #0x28]         @ 0x800d698 <__pow5Factor+0x2c>
 800d66e: b570         	push	{r4, r5, r6, lr}
 800d670: 4603         	mov	r3, r0
 800d672: f04f 36cc    	mov.w	r6, #0xcccccccc
 800d676: 2000         	movs	r0, #0x0
 800d678: f04f 3533    	mov.w	r5, #0x33333333
 800d67c: fb06 f403    	mul	r4, r6, r3
 800d680: fb02 4401    	mla	r4, r2, r1, r4
 800d684: fba3 3102    	umull	r3, r1, r3, r2
 800d688: 4421         	add	r1, r4
 800d68a: 429d         	cmp	r5, r3
 800d68c: eb75 0401    	sbcs.w	r4, r5, r1
 800d690: d301         	blo	0x800d696 <__pow5Factor+0x2a> @ imm = #0x2
 800d692: 3001         	adds	r0, #0x1
 800d694: e7f2         	b	0x800d67c <__pow5Factor+0x10> @ imm = #-0x1c
 800d696: bd70         	pop	{r4, r5, r6, pc}

0800d698 <$d>:
 800d698: cd cc cc cc  	.word	0xcccccccd

0800d69c <__double_computePow5>:
 800d69c: e92d 4ff0    	push.w	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
 800d6a0: 231a         	movs	r3, #0x1a
 800d6a2: 4e35         	ldr	r6, [pc, #0xd4]         @ 0x800d778 <__double_computePow5+0xdc>
 800d6a4: fbb0 faf3    	udiv	r10, r0, r3
 800d6a8: fb03 031a    	mls	r3, r3, r10, r0
 800d6ac: b089         	sub	sp, #0x24
 800d6ae: 4604         	mov	r4, r0
 800d6b0: 460d         	mov	r5, r1
 800d6b2: eb06 160a    	add.w	r6, r6, r10, lsl #4
 800d6b6: b953         	cbnz	r3, 0x800d6ce <__double_computePow5+0x32> @ imm = #0x14
 800d6b8: e9d6 2300    	ldrd	r2, r3, [r6]
 800d6bc: e9c1 2300    	strd	r2, r3, [r1]
 800d6c0: e9d6 0102    	ldrd	r0, r1, [r6, #8]
 800d6c4: e9c5 0102    	strd	r0, r1, [r5, #8]
 800d6c8: b009         	add	sp, #0x24
 800d6ca: e8bd 8ff0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, r11, pc}
 800d6ce: 4a2b         	ldr	r2, [pc, #0xac]         @ 0x800d77c <__double_computePow5+0xe0>
 800d6d0: eb02 03c3    	add.w	r3, r2, r3, lsl #3
 800d6d4: e9d3 8900    	ldrd	r8, r9, [r3]
 800d6d8: ab04         	add	r3, sp, #0x10
 800d6da: 9300         	str	r3, [sp]
 800d6dc: e9d6 2302    	ldrd	r2, r3, [r6, #8]
 800d6e0: 4640         	mov	r0, r8
 800d6e2: 4649         	mov	r1, r9
 800d6e4: f006 fe21    	bl	0x801432a <__umul128>   @ imm = #0x6c42
 800d6e8: ab06         	add	r3, sp, #0x18
 800d6ea: 9300         	str	r3, [sp]
 800d6ec: e9d6 2300    	ldrd	r2, r3, [r6]
 800d6f0: 4683         	mov	r11, r0
 800d6f2: 460f         	mov	r7, r1
 800d6f4: 4640         	mov	r0, r8
 800d6f6: 4649         	mov	r1, r9
 800d6f8: f006 fe17    	bl	0x801432a <__umul128>   @ imm = #0x6c2e
 800d6fc: e9dd 6206    	ldrd	r6, r2, [sp, #24]
 800d700: eb16 060b    	adds.w	r6, r6, r11
 800d704: eb52 0807    	adcs.w	r8, r2, r7
 800d708: f04f 0300    	mov.w	r3, #0x0
 800d70c: bf28         	it	hs
 800d70e: 2301         	movhs	r3, #0x1
 800d710: 4681         	mov	r9, r0
 800d712: b133         	cbz	r3, 0x800d722 <__double_computePow5+0x86> @ imm = #0xc
 800d714: 9b04         	ldr	r3, [sp, #0x10]
 800d716: 9a05         	ldr	r2, [sp, #0x14]
 800d718: 3301         	adds	r3, #0x1
 800d71a: f142 0200    	adc	r2, r2, #0x0
 800d71e: e9cd 3204    	strd	r3, r2, [sp, #16]
 800d722: 4620         	mov	r0, r4
 800d724: 9103         	str	r1, [sp, #0xc]
 800d726: f7ff ff99    	bl	0x800d65c <__pow5bits>  @ imm = #-0xce
 800d72a: 4607         	mov	r7, r0
 800d72c: 201a         	movs	r0, #0x1a
 800d72e: fb00 f00a    	mul	r0, r0, r10
 800d732: f7ff ff93    	bl	0x800d65c <__pow5bits>  @ imm = #-0xda
 800d736: 1a3f         	subs	r7, r7, r0
 800d738: 4632         	mov	r2, r6
 800d73a: 4643         	mov	r3, r8
 800d73c: 9903         	ldr	r1, [sp, #0xc]
 800d73e: 9700         	str	r7, [sp]
 800d740: 4648         	mov	r0, r9
 800d742: f006 fe0d    	bl	0x8014360 <__shiftright128> @ imm = #0x6c1a
 800d746: ea4f 1c14    	lsr.w	r12, r4, #0x4
 800d74a: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x800d780 <__double_computePow5+0xe4>
 800d74c: 0064         	lsls	r4, r4, #0x1
 800d74e: f004 031e    	and	r3, r4, #0x1e
 800d752: f852 402c    	ldr.w	r4, [r2, r12, lsl #2]
 800d756: 40dc         	lsrs	r4, r3
 800d758: f004 0403    	and	r4, r4, #0x3
 800d75c: 1824         	adds	r4, r4, r0
 800d75e: f141 0100    	adc	r1, r1, #0x0
 800d762: e9c5 4100    	strd	r4, r1, [r5]
 800d766: e9dd 2304    	ldrd	r2, r3, [sp, #16]
 800d76a: 9700         	str	r7, [sp]
 800d76c: 4630         	mov	r0, r6
 800d76e: 4641         	mov	r1, r8
 800d770: f006 fdf6    	bl	0x8014360 <__shiftright128> @ imm = #0x6bec
 800d774: e7a6         	b	0x800d6c4 <__double_computePow5+0x28> @ imm = #-0xb4
 800d776: bf00         	nop

0800d778 <$d>:
 800d778: 70 60 01 08  	.word	0x08016070
 800d77c: a0 5f 01 08  	.word	0x08015fa0
 800d780: 0c 68 01 08  	.word	0x0801680c

0800d784 <__double_computeInvPow5>:
 800d784: e92d 4ff0    	push.w	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
 800d788: 271a         	movs	r7, #0x1a
 800d78a: f8df a0e4    	ldr.w	r10, [pc, #0xe4]        @ 0x800d870 <__double_computeInvPow5+0xec>
 800d78e: f100 0519    	add.w	r5, r0, #0x19
 800d792: fbb5 f5f7    	udiv	r5, r5, r7
 800d796: 436f         	muls	r7, r5, r7
 800d798: 1a3a         	subs	r2, r7, r0
 800d79a: ea4f 1b05    	lsl.w	r11, r5, #0x4
 800d79e: b089         	sub	sp, #0x24
 800d7a0: 4604         	mov	r4, r0
 800d7a2: 460e         	mov	r6, r1
 800d7a4: eb0a 1505    	add.w	r5, r10, r5, lsl #4
 800d7a8: d10a         	bne	0x800d7c0 <__double_computeInvPow5+0x3c> @ imm = #0x14
 800d7aa: e9d5 2300    	ldrd	r2, r3, [r5]
 800d7ae: e9c1 2300    	strd	r2, r3, [r1]
 800d7b2: e9d5 0102    	ldrd	r0, r1, [r5, #8]
 800d7b6: e9c6 0102    	strd	r0, r1, [r6, #8]
 800d7ba: b009         	add	sp, #0x24
 800d7bc: e8bd 8ff0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, r11, pc}
 800d7c0: 4b2c         	ldr	r3, [pc, #0xb0]         @ 0x800d874 <__double_computeInvPow5+0xf0>
 800d7c2: eb03 03c2    	add.w	r3, r3, r2, lsl #3
 800d7c6: e9d3 8900    	ldrd	r8, r9, [r3]
 800d7ca: ab04         	add	r3, sp, #0x10
 800d7cc: 9300         	str	r3, [sp]
 800d7ce: e9d5 2302    	ldrd	r2, r3, [r5, #8]
 800d7d2: 4640         	mov	r0, r8
 800d7d4: 4649         	mov	r1, r9
 800d7d6: f006 fda8    	bl	0x801432a <__umul128>   @ imm = #0x6b50
 800d7da: f85a 200b    	ldr.w	r2, [r10, r11]
 800d7de: 686b         	ldr	r3, [r5, #0x4]
 800d7e0: 3a01         	subs	r2, #0x1
 800d7e2: e9cd 0102    	strd	r0, r1, [sp, #8]
 800d7e6: a906         	add	r1, sp, #0x18
 800d7e8: f163 0300    	sbc	r3, r3, #0x0
 800d7ec: 9100         	str	r1, [sp]
 800d7ee: 4640         	mov	r0, r8
 800d7f0: 4649         	mov	r1, r9
 800d7f2: f006 fd9a    	bl	0x801432a <__umul128>   @ imm = #0x6b34
 800d7f6: e9dd 5206    	ldrd	r5, r2, [sp, #24]
 800d7fa: 468a         	mov	r10, r1
 800d7fc: 9902         	ldr	r1, [sp, #0x8]
 800d7fe: 186d         	adds	r5, r5, r1
 800d800: 9903         	ldr	r1, [sp, #0xc]
 800d802: eb52 0801    	adcs.w	r8, r2, r1
 800d806: f04f 0300    	mov.w	r3, #0x0
 800d80a: bf28         	it	hs
 800d80c: 2301         	movhs	r3, #0x1
 800d80e: 4681         	mov	r9, r0
 800d810: b133         	cbz	r3, 0x800d820 <__double_computeInvPow5+0x9c> @ imm = #0xc
 800d812: 9b04         	ldr	r3, [sp, #0x10]
 800d814: 9a05         	ldr	r2, [sp, #0x14]
 800d816: 3301         	adds	r3, #0x1
 800d818: f142 0200    	adc	r2, r2, #0x0
 800d81c: e9cd 3204    	strd	r3, r2, [sp, #16]
 800d820: 4638         	mov	r0, r7
 800d822: f7ff ff1b    	bl	0x800d65c <__pow5bits>  @ imm = #-0x1ca
 800d826: 4607         	mov	r7, r0
 800d828: 4620         	mov	r0, r4
 800d82a: f7ff ff17    	bl	0x800d65c <__pow5bits>  @ imm = #-0x1d2
 800d82e: 1a3f         	subs	r7, r7, r0
 800d830: 462a         	mov	r2, r5
 800d832: 4643         	mov	r3, r8
 800d834: 9700         	str	r7, [sp]
 800d836: 4648         	mov	r0, r9
 800d838: 4651         	mov	r1, r10
 800d83a: f006 fd91    	bl	0x8014360 <__shiftright128> @ imm = #0x6b22
 800d83e: ea4f 1c14    	lsr.w	r12, r4, #0x4
 800d842: 4a0d         	ldr	r2, [pc, #0x34]         @ 0x800d878 <__double_computeInvPow5+0xf4>
 800d844: 0064         	lsls	r4, r4, #0x1
 800d846: f004 031e    	and	r3, r4, #0x1e
 800d84a: f852 402c    	ldr.w	r4, [r2, r12, lsl #2]
 800d84e: 40dc         	lsrs	r4, r3
 800d850: f004 0403    	and	r4, r4, #0x3
 800d854: 3401         	adds	r4, #0x1
 800d856: 1824         	adds	r4, r4, r0
 800d858: f141 0100    	adc	r1, r1, #0x0
 800d85c: e9c6 4100    	strd	r4, r1, [r6]
 800d860: e9dd 2304    	ldrd	r2, r3, [sp, #16]
 800d864: 9700         	str	r7, [sp]
 800d866: 4628         	mov	r0, r5
 800d868: 4641         	mov	r1, r8
 800d86a: f006 fd79    	bl	0x8014360 <__shiftright128> @ imm = #0x6af2
 800d86e: e7a2         	b	0x800d7b6 <__double_computeInvPow5+0x32> @ imm = #-0xbc

0800d870 <$d>:
 800d870: 40 61 01 08  	.word	0x08016140
 800d874: a0 5f 01 08  	.word	0x08015fa0
 800d878: 60 68 01 08  	.word	0x08016860

0800d87c <_OffsetAbsSyms>:
; GEN_ABS_SYM_BEGIN(_OffsetAbsSyms)
 800d87c: b480         	push	{r7}
 800d87e: af00         	add	r7, sp, #0x0
; GEN_ABS_SYM_END
 800d880: bf00         	nop
 800d882: 46bd         	mov	sp, r7
 800d884: bc80         	pop	{r7}
 800d886: 4770         	bx	lr

0800d888 <k_sleep>:
; {
 800d888: b580         	push	{r7, lr}
 800d88a: b082         	sub	sp, #0x8
 800d88c: af00         	add	r7, sp, #0x0
 800d88e: e9c7 0100    	strd	r0, r1, [r7]
; 	return z_impl_k_sleep(timeout);
 800d892: e9d7 0100    	ldrd	r0, r1, [r7]
 800d896: f7fe f84d    	bl	0x800b934 <z_impl_k_sleep> @ imm = #-0x1f66
 800d89a: 4603         	mov	r3, r0
; }
 800d89c: 4618         	mov	r0, r3
 800d89e: 3708         	adds	r7, #0x8
 800d8a0: 46bd         	mov	sp, r7
 800d8a2: bd80         	pop	{r7, pc}

0800d8a4 <z_impl_can_start>:
; {
 800d8a4: b580         	push	{r7, lr}
 800d8a6: b084         	sub	sp, #0x10
 800d8a8: af00         	add	r7, sp, #0x0
 800d8aa: 6078         	str	r0, [r7, #0x4]
; 	const struct can_driver_api *api = (const struct can_driver_api *)dev->api;
 800d8ac: 687b         	ldr	r3, [r7, #0x4]
 800d8ae: 689b         	ldr	r3, [r3, #0x8]
 800d8b0: 60fb         	str	r3, [r7, #0xc]
; 	return api->start(dev);
 800d8b2: 68fb         	ldr	r3, [r7, #0xc]
 800d8b4: 685b         	ldr	r3, [r3, #0x4]
 800d8b6: 6878         	ldr	r0, [r7, #0x4]
 800d8b8: 4798         	blx	r3
 800d8ba: 4603         	mov	r3, r0
; }
 800d8bc: 4618         	mov	r0, r3
 800d8be: 3710         	adds	r7, #0x10
 800d8c0: 46bd         	mov	sp, r7
 800d8c2: bd80         	pop	{r7, pc}

0800d8c4 <can_start>:
; {
 800d8c4: b580         	push	{r7, lr}
 800d8c6: b082         	sub	sp, #0x8
 800d8c8: af00         	add	r7, sp, #0x0
 800d8ca: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_can_start(dev);
 800d8cc: 6878         	ldr	r0, [r7, #0x4]
 800d8ce: f7ff ffe9    	bl	0x800d8a4 <z_impl_can_start> @ imm = #-0x2e
 800d8d2: 4603         	mov	r3, r0
; }
 800d8d4: 4618         	mov	r0, r3
 800d8d6: 3708         	adds	r7, #0x8
 800d8d8: 46bd         	mov	sp, r7
 800d8da: bd80         	pop	{r7, pc}

0800d8dc <can_send>:
; {
 800d8dc: b580         	push	{r7, lr}
 800d8de: b086         	sub	sp, #0x18
 800d8e0: af02         	add	r7, sp, #0x8
 800d8e2: 60f8         	str	r0, [r7, #0xc]
 800d8e4: 60b9         	str	r1, [r7, #0x8]
 800d8e6: e9c7 2300    	strd	r2, r3, [r7]
; 	return z_impl_can_send(dev, frame, timeout, callback, user_data);
 800d8ea: 69fb         	ldr	r3, [r7, #0x1c]
 800d8ec: 9301         	str	r3, [sp, #0x4]
 800d8ee: 69bb         	ldr	r3, [r7, #0x18]
 800d8f0: 9300         	str	r3, [sp]
 800d8f2: e9d7 2300    	ldrd	r2, r3, [r7]
 800d8f6: 68b9         	ldr	r1, [r7, #0x8]
 800d8f8: 68f8         	ldr	r0, [r7, #0xc]
 800d8fa: f7f6 f83b    	bl	0x8003974 <z_impl_can_send> @ imm = #-0x9f8a
 800d8fe: 4603         	mov	r3, r0
; }
 800d900: 4618         	mov	r0, r3
 800d902: 3710         	adds	r7, #0x10
 800d904: 46bd         	mov	sp, r7
 800d906: bd80         	pop	{r7, pc}

0800d908 <big_heap_chunks>:
; {
 800d908: b480         	push	{r7}
 800d90a: b083         	sub	sp, #0xc
 800d90c: af00         	add	r7, sp, #0x0
 800d90e: 6078         	str	r0, [r7, #0x4]
; 		return false;
 800d910: 2300         	movs	r3, #0x0
; }
 800d912: 4618         	mov	r0, r3
 800d914: 370c         	adds	r7, #0xc
 800d916: 46bd         	mov	sp, r7
 800d918: bc80         	pop	{r7}
 800d91a: 4770         	bx	lr

0800d91c <big_heap_bytes>:
; {
 800d91c: b580         	push	{r7, lr}
 800d91e: b082         	sub	sp, #0x8
 800d920: af00         	add	r7, sp, #0x0
 800d922: 6078         	str	r0, [r7, #0x4]
; 	return big_heap_chunks(bytes / CHUNK_UNIT);
 800d924: 687b         	ldr	r3, [r7, #0x4]
 800d926: 08db         	lsrs	r3, r3, #0x3
 800d928: 4618         	mov	r0, r3
 800d92a: f7ff ffed    	bl	0x800d908 <big_heap_chunks> @ imm = #-0x26
 800d92e: 4603         	mov	r3, r0
; }
 800d930: 4618         	mov	r0, r3
 800d932: 3708         	adds	r7, #0x8
 800d934: 46bd         	mov	sp, r7
 800d936: bd80         	pop	{r7, pc}

0800d938 <big_heap>:
; {
 800d938: b580         	push	{r7, lr}
 800d93a: b082         	sub	sp, #0x8
 800d93c: af00         	add	r7, sp, #0x0
 800d93e: 6078         	str	r0, [r7, #0x4]
; 	return big_heap_chunks(h->end_chunk);
 800d940: 687b         	ldr	r3, [r7, #0x4]
 800d942: 689b         	ldr	r3, [r3, #0x8]
 800d944: 4618         	mov	r0, r3
 800d946: f7ff ffdf    	bl	0x800d908 <big_heap_chunks> @ imm = #-0x42
 800d94a: 4603         	mov	r3, r0
; }
 800d94c: 4618         	mov	r0, r3
 800d94e: 3708         	adds	r7, #0x8
 800d950: 46bd         	mov	sp, r7
 800d952: bd80         	pop	{r7, pc}

0800d954 <chunk_buf>:
; {
 800d954: b480         	push	{r7}
 800d956: b083         	sub	sp, #0xc
 800d958: af00         	add	r7, sp, #0x0
 800d95a: 6078         	str	r0, [r7, #0x4]
; 	return (chunk_unit_t *)h;
 800d95c: 687b         	ldr	r3, [r7, #0x4]
; }
 800d95e: 4618         	mov	r0, r3
 800d960: 370c         	adds	r7, #0xc
 800d962: 46bd         	mov	sp, r7
 800d964: bc80         	pop	{r7}
 800d966: 4770         	bx	lr

0800d968 <chunk_field>:
; {
 800d968: b580         	push	{r7, lr}
 800d96a: b086         	sub	sp, #0x18
 800d96c: af00         	add	r7, sp, #0x0
 800d96e: 60f8         	str	r0, [r7, #0xc]
 800d970: 60b9         	str	r1, [r7, #0x8]
 800d972: 4613         	mov	r3, r2
 800d974: 71fb         	strb	r3, [r7, #0x7]
; 	chunk_unit_t *buf = chunk_buf(h);
 800d976: 68f8         	ldr	r0, [r7, #0xc]
 800d978: f7ff ffec    	bl	0x800d954 <chunk_buf>   @ imm = #-0x28
 800d97c: 6178         	str	r0, [r7, #0x14]
; 	void *cmem = &buf[c];
 800d97e: 68bb         	ldr	r3, [r7, #0x8]
 800d980: 00db         	lsls	r3, r3, #0x3
 800d982: 697a         	ldr	r2, [r7, #0x14]
 800d984: 4413         	add	r3, r2
 800d986: 613b         	str	r3, [r7, #0x10]
; 	if (big_heap(h)) {
 800d988: 68f8         	ldr	r0, [r7, #0xc]
 800d98a: f7ff ffd5    	bl	0x800d938 <big_heap>    @ imm = #-0x56
 800d98e: 4603         	mov	r3, r0
 800d990: 2b00         	cmp	r3, #0x0
 800d992: d005         	beq	0x800d9a0 <chunk_field+0x38> @ imm = #0xa
; 		return ((uint32_t *)cmem)[f];
 800d994: 79fb         	ldrb	r3, [r7, #0x7]
 800d996: 009b         	lsls	r3, r3, #0x2
 800d998: 693a         	ldr	r2, [r7, #0x10]
 800d99a: 4413         	add	r3, r2
 800d99c: 681b         	ldr	r3, [r3]
 800d99e: e004         	b	0x800d9aa <chunk_field+0x42> @ imm = #0x8
; 		return ((uint16_t *)cmem)[f];
 800d9a0: 79fb         	ldrb	r3, [r7, #0x7]
 800d9a2: 005b         	lsls	r3, r3, #0x1
 800d9a4: 693a         	ldr	r2, [r7, #0x10]
 800d9a6: 4413         	add	r3, r2
 800d9a8: 881b         	ldrh	r3, [r3]
; }
 800d9aa: 4618         	mov	r0, r3
 800d9ac: 3718         	adds	r7, #0x18
 800d9ae: 46bd         	mov	sp, r7
 800d9b0: bd80         	pop	{r7, pc}

0800d9b2 <chunk_set>:
; {
 800d9b2: b580         	push	{r7, lr}
 800d9b4: b086         	sub	sp, #0x18
 800d9b6: af00         	add	r7, sp, #0x0
 800d9b8: 60f8         	str	r0, [r7, #0xc]
 800d9ba: 60b9         	str	r1, [r7, #0x8]
 800d9bc: 603b         	str	r3, [r7]
 800d9be: 4613         	mov	r3, r2
 800d9c0: 71fb         	strb	r3, [r7, #0x7]
; 	chunk_unit_t *buf = chunk_buf(h);
 800d9c2: 68f8         	ldr	r0, [r7, #0xc]
 800d9c4: f7ff ffc6    	bl	0x800d954 <chunk_buf>   @ imm = #-0x74
 800d9c8: 6178         	str	r0, [r7, #0x14]
; 	void *cmem = &buf[c];
 800d9ca: 68bb         	ldr	r3, [r7, #0x8]
 800d9cc: 00db         	lsls	r3, r3, #0x3
 800d9ce: 697a         	ldr	r2, [r7, #0x14]
 800d9d0: 4413         	add	r3, r2
 800d9d2: 613b         	str	r3, [r7, #0x10]
; 	if (big_heap(h)) {
 800d9d4: 68f8         	ldr	r0, [r7, #0xc]
 800d9d6: f7ff ffaf    	bl	0x800d938 <big_heap>    @ imm = #-0xa2
 800d9da: 4603         	mov	r3, r0
 800d9dc: 2b00         	cmp	r3, #0x0
 800d9de: d006         	beq	0x800d9ee <chunk_set+0x3c> @ imm = #0xc
; 		((uint32_t *)cmem)[f] = val;
 800d9e0: 79fb         	ldrb	r3, [r7, #0x7]
 800d9e2: 009b         	lsls	r3, r3, #0x2
 800d9e4: 693a         	ldr	r2, [r7, #0x10]
 800d9e6: 4413         	add	r3, r2
 800d9e8: 683a         	ldr	r2, [r7]
 800d9ea: 601a         	str	r2, [r3]
; }
 800d9ec: e006         	b	0x800d9fc <chunk_set+0x4a> @ imm = #0xc
; 		((uint16_t *)cmem)[f] = val;
 800d9ee: 79fb         	ldrb	r3, [r7, #0x7]
 800d9f0: 005b         	lsls	r3, r3, #0x1
 800d9f2: 693a         	ldr	r2, [r7, #0x10]
 800d9f4: 4413         	add	r3, r2
 800d9f6: 683a         	ldr	r2, [r7]
 800d9f8: b292         	uxth	r2, r2
 800d9fa: 801a         	strh	r2, [r3]
; }
 800d9fc: bf00         	nop
 800d9fe: 3718         	adds	r7, #0x18
 800da00: 46bd         	mov	sp, r7
 800da02: bd80         	pop	{r7, pc}

0800da04 <chunk_size>:
; {
 800da04: b580         	push	{r7, lr}
 800da06: b082         	sub	sp, #0x8
 800da08: af00         	add	r7, sp, #0x0
 800da0a: 6078         	str	r0, [r7, #0x4]
 800da0c: 6039         	str	r1, [r7]
; 	return chunk_field(h, c, SIZE_AND_USED) >> 1;
 800da0e: 2201         	movs	r2, #0x1
 800da10: 6839         	ldr	r1, [r7]
 800da12: 6878         	ldr	r0, [r7, #0x4]
 800da14: f7ff ffa8    	bl	0x800d968 <chunk_field> @ imm = #-0xb0
 800da18: 4603         	mov	r3, r0
 800da1a: 085b         	lsrs	r3, r3, #0x1
; }
 800da1c: 4618         	mov	r0, r3
 800da1e: 3708         	adds	r7, #0x8
 800da20: 46bd         	mov	sp, r7
 800da22: bd80         	pop	{r7, pc}

0800da24 <set_chunk_used>:
; {
 800da24: b580         	push	{r7, lr}
 800da26: b086         	sub	sp, #0x18
 800da28: af00         	add	r7, sp, #0x0
 800da2a: 60f8         	str	r0, [r7, #0xc]
 800da2c: 60b9         	str	r1, [r7, #0x8]
 800da2e: 4613         	mov	r3, r2
 800da30: 71fb         	strb	r3, [r7, #0x7]
; 	chunk_unit_t *buf = chunk_buf(h);
 800da32: 68f8         	ldr	r0, [r7, #0xc]
 800da34: f7ff ff8e    	bl	0x800d954 <chunk_buf>   @ imm = #-0xe4
 800da38: 6178         	str	r0, [r7, #0x14]
; 	void *cmem = &buf[c];
 800da3a: 68bb         	ldr	r3, [r7, #0x8]
 800da3c: 00db         	lsls	r3, r3, #0x3
 800da3e: 697a         	ldr	r2, [r7, #0x14]
 800da40: 4413         	add	r3, r2
 800da42: 613b         	str	r3, [r7, #0x10]
; 	if (big_heap(h)) {
 800da44: 68f8         	ldr	r0, [r7, #0xc]
 800da46: f7ff ff77    	bl	0x800d938 <big_heap>    @ imm = #-0x112
 800da4a: 4603         	mov	r3, r0
 800da4c: 2b00         	cmp	r3, #0x0
 800da4e: d014         	beq	0x800da7a <set_chunk_used+0x56> @ imm = #0x28
; 		if (used) {
 800da50: 79fb         	ldrb	r3, [r7, #0x7]
 800da52: 2b00         	cmp	r3, #0x0
 800da54: d008         	beq	0x800da68 <set_chunk_used+0x44> @ imm = #0x10
; 			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
 800da56: 693b         	ldr	r3, [r7, #0x10]
 800da58: 3304         	adds	r3, #0x4
 800da5a: 681a         	ldr	r2, [r3]
 800da5c: 693b         	ldr	r3, [r7, #0x10]
 800da5e: 3304         	adds	r3, #0x4
 800da60: f042 0201    	orr	r2, r2, #0x1
 800da64: 601a         	str	r2, [r3]
; }
 800da66: e01e         	b	0x800daa6 <set_chunk_used+0x82> @ imm = #0x3c
; 			((uint32_t *)cmem)[SIZE_AND_USED] &= ~1U;
 800da68: 693b         	ldr	r3, [r7, #0x10]
 800da6a: 3304         	adds	r3, #0x4
 800da6c: 681a         	ldr	r2, [r3]
 800da6e: 693b         	ldr	r3, [r7, #0x10]
 800da70: 3304         	adds	r3, #0x4
 800da72: f022 0201    	bic	r2, r2, #0x1
 800da76: 601a         	str	r2, [r3]
; }
 800da78: e015         	b	0x800daa6 <set_chunk_used+0x82> @ imm = #0x2a
; 		if (used) {
 800da7a: 79fb         	ldrb	r3, [r7, #0x7]
 800da7c: 2b00         	cmp	r3, #0x0
 800da7e: d009         	beq	0x800da94 <set_chunk_used+0x70> @ imm = #0x12
; 			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
 800da80: 693b         	ldr	r3, [r7, #0x10]
 800da82: 3302         	adds	r3, #0x2
 800da84: 881a         	ldrh	r2, [r3]
 800da86: 693b         	ldr	r3, [r7, #0x10]
 800da88: 3302         	adds	r3, #0x2
 800da8a: f042 0201    	orr	r2, r2, #0x1
 800da8e: b292         	uxth	r2, r2
 800da90: 801a         	strh	r2, [r3]
; }
 800da92: e008         	b	0x800daa6 <set_chunk_used+0x82> @ imm = #0x10
; 			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
 800da94: 693b         	ldr	r3, [r7, #0x10]
 800da96: 3302         	adds	r3, #0x2
 800da98: 881a         	ldrh	r2, [r3]
 800da9a: 693b         	ldr	r3, [r7, #0x10]
 800da9c: 3302         	adds	r3, #0x2
 800da9e: f022 0201    	bic	r2, r2, #0x1
 800daa2: b292         	uxth	r2, r2
 800daa4: 801a         	strh	r2, [r3]
; }
 800daa6: bf00         	nop
 800daa8: 3718         	adds	r7, #0x18
 800daaa: 46bd         	mov	sp, r7
 800daac: bd80         	pop	{r7, pc}

0800daae <set_chunk_size>:
; {
 800daae: b580         	push	{r7, lr}
 800dab0: b084         	sub	sp, #0x10
 800dab2: af00         	add	r7, sp, #0x0
 800dab4: 60f8         	str	r0, [r7, #0xc]
 800dab6: 60b9         	str	r1, [r7, #0x8]
 800dab8: 607a         	str	r2, [r7, #0x4]
; 	chunk_set(h, c, SIZE_AND_USED, size << 1);
 800daba: 687b         	ldr	r3, [r7, #0x4]
 800dabc: 005b         	lsls	r3, r3, #0x1
 800dabe: 2201         	movs	r2, #0x1
 800dac0: 68b9         	ldr	r1, [r7, #0x8]
 800dac2: 68f8         	ldr	r0, [r7, #0xc]
 800dac4: f7ff ff75    	bl	0x800d9b2 <chunk_set>   @ imm = #-0x116
; }
 800dac8: bf00         	nop
 800daca: 3710         	adds	r7, #0x10
 800dacc: 46bd         	mov	sp, r7
 800dace: bd80         	pop	{r7, pc}

0800dad0 <prev_free_chunk>:
; {
 800dad0: b580         	push	{r7, lr}
 800dad2: b082         	sub	sp, #0x8
 800dad4: af00         	add	r7, sp, #0x0
 800dad6: 6078         	str	r0, [r7, #0x4]
 800dad8: 6039         	str	r1, [r7]
; 	return chunk_field(h, c, FREE_PREV);
 800dada: 2202         	movs	r2, #0x2
 800dadc: 6839         	ldr	r1, [r7]
 800dade: 6878         	ldr	r0, [r7, #0x4]
 800dae0: f7ff ff42    	bl	0x800d968 <chunk_field> @ imm = #-0x17c
 800dae4: 4603         	mov	r3, r0
; }
 800dae6: 4618         	mov	r0, r3
 800dae8: 3708         	adds	r7, #0x8
 800daea: 46bd         	mov	sp, r7
 800daec: bd80         	pop	{r7, pc}

0800daee <set_prev_free_chunk>:
; {
 800daee: b580         	push	{r7, lr}
 800daf0: b084         	sub	sp, #0x10
 800daf2: af00         	add	r7, sp, #0x0
 800daf4: 60f8         	str	r0, [r7, #0xc]
 800daf6: 60b9         	str	r1, [r7, #0x8]
 800daf8: 607a         	str	r2, [r7, #0x4]
; 	chunk_set(h, c, FREE_PREV, prev);
 800dafa: 687b         	ldr	r3, [r7, #0x4]
 800dafc: 2202         	movs	r2, #0x2
 800dafe: 68b9         	ldr	r1, [r7, #0x8]
 800db00: 68f8         	ldr	r0, [r7, #0xc]
 800db02: f7ff ff56    	bl	0x800d9b2 <chunk_set>   @ imm = #-0x154
; }
 800db06: bf00         	nop
 800db08: 3710         	adds	r7, #0x10
 800db0a: 46bd         	mov	sp, r7
 800db0c: bd80         	pop	{r7, pc}

0800db0e <set_next_free_chunk>:
; {
 800db0e: b580         	push	{r7, lr}
 800db10: b084         	sub	sp, #0x10
 800db12: af00         	add	r7, sp, #0x0
 800db14: 60f8         	str	r0, [r7, #0xc]
 800db16: 60b9         	str	r1, [r7, #0x8]
 800db18: 607a         	str	r2, [r7, #0x4]
; 	chunk_set(h, c, FREE_NEXT, next);
 800db1a: 687b         	ldr	r3, [r7, #0x4]
 800db1c: 2203         	movs	r2, #0x3
 800db1e: 68b9         	ldr	r1, [r7, #0x8]
 800db20: 68f8         	ldr	r0, [r7, #0xc]
 800db22: f7ff ff46    	bl	0x800d9b2 <chunk_set>   @ imm = #-0x174
; }
 800db26: bf00         	nop
 800db28: 3710         	adds	r7, #0x10
 800db2a: 46bd         	mov	sp, r7
 800db2c: bd80         	pop	{r7, pc}

0800db2e <set_left_chunk_size>:
; {
 800db2e: b580         	push	{r7, lr}
 800db30: b084         	sub	sp, #0x10
 800db32: af00         	add	r7, sp, #0x0
 800db34: 60f8         	str	r0, [r7, #0xc]
 800db36: 60b9         	str	r1, [r7, #0x8]
 800db38: 607a         	str	r2, [r7, #0x4]
; 	chunk_set(h, c, LEFT_SIZE, size);
 800db3a: 687b         	ldr	r3, [r7, #0x4]
 800db3c: 2200         	movs	r2, #0x0
 800db3e: 68b9         	ldr	r1, [r7, #0x8]
 800db40: 68f8         	ldr	r0, [r7, #0xc]
 800db42: f7ff ff36    	bl	0x800d9b2 <chunk_set>   @ imm = #-0x194
; }
 800db46: bf00         	nop
 800db48: 3710         	adds	r7, #0x10
 800db4a: 46bd         	mov	sp, r7
 800db4c: bd80         	pop	{r7, pc}

0800db4e <solo_free_header>:
; {
 800db4e: b580         	push	{r7, lr}
 800db50: b082         	sub	sp, #0x8
 800db52: af00         	add	r7, sp, #0x0
 800db54: 6078         	str	r0, [r7, #0x4]
 800db56: 6039         	str	r1, [r7]
; 	return big_heap(h) && (chunk_size(h, c) == 1U);
 800db58: 6878         	ldr	r0, [r7, #0x4]
 800db5a: f7ff feed    	bl	0x800d938 <big_heap>    @ imm = #-0x226
 800db5e: 4603         	mov	r3, r0
 800db60: 2b00         	cmp	r3, #0x0
 800db62: d008         	beq	0x800db76 <solo_free_header+0x28> @ imm = #0x10
 800db64: 6839         	ldr	r1, [r7]
 800db66: 6878         	ldr	r0, [r7, #0x4]
 800db68: f7ff ff4c    	bl	0x800da04 <chunk_size>  @ imm = #-0x168
 800db6c: 4603         	mov	r3, r0
 800db6e: 2b01         	cmp	r3, #0x1
 800db70: d101         	bne	0x800db76 <solo_free_header+0x28> @ imm = #0x2
 800db72: 2301         	movs	r3, #0x1
 800db74: e000         	b	0x800db78 <solo_free_header+0x2a> @ imm = #0x0
 800db76: 2300         	movs	r3, #0x0
 800db78: f003 0301    	and	r3, r3, #0x1
 800db7c: b2db         	uxtb	r3, r3
; }
 800db7e: 4618         	mov	r0, r3
 800db80: 3708         	adds	r7, #0x8
 800db82: 46bd         	mov	sp, r7
 800db84: bd80         	pop	{r7, pc}

0800db86 <chunk_header_bytes>:
; {
 800db86: b580         	push	{r7, lr}
 800db88: b082         	sub	sp, #0x8
 800db8a: af00         	add	r7, sp, #0x0
 800db8c: 6078         	str	r0, [r7, #0x4]
; 	return big_heap(h) ? 8 : 4;
 800db8e: 6878         	ldr	r0, [r7, #0x4]
 800db90: f7ff fed2    	bl	0x800d938 <big_heap>    @ imm = #-0x25c
 800db94: 4603         	mov	r3, r0
 800db96: 2b00         	cmp	r3, #0x0
 800db98: d001         	beq	0x800db9e <chunk_header_bytes+0x18> @ imm = #0x2
 800db9a: 2308         	movs	r3, #0x8
 800db9c: e000         	b	0x800dba0 <chunk_header_bytes+0x1a> @ imm = #0x0
 800db9e: 2304         	movs	r3, #0x4
; }
 800dba0: 4618         	mov	r0, r3
 800dba2: 3708         	adds	r7, #0x8
 800dba4: 46bd         	mov	sp, r7
 800dba6: bd80         	pop	{r7, pc}

0800dba8 <heap_footer_bytes>:
; {
 800dba8: b580         	push	{r7, lr}
 800dbaa: b082         	sub	sp, #0x8
 800dbac: af00         	add	r7, sp, #0x0
 800dbae: 6078         	str	r0, [r7, #0x4]
; 	return big_heap_bytes(size) ? 8 : 4;
 800dbb0: 6878         	ldr	r0, [r7, #0x4]
 800dbb2: f7ff feb3    	bl	0x800d91c <big_heap_bytes> @ imm = #-0x29a
 800dbb6: 4603         	mov	r3, r0
 800dbb8: 2b00         	cmp	r3, #0x0
 800dbba: d001         	beq	0x800dbc0 <heap_footer_bytes+0x18> @ imm = #0x2
 800dbbc: 2308         	movs	r3, #0x8
 800dbbe: e000         	b	0x800dbc2 <heap_footer_bytes+0x1a> @ imm = #0x0
 800dbc0: 2304         	movs	r3, #0x4
; }
 800dbc2: 4618         	mov	r0, r3
 800dbc4: 3708         	adds	r7, #0x8
 800dbc6: 46bd         	mov	sp, r7
 800dbc8: bd80         	pop	{r7, pc}

0800dbca <chunksz>:
; {
 800dbca: b480         	push	{r7}
 800dbcc: b083         	sub	sp, #0xc
 800dbce: af00         	add	r7, sp, #0x0
 800dbd0: 6078         	str	r0, [r7, #0x4]
; 	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
 800dbd2: 687b         	ldr	r3, [r7, #0x4]
 800dbd4: 3307         	adds	r3, #0x7
 800dbd6: 08db         	lsrs	r3, r3, #0x3
; }
 800dbd8: 4618         	mov	r0, r3
 800dbda: 370c         	adds	r7, #0xc
 800dbdc: 46bd         	mov	sp, r7
 800dbde: bc80         	pop	{r7}
 800dbe0: 4770         	bx	lr

0800dbe2 <bytes_to_chunksz>:
; {
 800dbe2: b580         	push	{r7, lr}
 800dbe4: b082         	sub	sp, #0x8
 800dbe6: af00         	add	r7, sp, #0x0
 800dbe8: 6078         	str	r0, [r7, #0x4]
 800dbea: 6039         	str	r1, [r7]
; 	return chunksz(chunk_header_bytes(h) + bytes);
 800dbec: 6878         	ldr	r0, [r7, #0x4]
 800dbee: f7ff ffca    	bl	0x800db86 <chunk_header_bytes> @ imm = #-0x6c
 800dbf2: 4602         	mov	r2, r0
 800dbf4: 683b         	ldr	r3, [r7]
 800dbf6: 4413         	add	r3, r2
 800dbf8: 4618         	mov	r0, r3
 800dbfa: f7ff ffe6    	bl	0x800dbca <chunksz>     @ imm = #-0x34
 800dbfe: 4603         	mov	r3, r0
; }
 800dc00: 4618         	mov	r0, r3
 800dc02: 3708         	adds	r7, #0x8
 800dc04: 46bd         	mov	sp, r7
 800dc06: bd80         	pop	{r7, pc}

0800dc08 <min_chunk_size>:
; {
 800dc08: b580         	push	{r7, lr}
 800dc0a: b082         	sub	sp, #0x8
 800dc0c: af00         	add	r7, sp, #0x0
 800dc0e: 6078         	str	r0, [r7, #0x4]
; 	return bytes_to_chunksz(h, 1);
 800dc10: 2101         	movs	r1, #0x1
 800dc12: 6878         	ldr	r0, [r7, #0x4]
 800dc14: f7ff ffe5    	bl	0x800dbe2 <bytes_to_chunksz> @ imm = #-0x36
 800dc18: 4603         	mov	r3, r0
; }
 800dc1a: 4618         	mov	r0, r3
 800dc1c: 3708         	adds	r7, #0x8
 800dc1e: 46bd         	mov	sp, r7
 800dc20: bd80         	pop	{r7, pc}

0800dc22 <bucket_idx>:
; {
 800dc22: b580         	push	{r7, lr}
 800dc24: b084         	sub	sp, #0x10
 800dc26: af00         	add	r7, sp, #0x0
 800dc28: 6078         	str	r0, [r7, #0x4]
 800dc2a: 6039         	str	r1, [r7]
; 	unsigned int usable_sz = sz - min_chunk_size(h) + 1;
 800dc2c: 6878         	ldr	r0, [r7, #0x4]
 800dc2e: f7ff ffeb    	bl	0x800dc08 <min_chunk_size> @ imm = #-0x2a
 800dc32: 4602         	mov	r2, r0
 800dc34: 683b         	ldr	r3, [r7]
 800dc36: 1a9b         	subs	r3, r3, r2
 800dc38: 3301         	adds	r3, #0x1
 800dc3a: 60fb         	str	r3, [r7, #0xc]
; 	return 31 - __builtin_clz(usable_sz);
 800dc3c: 68fb         	ldr	r3, [r7, #0xc]
 800dc3e: fab3 f383    	clz	r3, r3
 800dc42: f1c3 031f    	rsb.w	r3, r3, #0x1f
; }
 800dc46: 4618         	mov	r0, r3
 800dc48: 3710         	adds	r7, #0x10
 800dc4a: 46bd         	mov	sp, r7
 800dc4c: bd80         	pop	{r7, pc}

0800dc4e <free_list_add_bidx>:
; {
 800dc4e: b580         	push	{r7, lr}
 800dc50: b088         	sub	sp, #0x20
 800dc52: af00         	add	r7, sp, #0x0
 800dc54: 60f8         	str	r0, [r7, #0xc]
 800dc56: 60b9         	str	r1, [r7, #0x8]
 800dc58: 607a         	str	r2, [r7, #0x4]
; 	struct z_heap_bucket *b = &h->buckets[bidx];
 800dc5a: 687b         	ldr	r3, [r7, #0x4]
 800dc5c: 3304         	adds	r3, #0x4
 800dc5e: 009b         	lsls	r3, r3, #0x2
 800dc60: 68fa         	ldr	r2, [r7, #0xc]
 800dc62: 4413         	add	r3, r2
 800dc64: 61fb         	str	r3, [r7, #0x1c]
; 	if (b->next == 0U) {
 800dc66: 69fb         	ldr	r3, [r7, #0x1c]
 800dc68: 681b         	ldr	r3, [r3]
 800dc6a: 2b00         	cmp	r3, #0x0
 800dc6c: d116         	bne	0x800dc9c <free_list_add_bidx+0x4e> @ imm = #0x2c
; 		h->avail_buckets |= BIT(bidx);
 800dc6e: 68fb         	ldr	r3, [r7, #0xc]
 800dc70: 68da         	ldr	r2, [r3, #0xc]
 800dc72: 2101         	movs	r1, #0x1
 800dc74: 687b         	ldr	r3, [r7, #0x4]
 800dc76: fa01 f303    	lsl.w	r3, r1, r3
 800dc7a: 431a         	orrs	r2, r3
 800dc7c: 68fb         	ldr	r3, [r7, #0xc]
 800dc7e: 60da         	str	r2, [r3, #0xc]
; 		b->next = c;
 800dc80: 69fb         	ldr	r3, [r7, #0x1c]
 800dc82: 68ba         	ldr	r2, [r7, #0x8]
 800dc84: 601a         	str	r2, [r3]
; 		set_prev_free_chunk(h, c, c);
 800dc86: 68ba         	ldr	r2, [r7, #0x8]
 800dc88: 68b9         	ldr	r1, [r7, #0x8]
 800dc8a: 68f8         	ldr	r0, [r7, #0xc]
 800dc8c: f7ff ff2f    	bl	0x800daee <set_prev_free_chunk> @ imm = #-0x1a2
; 		set_next_free_chunk(h, c, c);
 800dc90: 68ba         	ldr	r2, [r7, #0x8]
 800dc92: 68b9         	ldr	r1, [r7, #0x8]
 800dc94: 68f8         	ldr	r0, [r7, #0xc]
 800dc96: f7ff ff3a    	bl	0x800db0e <set_next_free_chunk> @ imm = #-0x18c
; }
 800dc9a: e01b         	b	0x800dcd4 <free_list_add_bidx+0x86> @ imm = #0x36
; 		chunkid_t second = b->next;
 800dc9c: 69fb         	ldr	r3, [r7, #0x1c]
 800dc9e: 681b         	ldr	r3, [r3]
 800dca0: 61bb         	str	r3, [r7, #0x18]
; 		chunkid_t first = prev_free_chunk(h, second);
 800dca2: 69b9         	ldr	r1, [r7, #0x18]
 800dca4: 68f8         	ldr	r0, [r7, #0xc]
 800dca6: f7ff ff13    	bl	0x800dad0 <prev_free_chunk> @ imm = #-0x1da
 800dcaa: 6178         	str	r0, [r7, #0x14]
; 		set_prev_free_chunk(h, c, first);
 800dcac: 697a         	ldr	r2, [r7, #0x14]
 800dcae: 68b9         	ldr	r1, [r7, #0x8]
 800dcb0: 68f8         	ldr	r0, [r7, #0xc]
 800dcb2: f7ff ff1c    	bl	0x800daee <set_prev_free_chunk> @ imm = #-0x1c8
; 		set_next_free_chunk(h, c, second);
 800dcb6: 69ba         	ldr	r2, [r7, #0x18]
 800dcb8: 68b9         	ldr	r1, [r7, #0x8]
 800dcba: 68f8         	ldr	r0, [r7, #0xc]
 800dcbc: f7ff ff27    	bl	0x800db0e <set_next_free_chunk> @ imm = #-0x1b2
; 		set_next_free_chunk(h, first, c);
 800dcc0: 68ba         	ldr	r2, [r7, #0x8]
 800dcc2: 6979         	ldr	r1, [r7, #0x14]
 800dcc4: 68f8         	ldr	r0, [r7, #0xc]
 800dcc6: f7ff ff22    	bl	0x800db0e <set_next_free_chunk> @ imm = #-0x1bc
; 		set_prev_free_chunk(h, second, c);
 800dcca: 68ba         	ldr	r2, [r7, #0x8]
 800dccc: 69b9         	ldr	r1, [r7, #0x18]
 800dcce: 68f8         	ldr	r0, [r7, #0xc]
 800dcd0: f7ff ff0d    	bl	0x800daee <set_prev_free_chunk> @ imm = #-0x1e6
; }
 800dcd4: bf00         	nop
 800dcd6: 3720         	adds	r7, #0x20
 800dcd8: 46bd         	mov	sp, r7
 800dcda: bd80         	pop	{r7, pc}

0800dcdc <free_list_add>:
; {
 800dcdc: b580         	push	{r7, lr}
 800dcde: b084         	sub	sp, #0x10
 800dce0: af00         	add	r7, sp, #0x0
 800dce2: 6078         	str	r0, [r7, #0x4]
 800dce4: 6039         	str	r1, [r7]
; 	if (!solo_free_header(h, c)) {
 800dce6: 6839         	ldr	r1, [r7]
 800dce8: 6878         	ldr	r0, [r7, #0x4]
 800dcea: f7ff ff30    	bl	0x800db4e <solo_free_header> @ imm = #-0x1a0
 800dcee: 4603         	mov	r3, r0
 800dcf0: f083 0301    	eor	r3, r3, #0x1
 800dcf4: b2db         	uxtb	r3, r3
 800dcf6: 2b00         	cmp	r3, #0x0
 800dcf8: d00e         	beq	0x800dd18 <free_list_add+0x3c> @ imm = #0x1c
; 		int bidx = bucket_idx(h, chunk_size(h, c));
 800dcfa: 6839         	ldr	r1, [r7]
 800dcfc: 6878         	ldr	r0, [r7, #0x4]
 800dcfe: f7ff fe81    	bl	0x800da04 <chunk_size>  @ imm = #-0x2fe
 800dd02: 4603         	mov	r3, r0
 800dd04: 4619         	mov	r1, r3
 800dd06: 6878         	ldr	r0, [r7, #0x4]
 800dd08: f7ff ff8b    	bl	0x800dc22 <bucket_idx>  @ imm = #-0xea
 800dd0c: 60f8         	str	r0, [r7, #0xc]
; 		free_list_add_bidx(h, c, bidx);
 800dd0e: 68fa         	ldr	r2, [r7, #0xc]
 800dd10: 6839         	ldr	r1, [r7]
 800dd12: 6878         	ldr	r0, [r7, #0x4]
 800dd14: f7ff ff9b    	bl	0x800dc4e <free_list_add_bidx> @ imm = #-0xca
; }
 800dd18: bf00         	nop
 800dd1a: 3710         	adds	r7, #0x10
 800dd1c: 46bd         	mov	sp, r7
 800dd1e: bd80         	pop	{r7, pc}

0800dd20 <sys_heap_init>:
; {
 800dd20: b580         	push	{r7, lr}
 800dd22: b08c         	sub	sp, #0x30
 800dd24: af00         	add	r7, sp, #0x0
 800dd26: 60f8         	str	r0, [r7, #0xc]
 800dd28: 60b9         	str	r1, [r7, #0x8]
 800dd2a: 607a         	str	r2, [r7, #0x4]
; 	bytes -= heap_footer_bytes(bytes);
 800dd2c: 6878         	ldr	r0, [r7, #0x4]
 800dd2e: f7ff ff3b    	bl	0x800dba8 <heap_footer_bytes> @ imm = #-0x18a
 800dd32: 4602         	mov	r2, r0
 800dd34: 687b         	ldr	r3, [r7, #0x4]
 800dd36: 1a9b         	subs	r3, r3, r2
 800dd38: 607b         	str	r3, [r7, #0x4]
; 	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
 800dd3a: 68bb         	ldr	r3, [r7, #0x8]
 800dd3c: 3307         	adds	r3, #0x7
 800dd3e: f023 0307    	bic	r3, r3, #0x7
 800dd42: 62bb         	str	r3, [r7, #0x28]
; 	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
 800dd44: 68ba         	ldr	r2, [r7, #0x8]
 800dd46: 687b         	ldr	r3, [r7, #0x4]
 800dd48: 4413         	add	r3, r2
 800dd4a: f023 0307    	bic	r3, r3, #0x7
 800dd4e: 627b         	str	r3, [r7, #0x24]
; 	chunksz_t heap_sz = (end - addr) / CHUNK_UNIT;
 800dd50: 6a7a         	ldr	r2, [r7, #0x24]
 800dd52: 6abb         	ldr	r3, [r7, #0x28]
 800dd54: 1ad3         	subs	r3, r2, r3
 800dd56: 08db         	lsrs	r3, r3, #0x3
 800dd58: 623b         	str	r3, [r7, #0x20]
; 	struct z_heap *h = (struct z_heap *)addr;
 800dd5a: 6abb         	ldr	r3, [r7, #0x28]
 800dd5c: 61fb         	str	r3, [r7, #0x1c]
; 	heap->heap = h;
 800dd5e: 68fb         	ldr	r3, [r7, #0xc]
 800dd60: 69fa         	ldr	r2, [r7, #0x1c]
 800dd62: 601a         	str	r2, [r3]
; 	h->end_chunk = heap_sz;
 800dd64: 69fb         	ldr	r3, [r7, #0x1c]
 800dd66: 6a3a         	ldr	r2, [r7, #0x20]
 800dd68: 609a         	str	r2, [r3, #0x8]
; 	h->avail_buckets = 0;
 800dd6a: 69fb         	ldr	r3, [r7, #0x1c]
 800dd6c: 2200         	movs	r2, #0x0
 800dd6e: 60da         	str	r2, [r3, #0xc]
; 	int nb_buckets = bucket_idx(h, heap_sz) + 1;
 800dd70: 6a39         	ldr	r1, [r7, #0x20]
 800dd72: 69f8         	ldr	r0, [r7, #0x1c]
 800dd74: f7ff ff55    	bl	0x800dc22 <bucket_idx>  @ imm = #-0x156
 800dd78: 4603         	mov	r3, r0
 800dd7a: 3301         	adds	r3, #0x1
 800dd7c: 61bb         	str	r3, [r7, #0x18]
; 	chunksz_t chunk0_size = chunksz(sizeof(struct z_heap) +
 800dd7e: 69bb         	ldr	r3, [r7, #0x18]
 800dd80: 3304         	adds	r3, #0x4
 800dd82: 009b         	lsls	r3, r3, #0x2
 800dd84: 4618         	mov	r0, r3
 800dd86: f7ff ff20    	bl	0x800dbca <chunksz>     @ imm = #-0x1c0
 800dd8a: 6178         	str	r0, [r7, #0x14]
; 	for (int i = 0; i < nb_buckets; i++) {
 800dd8c: 2300         	movs	r3, #0x0
 800dd8e: 62fb         	str	r3, [r7, #0x2c]
 800dd90: e008         	b	0x800dda4 <sys_heap_init+0x84> @ imm = #0x10
; 		h->buckets[i].next = 0;
 800dd92: 69fb         	ldr	r3, [r7, #0x1c]
 800dd94: 6afa         	ldr	r2, [r7, #0x2c]
 800dd96: 3204         	adds	r2, #0x4
 800dd98: 2100         	movs	r1, #0x0
 800dd9a: f843 1022    	str.w	r1, [r3, r2, lsl #2]
; 	for (int i = 0; i < nb_buckets; i++) {
 800dd9e: 6afb         	ldr	r3, [r7, #0x2c]
 800dda0: 3301         	adds	r3, #0x1
 800dda2: 62fb         	str	r3, [r7, #0x2c]
 800dda4: 6afa         	ldr	r2, [r7, #0x2c]
 800dda6: 69bb         	ldr	r3, [r7, #0x18]
 800dda8: 429a         	cmp	r2, r3
 800ddaa: dbf2         	blt	0x800dd92 <sys_heap_init+0x72> @ imm = #-0x1c
; 	set_chunk_size(h, 0, chunk0_size);
 800ddac: 697a         	ldr	r2, [r7, #0x14]
 800ddae: 2100         	movs	r1, #0x0
 800ddb0: 69f8         	ldr	r0, [r7, #0x1c]
 800ddb2: f7ff fe7c    	bl	0x800daae <set_chunk_size> @ imm = #-0x308
; 	set_left_chunk_size(h, 0, 0);
 800ddb6: 2200         	movs	r2, #0x0
 800ddb8: 2100         	movs	r1, #0x0
 800ddba: 69f8         	ldr	r0, [r7, #0x1c]
 800ddbc: f7ff feb7    	bl	0x800db2e <set_left_chunk_size> @ imm = #-0x292
; 	set_chunk_used(h, 0, true);
 800ddc0: 2201         	movs	r2, #0x1
 800ddc2: 2100         	movs	r1, #0x0
 800ddc4: 69f8         	ldr	r0, [r7, #0x1c]
 800ddc6: f7ff fe2d    	bl	0x800da24 <set_chunk_used> @ imm = #-0x3a6
; 	set_chunk_size(h, chunk0_size, heap_sz - chunk0_size);
 800ddca: 6a3a         	ldr	r2, [r7, #0x20]
 800ddcc: 697b         	ldr	r3, [r7, #0x14]
 800ddce: 1ad3         	subs	r3, r2, r3
 800ddd0: 461a         	mov	r2, r3
 800ddd2: 6979         	ldr	r1, [r7, #0x14]
 800ddd4: 69f8         	ldr	r0, [r7, #0x1c]
 800ddd6: f7ff fe6a    	bl	0x800daae <set_chunk_size> @ imm = #-0x32c
; 	set_left_chunk_size(h, chunk0_size, chunk0_size);
 800ddda: 697a         	ldr	r2, [r7, #0x14]
 800dddc: 6979         	ldr	r1, [r7, #0x14]
 800ddde: 69f8         	ldr	r0, [r7, #0x1c]
 800dde0: f7ff fea5    	bl	0x800db2e <set_left_chunk_size> @ imm = #-0x2b6
; 	set_chunk_size(h, heap_sz, 0);
 800dde4: 2200         	movs	r2, #0x0
 800dde6: 6a39         	ldr	r1, [r7, #0x20]
 800dde8: 69f8         	ldr	r0, [r7, #0x1c]
 800ddea: f7ff fe60    	bl	0x800daae <set_chunk_size> @ imm = #-0x340
; 	set_left_chunk_size(h, heap_sz, heap_sz - chunk0_size);
 800ddee: 6a3a         	ldr	r2, [r7, #0x20]
 800ddf0: 697b         	ldr	r3, [r7, #0x14]
 800ddf2: 1ad3         	subs	r3, r2, r3
 800ddf4: 461a         	mov	r2, r3
 800ddf6: 6a39         	ldr	r1, [r7, #0x20]
 800ddf8: 69f8         	ldr	r0, [r7, #0x1c]
 800ddfa: f7ff fe98    	bl	0x800db2e <set_left_chunk_size> @ imm = #-0x2d0
; 	set_chunk_used(h, heap_sz, true);
 800ddfe: 2201         	movs	r2, #0x1
 800de00: 6a39         	ldr	r1, [r7, #0x20]
 800de02: 69f8         	ldr	r0, [r7, #0x1c]
 800de04: f7ff fe0e    	bl	0x800da24 <set_chunk_used> @ imm = #-0x3e4
; 	free_list_add(h, chunk0_size);
 800de08: 6979         	ldr	r1, [r7, #0x14]
 800de0a: 69f8         	ldr	r0, [r7, #0x1c]
 800de0c: f7ff ff66    	bl	0x800dcdc <free_list_add> @ imm = #-0x134
; }
 800de10: bf00         	nop
 800de12: 3730         	adds	r7, #0x30
 800de14: 46bd         	mov	sp, r7
 800de16: bd80         	pop	{r7, pc}

0800de18 <ptr_in_rodata>:
; {
 800de18: b580         	push	{r7, lr}
 800de1a: b082         	sub	sp, #0x8
 800de1c: af00         	add	r7, sp, #0x0
 800de1e: 6078         	str	r0, [r7, #0x4]
; 	return linker_is_in_rodata(addr);
 800de20: 6878         	ldr	r0, [r7, #0x4]
 800de22: f7f2 fe63    	bl	0x8000aec <linker_is_in_rodata> @ imm = #-0xd33a
 800de26: 4603         	mov	r3, r0
; }
 800de28: 4618         	mov	r0, r3
 800de2a: 3708         	adds	r7, #0x8
 800de2c: 46bd         	mov	sp, r7
 800de2e: bd80         	pop	{r7, pc}

0800de30 <cbprintf_via_va_list>:
; {
 800de30: b590         	push	{r4, r7, lr}
 800de32: b087         	sub	sp, #0x1c
 800de34: af00         	add	r7, sp, #0x0
 800de36: 60f8         	str	r0, [r7, #0xc]
 800de38: 60b9         	str	r1, [r7, #0x8]
 800de3a: 607a         	str	r2, [r7, #0x4]
 800de3c: 603b         	str	r3, [r7]
; 	u.ptr = buf;
 800de3e: 6abb         	ldr	r3, [r7, #0x28]
 800de40: 617b         	str	r3, [r7, #0x14]
; 	return formatter(out, ctx, fmt, u.ap);
 800de42: 68bc         	ldr	r4, [r7, #0x8]
 800de44: 697b         	ldr	r3, [r7, #0x14]
 800de46: 683a         	ldr	r2, [r7]
 800de48: 6879         	ldr	r1, [r7, #0x4]
 800de4a: 68f8         	ldr	r0, [r7, #0xc]
 800de4c: 47a0         	blx	r4
 800de4e: 4603         	mov	r3, r0
; }
 800de50: 4618         	mov	r0, r3
 800de52: 371c         	adds	r7, #0x1c
 800de54: 46bd         	mov	sp, r7
 800de56: bd90         	pop	{r4, r7, pc}

0800de58 <cbpprintf_external>:
; {
 800de58: b580         	push	{r7, lr}
 800de5a: b090         	sub	sp, #0x40
 800de5c: af02         	add	r7, sp, #0x8
 800de5e: 60f8         	str	r0, [r7, #0xc]
 800de60: 60b9         	str	r1, [r7, #0x8]
 800de62: 607a         	str	r2, [r7, #0x4]
 800de64: 603b         	str	r3, [r7]
; 	uint8_t *buf = packaged;
 800de66: 683b         	ldr	r3, [r7]
 800de68: 62fb         	str	r3, [r7, #0x2c]
; 	struct cbprintf_package_hdr_ext *hdr = packaged;
 800de6a: 683b         	ldr	r3, [r7]
 800de6c: 62bb         	str	r3, [r7, #0x28]
; 	if (buf == NULL) {
 800de6e: 6afb         	ldr	r3, [r7, #0x2c]
 800de70: 2b00         	cmp	r3, #0x0
 800de72: d102         	bne	0x800de7a <cbpprintf_external+0x22> @ imm = #0x4
; 		return -EINVAL;
 800de74: f06f 0315    	mvn	r3, #0x15
 800de78: e043         	b	0x800df02 <cbpprintf_external+0xaa> @ imm = #0x86
; 	args_size = hdr->hdr.desc.len * sizeof(int);
 800de7a: 6abb         	ldr	r3, [r7, #0x28]
 800de7c: 781b         	ldrb	r3, [r3]
 800de7e: 009b         	lsls	r3, r3, #0x2
 800de80: 627b         	str	r3, [r7, #0x24]
; 	s_nbr     = hdr->hdr.desc.str_cnt;
 800de82: 6abb         	ldr	r3, [r7, #0x28]
 800de84: 785b         	ldrb	r3, [r3, #0x1]
 800de86: 623b         	str	r3, [r7, #0x20]
; 	ros_nbr   = hdr->hdr.desc.ro_str_cnt;
 800de88: 6abb         	ldr	r3, [r7, #0x28]
 800de8a: 789b         	ldrb	r3, [r3, #0x2]
 800de8c: 61fb         	str	r3, [r7, #0x1c]
; 	rws_nbr   = hdr->hdr.desc.rw_str_cnt;
 800de8e: 6abb         	ldr	r3, [r7, #0x28]
 800de90: 78db         	ldrb	r3, [r3, #0x3]
 800de92: 61bb         	str	r3, [r7, #0x18]
; 	s = (char *)(buf + args_size + ros_nbr + 2 * rws_nbr);
 800de94: 6a7a         	ldr	r2, [r7, #0x24]
 800de96: 69fb         	ldr	r3, [r7, #0x1c]
 800de98: 441a         	add	r2, r3
 800de9a: 69bb         	ldr	r3, [r7, #0x18]
 800de9c: 005b         	lsls	r3, r3, #0x1
 800de9e: 4413         	add	r3, r2
 800dea0: 6afa         	ldr	r2, [r7, #0x2c]
 800dea2: 4413         	add	r3, r2
 800dea4: 637b         	str	r3, [r7, #0x34]
; 	for (i = 0; i < s_nbr; i++) {
 800dea6: 2300         	movs	r3, #0x0
 800dea8: 633b         	str	r3, [r7, #0x30]
 800deaa: e018         	b	0x800dede <cbpprintf_external+0x86> @ imm = #0x30
; 		s_idx = *(uint8_t *)s;
 800deac: 6b7b         	ldr	r3, [r7, #0x34]
 800deae: 781b         	ldrb	r3, [r3]
 800deb0: 617b         	str	r3, [r7, #0x14]
; 		++s;
 800deb2: 6b7b         	ldr	r3, [r7, #0x34]
 800deb4: 3301         	adds	r3, #0x1
 800deb6: 637b         	str	r3, [r7, #0x34]
; 		ps = (char **)(buf + s_idx * sizeof(int));
 800deb8: 697b         	ldr	r3, [r7, #0x14]
 800deba: 009b         	lsls	r3, r3, #0x2
 800debc: 6afa         	ldr	r2, [r7, #0x2c]
 800debe: 4413         	add	r3, r2
 800dec0: 613b         	str	r3, [r7, #0x10]
; 		*ps = s;
 800dec2: 693b         	ldr	r3, [r7, #0x10]
 800dec4: 6b7a         	ldr	r2, [r7, #0x34]
 800dec6: 601a         	str	r2, [r3]
; 		s += strlen(s) + 1;
 800dec8: 6b78         	ldr	r0, [r7, #0x34]
 800deca: f7f2 fc7b    	bl	0x80007c4 <strlen>      @ imm = #-0xd70a
 800dece: 4603         	mov	r3, r0
 800ded0: 3301         	adds	r3, #0x1
 800ded2: 6b7a         	ldr	r2, [r7, #0x34]
 800ded4: 4413         	add	r3, r2
 800ded6: 637b         	str	r3, [r7, #0x34]
; 	for (i = 0; i < s_nbr; i++) {
 800ded8: 6b3b         	ldr	r3, [r7, #0x30]
 800deda: 3301         	adds	r3, #0x1
 800dedc: 633b         	str	r3, [r7, #0x30]
 800dede: 6b3a         	ldr	r2, [r7, #0x30]
 800dee0: 6a3b         	ldr	r3, [r7, #0x20]
 800dee2: 429a         	cmp	r2, r3
 800dee4: d3e2         	blo	0x800deac <cbpprintf_external+0x54> @ imm = #-0x3c
; 	buf += sizeof(*hdr);
 800dee6: 6afb         	ldr	r3, [r7, #0x2c]
 800dee8: 3308         	adds	r3, #0x8
 800deea: 62fb         	str	r3, [r7, #0x2c]
; 	return cbprintf_via_va_list(out, formatter, ctx, hdr->fmt, buf);
 800deec: 6abb         	ldr	r3, [r7, #0x28]
 800deee: 685a         	ldr	r2, [r3, #0x4]
 800def0: 6afb         	ldr	r3, [r7, #0x2c]
 800def2: 9300         	str	r3, [sp]
 800def4: 4613         	mov	r3, r2
 800def6: 687a         	ldr	r2, [r7, #0x4]
 800def8: 68b9         	ldr	r1, [r7, #0x8]
 800defa: 68f8         	ldr	r0, [r7, #0xc]
 800defc: f7ff ff98    	bl	0x800de30 <cbprintf_via_va_list> @ imm = #-0xd0
 800df00: 4603         	mov	r3, r0
; }
 800df02: 4618         	mov	r0, r3
 800df04: 3738         	adds	r7, #0x38
 800df06: 46bd         	mov	sp, r7
 800df08: bd80         	pop	{r7, pc}

0800df0a <arch_printk_char_out>:
; {
 800df0a: b480         	push	{r7}
 800df0c: b083         	sub	sp, #0xc
 800df0e: af00         	add	r7, sp, #0x0
 800df10: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 800df12: 2300         	movs	r3, #0x0
; }
 800df14: 4618         	mov	r0, r3
 800df16: 370c         	adds	r7, #0xc
 800df18: 46bd         	mov	sp, r7
 800df1a: bc80         	pop	{r7}
 800df1c: 4770         	bx	lr

0800df1e <vprintk>:
; {
 800df1e: b580         	push	{r7, lr}
 800df20: b08c         	sub	sp, #0x30
 800df22: af00         	add	r7, sp, #0x0
 800df24: 6078         	str	r0, [r7, #0x4]
 800df26: 6039         	str	r1, [r7]
; 		z_log_vprintk(fmt, ap);
 800df28: 6839         	ldr	r1, [r7]
 800df2a: 6878         	ldr	r0, [r7, #0x4]
 800df2c: f000 f949    	bl	0x800e1c2 <z_log_vprintk> @ imm = #0x292
; 		return;
 800df30: bf00         	nop
; }
 800df32: 3730         	adds	r7, #0x30
 800df34: 46bd         	mov	sp, r7
 800df36: bd80         	pop	{r7, pc}

0800df38 <printk>:
; {
 800df38: b40f         	push	{r0, r1, r2, r3}
 800df3a: b580         	push	{r7, lr}
 800df3c: b082         	sub	sp, #0x8
 800df3e: af00         	add	r7, sp, #0x0
; 	va_start(ap, fmt);
 800df40: f107 0314    	add.w	r3, r7, #0x14
 800df44: 607b         	str	r3, [r7, #0x4]
; 	vprintk(fmt, ap);
 800df46: 6879         	ldr	r1, [r7, #0x4]
 800df48: 6938         	ldr	r0, [r7, #0x10]
 800df4a: f7ff ffe8    	bl	0x800df1e <vprintk>     @ imm = #-0x30
; }
 800df4e: bf00         	nop
 800df50: 3708         	adds	r7, #0x8
 800df52: 46bd         	mov	sp, r7
 800df54: e8bd 4080    	pop.w	{r7, lr}
 800df58: b004         	add	sp, #0x10
 800df5a: 4770         	bx	lr

0800df5c <k_sched_current_thread_query>:
; {
 800df5c: b580         	push	{r7, lr}
 800df5e: af00         	add	r7, sp, #0x0
; 	return z_impl_k_sched_current_thread_query();
 800df60: f7fd fd2a    	bl	0x800b9b8 <z_impl_k_sched_current_thread_query> @ imm = #-0x25ac
 800df64: 4603         	mov	r3, r0
; }
 800df66: 4618         	mov	r0, r3
 800df68: bd80         	pop	{r7, pc}

0800df6a <k_thread_abort>:
; {
 800df6a: b580         	push	{r7, lr}
 800df6c: b082         	sub	sp, #0x8
 800df6e: af00         	add	r7, sp, #0x0
 800df70: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_thread_abort(thread);
 800df72: 6878         	ldr	r0, [r7, #0x4]
 800df74: f7f5 f804    	bl	0x8002f80 <z_impl_k_thread_abort> @ imm = #-0xaff8
; }
 800df78: bf00         	nop
 800df7a: 3708         	adds	r7, #0x8
 800df7c: 46bd         	mov	sp, r7
 800df7e: bd80         	pop	{r7, pc}

0800df80 <_ConfigAbsSyms>:
; GEN_ABS_SYM_BEGIN (_ConfigAbsSyms)
 800df80: b480         	push	{r7}
 800df82: af00         	add	r7, sp, #0x0
; GEN_ABS_SYM_END
 800df84: bf00         	nop
 800df86: 46bd         	mov	sp, r7
 800df88: bc80         	pop	{r7}
 800df8a: 4770         	bx	lr

0800df8c <st_stm32_common_config>:
; {
 800df8c: b580         	push	{r7, lr}
 800df8e: af00         	add	r7, sp, #0x0
; 	LL_DBGMCU_DisableDBGStopMode();
 800df90: f7f3 f9da    	bl	0x8001348 <LL_DBGMCU_DisableDBGStopMode> @ imm = #-0xcc4c
; 	return 0;
 800df94: 2300         	movs	r3, #0x0
; }
 800df96: 4618         	mov	r0, r3
 800df98: bd80         	pop	{r7, pc}

0800df9a <atomic_add>:
; {
 800df9a: b490         	push	{r4, r7}
 800df9c: b082         	sub	sp, #0x8
 800df9e: af00         	add	r7, sp, #0x0
 800dfa0: 6078         	str	r0, [r7, #0x4]
 800dfa2: 6039         	str	r1, [r7]
; 	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
 800dfa4: 683a         	ldr	r2, [r7]
 800dfa6: 687b         	ldr	r3, [r7, #0x4]
 800dfa8: f3bf 8f5b    	dmb	ish
 800dfac: e853 1f00    	ldrex	r1, [r3]
 800dfb0: eb01 0002    	add.w	r0, r1, r2
 800dfb4: e843 0400    	strex	r4, r0, [r3]
 800dfb8: 2c00         	cmp	r4, #0x0
 800dfba: d1f7         	bne	0x800dfac <atomic_add+0x12> @ imm = #-0x12
 800dfbc: f3bf 8f5b    	dmb	ish
 800dfc0: 460b         	mov	r3, r1
; }
 800dfc2: 4618         	mov	r0, r3
 800dfc4: 3708         	adds	r7, #0x8
 800dfc6: 46bd         	mov	sp, r7
 800dfc8: bc90         	pop	{r4, r7}
 800dfca: 4770         	bx	lr

0800dfcc <atomic_sub>:
; {
 800dfcc: b490         	push	{r4, r7}
 800dfce: b082         	sub	sp, #0x8
 800dfd0: af00         	add	r7, sp, #0x0
 800dfd2: 6078         	str	r0, [r7, #0x4]
 800dfd4: 6039         	str	r1, [r7]
; 	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
 800dfd6: 683a         	ldr	r2, [r7]
 800dfd8: 687b         	ldr	r3, [r7, #0x4]
 800dfda: f3bf 8f5b    	dmb	ish
 800dfde: e853 1f00    	ldrex	r1, [r3]
 800dfe2: eba1 0002    	sub.w	r0, r1, r2
 800dfe6: e843 0400    	strex	r4, r0, [r3]
 800dfea: 2c00         	cmp	r4, #0x0
 800dfec: d1f7         	bne	0x800dfde <atomic_sub+0x12> @ imm = #-0x12
 800dfee: f3bf 8f5b    	dmb	ish
 800dff2: 460b         	mov	r3, r1
; }
 800dff4: 4618         	mov	r0, r3
 800dff6: 3708         	adds	r7, #0x8
 800dff8: 46bd         	mov	sp, r7
 800dffa: bc90         	pop	{r4, r7}
 800dffc: 4770         	bx	lr

0800dffe <atomic_inc>:
; {
 800dffe: b580         	push	{r7, lr}
 800e000: b082         	sub	sp, #0x8
 800e002: af00         	add	r7, sp, #0x0
 800e004: 6078         	str	r0, [r7, #0x4]
; 	return atomic_add(target, 1);
 800e006: 2101         	movs	r1, #0x1
 800e008: 6878         	ldr	r0, [r7, #0x4]
 800e00a: f7ff ffc6    	bl	0x800df9a <atomic_add>  @ imm = #-0x74
 800e00e: 4603         	mov	r3, r0
; }
 800e010: 4618         	mov	r0, r3
 800e012: 3708         	adds	r7, #0x8
 800e014: 46bd         	mov	sp, r7
 800e016: bd80         	pop	{r7, pc}

0800e018 <atomic_dec>:
; {
 800e018: b580         	push	{r7, lr}
 800e01a: b082         	sub	sp, #0x8
 800e01c: af00         	add	r7, sp, #0x0
 800e01e: 6078         	str	r0, [r7, #0x4]
; 	return atomic_sub(target, 1);
 800e020: 2101         	movs	r1, #0x1
 800e022: 6878         	ldr	r0, [r7, #0x4]
 800e024: f7ff ffd2    	bl	0x800dfcc <atomic_sub>  @ imm = #-0x5c
 800e028: 4603         	mov	r3, r0
; }
 800e02a: 4618         	mov	r0, r3
 800e02c: 3708         	adds	r7, #0x8
 800e02e: 46bd         	mov	sp, r7
 800e030: bd80         	pop	{r7, pc}

0800e032 <z_log_item_is_msg>:
; {
 800e032: b480         	push	{r7}
 800e034: b083         	sub	sp, #0xc
 800e036: af00         	add	r7, sp, #0x0
 800e038: 6078         	str	r0, [r7, #0x4]
; 	return msg->generic.type == Z_LOG_MSG_LOG;
 800e03a: 687b         	ldr	r3, [r7, #0x4]
 800e03c: 781b         	ldrb	r3, [r3]
 800e03e: f003 0304    	and	r3, r3, #0x4
 800e042: b2db         	uxtb	r3, r3
 800e044: 2b00         	cmp	r3, #0x0
 800e046: bf0c         	ite	eq
 800e048: 2301         	moveq	r3, #0x1
 800e04a: 2300         	movne	r3, #0x0
 800e04c: b2db         	uxtb	r3, r3
; }
 800e04e: 4618         	mov	r0, r3
 800e050: 370c         	adds	r7, #0xc
 800e052: 46bd         	mov	sp, r7
 800e054: bc80         	pop	{r7}
 800e056: 4770         	bx	lr

0800e058 <k_msleep>:
; {
 800e058: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 800e05c: b082         	sub	sp, #0x8
 800e05e: af00         	add	r7, sp, #0x0
 800e060: 6078         	str	r0, [r7, #0x4]
; 	return k_sleep(Z_TIMEOUT_MS(ms));
 800e062: 6879         	ldr	r1, [r7, #0x4]
 800e064: ea21 71e1    	bic.w	r1, r1, r1, asr #31
 800e068: 17c8         	asrs	r0, r1, #0x1f
 800e06a: 4688         	mov	r8, r1
 800e06c: 4681         	mov	r9, r0
 800e06e: 4640         	mov	r0, r8
 800e070: 4649         	mov	r1, r9
 800e072: f04f 0400    	mov.w	r4, #0x0
 800e076: f04f 0500    	mov.w	r5, #0x0
 800e07a: 008d         	lsls	r5, r1, #0x2
 800e07c: ea45 7590    	orr.w	r5, r5, r0, lsr #30
 800e080: 0084         	lsls	r4, r0, #0x2
 800e082: 4620         	mov	r0, r4
 800e084: 4629         	mov	r1, r5
 800e086: eb10 0208    	adds.w	r2, r0, r8
 800e08a: eb41 0309    	adc.w	r3, r1, r9
 800e08e: eb12 0a02    	adds.w	r10, r2, r2
 800e092: eb43 0b03    	adc.w	r11, r3, r3
 800e096: 4652         	mov	r2, r10
 800e098: 465b         	mov	r3, r11
 800e09a: 4610         	mov	r0, r2
 800e09c: 4619         	mov	r1, r3
 800e09e: f000 f823    	bl	0x800e0e8 <k_sleep>     @ imm = #0x46
 800e0a2: 4601         	mov	r1, r0
 800e0a4: 460b         	mov	r3, r1
; }
 800e0a6: 4618         	mov	r0, r3
 800e0a8: 3708         	adds	r7, #0x8
 800e0aa: 46bd         	mov	sp, r7
 800e0ac: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

0800e0b0 <k_uptime_get>:
; {
 800e0b0: b580         	push	{r7, lr}
 800e0b2: af00         	add	r7, sp, #0x0
; 	return k_ticks_to_ms_floor64(k_uptime_ticks());
 800e0b4: f000 f826    	bl	0x800e104 <k_uptime_ticks> @ imm = #0x4c
 800e0b8: 4602         	mov	r2, r0
 800e0ba: 460b         	mov	r3, r1
 800e0bc: 4610         	mov	r0, r2
 800e0be: 4619         	mov	r1, r3
 800e0c0: f04f 020a    	mov.w	r2, #0xa
 800e0c4: f04f 0300    	mov.w	r3, #0x0
 800e0c8: f7f2 fb58    	bl	0x800077c <__aeabi_uldivmod> @ imm = #-0xd950
 800e0cc: 4602         	mov	r2, r0
 800e0ce: 460b         	mov	r3, r1
; }
 800e0d0: 4610         	mov	r0, r2
 800e0d2: 4619         	mov	r1, r3
 800e0d4: bd80         	pop	{r7, pc}

0800e0d6 <k_uptime_get_32>:
; {
 800e0d6: b580         	push	{r7, lr}
 800e0d8: af00         	add	r7, sp, #0x0
; 	return (uint32_t)k_uptime_get();
 800e0da: f7ff ffe9    	bl	0x800e0b0 <k_uptime_get> @ imm = #-0x2e
 800e0de: 4602         	mov	r2, r0
 800e0e0: 460b         	mov	r3, r1
 800e0e2: 4613         	mov	r3, r2
; }
 800e0e4: 4618         	mov	r0, r3
 800e0e6: bd80         	pop	{r7, pc}

0800e0e8 <k_sleep>:
; {
 800e0e8: b580         	push	{r7, lr}
 800e0ea: b082         	sub	sp, #0x8
 800e0ec: af00         	add	r7, sp, #0x0
 800e0ee: e9c7 0100    	strd	r0, r1, [r7]
; 	return z_impl_k_sleep(timeout);
 800e0f2: e9d7 0100    	ldrd	r0, r1, [r7]
 800e0f6: f7fd fc1d    	bl	0x800b934 <z_impl_k_sleep> @ imm = #-0x27c6
 800e0fa: 4603         	mov	r3, r0
; }
 800e0fc: 4618         	mov	r0, r3
 800e0fe: 3708         	adds	r7, #0x8
 800e100: 46bd         	mov	sp, r7
 800e102: bd80         	pop	{r7, pc}

0800e104 <k_uptime_ticks>:
; {
 800e104: b580         	push	{r7, lr}
 800e106: af00         	add	r7, sp, #0x0
; 	return z_impl_k_uptime_ticks();
 800e108: f005 ff5e    	bl	0x8013fc8 <z_impl_k_uptime_ticks> @ imm = #0x5ebc
 800e10c: 4602         	mov	r2, r0
 800e10e: 460b         	mov	r3, r1
; }
 800e110: 4610         	mov	r0, r2
 800e112: 4619         	mov	r1, r3
 800e114: bd80         	pop	{r7, pc}

0800e116 <log_backend_init>:
; {
 800e116: b580         	push	{r7, lr}
 800e118: b082         	sub	sp, #0x8
 800e11a: af00         	add	r7, sp, #0x0
 800e11c: 6078         	str	r0, [r7, #0x4]
; 	if (backend->api->init) {
 800e11e: 687b         	ldr	r3, [r7, #0x4]
 800e120: 681b         	ldr	r3, [r3]
 800e122: 68db         	ldr	r3, [r3, #0xc]
 800e124: 2b00         	cmp	r3, #0x0
 800e126: d004         	beq	0x800e132 <log_backend_init+0x1c> @ imm = #0x8
; 		backend->api->init(backend);
 800e128: 687b         	ldr	r3, [r7, #0x4]
 800e12a: 681b         	ldr	r3, [r3]
 800e12c: 68db         	ldr	r3, [r3, #0xc]
 800e12e: 6878         	ldr	r0, [r7, #0x4]
 800e130: 4798         	blx	r3
; }
 800e132: bf00         	nop
 800e134: 3708         	adds	r7, #0x8
 800e136: 46bd         	mov	sp, r7
 800e138: bd80         	pop	{r7, pc}

0800e13a <log_backend_is_ready>:
; {
 800e13a: b580         	push	{r7, lr}
 800e13c: b082         	sub	sp, #0x8
 800e13e: af00         	add	r7, sp, #0x0
 800e140: 6078         	str	r0, [r7, #0x4]
; 	if (backend->api->is_ready != NULL) {
 800e142: 687b         	ldr	r3, [r7, #0x4]
 800e144: 681b         	ldr	r3, [r3]
 800e146: 691b         	ldr	r3, [r3, #0x10]
 800e148: 2b00         	cmp	r3, #0x0
 800e14a: d006         	beq	0x800e15a <log_backend_is_ready+0x20> @ imm = #0xc
; 		return backend->api->is_ready(backend);
 800e14c: 687b         	ldr	r3, [r7, #0x4]
 800e14e: 681b         	ldr	r3, [r3]
 800e150: 691b         	ldr	r3, [r3, #0x10]
 800e152: 6878         	ldr	r0, [r7, #0x4]
 800e154: 4798         	blx	r3
 800e156: 4603         	mov	r3, r0
 800e158: e000         	b	0x800e15c <log_backend_is_ready+0x22> @ imm = #0x0
; 	return 0;
 800e15a: 2300         	movs	r3, #0x0
; }
 800e15c: 4618         	mov	r0, r3
 800e15e: 3708         	adds	r7, #0x8
 800e160: 46bd         	mov	sp, r7
 800e162: bd80         	pop	{r7, pc}

0800e164 <log_backend_msg_process>:
; {
 800e164: b580         	push	{r7, lr}
 800e166: b082         	sub	sp, #0x8
 800e168: af00         	add	r7, sp, #0x0
 800e16a: 6078         	str	r0, [r7, #0x4]
 800e16c: 6039         	str	r1, [r7]
; 	backend->api->process(backend, msg);
 800e16e: 687b         	ldr	r3, [r7, #0x4]
 800e170: 681b         	ldr	r3, [r3]
 800e172: 681b         	ldr	r3, [r3]
 800e174: 6839         	ldr	r1, [r7]
 800e176: 6878         	ldr	r0, [r7, #0x4]
 800e178: 4798         	blx	r3
; }
 800e17a: bf00         	nop
 800e17c: 3708         	adds	r7, #0x8
 800e17e: 46bd         	mov	sp, r7
 800e180: bd80         	pop	{r7, pc}

0800e182 <log_backend_panic>:
; {
 800e182: b580         	push	{r7, lr}
 800e184: b082         	sub	sp, #0x8
 800e186: af00         	add	r7, sp, #0x0
 800e188: 6078         	str	r0, [r7, #0x4]
; 	backend->api->panic(backend);
 800e18a: 687b         	ldr	r3, [r7, #0x4]
 800e18c: 681b         	ldr	r3, [r3]
 800e18e: 689b         	ldr	r3, [r3, #0x8]
 800e190: 6878         	ldr	r0, [r7, #0x4]
 800e192: 4798         	blx	r3
; }
 800e194: bf00         	nop
 800e196: 3708         	adds	r7, #0x8
 800e198: 46bd         	mov	sp, r7
 800e19a: bd80         	pop	{r7, pc}

0800e19c <log_backend_is_active>:
; {
 800e19c: b480         	push	{r7}
 800e19e: b083         	sub	sp, #0xc
 800e1a0: af00         	add	r7, sp, #0x0
 800e1a2: 6078         	str	r0, [r7, #0x4]
; 	return backend->cb->active;
 800e1a4: 687b         	ldr	r3, [r7, #0x4]
 800e1a6: 685b         	ldr	r3, [r3, #0x4]
 800e1a8: 795b         	ldrb	r3, [r3, #0x5]
; }
 800e1aa: 4618         	mov	r0, r3
 800e1ac: 370c         	adds	r7, #0xc
 800e1ae: 46bd         	mov	sp, r7
 800e1b0: bc80         	pop	{r7}
 800e1b2: 4770         	bx	lr

0800e1b4 <dummy_timestamp>:
; {
 800e1b4: b480         	push	{r7}
 800e1b6: af00         	add	r7, sp, #0x0
; 	return 0;
 800e1b8: 2300         	movs	r3, #0x0
; }
 800e1ba: 4618         	mov	r0, r3
 800e1bc: 46bd         	mov	sp, r7
 800e1be: bc80         	pop	{r7}
 800e1c0: 4770         	bx	lr

0800e1c2 <z_log_vprintk>:
; {
 800e1c2: b580         	push	{r7, lr}
 800e1c4: b086         	sub	sp, #0x18
 800e1c6: af04         	add	r7, sp, #0x10
 800e1c8: 6078         	str	r0, [r7, #0x4]
 800e1ca: 6039         	str	r1, [r7]
; 	z_log_msg_runtime_vcreate(Z_LOG_LOCAL_DOMAIN_ID, NULL,
 800e1cc: 683b         	ldr	r3, [r7]
 800e1ce: 9303         	str	r3, [sp, #0xc]
 800e1d0: 687b         	ldr	r3, [r7, #0x4]
 800e1d2: 9302         	str	r3, [sp, #0x8]
 800e1d4: 2300         	movs	r3, #0x0
 800e1d6: 9301         	str	r3, [sp, #0x4]
 800e1d8: 2300         	movs	r3, #0x0
 800e1da: 9300         	str	r3, [sp]
 800e1dc: 2300         	movs	r3, #0x0
 800e1de: 2200         	movs	r2, #0x0
 800e1e0: 2100         	movs	r1, #0x0
 800e1e2: 2000         	movs	r0, #0x0
 800e1e4: f7f3 fb2e    	bl	0x8001844 <z_log_msg_runtime_vcreate> @ imm = #-0xc9a4
; }
 800e1e8: 3708         	adds	r7, #0x8
 800e1ea: 46bd         	mov	sp, r7
 800e1ec: bd80         	pop	{r7, pc}

0800e1ee <default_lf_get_timestamp>:
; {
 800e1ee: b580         	push	{r7, lr}
 800e1f0: af00         	add	r7, sp, #0x0
; 		k_uptime_get() : k_uptime_get_32();
 800e1f2: f7ff ff70    	bl	0x800e0d6 <k_uptime_get_32> @ imm = #-0x120
 800e1f6: 4603         	mov	r3, r0
; }
 800e1f8: 4618         	mov	r0, r3
 800e1fa: bd80         	pop	{r7, pc}

0800e1fc <activate_foreach_backend>:
; {
 800e1fc: b580         	push	{r7, lr}
 800e1fe: b086         	sub	sp, #0x18
 800e200: af00         	add	r7, sp, #0x0
 800e202: 6078         	str	r0, [r7, #0x4]
; 	uint32_t mask_cpy = mask;
 800e204: 687b         	ldr	r3, [r7, #0x4]
 800e206: 617b         	str	r3, [r7, #0x14]
; 	while (mask_cpy) {
 800e208: e02b         	b	0x800e262 <activate_foreach_backend+0x66> @ imm = #0x56
; 		uint32_t i = __builtin_ctz(mask_cpy);
 800e20a: 697b         	ldr	r3, [r7, #0x14]
 800e20c: fa93 f3a3    	rbit	r3, r3
 800e210: fab3 f383    	clz	r3, r3
 800e214: 613b         	str	r3, [r7, #0x10]
; 		const struct log_backend *backend = log_backend_get(i);
 800e216: 6938         	ldr	r0, [r7, #0x10]
 800e218: f7f3 f8e0    	bl	0x80013dc <log_backend_get> @ imm = #-0xce40
 800e21c: 60f8         	str	r0, [r7, #0xc]
; 		mask_cpy &= ~BIT(i);
 800e21e: 2201         	movs	r2, #0x1
 800e220: 693b         	ldr	r3, [r7, #0x10]
 800e222: fa02 f303    	lsl.w	r3, r2, r3
 800e226: 43db         	mvns	r3, r3
 800e228: 697a         	ldr	r2, [r7, #0x14]
 800e22a: 4013         	ands	r3, r2
 800e22c: 617b         	str	r3, [r7, #0x14]
; 		if (backend->autostart && (log_backend_is_ready(backend) == 0)) {
 800e22e: 68fb         	ldr	r3, [r7, #0xc]
 800e230: 7b1b         	ldrb	r3, [r3, #0xc]
 800e232: 2b00         	cmp	r3, #0x0
 800e234: d015         	beq	0x800e262 <activate_foreach_backend+0x66> @ imm = #0x2a
 800e236: 68f8         	ldr	r0, [r7, #0xc]
 800e238: f7ff ff7f    	bl	0x800e13a <log_backend_is_ready> @ imm = #-0x102
 800e23c: 4603         	mov	r3, r0
 800e23e: 2b00         	cmp	r3, #0x0
 800e240: d10f         	bne	0x800e262 <activate_foreach_backend+0x66> @ imm = #0x1e
; 			mask &= ~BIT(i);
 800e242: 2201         	movs	r2, #0x1
 800e244: 693b         	ldr	r3, [r7, #0x10]
 800e246: fa02 f303    	lsl.w	r3, r2, r3
 800e24a: 43db         	mvns	r3, r3
 800e24c: 687a         	ldr	r2, [r7, #0x4]
 800e24e: 4013         	ands	r3, r2
 800e250: 607b         	str	r3, [r7, #0x4]
; 					   backend->cb->ctx,
 800e252: 68fb         	ldr	r3, [r7, #0xc]
 800e254: 685b         	ldr	r3, [r3, #0x4]
; 			log_backend_enable(backend,
 800e256: 681b         	ldr	r3, [r3]
 800e258: 2204         	movs	r2, #0x4
 800e25a: 4619         	mov	r1, r3
 800e25c: 68f8         	ldr	r0, [r7, #0xc]
 800e25e: f000 f8c8    	bl	0x800e3f2 <log_backend_enable> @ imm = #0x190
; 	while (mask_cpy) {
 800e262: 697b         	ldr	r3, [r7, #0x14]
 800e264: 2b00         	cmp	r3, #0x0
 800e266: d1d0         	bne	0x800e20a <activate_foreach_backend+0xe> @ imm = #-0x60
; 	return mask;
 800e268: 687b         	ldr	r3, [r7, #0x4]
; }
 800e26a: 4618         	mov	r0, r3
 800e26c: 3718         	adds	r7, #0x18
 800e26e: 46bd         	mov	sp, r7
 800e270: bd80         	pop	{r7, pc}

0800e272 <msg_filter_check>:
; {
 800e272: b580         	push	{r7, lr}
 800e274: b082         	sub	sp, #0x8
 800e276: af00         	add	r7, sp, #0x0
 800e278: 6078         	str	r0, [r7, #0x4]
 800e27a: 6039         	str	r1, [r7]
; 	if (!z_log_item_is_msg(msg)) {
 800e27c: 6838         	ldr	r0, [r7]
 800e27e: f7ff fed8    	bl	0x800e032 <z_log_item_is_msg> @ imm = #-0x250
 800e282: 4603         	mov	r3, r0
 800e284: f083 0301    	eor	r3, r3, #0x1
 800e288: b2db         	uxtb	r3, r3
 800e28a: 2b00         	cmp	r3, #0x0
 800e28c: d001         	beq	0x800e292 <msg_filter_check+0x20> @ imm = #0x2
; 		return true;
 800e28e: 2301         	movs	r3, #0x1
 800e290: e000         	b	0x800e294 <msg_filter_check+0x22> @ imm = #0x0
; 		return true;
 800e292: 2301         	movs	r3, #0x1
; }
 800e294: 4618         	mov	r0, r3
 800e296: 3708         	adds	r7, #0x8
 800e298: 46bd         	mov	sp, r7
 800e29a: bd80         	pop	{r7, pc}

0800e29c <msg_commit>:
; {
 800e29c: b580         	push	{r7, lr}
 800e29e: b084         	sub	sp, #0x10
 800e2a0: af00         	add	r7, sp, #0x0
 800e2a2: 6078         	str	r0, [r7, #0x4]
 800e2a4: 6039         	str	r1, [r7]
; 	union log_msg_generic *m = (union log_msg_generic *)msg;
 800e2a6: 683b         	ldr	r3, [r7]
 800e2a8: 60fb         	str	r3, [r7, #0xc]
; 		msg_process(m);
 800e2aa: 68f8         	ldr	r0, [r7, #0xc]
 800e2ac: f7f3 f982    	bl	0x80015b4 <msg_process> @ imm = #-0xccfc
; }
 800e2b0: 3710         	adds	r7, #0x10
 800e2b2: 46bd         	mov	sp, r7
 800e2b4: bd80         	pop	{r7, pc}

0800e2b6 <z_log_get_tag>:
; {
 800e2b6: b480         	push	{r7}
 800e2b8: af00         	add	r7, sp, #0x0
; 	return CONFIG_LOG_TAG_MAX_LEN > 0 ? tag : NULL;
 800e2ba: 2300         	movs	r3, #0x0
; }
 800e2bc: 4618         	mov	r0, r3
 800e2be: 46bd         	mov	sp, r7
 800e2c0: bc80         	pop	{r7}
 800e2c2: 4770         	bx	lr

0800e2c4 <enable_logger>:
; {
 800e2c4: b580         	push	{r7, lr}
 800e2c6: af00         	add	r7, sp, #0x0
; 		(void)z_log_init(false, false);
 800e2c8: 2100         	movs	r1, #0x0
 800e2ca: 2000         	movs	r0, #0x0
 800e2cc: f7f3 f8c2    	bl	0x8001454 <z_log_init>  @ imm = #-0xce7c
; 	return 0;
 800e2d0: 2300         	movs	r3, #0x0
; }
 800e2d2: 4618         	mov	r0, r3
 800e2d4: bd80         	pop	{r7, pc}

0800e2d6 <z_log_is_local_domain>:
; {
 800e2d6: b480         	push	{r7}
 800e2d8: b083         	sub	sp, #0xc
 800e2da: af00         	add	r7, sp, #0x0
 800e2dc: 4603         	mov	r3, r0
 800e2de: 71fb         	strb	r3, [r7, #0x7]
; 	return !IS_ENABLED(CONFIG_LOG_MULTIDOMAIN) ||
 800e2e0: 2301         	movs	r3, #0x1
; }
 800e2e2: 4618         	mov	r0, r3
 800e2e4: 370c         	adds	r7, #0xc
 800e2e6: 46bd         	mov	sp, r7
 800e2e8: bc80         	pop	{r7}
 800e2ea: 4770         	bx	lr

0800e2ec <log_backend_id_set>:
; {
 800e2ec: b480         	push	{r7}
 800e2ee: b083         	sub	sp, #0xc
 800e2f0: af00         	add	r7, sp, #0x0
 800e2f2: 6078         	str	r0, [r7, #0x4]
 800e2f4: 460b         	mov	r3, r1
 800e2f6: 70fb         	strb	r3, [r7, #0x3]
; 	backend->cb->id = id;
 800e2f8: 687b         	ldr	r3, [r7, #0x4]
 800e2fa: 685b         	ldr	r3, [r3, #0x4]
 800e2fc: 78fa         	ldrb	r2, [r7, #0x3]
 800e2fe: 711a         	strb	r2, [r3, #0x4]
; }
 800e300: bf00         	nop
 800e302: 370c         	adds	r7, #0xc
 800e304: 46bd         	mov	sp, r7
 800e306: bc80         	pop	{r7}
 800e308: 4770         	bx	lr

0800e30a <log_backend_activate>:
; {
 800e30a: b480         	push	{r7}
 800e30c: b083         	sub	sp, #0xc
 800e30e: af00         	add	r7, sp, #0x0
 800e310: 6078         	str	r0, [r7, #0x4]
 800e312: 6039         	str	r1, [r7]
; 	backend->cb->ctx = ctx;
 800e314: 687b         	ldr	r3, [r7, #0x4]
 800e316: 685b         	ldr	r3, [r3, #0x4]
 800e318: 683a         	ldr	r2, [r7]
 800e31a: 601a         	str	r2, [r3]
; 	backend->cb->active = true;
 800e31c: 687b         	ldr	r3, [r7, #0x4]
 800e31e: 685b         	ldr	r3, [r3, #0x4]
 800e320: 2201         	movs	r2, #0x1
 800e322: 715a         	strb	r2, [r3, #0x5]
; }
 800e324: bf00         	nop
 800e326: 370c         	adds	r7, #0xc
 800e328: 46bd         	mov	sp, r7
 800e32a: bc80         	pop	{r7}
 800e32c: 4770         	bx	lr

0800e32e <log_link_sources_count>:
; {
 800e32e: b480         	push	{r7}
 800e330: b083         	sub	sp, #0xc
 800e332: af00         	add	r7, sp, #0x0
 800e334: 6078         	str	r0, [r7, #0x4]
 800e336: 6039         	str	r1, [r7]
; 	return link->ctrl_blk->source_cnt[domain_id];
 800e338: 687b         	ldr	r3, [r7, #0x4]
 800e33a: 689a         	ldr	r2, [r3, #0x8]
 800e33c: 683b         	ldr	r3, [r7]
 800e33e: 005b         	lsls	r3, r3, #0x1
 800e340: 4413         	add	r3, r2
 800e342: 889b         	ldrh	r3, [r3, #0x4]
; }
 800e344: 4618         	mov	r0, r3
 800e346: 370c         	adds	r7, #0xc
 800e348: 46bd         	mov	sp, r7
 800e34a: bc80         	pop	{r7}
 800e34c: 4770         	bx	lr

0800e34e <log_link_get_source_name>:
; {
 800e34e: b590         	push	{r4, r7, lr}
 800e350: b087         	sub	sp, #0x1c
 800e352: af02         	add	r7, sp, #0x8
 800e354: 60f8         	str	r0, [r7, #0xc]
 800e356: 60b9         	str	r1, [r7, #0x8]
 800e358: 603b         	str	r3, [r7]
 800e35a: 4613         	mov	r3, r2
 800e35c: 80fb         	strh	r3, [r7, #0x6]
; 	return link->api->get_source_name(link, domain_id, source_id,
 800e35e: 68fb         	ldr	r3, [r7, #0xc]
 800e360: 681b         	ldr	r3, [r3]
 800e362: 68dc         	ldr	r4, [r3, #0xc]
 800e364: 88fa         	ldrh	r2, [r7, #0x6]
 800e366: 6a3b         	ldr	r3, [r7, #0x20]
 800e368: 9300         	str	r3, [sp]
 800e36a: 683b         	ldr	r3, [r7]
 800e36c: 68b9         	ldr	r1, [r7, #0x8]
 800e36e: 68f8         	ldr	r0, [r7, #0xc]
 800e370: 47a0         	blx	r4
 800e372: 4603         	mov	r3, r0
; }
 800e374: 4618         	mov	r0, r3
 800e376: 3714         	adds	r7, #0x14
 800e378: 46bd         	mov	sp, r7
 800e37a: bd90         	pop	{r4, r7, pc}

0800e37c <link_source_count>:
; {
 800e37c: b580         	push	{r7, lr}
 800e37e: b084         	sub	sp, #0x10
 800e380: af00         	add	r7, sp, #0x0
 800e382: 4603         	mov	r3, r0
 800e384: 71fb         	strb	r3, [r7, #0x7]
; 	const struct log_link *link = get_link_domain(domain_id, &rel_domain_id);
 800e386: f107 020b    	add.w	r2, r7, #0xb
 800e38a: 79fb         	ldrb	r3, [r7, #0x7]
 800e38c: 4611         	mov	r1, r2
 800e38e: 4618         	mov	r0, r3
 800e390: f7f3 f9a2    	bl	0x80016d8 <get_link_domain> @ imm = #-0xccbc
 800e394: 60f8         	str	r0, [r7, #0xc]
; 	return log_link_sources_count(link, rel_domain_id);
 800e396: 7afb         	ldrb	r3, [r7, #0xb]
 800e398: 4619         	mov	r1, r3
 800e39a: 68f8         	ldr	r0, [r7, #0xc]
 800e39c: f7ff ffc7    	bl	0x800e32e <log_link_sources_count> @ imm = #-0x72
 800e3a0: 4603         	mov	r3, r0
; }
 800e3a2: 4618         	mov	r0, r3
 800e3a4: 3710         	adds	r7, #0x10
 800e3a6: 46bd         	mov	sp, r7
 800e3a8: bd80         	pop	{r7, pc}

0800e3aa <log_src_cnt_get>:
; {
 800e3aa: b580         	push	{r7, lr}
 800e3ac: b082         	sub	sp, #0x8
 800e3ae: af00         	add	r7, sp, #0x0
 800e3b0: 6078         	str	r0, [r7, #0x4]
; 	if (z_log_is_local_domain(domain_id)) {
 800e3b2: 687b         	ldr	r3, [r7, #0x4]
 800e3b4: b2db         	uxtb	r3, r3
 800e3b6: 4618         	mov	r0, r3
 800e3b8: f7ff ff8d    	bl	0x800e2d6 <z_log_is_local_domain> @ imm = #-0xe6
 800e3bc: 4603         	mov	r3, r0
 800e3be: 2b00         	cmp	r3, #0x0
 800e3c0: d003         	beq	0x800e3ca <log_src_cnt_get+0x20> @ imm = #0x6
; 		return z_log_sources_count();
 800e3c2: f7f3 f96d    	bl	0x80016a0 <z_log_sources_count> @ imm = #-0xcd26
 800e3c6: 4603         	mov	r3, r0
 800e3c8: e005         	b	0x800e3d6 <log_src_cnt_get+0x2c> @ imm = #0xa
; 	return link_source_count(domain_id);
 800e3ca: 687b         	ldr	r3, [r7, #0x4]
 800e3cc: b2db         	uxtb	r3, r3
 800e3ce: 4618         	mov	r0, r3
 800e3d0: f7ff ffd4    	bl	0x800e37c <link_source_count> @ imm = #-0x58
 800e3d4: 4603         	mov	r3, r0
; }
 800e3d6: 4618         	mov	r0, r3
 800e3d8: 3708         	adds	r7, #0x8
 800e3da: 46bd         	mov	sp, r7
 800e3dc: bd80         	pop	{r7, pc}

0800e3de <backend_filter_set>:
; {
 800e3de: b480         	push	{r7}
 800e3e0: b083         	sub	sp, #0xc
 800e3e2: af00         	add	r7, sp, #0x0
 800e3e4: 6078         	str	r0, [r7, #0x4]
 800e3e6: 6039         	str	r1, [r7]
; 		return;
 800e3e8: bf00         	nop
; }
 800e3ea: 370c         	adds	r7, #0xc
 800e3ec: 46bd         	mov	sp, r7
 800e3ee: bc80         	pop	{r7}
 800e3f0: 4770         	bx	lr

0800e3f2 <log_backend_enable>:
; {
 800e3f2: b580         	push	{r7, lr}
 800e3f4: b086         	sub	sp, #0x18
 800e3f6: af00         	add	r7, sp, #0x0
 800e3f8: 60f8         	str	r0, [r7, #0xc]
 800e3fa: 60b9         	str	r1, [r7, #0x8]
 800e3fc: 607a         	str	r2, [r7, #0x4]
; 	uint32_t id = LOG_FILTER_FIRST_BACKEND_SLOT_IDX;
 800e3fe: 2301         	movs	r3, #0x1
 800e400: 617b         	str	r3, [r7, #0x14]
; 	id += backend - log_backend_get(0);
 800e402: 2000         	movs	r0, #0x0
 800e404: f7f3 f956    	bl	0x80016b4 <log_backend_get> @ imm = #-0xcd54
 800e408: 4602         	mov	r2, r0
 800e40a: 68fb         	ldr	r3, [r7, #0xc]
 800e40c: 1a9b         	subs	r3, r3, r2
 800e40e: 111b         	asrs	r3, r3, #0x4
 800e410: 461a         	mov	r2, r3
 800e412: 697b         	ldr	r3, [r7, #0x14]
 800e414: 4413         	add	r3, r2
 800e416: 617b         	str	r3, [r7, #0x14]
; 	log_backend_id_set(backend, id);
 800e418: 697b         	ldr	r3, [r7, #0x14]
 800e41a: b2db         	uxtb	r3, r3
 800e41c: 4619         	mov	r1, r3
 800e41e: 68f8         	ldr	r0, [r7, #0xc]
 800e420: f7ff ff64    	bl	0x800e2ec <log_backend_id_set> @ imm = #-0x138
; 	backend->cb->level = level;
 800e424: 68fb         	ldr	r3, [r7, #0xc]
 800e426: 685b         	ldr	r3, [r3, #0x4]
 800e428: 687a         	ldr	r2, [r7, #0x4]
 800e42a: b2d2         	uxtb	r2, r2
 800e42c: 719a         	strb	r2, [r3, #0x6]
; 	backend_filter_set(backend, level);
 800e42e: 6879         	ldr	r1, [r7, #0x4]
 800e430: 68f8         	ldr	r0, [r7, #0xc]
 800e432: f7ff ffd4    	bl	0x800e3de <backend_filter_set> @ imm = #-0x58
; 	log_backend_activate(backend, ctx);
 800e436: 68b9         	ldr	r1, [r7, #0x8]
 800e438: 68f8         	ldr	r0, [r7, #0xc]
 800e43a: f7ff ff66    	bl	0x800e30a <log_backend_activate> @ imm = #-0x134
; 	z_log_notify_backend_enabled();
 800e43e: f7f3 f8e7    	bl	0x8001610 <z_log_notify_backend_enabled> @ imm = #-0xce32
; }
 800e442: bf00         	nop
 800e444: 3718         	adds	r7, #0x18
 800e446: 46bd         	mov	sp, r7
 800e448: bd80         	pop	{r7, pc}

0800e44a <z_snode_next_peek>:
; {
 800e44a: b480         	push	{r7}
 800e44c: b083         	sub	sp, #0xc
 800e44e: af00         	add	r7, sp, #0x0
 800e450: 6078         	str	r0, [r7, #0x4]
; 	return node->next;
 800e452: 687b         	ldr	r3, [r7, #0x4]
 800e454: 681b         	ldr	r3, [r3]
; }
 800e456: 4618         	mov	r0, r3
 800e458: 370c         	adds	r7, #0xc
 800e45a: 46bd         	mov	sp, r7
 800e45c: bc80         	pop	{r7}
 800e45e: 4770         	bx	lr

0800e460 <z_snode_next_set>:
; {
 800e460: b480         	push	{r7}
 800e462: b083         	sub	sp, #0xc
 800e464: af00         	add	r7, sp, #0x0
 800e466: 6078         	str	r0, [r7, #0x4]
 800e468: 6039         	str	r1, [r7]
; 	parent->next = child;
 800e46a: 687b         	ldr	r3, [r7, #0x4]
 800e46c: 683a         	ldr	r2, [r7]
 800e46e: 601a         	str	r2, [r3]
; }
 800e470: bf00         	nop
 800e472: 370c         	adds	r7, #0xc
 800e474: 46bd         	mov	sp, r7
 800e476: bc80         	pop	{r7}
 800e478: 4770         	bx	lr

0800e47a <z_slist_head_set>:
; {
 800e47a: b480         	push	{r7}
 800e47c: b083         	sub	sp, #0xc
 800e47e: af00         	add	r7, sp, #0x0
 800e480: 6078         	str	r0, [r7, #0x4]
 800e482: 6039         	str	r1, [r7]
; 	list->head = node;
 800e484: 687b         	ldr	r3, [r7, #0x4]
 800e486: 683a         	ldr	r2, [r7]
 800e488: 601a         	str	r2, [r3]
; }
 800e48a: bf00         	nop
 800e48c: 370c         	adds	r7, #0xc
 800e48e: 46bd         	mov	sp, r7
 800e490: bc80         	pop	{r7}
 800e492: 4770         	bx	lr

0800e494 <z_slist_tail_set>:
; {
 800e494: b480         	push	{r7}
 800e496: b083         	sub	sp, #0xc
 800e498: af00         	add	r7, sp, #0x0
 800e49a: 6078         	str	r0, [r7, #0x4]
 800e49c: 6039         	str	r1, [r7]
; 	list->tail = node;
 800e49e: 687b         	ldr	r3, [r7, #0x4]
 800e4a0: 683a         	ldr	r2, [r7]
 800e4a2: 605a         	str	r2, [r3, #0x4]
; }
 800e4a4: bf00         	nop
 800e4a6: 370c         	adds	r7, #0xc
 800e4a8: 46bd         	mov	sp, r7
 800e4aa: bc80         	pop	{r7}
 800e4ac: 4770         	bx	lr

0800e4ae <sys_slist_peek_head>:
; {
 800e4ae: b480         	push	{r7}
 800e4b0: b083         	sub	sp, #0xc
 800e4b2: af00         	add	r7, sp, #0x0
 800e4b4: 6078         	str	r0, [r7, #0x4]
; 	return list->head;
 800e4b6: 687b         	ldr	r3, [r7, #0x4]
 800e4b8: 681b         	ldr	r3, [r3]
; }
 800e4ba: 4618         	mov	r0, r3
 800e4bc: 370c         	adds	r7, #0xc
 800e4be: 46bd         	mov	sp, r7
 800e4c0: bc80         	pop	{r7}
 800e4c2: 4770         	bx	lr

0800e4c4 <sys_slist_peek_tail>:
; {
 800e4c4: b480         	push	{r7}
 800e4c6: b083         	sub	sp, #0xc
 800e4c8: af00         	add	r7, sp, #0x0
 800e4ca: 6078         	str	r0, [r7, #0x4]
; 	return list->tail;
 800e4cc: 687b         	ldr	r3, [r7, #0x4]
 800e4ce: 685b         	ldr	r3, [r3, #0x4]
; }
 800e4d0: 4618         	mov	r0, r3
 800e4d2: 370c         	adds	r7, #0xc
 800e4d4: 46bd         	mov	sp, r7
 800e4d6: bc80         	pop	{r7}
 800e4d8: 4770         	bx	lr

0800e4da <sys_slist_is_empty>:
; Z_GENLIST_IS_EMPTY(slist)
 800e4da: b580         	push	{r7, lr}
 800e4dc: b082         	sub	sp, #0x8
 800e4de: af00         	add	r7, sp, #0x0
 800e4e0: 6078         	str	r0, [r7, #0x4]
 800e4e2: 6878         	ldr	r0, [r7, #0x4]
 800e4e4: f7ff ffe3    	bl	0x800e4ae <sys_slist_peek_head> @ imm = #-0x3a
 800e4e8: 4603         	mov	r3, r0
 800e4ea: 2b00         	cmp	r3, #0x0
 800e4ec: bf0c         	ite	eq
 800e4ee: 2301         	moveq	r3, #0x1
 800e4f0: 2300         	movne	r3, #0x0
 800e4f2: b2db         	uxtb	r3, r3
 800e4f4: 4618         	mov	r0, r3
 800e4f6: 3708         	adds	r7, #0x8
 800e4f8: 46bd         	mov	sp, r7
 800e4fa: bd80         	pop	{r7, pc}

0800e4fc <sys_slist_peek_next_no_check>:
; Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
 800e4fc: b580         	push	{r7, lr}
 800e4fe: b082         	sub	sp, #0x8
 800e500: af00         	add	r7, sp, #0x0
 800e502: 6078         	str	r0, [r7, #0x4]
 800e504: 6878         	ldr	r0, [r7, #0x4]
 800e506: f7ff ffa0    	bl	0x800e44a <z_snode_next_peek> @ imm = #-0xc0
 800e50a: 4603         	mov	r3, r0
 800e50c: 4618         	mov	r0, r3
 800e50e: 3708         	adds	r7, #0x8
 800e510: 46bd         	mov	sp, r7
 800e512: bd80         	pop	{r7, pc}

0800e514 <sys_slist_peek_next>:
; Z_GENLIST_PEEK_NEXT(slist, snode)
 800e514: b580         	push	{r7, lr}
 800e516: b082         	sub	sp, #0x8
 800e518: af00         	add	r7, sp, #0x0
 800e51a: 6078         	str	r0, [r7, #0x4]
 800e51c: 687b         	ldr	r3, [r7, #0x4]
 800e51e: 2b00         	cmp	r3, #0x0
 800e520: d004         	beq	0x800e52c <sys_slist_peek_next+0x18> @ imm = #0x8
 800e522: 6878         	ldr	r0, [r7, #0x4]
 800e524: f7ff ffea    	bl	0x800e4fc <sys_slist_peek_next_no_check> @ imm = #-0x2c
 800e528: 4603         	mov	r3, r0
 800e52a: e000         	b	0x800e52e <sys_slist_peek_next+0x1a> @ imm = #0x0
 800e52c: 2300         	movs	r3, #0x0
 800e52e: 4618         	mov	r0, r3
 800e530: 3708         	adds	r7, #0x8
 800e532: 46bd         	mov	sp, r7
 800e534: bd80         	pop	{r7, pc}

0800e536 <sys_slist_prepend>:
; Z_GENLIST_PREPEND(slist, snode)
 800e536: b580         	push	{r7, lr}
 800e538: b082         	sub	sp, #0x8
 800e53a: af00         	add	r7, sp, #0x0
 800e53c: 6078         	str	r0, [r7, #0x4]
 800e53e: 6039         	str	r1, [r7]
 800e540: 6878         	ldr	r0, [r7, #0x4]
 800e542: f7ff ffb4    	bl	0x800e4ae <sys_slist_peek_head> @ imm = #-0x98
 800e546: 4603         	mov	r3, r0
 800e548: 4619         	mov	r1, r3
 800e54a: 6838         	ldr	r0, [r7]
 800e54c: f7ff ff88    	bl	0x800e460 <z_snode_next_set> @ imm = #-0xf0
 800e550: 6839         	ldr	r1, [r7]
 800e552: 6878         	ldr	r0, [r7, #0x4]
 800e554: f7ff ff91    	bl	0x800e47a <z_slist_head_set> @ imm = #-0xde
 800e558: 6878         	ldr	r0, [r7, #0x4]
 800e55a: f7ff ffb3    	bl	0x800e4c4 <sys_slist_peek_tail> @ imm = #-0x9a
 800e55e: 4603         	mov	r3, r0
 800e560: 2b00         	cmp	r3, #0x0
 800e562: d107         	bne	0x800e574 <sys_slist_prepend+0x3e> @ imm = #0xe
 800e564: 6878         	ldr	r0, [r7, #0x4]
 800e566: f7ff ffa2    	bl	0x800e4ae <sys_slist_peek_head> @ imm = #-0xbc
 800e56a: 4603         	mov	r3, r0
 800e56c: 4619         	mov	r1, r3
 800e56e: 6878         	ldr	r0, [r7, #0x4]
 800e570: f7ff ff90    	bl	0x800e494 <z_slist_tail_set> @ imm = #-0xe0
 800e574: 3708         	adds	r7, #0x8
 800e576: 46bd         	mov	sp, r7
 800e578: bd80         	pop	{r7, pc}

0800e57a <sys_slist_get_not_empty>:
; Z_GENLIST_GET_NOT_EMPTY(slist, snode)
 800e57a: b580         	push	{r7, lr}
 800e57c: b084         	sub	sp, #0x10
 800e57e: af00         	add	r7, sp, #0x0
 800e580: 6078         	str	r0, [r7, #0x4]
 800e582: 6878         	ldr	r0, [r7, #0x4]
 800e584: f7ff ff93    	bl	0x800e4ae <sys_slist_peek_head> @ imm = #-0xda
 800e588: 60f8         	str	r0, [r7, #0xc]
 800e58a: 68f8         	ldr	r0, [r7, #0xc]
 800e58c: f7ff ff5d    	bl	0x800e44a <z_snode_next_peek> @ imm = #-0x146
 800e590: 4603         	mov	r3, r0
 800e592: 4619         	mov	r1, r3
 800e594: 6878         	ldr	r0, [r7, #0x4]
 800e596: f7ff ff70    	bl	0x800e47a <z_slist_head_set> @ imm = #-0x120
 800e59a: 6878         	ldr	r0, [r7, #0x4]
 800e59c: f7ff ff92    	bl	0x800e4c4 <sys_slist_peek_tail> @ imm = #-0xdc
 800e5a0: 4602         	mov	r2, r0
 800e5a2: 68fb         	ldr	r3, [r7, #0xc]
 800e5a4: 4293         	cmp	r3, r2
 800e5a6: d107         	bne	0x800e5b8 <sys_slist_get_not_empty+0x3e> @ imm = #0xe
 800e5a8: 6878         	ldr	r0, [r7, #0x4]
 800e5aa: f7ff ff80    	bl	0x800e4ae <sys_slist_peek_head> @ imm = #-0x100
 800e5ae: 4603         	mov	r3, r0
 800e5b0: 4619         	mov	r1, r3
 800e5b2: 6878         	ldr	r0, [r7, #0x4]
 800e5b4: f7ff ff6e    	bl	0x800e494 <z_slist_tail_set> @ imm = #-0x124
 800e5b8: 68fb         	ldr	r3, [r7, #0xc]
 800e5ba: 4618         	mov	r0, r3
 800e5bc: 3710         	adds	r7, #0x10
 800e5be: 46bd         	mov	sp, r7
 800e5c0: bd80         	pop	{r7, pc}

0800e5c2 <sys_slist_get>:
; Z_GENLIST_GET(slist, snode)
 800e5c2: b580         	push	{r7, lr}
 800e5c4: b082         	sub	sp, #0x8
 800e5c6: af00         	add	r7, sp, #0x0
 800e5c8: 6078         	str	r0, [r7, #0x4]
 800e5ca: 6878         	ldr	r0, [r7, #0x4]
 800e5cc: f7ff ff85    	bl	0x800e4da <sys_slist_is_empty> @ imm = #-0xf6
 800e5d0: 4603         	mov	r3, r0
 800e5d2: 2b00         	cmp	r3, #0x0
 800e5d4: d104         	bne	0x800e5e0 <sys_slist_get+0x1e> @ imm = #0x8
 800e5d6: 6878         	ldr	r0, [r7, #0x4]
 800e5d8: f7ff ffcf    	bl	0x800e57a <sys_slist_get_not_empty> @ imm = #-0x62
 800e5dc: 4603         	mov	r3, r0
 800e5de: e000         	b	0x800e5e2 <sys_slist_get+0x20> @ imm = #0x0
 800e5e0: 2300         	movs	r3, #0x0
 800e5e2: 4618         	mov	r0, r3
 800e5e4: 3708         	adds	r7, #0x8
 800e5e6: 46bd         	mov	sp, r7
 800e5e8: bd80         	pop	{r7, pc}

0800e5ea <sys_slist_remove>:
; Z_GENLIST_REMOVE(slist, snode)
 800e5ea: b580         	push	{r7, lr}
 800e5ec: b084         	sub	sp, #0x10
 800e5ee: af00         	add	r7, sp, #0x0
 800e5f0: 60f8         	str	r0, [r7, #0xc]
 800e5f2: 60b9         	str	r1, [r7, #0x8]
 800e5f4: 607a         	str	r2, [r7, #0x4]
 800e5f6: 68bb         	ldr	r3, [r7, #0x8]
 800e5f8: 2b00         	cmp	r3, #0x0
 800e5fa: d117         	bne	0x800e62c <sys_slist_remove+0x42> @ imm = #0x2e
 800e5fc: 6878         	ldr	r0, [r7, #0x4]
 800e5fe: f7ff ff24    	bl	0x800e44a <z_snode_next_peek> @ imm = #-0x1b8
 800e602: 4603         	mov	r3, r0
 800e604: 4619         	mov	r1, r3
 800e606: 68f8         	ldr	r0, [r7, #0xc]
 800e608: f7ff ff37    	bl	0x800e47a <z_slist_head_set> @ imm = #-0x192
 800e60c: 68f8         	ldr	r0, [r7, #0xc]
 800e60e: f7ff ff59    	bl	0x800e4c4 <sys_slist_peek_tail> @ imm = #-0x14e
 800e612: 4602         	mov	r2, r0
 800e614: 687b         	ldr	r3, [r7, #0x4]
 800e616: 4293         	cmp	r3, r2
 800e618: d11b         	bne	0x800e652 <sys_slist_remove+0x68> @ imm = #0x36
 800e61a: 68f8         	ldr	r0, [r7, #0xc]
 800e61c: f7ff ff47    	bl	0x800e4ae <sys_slist_peek_head> @ imm = #-0x172
 800e620: 4603         	mov	r3, r0
 800e622: 4619         	mov	r1, r3
 800e624: 68f8         	ldr	r0, [r7, #0xc]
 800e626: f7ff ff35    	bl	0x800e494 <z_slist_tail_set> @ imm = #-0x196
 800e62a: e012         	b	0x800e652 <sys_slist_remove+0x68> @ imm = #0x24
 800e62c: 6878         	ldr	r0, [r7, #0x4]
 800e62e: f7ff ff0c    	bl	0x800e44a <z_snode_next_peek> @ imm = #-0x1e8
 800e632: 4603         	mov	r3, r0
 800e634: 4619         	mov	r1, r3
 800e636: 68b8         	ldr	r0, [r7, #0x8]
 800e638: f7ff ff12    	bl	0x800e460 <z_snode_next_set> @ imm = #-0x1dc
 800e63c: 68f8         	ldr	r0, [r7, #0xc]
 800e63e: f7ff ff41    	bl	0x800e4c4 <sys_slist_peek_tail> @ imm = #-0x17e
 800e642: 4602         	mov	r2, r0
 800e644: 687b         	ldr	r3, [r7, #0x4]
 800e646: 4293         	cmp	r3, r2
 800e648: d103         	bne	0x800e652 <sys_slist_remove+0x68> @ imm = #0x6
 800e64a: 68b9         	ldr	r1, [r7, #0x8]
 800e64c: 68f8         	ldr	r0, [r7, #0xc]
 800e64e: f7ff ff21    	bl	0x800e494 <z_slist_tail_set> @ imm = #-0x1be
 800e652: 2100         	movs	r1, #0x0
 800e654: 6878         	ldr	r0, [r7, #0x4]
 800e656: f7ff ff03    	bl	0x800e460 <z_snode_next_set> @ imm = #-0x1fa
 800e65a: 3710         	adds	r7, #0x10
 800e65c: 46bd         	mov	sp, r7
 800e65e: bd80         	pop	{r7, pc}

0800e660 <log_cache_get>:
; {
 800e660: b590         	push	{r4, r7, lr}
 800e662: b089         	sub	sp, #0x24
 800e664: af00         	add	r7, sp, #0x0
 800e666: 60f8         	str	r0, [r7, #0xc]
 800e668: 60b9         	str	r1, [r7, #0x8]
 800e66a: 607a         	str	r2, [r7, #0x4]
; 	sys_snode_t *prev_node = NULL;
 800e66c: 2300         	movs	r3, #0x0
 800e66e: 61fb         	str	r3, [r7, #0x1c]
; 	bool hit = false;
 800e670: 2300         	movs	r3, #0x0
 800e672: 75fb         	strb	r3, [r7, #0x17]
; 	SYS_SLIST_FOR_EACH_CONTAINER(&cache->active, entry, node) {
 800e674: 68fb         	ldr	r3, [r7, #0xc]
 800e676: 4618         	mov	r0, r3
 800e678: f7ff ff19    	bl	0x800e4ae <sys_slist_peek_head> @ imm = #-0x1ce
 800e67c: 4603         	mov	r3, r0
 800e67e: 2b00         	cmp	r3, #0x0
 800e680: d005         	beq	0x800e68e <log_cache_get+0x2e> @ imm = #0xa
 800e682: 68fb         	ldr	r3, [r7, #0xc]
 800e684: 4618         	mov	r0, r3
 800e686: f7ff ff12    	bl	0x800e4ae <sys_slist_peek_head> @ imm = #-0x1dc
 800e68a: 4603         	mov	r3, r0
 800e68c: e000         	b	0x800e690 <log_cache_get+0x30> @ imm = #0x0
 800e68e: 2300         	movs	r3, #0x0
 800e690: 61bb         	str	r3, [r7, #0x18]
 800e692: e02f         	b	0x800e6f4 <log_cache_get+0x94> @ imm = #0x5e
; 		if (cache->cmp(entry->id, id)) {
 800e694: 68fb         	ldr	r3, [r7, #0xc]
 800e696: 691b         	ldr	r3, [r3, #0x10]
 800e698: 69ba         	ldr	r2, [r7, #0x18]
 800e69a: 6852         	ldr	r2, [r2, #0x4]
 800e69c: 68b9         	ldr	r1, [r7, #0x8]
 800e69e: 4610         	mov	r0, r2
 800e6a0: 4798         	blx	r3
 800e6a2: 4603         	mov	r3, r0
 800e6a4: 2b00         	cmp	r3, #0x0
 800e6a6: d007         	beq	0x800e6b8 <log_cache_get+0x58> @ imm = #0xe
; 			cache->hit++;
 800e6a8: 68fb         	ldr	r3, [r7, #0xc]
 800e6aa: 695b         	ldr	r3, [r3, #0x14]
 800e6ac: 1c5a         	adds	r2, r3, #0x1
 800e6ae: 68fb         	ldr	r3, [r7, #0xc]
 800e6b0: 615a         	str	r2, [r3, #0x14]
; 			hit = true;
 800e6b2: 2301         	movs	r3, #0x1
 800e6b4: 75fb         	strb	r3, [r7, #0x17]
; 			break;
 800e6b6: e022         	b	0x800e6fe <log_cache_get+0x9e> @ imm = #0x44
; 		if (&entry->node == sys_slist_peek_tail(&cache->active)) {
 800e6b8: 69bc         	ldr	r4, [r7, #0x18]
 800e6ba: 68fb         	ldr	r3, [r7, #0xc]
 800e6bc: 4618         	mov	r0, r3
 800e6be: f7ff ff01    	bl	0x800e4c4 <sys_slist_peek_tail> @ imm = #-0x1fe
 800e6c2: 4603         	mov	r3, r0
 800e6c4: 429c         	cmp	r4, r3
 800e6c6: d019         	beq	0x800e6fc <log_cache_get+0x9c> @ imm = #0x32
; 		prev_node = &entry->node;
 800e6c8: 69bb         	ldr	r3, [r7, #0x18]
 800e6ca: 61fb         	str	r3, [r7, #0x1c]
; 	SYS_SLIST_FOR_EACH_CONTAINER(&cache->active, entry, node) {
 800e6cc: 69bb         	ldr	r3, [r7, #0x18]
 800e6ce: 2b00         	cmp	r3, #0x0
 800e6d0: d00e         	beq	0x800e6f0 <log_cache_get+0x90> @ imm = #0x1c
 800e6d2: 69bb         	ldr	r3, [r7, #0x18]
 800e6d4: 4618         	mov	r0, r3
 800e6d6: f7ff ff1d    	bl	0x800e514 <sys_slist_peek_next> @ imm = #-0x1c6
 800e6da: 4603         	mov	r3, r0
 800e6dc: 2b00         	cmp	r3, #0x0
 800e6de: d005         	beq	0x800e6ec <log_cache_get+0x8c> @ imm = #0xa
 800e6e0: 69bb         	ldr	r3, [r7, #0x18]
 800e6e2: 4618         	mov	r0, r3
 800e6e4: f7ff ff16    	bl	0x800e514 <sys_slist_peek_next> @ imm = #-0x1d4
 800e6e8: 4603         	mov	r3, r0
 800e6ea: e002         	b	0x800e6f2 <log_cache_get+0x92> @ imm = #0x4
 800e6ec: 2300         	movs	r3, #0x0
 800e6ee: e000         	b	0x800e6f2 <log_cache_get+0x92> @ imm = #0x0
 800e6f0: 2300         	movs	r3, #0x0
 800e6f2: 61bb         	str	r3, [r7, #0x18]
 800e6f4: 69bb         	ldr	r3, [r7, #0x18]
 800e6f6: 2b00         	cmp	r3, #0x0
 800e6f8: d1cc         	bne	0x800e694 <log_cache_get+0x34> @ imm = #-0x68
 800e6fa: e000         	b	0x800e6fe <log_cache_get+0x9e> @ imm = #0x0
; 			break;
 800e6fc: bf00         	nop
; 	if (hit) {
 800e6fe: 7dfb         	ldrb	r3, [r7, #0x17]
 800e700: 2b00         	cmp	r3, #0x0
 800e702: d00c         	beq	0x800e71e <log_cache_get+0xbe> @ imm = #0x18
; 		sys_slist_remove(&cache->active, prev_node, &entry->node);
 800e704: 68fb         	ldr	r3, [r7, #0xc]
 800e706: 69ba         	ldr	r2, [r7, #0x18]
 800e708: 69f9         	ldr	r1, [r7, #0x1c]
 800e70a: 4618         	mov	r0, r3
 800e70c: f7ff ff6d    	bl	0x800e5ea <sys_slist_remove> @ imm = #-0x126
; 		sys_slist_prepend(&cache->active, &entry->node);
 800e710: 68fb         	ldr	r3, [r7, #0xc]
 800e712: 69ba         	ldr	r2, [r7, #0x18]
 800e714: 4611         	mov	r1, r2
 800e716: 4618         	mov	r0, r3
 800e718: f7ff ff0d    	bl	0x800e536 <sys_slist_prepend> @ imm = #-0x1e6
 800e71c: e016         	b	0x800e74c <log_cache_get+0xec> @ imm = #0x2c
; 		cache->miss++;
 800e71e: 68fb         	ldr	r3, [r7, #0xc]
 800e720: 699b         	ldr	r3, [r3, #0x18]
 800e722: 1c5a         	adds	r2, r3, #0x1
 800e724: 68fb         	ldr	r3, [r7, #0xc]
 800e726: 619a         	str	r2, [r3, #0x18]
; 		sys_snode_t *from_idle = sys_slist_get(&cache->idle);
 800e728: 68fb         	ldr	r3, [r7, #0xc]
 800e72a: 3308         	adds	r3, #0x8
 800e72c: 4618         	mov	r0, r3
 800e72e: f7ff ff48    	bl	0x800e5c2 <sys_slist_get> @ imm = #-0x170
 800e732: 6138         	str	r0, [r7, #0x10]
; 		if (from_idle) {
 800e734: 693b         	ldr	r3, [r7, #0x10]
 800e736: 2b00         	cmp	r3, #0x0
 800e738: d002         	beq	0x800e740 <log_cache_get+0xe0> @ imm = #0x4
; 			entry = CONTAINER_OF(from_idle, struct log_cache_entry, node);
 800e73a: 693b         	ldr	r3, [r7, #0x10]
 800e73c: 61bb         	str	r3, [r7, #0x18]
 800e73e: e005         	b	0x800e74c <log_cache_get+0xec> @ imm = #0xa
; 			sys_slist_remove(&cache->active, prev_node, &entry->node);
 800e740: 68fb         	ldr	r3, [r7, #0xc]
 800e742: 69ba         	ldr	r2, [r7, #0x18]
 800e744: 69f9         	ldr	r1, [r7, #0x1c]
 800e746: 4618         	mov	r0, r3
 800e748: f7ff ff4f    	bl	0x800e5ea <sys_slist_remove> @ imm = #-0x162
; 	*data = entry->data;
 800e74c: 69bb         	ldr	r3, [r7, #0x18]
 800e74e: f103 0208    	add.w	r2, r3, #0x8
 800e752: 687b         	ldr	r3, [r7, #0x4]
 800e754: 601a         	str	r2, [r3]
; 	entry->id = id;
 800e756: 69bb         	ldr	r3, [r7, #0x18]
 800e758: 68ba         	ldr	r2, [r7, #0x8]
 800e75a: 605a         	str	r2, [r3, #0x4]
; 	return hit;
 800e75c: 7dfb         	ldrb	r3, [r7, #0x17]
; }
 800e75e: 4618         	mov	r0, r3
 800e760: 3724         	adds	r7, #0x24
 800e762: 46bd         	mov	sp, r7
 800e764: bd90         	pop	{r4, r7, pc}

0800e766 <log_cache_put>:
; {
 800e766: b580         	push	{r7, lr}
 800e768: b084         	sub	sp, #0x10
 800e76a: af00         	add	r7, sp, #0x0
 800e76c: 6078         	str	r0, [r7, #0x4]
 800e76e: 6039         	str	r1, [r7]
; 	struct log_cache_entry *entry = CONTAINER_OF(data, struct log_cache_entry, data[0]);
 800e770: 683b         	ldr	r3, [r7]
 800e772: 3b08         	subs	r3, #0x8
 800e774: 60fb         	str	r3, [r7, #0xc]
; 	sys_slist_prepend(&cache->active, &entry->node);
 800e776: 687b         	ldr	r3, [r7, #0x4]
 800e778: 68fa         	ldr	r2, [r7, #0xc]
 800e77a: 4611         	mov	r1, r2
 800e77c: 4618         	mov	r0, r3
 800e77e: f7ff feda    	bl	0x800e536 <sys_slist_prepend> @ imm = #-0x24c
; }
 800e782: bf00         	nop
 800e784: 3710         	adds	r7, #0x10
 800e786: 46bd         	mov	sp, r7
 800e788: bd80         	pop	{r7, pc}

0800e78a <z_log_msg_runtime_create>:
; {
 800e78a: b580         	push	{r7, lr}
 800e78c: b08a         	sub	sp, #0x28
 800e78e: af04         	add	r7, sp, #0x10
 800e790: 60b9         	str	r1, [r7, #0x8]
 800e792: 607b         	str	r3, [r7, #0x4]
 800e794: 4603         	mov	r3, r0
 800e796: 73fb         	strb	r3, [r7, #0xf]
 800e798: 4613         	mov	r3, r2
 800e79a: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 800e79c: f107 032c    	add.w	r3, r7, #0x2c
 800e7a0: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 800e7a2: 7bba         	ldrb	r2, [r7, #0xe]
 800e7a4: 7bf8         	ldrb	r0, [r7, #0xf]
 800e7a6: 697b         	ldr	r3, [r7, #0x14]
 800e7a8: 9303         	str	r3, [sp, #0xc]
 800e7aa: 6abb         	ldr	r3, [r7, #0x28]
 800e7ac: 9302         	str	r3, [sp, #0x8]
 800e7ae: 6a7b         	ldr	r3, [r7, #0x24]
 800e7b0: 9301         	str	r3, [sp, #0x4]
 800e7b2: 6a3b         	ldr	r3, [r7, #0x20]
 800e7b4: 9300         	str	r3, [sp]
 800e7b6: 687b         	ldr	r3, [r7, #0x4]
 800e7b8: 68b9         	ldr	r1, [r7, #0x8]
 800e7ba: f7f3 f843    	bl	0x8001844 <z_log_msg_runtime_vcreate> @ imm = #-0xcf7a
; }
 800e7be: bf00         	nop
 800e7c0: 3718         	adds	r7, #0x18
 800e7c2: 46bd         	mov	sp, r7
 800e7c4: bd80         	pop	{r7, pc}

0800e7c6 <log_msg_get_domain>:
; {
 800e7c6: b480         	push	{r7}
 800e7c8: b083         	sub	sp, #0xc
 800e7ca: af00         	add	r7, sp, #0x0
 800e7cc: 6078         	str	r0, [r7, #0x4]
; 	return msg->hdr.desc.domain;
 800e7ce: 687b         	ldr	r3, [r7, #0x4]
 800e7d0: 781b         	ldrb	r3, [r3]
 800e7d2: f3c3 03c2    	ubfx	r3, r3, #0x3, #0x3
 800e7d6: b2db         	uxtb	r3, r3
; }
 800e7d8: 4618         	mov	r0, r3
 800e7da: 370c         	adds	r7, #0xc
 800e7dc: 46bd         	mov	sp, r7
 800e7de: bc80         	pop	{r7}
 800e7e0: 4770         	bx	lr

0800e7e2 <log_msg_get_source>:
; {
 800e7e2: b480         	push	{r7}
 800e7e4: b083         	sub	sp, #0xc
 800e7e6: af00         	add	r7, sp, #0x0
 800e7e8: 6078         	str	r0, [r7, #0x4]
; 	return msg->hdr.source;
 800e7ea: 687b         	ldr	r3, [r7, #0x4]
 800e7ec: 685b         	ldr	r3, [r3, #0x4]
; }
 800e7ee: 4618         	mov	r0, r3
 800e7f0: 370c         	adds	r7, #0xc
 800e7f2: 46bd         	mov	sp, r7
 800e7f4: bc80         	pop	{r7}
 800e7f6: 4770         	bx	lr

0800e7f8 <log_source_id>:
; {
 800e7f8: b580         	push	{r7, lr}
 800e7fa: b082         	sub	sp, #0x8
 800e7fc: af00         	add	r7, sp, #0x0
 800e7fe: 6078         	str	r0, [r7, #0x4]
; 		log_dynamic_source_id((struct log_source_dynamic_data *)source) :
 800e800: 6878         	ldr	r0, [r7, #0x4]
 800e802: f7f3 f80f    	bl	0x8001824 <log_const_source_id> @ imm = #-0xcfe2
 800e806: 4603         	mov	r3, r0
; }
 800e808: 4618         	mov	r0, r3
 800e80a: 3708         	adds	r7, #0x8
 800e80c: 46bd         	mov	sp, r7
 800e80e: bd80         	pop	{r7, pc}

0800e810 <z_log_is_local_domain>:
; {
 800e810: b480         	push	{r7}
 800e812: b083         	sub	sp, #0xc
 800e814: af00         	add	r7, sp, #0x0
 800e816: 4603         	mov	r3, r0
 800e818: 71fb         	strb	r3, [r7, #0x7]
; 	return !IS_ENABLED(CONFIG_LOG_MULTIDOMAIN) ||
 800e81a: 2301         	movs	r3, #0x1
; }
 800e81c: 4618         	mov	r0, r3
 800e81e: 370c         	adds	r7, #0xc
 800e820: 46bd         	mov	sp, r7
 800e822: bc80         	pop	{r7}
 800e824: 4770         	bx	lr

0800e826 <z_log_msg_finalize>:
; {
 800e826: b580         	push	{r7, lr}
 800e828: b086         	sub	sp, #0x18
 800e82a: af00         	add	r7, sp, #0x0
 800e82c: 60f8         	str	r0, [r7, #0xc]
 800e82e: 60b9         	str	r1, [r7, #0x8]
 800e830: 607a         	str	r2, [r7, #0x4]
 800e832: 603b         	str	r3, [r7]
; 	if (!msg) {
 800e834: 68fb         	ldr	r3, [r7, #0xc]
 800e836: 2b00         	cmp	r3, #0x0
 800e838: d103         	bne	0x800e842 <z_log_msg_finalize+0x1c> @ imm = #0x6
; 		z_log_dropped(false);
 800e83a: 2000         	movs	r0, #0x0
 800e83c: f7f2 fef4    	bl	0x8001628 <z_log_dropped> @ imm = #-0xd218
; 		return;
 800e840: e01c         	b	0x800e87c <z_log_msg_finalize+0x56> @ imm = #0x38
; 	if (data) {
 800e842: 683b         	ldr	r3, [r7]
 800e844: 2b00         	cmp	r3, #0x0
 800e846: d010         	beq	0x800e86a <z_log_msg_finalize+0x44> @ imm = #0x20
; 		uint8_t *d = msg->data + desc.package_len;
 800e848: 68fb         	ldr	r3, [r7, #0xc]
 800e84a: 3310         	adds	r3, #0x10
 800e84c: 687a         	ldr	r2, [r7, #0x4]
 800e84e: f3c2 224a    	ubfx	r2, r2, #0x9, #0xb
 800e852: b292         	uxth	r2, r2
 800e854: 4413         	add	r3, r2
 800e856: 617b         	str	r3, [r7, #0x14]
; 		memcpy(d, data, desc.data_len);
 800e858: 88fb         	ldrh	r3, [r7, #0x6]
 800e85a: f3c3 130b    	ubfx	r3, r3, #0x4, #0xc
 800e85e: b29b         	uxth	r3, r3
 800e860: 461a         	mov	r2, r3
 800e862: 6839         	ldr	r1, [r7]
 800e864: 6978         	ldr	r0, [r7, #0x14]
 800e866: f005 fc4b    	bl	0x8014100 <memcpy>      @ imm = #0x5896
; 	msg->hdr.desc = desc;
 800e86a: 68fb         	ldr	r3, [r7, #0xc]
 800e86c: 687a         	ldr	r2, [r7, #0x4]
 800e86e: 601a         	str	r2, [r3]
; 	msg->hdr.source = source;
 800e870: 68fb         	ldr	r3, [r7, #0xc]
 800e872: 68ba         	ldr	r2, [r7, #0x8]
 800e874: 605a         	str	r2, [r3, #0x4]
; 	z_log_msg_commit(msg);
 800e876: 68f8         	ldr	r0, [r7, #0xc]
 800e878: f7f2 feec    	bl	0x8001654 <z_log_msg_commit> @ imm = #-0xd228
; }
 800e87c: 3718         	adds	r7, #0x18
 800e87e: 46bd         	mov	sp, r7
 800e880: bd80         	pop	{r7, pc}

0800e882 <log_msg_get_source_id>:
; {
 800e882: b580         	push	{r7, lr}
 800e884: b084         	sub	sp, #0x10
 800e886: af00         	add	r7, sp, #0x0
 800e888: 6078         	str	r0, [r7, #0x4]
; 	if (!z_log_is_local_domain(log_msg_get_domain(msg))) {
 800e88a: 6878         	ldr	r0, [r7, #0x4]
 800e88c: f7ff ff9b    	bl	0x800e7c6 <log_msg_get_domain> @ imm = #-0xca
 800e890: 4603         	mov	r3, r0
 800e892: 4618         	mov	r0, r3
 800e894: f7ff ffbc    	bl	0x800e810 <z_log_is_local_domain> @ imm = #-0x88
 800e898: 4603         	mov	r3, r0
 800e89a: f083 0301    	eor	r3, r3, #0x1
 800e89e: b2db         	uxtb	r3, r3
 800e8a0: 2b00         	cmp	r3, #0x0
 800e8a2: d005         	beq	0x800e8b0 <log_msg_get_source_id+0x2e> @ imm = #0xa
; 		return (int16_t)(uintptr_t)log_msg_get_source(msg);
 800e8a4: 6878         	ldr	r0, [r7, #0x4]
 800e8a6: f7ff ff9c    	bl	0x800e7e2 <log_msg_get_source> @ imm = #-0xc8
 800e8aa: 4603         	mov	r3, r0
 800e8ac: b21b         	sxth	r3, r3
 800e8ae: e00e         	b	0x800e8ce <log_msg_get_source_id+0x4c> @ imm = #0x1c
; 	void *source = (void *)log_msg_get_source(msg);
 800e8b0: 6878         	ldr	r0, [r7, #0x4]
 800e8b2: f7ff ff96    	bl	0x800e7e2 <log_msg_get_source> @ imm = #-0xd4
 800e8b6: 60f8         	str	r0, [r7, #0xc]
; 	if (source != NULL) {
 800e8b8: 68fb         	ldr	r3, [r7, #0xc]
 800e8ba: 2b00         	cmp	r3, #0x0
 800e8bc: d005         	beq	0x800e8ca <log_msg_get_source_id+0x48> @ imm = #0xa
; 		return log_source_id(source);
 800e8be: 68f8         	ldr	r0, [r7, #0xc]
 800e8c0: f7ff ff9a    	bl	0x800e7f8 <log_source_id> @ imm = #-0xcc
 800e8c4: 4603         	mov	r3, r0
 800e8c6: b21b         	sxth	r3, r3
 800e8c8: e001         	b	0x800e8ce <log_msg_get_source_id+0x4c> @ imm = #0x2
; 	return -1;
 800e8ca: f04f 33ff    	mov.w	r3, #0xffffffff
; }
 800e8ce: 4618         	mov	r0, r3
 800e8d0: 3710         	adds	r7, #0x10
 800e8d2: 46bd         	mov	sp, r7
 800e8d4: bd80         	pop	{r7, pc}

0800e8d6 <log_msg_get_domain>:
; {
 800e8d6: b480         	push	{r7}
 800e8d8: b083         	sub	sp, #0xc
 800e8da: af00         	add	r7, sp, #0x0
 800e8dc: 6078         	str	r0, [r7, #0x4]
; 	return msg->hdr.desc.domain;
 800e8de: 687b         	ldr	r3, [r7, #0x4]
 800e8e0: 781b         	ldrb	r3, [r3]
 800e8e2: f3c3 03c2    	ubfx	r3, r3, #0x3, #0x3
 800e8e6: b2db         	uxtb	r3, r3
; }
 800e8e8: 4618         	mov	r0, r3
 800e8ea: 370c         	adds	r7, #0xc
 800e8ec: 46bd         	mov	sp, r7
 800e8ee: bc80         	pop	{r7}
 800e8f0: 4770         	bx	lr

0800e8f2 <log_msg_get_level>:
; {
 800e8f2: b480         	push	{r7}
 800e8f4: b083         	sub	sp, #0xc
 800e8f6: af00         	add	r7, sp, #0x0
 800e8f8: 6078         	str	r0, [r7, #0x4]
; 	return msg->hdr.desc.level;
 800e8fa: 687b         	ldr	r3, [r7, #0x4]
 800e8fc: 881b         	ldrh	r3, [r3]
 800e8fe: f3c3 1382    	ubfx	r3, r3, #0x6, #0x3
 800e902: b2db         	uxtb	r3, r3
; }
 800e904: 4618         	mov	r0, r3
 800e906: 370c         	adds	r7, #0xc
 800e908: 46bd         	mov	sp, r7
 800e90a: bc80         	pop	{r7}
 800e90c: 4770         	bx	lr

0800e90e <log_msg_get_timestamp>:
; {
 800e90e: b480         	push	{r7}
 800e910: b083         	sub	sp, #0xc
 800e912: af00         	add	r7, sp, #0x0
 800e914: 6078         	str	r0, [r7, #0x4]
; 	return msg->hdr.timestamp;
 800e916: 687b         	ldr	r3, [r7, #0x4]
 800e918: 689b         	ldr	r3, [r3, #0x8]
; }
 800e91a: 4618         	mov	r0, r3
 800e91c: 370c         	adds	r7, #0xc
 800e91e: 46bd         	mov	sp, r7
 800e920: bc80         	pop	{r7}
 800e922: 4770         	bx	lr

0800e924 <log_msg_get_tid>:
; {
 800e924: b480         	push	{r7}
 800e926: b083         	sub	sp, #0xc
 800e928: af00         	add	r7, sp, #0x0
 800e92a: 6078         	str	r0, [r7, #0x4]
; 	return NULL;
 800e92c: 2300         	movs	r3, #0x0
; }
 800e92e: 4618         	mov	r0, r3
 800e930: 370c         	adds	r7, #0xc
 800e932: 46bd         	mov	sp, r7
 800e934: bc80         	pop	{r7}
 800e936: 4770         	bx	lr

0800e938 <log_msg_get_data>:
; {
 800e938: b480         	push	{r7}
 800e93a: b083         	sub	sp, #0xc
 800e93c: af00         	add	r7, sp, #0x0
 800e93e: 6078         	str	r0, [r7, #0x4]
 800e940: 6039         	str	r1, [r7]
; 	*len = msg->hdr.desc.data_len;
 800e942: 687b         	ldr	r3, [r7, #0x4]
 800e944: 885b         	ldrh	r3, [r3, #0x2]
 800e946: f3c3 130b    	ubfx	r3, r3, #0x4, #0xc
 800e94a: b29b         	uxth	r3, r3
 800e94c: 461a         	mov	r2, r3
 800e94e: 683b         	ldr	r3, [r7]
 800e950: 601a         	str	r2, [r3]
; 	return msg->data + msg->hdr.desc.package_len;
 800e952: 687b         	ldr	r3, [r7, #0x4]
 800e954: 3310         	adds	r3, #0x10
 800e956: 687a         	ldr	r2, [r7, #0x4]
 800e958: 6812         	ldr	r2, [r2]
 800e95a: f3c2 224a    	ubfx	r2, r2, #0x9, #0xb
 800e95e: b292         	uxth	r2, r2
 800e960: 4413         	add	r3, r2
; }
 800e962: 4618         	mov	r0, r3
 800e964: 370c         	adds	r7, #0xc
 800e966: 46bd         	mov	sp, r7
 800e968: bc80         	pop	{r7}
 800e96a: 4770         	bx	lr

0800e96c <log_msg_get_package>:
; {
 800e96c: b480         	push	{r7}
 800e96e: b083         	sub	sp, #0xc
 800e970: af00         	add	r7, sp, #0x0
 800e972: 6078         	str	r0, [r7, #0x4]
 800e974: 6039         	str	r1, [r7]
; 	*len = msg->hdr.desc.package_len;
 800e976: 687b         	ldr	r3, [r7, #0x4]
 800e978: 681b         	ldr	r3, [r3]
 800e97a: f3c3 234a    	ubfx	r3, r3, #0x9, #0xb
 800e97e: b29b         	uxth	r3, r3
 800e980: 461a         	mov	r2, r3
 800e982: 683b         	ldr	r3, [r7]
 800e984: 601a         	str	r2, [r3]
; 	return msg->data;
 800e986: 687b         	ldr	r3, [r7, #0x4]
 800e988: 3310         	adds	r3, #0x10
; }
 800e98a: 4618         	mov	r0, r3
 800e98c: 370c         	adds	r7, #0xc
 800e98e: 46bd         	mov	sp, r7
 800e990: bc80         	pop	{r7}
 800e992: 4770         	bx	lr

0800e994 <log_output_write>:
; {
 800e994: b580         	push	{r7, lr}
 800e996: b086         	sub	sp, #0x18
 800e998: af00         	add	r7, sp, #0x0
 800e99a: 60f8         	str	r0, [r7, #0xc]
 800e99c: 60b9         	str	r1, [r7, #0x8]
 800e99e: 607a         	str	r2, [r7, #0x4]
 800e9a0: 603b         	str	r3, [r7]
; 	while (len != 0) {
 800e9a2: e00d         	b	0x800e9c0 <log_output_write+0x2c> @ imm = #0x1a
; 		processed = outf(buf, len, ctx);
 800e9a4: 68fb         	ldr	r3, [r7, #0xc]
 800e9a6: 683a         	ldr	r2, [r7]
 800e9a8: 6879         	ldr	r1, [r7, #0x4]
 800e9aa: 68b8         	ldr	r0, [r7, #0x8]
 800e9ac: 4798         	blx	r3
 800e9ae: 6178         	str	r0, [r7, #0x14]
; 		len -= processed;
 800e9b0: 697b         	ldr	r3, [r7, #0x14]
 800e9b2: 687a         	ldr	r2, [r7, #0x4]
 800e9b4: 1ad3         	subs	r3, r2, r3
 800e9b6: 607b         	str	r3, [r7, #0x4]
; 		buf += processed;
 800e9b8: 697b         	ldr	r3, [r7, #0x14]
 800e9ba: 68ba         	ldr	r2, [r7, #0x8]
 800e9bc: 4413         	add	r3, r2
 800e9be: 60bb         	str	r3, [r7, #0x8]
; 	while (len != 0) {
 800e9c0: 687b         	ldr	r3, [r7, #0x4]
 800e9c2: 2b00         	cmp	r3, #0x0
 800e9c4: d1ee         	bne	0x800e9a4 <log_output_write+0x10> @ imm = #-0x24
; }
 800e9c6: bf00         	nop
 800e9c8: bf00         	nop
 800e9ca: 3718         	adds	r7, #0x18
 800e9cc: 46bd         	mov	sp, r7
 800e9ce: bd80         	pop	{r7, pc}

0800e9d0 <log_output_flush>:
; {
 800e9d0: b580         	push	{r7, lr}
 800e9d2: b082         	sub	sp, #0x8
 800e9d4: af00         	add	r7, sp, #0x0
 800e9d6: 6078         	str	r0, [r7, #0x4]
; 	log_output_write(output->func, output->buf, output->control_block->offset,
 800e9d8: 687b         	ldr	r3, [r7, #0x4]
 800e9da: 6818         	ldr	r0, [r3]
 800e9dc: 687b         	ldr	r3, [r7, #0x4]
 800e9de: 6899         	ldr	r1, [r3, #0x8]
 800e9e0: 687b         	ldr	r3, [r7, #0x4]
 800e9e2: 685b         	ldr	r3, [r3, #0x4]
 800e9e4: 681b         	ldr	r3, [r3]
 800e9e6: 461a         	mov	r2, r3
; 			 output->control_block->ctx);
 800e9e8: 687b         	ldr	r3, [r7, #0x4]
 800e9ea: 685b         	ldr	r3, [r3, #0x4]
; 	log_output_write(output->func, output->buf, output->control_block->offset,
 800e9ec: 685b         	ldr	r3, [r3, #0x4]
 800e9ee: f7ff ffd1    	bl	0x800e994 <log_output_write> @ imm = #-0x5e
; 	output->control_block->offset = 0;
 800e9f2: 687b         	ldr	r3, [r7, #0x4]
 800e9f4: 685b         	ldr	r3, [r3, #0x4]
 800e9f6: 2200         	movs	r2, #0x0
 800e9f8: 601a         	str	r2, [r3]
; }
 800e9fa: bf00         	nop
 800e9fc: 3708         	adds	r7, #0x8
 800e9fe: 46bd         	mov	sp, r7
 800ea00: bd80         	pop	{r7, pc}

0800ea02 <out_func>:
; {
 800ea02: b580         	push	{r7, lr}
 800ea04: b084         	sub	sp, #0x10
 800ea06: af00         	add	r7, sp, #0x0
 800ea08: 6078         	str	r0, [r7, #0x4]
 800ea0a: 6039         	str	r1, [r7]
; 	const struct log_output *out_ctx = (const struct log_output *)ctx;
 800ea0c: 683b         	ldr	r3, [r7]
 800ea0e: 60fb         	str	r3, [r7, #0xc]
; 		char x = (char)c;
 800ea10: 687b         	ldr	r3, [r7, #0x4]
 800ea12: b2db         	uxtb	r3, r3
 800ea14: 72fb         	strb	r3, [r7, #0xb]
; 		out_ctx->func((uint8_t *)&x, 1, out_ctx->control_block->ctx);
 800ea16: 68fb         	ldr	r3, [r7, #0xc]
 800ea18: 681b         	ldr	r3, [r3]
 800ea1a: 68fa         	ldr	r2, [r7, #0xc]
 800ea1c: 6852         	ldr	r2, [r2, #0x4]
 800ea1e: 6852         	ldr	r2, [r2, #0x4]
 800ea20: f107 000b    	add.w	r0, r7, #0xb
 800ea24: 2101         	movs	r1, #0x1
 800ea26: 4798         	blx	r3
; 		return 0;
 800ea28: 2300         	movs	r3, #0x0
; }
 800ea2a: 4618         	mov	r0, r3
 800ea2c: 3710         	adds	r7, #0x10
 800ea2e: 46bd         	mov	sp, r7
 800ea30: bd80         	pop	{r7, pc}

0800ea32 <cr_out_func>:
; {
 800ea32: b580         	push	{r7, lr}
 800ea34: b082         	sub	sp, #0x8
 800ea36: af00         	add	r7, sp, #0x0
 800ea38: 6078         	str	r0, [r7, #0x4]
 800ea3a: 6039         	str	r1, [r7]
; 	if (c == '\n') {
 800ea3c: 687b         	ldr	r3, [r7, #0x4]
 800ea3e: 2b0a         	cmp	r3, #0xa
 800ea40: d103         	bne	0x800ea4a <cr_out_func+0x18> @ imm = #0x6
; 		out_func((int)'\r', ctx);
 800ea42: 6839         	ldr	r1, [r7]
 800ea44: 200d         	movs	r0, #0xd
 800ea46: f7ff ffdc    	bl	0x800ea02 <out_func>    @ imm = #-0x48
; 	out_func(c, ctx);
 800ea4a: 6839         	ldr	r1, [r7]
 800ea4c: 6878         	ldr	r0, [r7, #0x4]
 800ea4e: f7ff ffd8    	bl	0x800ea02 <out_func>    @ imm = #-0x50
; 	return 0;
 800ea52: 2300         	movs	r3, #0x0
; }
 800ea54: 4618         	mov	r0, r3
 800ea56: 3708         	adds	r7, #0x8
 800ea58: 46bd         	mov	sp, r7
 800ea5a: bd80         	pop	{r7, pc}

0800ea5c <color_prefix>:
; {
 800ea5c: b580         	push	{r7, lr}
 800ea5e: b084         	sub	sp, #0x10
 800ea60: af00         	add	r7, sp, #0x0
 800ea62: 60f8         	str	r0, [r7, #0xc]
 800ea64: 460b         	mov	r3, r1
 800ea66: 607a         	str	r2, [r7, #0x4]
 800ea68: 72fb         	strb	r3, [r7, #0xb]
; 	color_print(output, color, true, level);
 800ea6a: 7af9         	ldrb	r1, [r7, #0xb]
 800ea6c: 687b         	ldr	r3, [r7, #0x4]
 800ea6e: 2201         	movs	r2, #0x1
 800ea70: 68f8         	ldr	r0, [r7, #0xc]
 800ea72: f7f3 f857    	bl	0x8001b24 <color_print> @ imm = #-0xcf52
; }
 800ea76: bf00         	nop
 800ea78: 3710         	adds	r7, #0x10
 800ea7a: 46bd         	mov	sp, r7
 800ea7c: bd80         	pop	{r7, pc}

0800ea7e <color_postfix>:
; {
 800ea7e: b580         	push	{r7, lr}
 800ea80: b084         	sub	sp, #0x10
 800ea82: af00         	add	r7, sp, #0x0
 800ea84: 60f8         	str	r0, [r7, #0xc]
 800ea86: 460b         	mov	r3, r1
 800ea88: 607a         	str	r2, [r7, #0x4]
 800ea8a: 72fb         	strb	r3, [r7, #0xb]
; 	color_print(output, color, false, level);
 800ea8c: 7af9         	ldrb	r1, [r7, #0xb]
 800ea8e: 687b         	ldr	r3, [r7, #0x4]
 800ea90: 2200         	movs	r2, #0x0
 800ea92: 68f8         	ldr	r0, [r7, #0xc]
 800ea94: f7f3 f846    	bl	0x8001b24 <color_print> @ imm = #-0xcf74
; }
 800ea98: bf00         	nop
 800ea9a: 3710         	adds	r7, #0x10
 800ea9c: 46bd         	mov	sp, r7
 800ea9e: bd80         	pop	{r7, pc}

0800eaa0 <log_msg_hexdump>:
; {
 800eaa0: b580         	push	{r7, lr}
 800eaa2: b088         	sub	sp, #0x20
 800eaa4: af02         	add	r7, sp, #0x8
 800eaa6: 60f8         	str	r0, [r7, #0xc]
 800eaa8: 60b9         	str	r1, [r7, #0x8]
 800eaaa: 607a         	str	r2, [r7, #0x4]
 800eaac: 603b         	str	r3, [r7]
; 		length = MIN(len, HEXDUMP_BYTES_IN_LINE);
 800eaae: 687b         	ldr	r3, [r7, #0x4]
 800eab0: 2b10         	cmp	r3, #0x10
 800eab2: bf28         	it	hs
 800eab4: 2310         	movhs	r3, #0x10
 800eab6: 617b         	str	r3, [r7, #0x14]
; 		hexdump_line_print(output, data, length,
 800eab8: 6a3b         	ldr	r3, [r7, #0x20]
 800eaba: 9300         	str	r3, [sp]
 800eabc: 683b         	ldr	r3, [r7]
 800eabe: 697a         	ldr	r2, [r7, #0x14]
 800eac0: 68b9         	ldr	r1, [r7, #0x8]
 800eac2: 68f8         	ldr	r0, [r7, #0xc]
 800eac4: f7f3 f8cc    	bl	0x8001c60 <hexdump_line_print> @ imm = #-0xce68
; 		data += length;
 800eac8: 68ba         	ldr	r2, [r7, #0x8]
 800eaca: 697b         	ldr	r3, [r7, #0x14]
 800eacc: 4413         	add	r3, r2
 800eace: 60bb         	str	r3, [r7, #0x8]
; 		len -= length;
 800ead0: 687a         	ldr	r2, [r7, #0x4]
 800ead2: 697b         	ldr	r3, [r7, #0x14]
 800ead4: 1ad3         	subs	r3, r2, r3
 800ead6: 607b         	str	r3, [r7, #0x4]
; 	} while (len);
 800ead8: 687b         	ldr	r3, [r7, #0x4]
 800eada: 2b00         	cmp	r3, #0x0
 800eadc: d1e7         	bne	0x800eaae <log_msg_hexdump+0xe> @ imm = #-0x32
; }
 800eade: bf00         	nop
 800eae0: bf00         	nop
 800eae2: 3718         	adds	r7, #0x18
 800eae4: 46bd         	mov	sp, r7
 800eae6: bd80         	pop	{r7, pc}

0800eae8 <postfix_print>:
; {
 800eae8: b580         	push	{r7, lr}
 800eaea: b084         	sub	sp, #0x10
 800eaec: af00         	add	r7, sp, #0x0
 800eaee: 60f8         	str	r0, [r7, #0xc]
 800eaf0: 60b9         	str	r1, [r7, #0x8]
 800eaf2: 4613         	mov	r3, r2
 800eaf4: 71fb         	strb	r3, [r7, #0x7]
; 	color_postfix(output, (flags & LOG_OUTPUT_FLAG_COLORS),
 800eaf6: 68bb         	ldr	r3, [r7, #0x8]
 800eaf8: f003 0301    	and	r3, r3, #0x1
 800eafc: 2b00         	cmp	r3, #0x0
 800eafe: bf14         	ite	ne
 800eb00: 2301         	movne	r3, #0x1
 800eb02: 2300         	moveq	r3, #0x0
 800eb04: b2db         	uxtb	r3, r3
 800eb06: 79fa         	ldrb	r2, [r7, #0x7]
 800eb08: 4619         	mov	r1, r3
 800eb0a: 68f8         	ldr	r0, [r7, #0xc]
 800eb0c: f7ff ffb7    	bl	0x800ea7e <color_postfix> @ imm = #-0x92
; 	newline_print(output, flags);
 800eb10: 68b9         	ldr	r1, [r7, #0x8]
 800eb12: 68f8         	ldr	r0, [r7, #0xc]
 800eb14: f7f3 f882    	bl	0x8001c1c <newline_print> @ imm = #-0xcefc
; }
 800eb18: bf00         	nop
 800eb1a: 3710         	adds	r7, #0x10
 800eb1c: 46bd         	mov	sp, r7
 800eb1e: bd80         	pop	{r7, pc}

0800eb20 <log_output_msg_process>:
; {
 800eb20: b580         	push	{r7, lr}
 800eb22: b092         	sub	sp, #0x48
 800eb24: af06         	add	r7, sp, #0x18
 800eb26: 60f8         	str	r0, [r7, #0xc]
 800eb28: 60b9         	str	r1, [r7, #0x8]
 800eb2a: 607a         	str	r2, [r7, #0x4]
; 	log_timestamp_t timestamp = log_msg_get_timestamp(msg);
 800eb2c: 68b8         	ldr	r0, [r7, #0x8]
 800eb2e: f7ff feee    	bl	0x800e90e <log_msg_get_timestamp> @ imm = #-0x224
 800eb32: 62f8         	str	r0, [r7, #0x2c]
; 	uint8_t level = log_msg_get_level(msg);
 800eb34: 68b8         	ldr	r0, [r7, #0x8]
 800eb36: f7ff fedc    	bl	0x800e8f2 <log_msg_get_level> @ imm = #-0x248
 800eb3a: 4603         	mov	r3, r0
 800eb3c: f887 302b    	strb.w	r3, [r7, #0x2b]
; 	uint8_t domain_id = log_msg_get_domain(msg);
 800eb40: 68b8         	ldr	r0, [r7, #0x8]
 800eb42: f7ff fec8    	bl	0x800e8d6 <log_msg_get_domain> @ imm = #-0x270
 800eb46: 4603         	mov	r3, r0
 800eb48: f887 302a    	strb.w	r3, [r7, #0x2a]
; 	int16_t source_id = log_msg_get_source_id(msg);
 800eb4c: 68b8         	ldr	r0, [r7, #0x8]
 800eb4e: f7ff fe98    	bl	0x800e882 <log_msg_get_source_id> @ imm = #-0x2d0
 800eb52: 4603         	mov	r3, r0
 800eb54: 853b         	strh	r3, [r7, #0x28]
; 	const char *sname = source_id >= 0 ? log_source_name_get(domain_id, source_id) : NULL;
 800eb56: f9b7 3028    	ldrsh.w	r3, [r7, #0x28]
 800eb5a: 2b00         	cmp	r3, #0x0
 800eb5c: db09         	blt	0x800eb72 <log_output_msg_process+0x52> @ imm = #0x12
 800eb5e: f897 302a    	ldrb.w	r3, [r7, #0x2a]
 800eb62: f9b7 2028    	ldrsh.w	r2, [r7, #0x28]
 800eb66: 4611         	mov	r1, r2
 800eb68: 4618         	mov	r0, r3
 800eb6a: f7f2 fe33    	bl	0x80017d4 <log_source_name_get> @ imm = #-0xd39a
 800eb6e: 4603         	mov	r3, r0
 800eb70: e000         	b	0x800eb74 <log_output_msg_process+0x54> @ imm = #0x0
 800eb72: 2300         	movs	r3, #0x0
 800eb74: 627b         	str	r3, [r7, #0x24]
; 	uint8_t *package = log_msg_get_package(msg, &plen);
 800eb76: f107 0318    	add.w	r3, r7, #0x18
 800eb7a: 4619         	mov	r1, r3
 800eb7c: 68b8         	ldr	r0, [r7, #0x8]
 800eb7e: f7ff fef5    	bl	0x800e96c <log_msg_get_package> @ imm = #-0x216
 800eb82: 6238         	str	r0, [r7, #0x20]
; 	uint8_t *data = log_msg_get_data(msg, &dlen);
 800eb84: f107 0314    	add.w	r3, r7, #0x14
 800eb88: 4619         	mov	r1, r3
 800eb8a: 68b8         	ldr	r0, [r7, #0x8]
 800eb8c: f7ff fed4    	bl	0x800e938 <log_msg_get_data> @ imm = #-0x258
 800eb90: 61f8         	str	r0, [r7, #0x1c]
; 	log_output_process(output, timestamp, NULL, sname, (k_tid_t)log_msg_get_tid(msg), level,
 800eb92: 68b8         	ldr	r0, [r7, #0x8]
 800eb94: f7ff fec6    	bl	0x800e924 <log_msg_get_tid> @ imm = #-0x274
; 			   plen > 0 ? package : NULL, data, dlen, flags);
 800eb98: 69bb         	ldr	r3, [r7, #0x18]
; 	log_output_process(output, timestamp, NULL, sname, (k_tid_t)log_msg_get_tid(msg), level,
 800eb9a: 2b00         	cmp	r3, #0x0
 800eb9c: d001         	beq	0x800eba2 <log_output_msg_process+0x82> @ imm = #0x2
 800eb9e: 6a3b         	ldr	r3, [r7, #0x20]
 800eba0: e000         	b	0x800eba4 <log_output_msg_process+0x84> @ imm = #0x0
 800eba2: 2300         	movs	r3, #0x0
 800eba4: 697a         	ldr	r2, [r7, #0x14]
 800eba6: 6879         	ldr	r1, [r7, #0x4]
 800eba8: 9105         	str	r1, [sp, #0x14]
 800ebaa: 9204         	str	r2, [sp, #0x10]
 800ebac: 69fa         	ldr	r2, [r7, #0x1c]
 800ebae: 9203         	str	r2, [sp, #0xc]
 800ebb0: 9302         	str	r3, [sp, #0x8]
 800ebb2: f897 302b    	ldrb.w	r3, [r7, #0x2b]
 800ebb6: 9301         	str	r3, [sp, #0x4]
 800ebb8: 9000         	str	r0, [sp]
 800ebba: 6a7b         	ldr	r3, [r7, #0x24]
 800ebbc: 2200         	movs	r2, #0x0
 800ebbe: 6af9         	ldr	r1, [r7, #0x2c]
 800ebc0: 68f8         	ldr	r0, [r7, #0xc]
 800ebc2: f7f3 f947    	bl	0x8001e54 <log_output_process> @ imm = #-0xcd72
; }
 800ebc6: bf00         	nop
 800ebc8: 3730         	adds	r7, #0x30
 800ebca: 46bd         	mov	sp, r7
 800ebcc: bd80         	pop	{r7, pc}

0800ebce <log_output_write>:
; {
 800ebce: b580         	push	{r7, lr}
 800ebd0: b086         	sub	sp, #0x18
 800ebd2: af00         	add	r7, sp, #0x0
 800ebd4: 60f8         	str	r0, [r7, #0xc]
 800ebd6: 60b9         	str	r1, [r7, #0x8]
 800ebd8: 607a         	str	r2, [r7, #0x4]
 800ebda: 603b         	str	r3, [r7]
; 	while (len != 0) {
 800ebdc: e00d         	b	0x800ebfa <log_output_write+0x2c> @ imm = #0x1a
; 		processed = outf(buf, len, ctx);
 800ebde: 68fb         	ldr	r3, [r7, #0xc]
 800ebe0: 683a         	ldr	r2, [r7]
 800ebe2: 6879         	ldr	r1, [r7, #0x4]
 800ebe4: 68b8         	ldr	r0, [r7, #0x8]
 800ebe6: 4798         	blx	r3
 800ebe8: 6178         	str	r0, [r7, #0x14]
; 		len -= processed;
 800ebea: 697b         	ldr	r3, [r7, #0x14]
 800ebec: 687a         	ldr	r2, [r7, #0x4]
 800ebee: 1ad3         	subs	r3, r2, r3
 800ebf0: 607b         	str	r3, [r7, #0x4]
; 		buf += processed;
 800ebf2: 697b         	ldr	r3, [r7, #0x14]
 800ebf4: 68ba         	ldr	r2, [r7, #0x8]
 800ebf6: 4413         	add	r3, r2
 800ebf8: 60bb         	str	r3, [r7, #0x8]
; 	while (len != 0) {
 800ebfa: 687b         	ldr	r3, [r7, #0x4]
 800ebfc: 2b00         	cmp	r3, #0x0
 800ebfe: d1ee         	bne	0x800ebde <log_output_write+0x10> @ imm = #-0x24
; }
 800ec00: bf00         	nop
 800ec02: bf00         	nop
 800ec04: 3718         	adds	r7, #0x18
 800ec06: 46bd         	mov	sp, r7
 800ec08: bd80         	pop	{r7, pc}

0800ec0a <log_output_flush>:
; {
 800ec0a: b580         	push	{r7, lr}
 800ec0c: b082         	sub	sp, #0x8
 800ec0e: af00         	add	r7, sp, #0x0
 800ec10: 6078         	str	r0, [r7, #0x4]
; 	log_output_write(output->func, output->buf, output->control_block->offset,
 800ec12: 687b         	ldr	r3, [r7, #0x4]
 800ec14: 6818         	ldr	r0, [r3]
 800ec16: 687b         	ldr	r3, [r7, #0x4]
 800ec18: 6899         	ldr	r1, [r3, #0x8]
 800ec1a: 687b         	ldr	r3, [r7, #0x4]
 800ec1c: 685b         	ldr	r3, [r3, #0x4]
 800ec1e: 681b         	ldr	r3, [r3]
 800ec20: 461a         	mov	r2, r3
; 			 output->control_block->ctx);
 800ec22: 687b         	ldr	r3, [r7, #0x4]
 800ec24: 685b         	ldr	r3, [r3, #0x4]
; 	log_output_write(output->func, output->buf, output->control_block->offset,
 800ec26: 685b         	ldr	r3, [r3, #0x4]
 800ec28: f7ff ffd1    	bl	0x800ebce <log_output_write> @ imm = #-0x5e
; 	output->control_block->offset = 0;
 800ec2c: 687b         	ldr	r3, [r7, #0x4]
 800ec2e: 685b         	ldr	r3, [r3, #0x4]
 800ec30: 2200         	movs	r2, #0x0
 800ec32: 601a         	str	r2, [r3]
; }
 800ec34: bf00         	nop
 800ec36: 3708         	adds	r7, #0x8
 800ec38: 46bd         	mov	sp, r7
 800ec3a: bd80         	pop	{r7, pc}

0800ec3c <log_output_ctx_set>:
; {
 800ec3c: b480         	push	{r7}
 800ec3e: b083         	sub	sp, #0xc
 800ec40: af00         	add	r7, sp, #0x0
 800ec42: 6078         	str	r0, [r7, #0x4]
 800ec44: 6039         	str	r1, [r7]
; 	output->control_block->ctx = ctx;
 800ec46: 687b         	ldr	r3, [r7, #0x4]
 800ec48: 685b         	ldr	r3, [r3, #0x4]
 800ec4a: 683a         	ldr	r2, [r7]
 800ec4c: 605a         	str	r2, [r3, #0x4]
; }
 800ec4e: bf00         	nop
 800ec50: 370c         	adds	r7, #0xc
 800ec52: 46bd         	mov	sp, r7
 800ec54: bc80         	pop	{r7}
 800ec56: 4770         	bx	lr

0800ec58 <log_backend_std_get_flags>:
; {
 800ec58: b480         	push	{r7}
 800ec5a: b083         	sub	sp, #0xc
 800ec5c: af00         	add	r7, sp, #0x0
; 	uint32_t flags = (LOG_OUTPUT_FLAG_LEVEL | LOG_OUTPUT_FLAG_TIMESTAMP);
 800ec5e: 230a         	movs	r3, #0xa
 800ec60: 607b         	str	r3, [r7, #0x4]
; 		flags |= LOG_OUTPUT_FLAG_COLORS;
 800ec62: 687b         	ldr	r3, [r7, #0x4]
 800ec64: f043 0301    	orr	r3, r3, #0x1
 800ec68: 607b         	str	r3, [r7, #0x4]
; 		flags |= LOG_OUTPUT_FLAG_FORMAT_TIMESTAMP;
 800ec6a: 687b         	ldr	r3, [r7, #0x4]
 800ec6c: f043 0304    	orr	r3, r3, #0x4
 800ec70: 607b         	str	r3, [r7, #0x4]
; 	return flags;
 800ec72: 687b         	ldr	r3, [r7, #0x4]
; }
 800ec74: 4618         	mov	r0, r3
 800ec76: 370c         	adds	r7, #0xc
 800ec78: 46bd         	mov	sp, r7
 800ec7a: bc80         	pop	{r7}
 800ec7c: 4770         	bx	lr

0800ec7e <log_backend_std_panic>:
; {
 800ec7e: b580         	push	{r7, lr}
 800ec80: b082         	sub	sp, #0x8
 800ec82: af00         	add	r7, sp, #0x0
 800ec84: 6078         	str	r0, [r7, #0x4]
; 	log_output_flush(output);
 800ec86: 6878         	ldr	r0, [r7, #0x4]
 800ec88: f7ff ffbf    	bl	0x800ec0a <log_output_flush> @ imm = #-0x82
; }
 800ec8c: bf00         	nop
 800ec8e: 3708         	adds	r7, #0x8
 800ec90: 46bd         	mov	sp, r7
 800ec92: bd80         	pop	{r7, pc}

0800ec94 <z_impl_uart_poll_out>:
; {
 800ec94: b580         	push	{r7, lr}
 800ec96: b084         	sub	sp, #0x10
 800ec98: af00         	add	r7, sp, #0x0
 800ec9a: 6078         	str	r0, [r7, #0x4]
 800ec9c: 460b         	mov	r3, r1
 800ec9e: 70fb         	strb	r3, [r7, #0x3]
; 	const struct uart_driver_api *api = (const struct uart_driver_api *)dev->api;
 800eca0: 687b         	ldr	r3, [r7, #0x4]
 800eca2: 689b         	ldr	r3, [r3, #0x8]
 800eca4: 60fb         	str	r3, [r7, #0xc]
; 	api->poll_out(dev, out_char);
 800eca6: 68fb         	ldr	r3, [r7, #0xc]
 800eca8: 685b         	ldr	r3, [r3, #0x4]
 800ecaa: 78fa         	ldrb	r2, [r7, #0x3]
 800ecac: 4611         	mov	r1, r2
 800ecae: 6878         	ldr	r0, [r7, #0x4]
 800ecb0: 4798         	blx	r3
; }
 800ecb2: bf00         	nop
 800ecb4: 3710         	adds	r7, #0x10
 800ecb6: 46bd         	mov	sp, r7
 800ecb8: bd80         	pop	{r7, pc}

0800ecba <uart_poll_out>:
; {
 800ecba: b580         	push	{r7, lr}
 800ecbc: b082         	sub	sp, #0x8
 800ecbe: af00         	add	r7, sp, #0x0
 800ecc0: 6078         	str	r0, [r7, #0x4]
 800ecc2: 460b         	mov	r3, r1
 800ecc4: 70fb         	strb	r3, [r7, #0x3]
; 	z_impl_uart_poll_out(dev, out_char);
 800ecc6: 78fb         	ldrb	r3, [r7, #0x3]
 800ecc8: 4619         	mov	r1, r3
 800ecca: 6878         	ldr	r0, [r7, #0x4]
 800eccc: f7ff ffe2    	bl	0x800ec94 <z_impl_uart_poll_out> @ imm = #-0x3c
; }
 800ecd0: bf00         	nop
 800ecd2: 3708         	adds	r7, #0x8
 800ecd4: 46bd         	mov	sp, r7
 800ecd6: bd80         	pop	{r7, pc}

0800ecd8 <pm_device_runtime_get>:
; {
 800ecd8: b480         	push	{r7}
 800ecda: b083         	sub	sp, #0xc
 800ecdc: af00         	add	r7, sp, #0x0
 800ecde: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 800ece0: 2300         	movs	r3, #0x0
; }
 800ece2: 4618         	mov	r0, r3
 800ece4: 370c         	adds	r7, #0xc
 800ece6: 46bd         	mov	sp, r7
 800ece8: bc80         	pop	{r7}
 800ecea: 4770         	bx	lr

0800ecec <pm_device_runtime_put_async>:
; {
 800ecec: b480         	push	{r7}
 800ecee: b085         	sub	sp, #0x14
 800ecf0: af00         	add	r7, sp, #0x0
 800ecf2: 60f8         	str	r0, [r7, #0xc]
 800ecf4: e9c7 2300    	strd	r2, r3, [r7]
; 	return 0;
 800ecf8: 2300         	movs	r3, #0x0
; }
 800ecfa: 4618         	mov	r0, r3
 800ecfc: 3714         	adds	r7, #0x14
 800ecfe: 46bd         	mov	sp, r7
 800ed00: bc80         	pop	{r7}
 800ed02: 4770         	bx	lr

0800ed04 <process>:
; {
 800ed04: b580         	push	{r7, lr}
 800ed06: b086         	sub	sp, #0x18
 800ed08: af00         	add	r7, sp, #0x0
 800ed0a: 6078         	str	r0, [r7, #0x4]
 800ed0c: 6039         	str	r1, [r7]
; 	const struct lbu_cb_ctx *ctx = backend->cb->ctx;
 800ed0e: 687b         	ldr	r3, [r7, #0x4]
 800ed10: 685b         	ldr	r3, [r3, #0x4]
 800ed12: 681b         	ldr	r3, [r3]
 800ed14: 617b         	str	r3, [r7, #0x14]
; 	struct lbu_data *data = ctx->data;
 800ed16: 697b         	ldr	r3, [r7, #0x14]
 800ed18: 685b         	ldr	r3, [r3, #0x4]
 800ed1a: 613b         	str	r3, [r7, #0x10]
; 	uint32_t flags = log_backend_std_get_flags();
 800ed1c: f7ff ff9c    	bl	0x800ec58 <log_backend_std_get_flags> @ imm = #-0xc8
 800ed20: 60f8         	str	r0, [r7, #0xc]
; 	log_format_func_t log_output_func = log_format_func_t_get(data->log_format_current);
 800ed22: 693b         	ldr	r3, [r7, #0x10]
 800ed24: 691b         	ldr	r3, [r3, #0x10]
 800ed26: 4618         	mov	r0, r3
 800ed28: f7f2 fb6a    	bl	0x8001400 <log_format_func_t_get> @ imm = #-0xd92c
 800ed2c: 60b8         	str	r0, [r7, #0x8]
; 	log_output_func(ctx->output, &msg->log, flags);
 800ed2e: 697b         	ldr	r3, [r7, #0x14]
 800ed30: 6818         	ldr	r0, [r3]
 800ed32: 6839         	ldr	r1, [r7]
 800ed34: 68bb         	ldr	r3, [r7, #0x8]
 800ed36: 68fa         	ldr	r2, [r7, #0xc]
 800ed38: 4798         	blx	r3
; }
 800ed3a: bf00         	nop
 800ed3c: 3718         	adds	r7, #0x18
 800ed3e: 46bd         	mov	sp, r7
 800ed40: bd80         	pop	{r7, pc}

0800ed42 <format_set>:
; {
 800ed42: b480         	push	{r7}
 800ed44: b085         	sub	sp, #0x14
 800ed46: af00         	add	r7, sp, #0x0
 800ed48: 6078         	str	r0, [r7, #0x4]
 800ed4a: 6039         	str	r1, [r7]
; 	const struct lbu_cb_ctx *ctx = backend->cb->ctx;
 800ed4c: 687b         	ldr	r3, [r7, #0x4]
 800ed4e: 685b         	ldr	r3, [r3, #0x4]
 800ed50: 681b         	ldr	r3, [r3]
 800ed52: 60fb         	str	r3, [r7, #0xc]
; 	struct lbu_data *data = ctx->data;
 800ed54: 68fb         	ldr	r3, [r7, #0xc]
 800ed56: 685b         	ldr	r3, [r3, #0x4]
 800ed58: 60bb         	str	r3, [r7, #0x8]
; 	data->log_format_current = log_type;
 800ed5a: 68bb         	ldr	r3, [r7, #0x8]
 800ed5c: 683a         	ldr	r2, [r7]
 800ed5e: 611a         	str	r2, [r3, #0x10]
; 	return 0;
 800ed60: 2300         	movs	r3, #0x0
; }
 800ed62: 4618         	mov	r0, r3
 800ed64: 3714         	adds	r7, #0x14
 800ed66: 46bd         	mov	sp, r7
 800ed68: bc80         	pop	{r7}
 800ed6a: 4770         	bx	lr

0800ed6c <z_log_msg_runtime_create>:
; {
 800ed6c: b580         	push	{r7, lr}
 800ed6e: b08a         	sub	sp, #0x28
 800ed70: af04         	add	r7, sp, #0x10
 800ed72: 60b9         	str	r1, [r7, #0x8]
 800ed74: 607b         	str	r3, [r7, #0x4]
 800ed76: 4603         	mov	r3, r0
 800ed78: 73fb         	strb	r3, [r7, #0xf]
 800ed7a: 4613         	mov	r3, r2
 800ed7c: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 800ed7e: f107 032c    	add.w	r3, r7, #0x2c
 800ed82: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 800ed84: 7bba         	ldrb	r2, [r7, #0xe]
 800ed86: 7bf8         	ldrb	r0, [r7, #0xf]
 800ed88: 697b         	ldr	r3, [r7, #0x14]
 800ed8a: 9303         	str	r3, [sp, #0xc]
 800ed8c: 6abb         	ldr	r3, [r7, #0x28]
 800ed8e: 9302         	str	r3, [sp, #0x8]
 800ed90: 6a7b         	ldr	r3, [r7, #0x24]
 800ed92: 9301         	str	r3, [sp, #0x4]
 800ed94: 6a3b         	ldr	r3, [r7, #0x20]
 800ed96: 9300         	str	r3, [sp]
 800ed98: 687b         	ldr	r3, [r7, #0x4]
 800ed9a: 68b9         	ldr	r1, [r7, #0x8]
 800ed9c: f7f2 fd52    	bl	0x8001844 <z_log_msg_runtime_vcreate> @ imm = #-0xd55c
; }
 800eda0: bf00         	nop
 800eda2: 3718         	adds	r7, #0x18
 800eda4: 46bd         	mov	sp, r7
 800eda6: bd80         	pop	{r7, pc}

0800eda8 <z_do_kernel_oops>:
; {
 800eda8: b580         	push	{r7, lr}
 800edaa: b088         	sub	sp, #0x20
 800edac: af00         	add	r7, sp, #0x0
 800edae: 60f8         	str	r0, [r7, #0xc]
 800edb0: 60b9         	str	r1, [r7, #0x8]
 800edb2: 607a         	str	r2, [r7, #0x4]
; 	unsigned int reason = esf->basic.r0;
 800edb4: 68fb         	ldr	r3, [r7, #0xc]
 800edb6: 681b         	ldr	r3, [r3]
 800edb8: 61fb         	str	r3, [r7, #0x1c]
 800edba: 68fb         	ldr	r3, [r7, #0xc]
 800edbc: 61bb         	str	r3, [r7, #0x18]
 800edbe: 687b         	ldr	r3, [r7, #0x4]
 800edc0: 617b         	str	r3, [r7, #0x14]
; }
 800edc2: bf00         	nop
; 	z_arm_fatal_error(reason, esf);
 800edc4: 68f9         	ldr	r1, [r7, #0xc]
 800edc6: 69f8         	ldr	r0, [r7, #0x1c]
 800edc8: f7f3 f9c6    	bl	0x8002158 <z_arm_fatal_error> @ imm = #-0xcc74
; }
 800edcc: bf00         	nop
 800edce: 3720         	adds	r7, #0x20
 800edd0: 46bd         	mov	sp, r7
 800edd2: bd80         	pop	{r7, pc}

0800edd4 <arch_tls_stack_setup>:
; {
 800edd4: b580         	push	{r7, lr}
 800edd6: b082         	sub	sp, #0x8
 800edd8: af00         	add	r7, sp, #0x0
 800edda: 6078         	str	r0, [r7, #0x4]
 800eddc: 6039         	str	r1, [r7]
; 	stack_ptr -= z_tls_data_size();
 800edde: f7f3 fa07    	bl	0x80021f0 <z_tls_data_size> @ imm = #-0xcbf2
 800ede2: 4603         	mov	r3, r0
 800ede4: 425b         	rsbs	r3, r3, #0
 800ede6: 683a         	ldr	r2, [r7]
 800ede8: 4413         	add	r3, r2
 800edea: 603b         	str	r3, [r7]
; 	z_tls_copy(stack_ptr);
 800edec: 6838         	ldr	r0, [r7]
 800edee: f7f3 fa0d    	bl	0x800220c <z_tls_copy>  @ imm = #-0xcbe6
; 	stack_ptr -= sizeof(uintptr_t) * 2;
 800edf2: 683b         	ldr	r3, [r7]
 800edf4: 3b08         	subs	r3, #0x8
 800edf6: 603b         	str	r3, [r7]
; 	new_thread->tls = POINTER_TO_UINT(stack_ptr);
 800edf8: 683a         	ldr	r2, [r7]
 800edfa: 687b         	ldr	r3, [r7, #0x4]
 800edfc: f8c3 20c4    	str.w	r2, [r3, #0xc4]
; 	return (z_tls_data_size() + (sizeof(uintptr_t) * 2));
 800ee00: f7f3 f9f6    	bl	0x80021f0 <z_tls_data_size> @ imm = #-0xcc14
 800ee04: 4603         	mov	r3, r0
 800ee06: 3308         	adds	r3, #0x8
; }
 800ee08: 4618         	mov	r0, r3
 800ee0a: 3708         	adds	r7, #0x8
 800ee0c: 46bd         	mov	sp, r7
 800ee0e: bd80         	pop	{r7, pc}

0800ee10 <z_log_msg_runtime_create>:
; {
 800ee10: b580         	push	{r7, lr}
 800ee12: b08a         	sub	sp, #0x28
 800ee14: af04         	add	r7, sp, #0x10
 800ee16: 60b9         	str	r1, [r7, #0x8]
 800ee18: 607b         	str	r3, [r7, #0x4]
 800ee1a: 4603         	mov	r3, r0
 800ee1c: 73fb         	strb	r3, [r7, #0xf]
 800ee1e: 4613         	mov	r3, r2
 800ee20: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 800ee22: f107 032c    	add.w	r3, r7, #0x2c
 800ee26: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 800ee28: 7bba         	ldrb	r2, [r7, #0xe]
 800ee2a: 7bf8         	ldrb	r0, [r7, #0xf]
 800ee2c: 697b         	ldr	r3, [r7, #0x14]
 800ee2e: 9303         	str	r3, [sp, #0xc]
 800ee30: 6abb         	ldr	r3, [r7, #0x28]
 800ee32: 9302         	str	r3, [sp, #0x8]
 800ee34: 6a7b         	ldr	r3, [r7, #0x24]
 800ee36: 9301         	str	r3, [sp, #0x4]
 800ee38: 6a3b         	ldr	r3, [r7, #0x20]
 800ee3a: 9300         	str	r3, [sp]
 800ee3c: 687b         	ldr	r3, [r7, #0x4]
 800ee3e: 68b9         	ldr	r1, [r7, #0x8]
 800ee40: f7f2 fd00    	bl	0x8001844 <z_log_msg_runtime_vcreate> @ imm = #-0xd600
; }
 800ee44: bf00         	nop
 800ee46: 3718         	adds	r7, #0x18
 800ee48: 46bd         	mov	sp, r7
 800ee4a: bd80         	pop	{r7, pc}

0800ee4c <fault_show>:
; {
 800ee4c: b480         	push	{r7}
 800ee4e: b083         	sub	sp, #0xc
 800ee50: af00         	add	r7, sp, #0x0
 800ee52: 6078         	str	r0, [r7, #0x4]
 800ee54: 6039         	str	r1, [r7]
; }
 800ee56: bf00         	nop
 800ee58: 370c         	adds	r7, #0xc
 800ee5a: 46bd         	mov	sp, r7
 800ee5c: bc80         	pop	{r7}
 800ee5e: 4770         	bx	lr

0800ee60 <memory_fault_recoverable>:
; {
 800ee60: b480         	push	{r7}
 800ee62: b083         	sub	sp, #0xc
 800ee64: af00         	add	r7, sp, #0x0
 800ee66: 6078         	str	r0, [r7, #0x4]
 800ee68: 460b         	mov	r3, r1
 800ee6a: 70fb         	strb	r3, [r7, #0x3]
; 	return false;
 800ee6c: 2300         	movs	r3, #0x0
; }
 800ee6e: 4618         	mov	r0, r3
 800ee70: 370c         	adds	r7, #0xc
 800ee72: 46bd         	mov	sp, r7
 800ee74: bc80         	pop	{r7}
 800ee76: 4770         	bx	lr

0800ee78 <arch_irq_enable>:
; {
 800ee78: b580         	push	{r7, lr}
 800ee7a: b082         	sub	sp, #0x8
 800ee7c: af00         	add	r7, sp, #0x0
 800ee7e: 6078         	str	r0, [r7, #0x4]
; 	NVIC_EnableIRQ((IRQn_Type)irq);
 800ee80: 687b         	ldr	r3, [r7, #0x4]
 800ee82: b25b         	sxtb	r3, r3
 800ee84: 4618         	mov	r0, r3
 800ee86: f7f4 f927    	bl	0x80030d8 <__NVIC_EnableIRQ> @ imm = #-0xbdb2
; }
 800ee8a: bf00         	nop
 800ee8c: 3708         	adds	r7, #0x8
 800ee8e: 46bd         	mov	sp, r7
 800ee90: bd80         	pop	{r7, pc}

0800ee92 <z_arm_irq_priority_set>:
; {
 800ee92: b580         	push	{r7, lr}
 800ee94: b084         	sub	sp, #0x10
 800ee96: af00         	add	r7, sp, #0x0
 800ee98: 60f8         	str	r0, [r7, #0xc]
 800ee9a: 60b9         	str	r1, [r7, #0x8]
 800ee9c: 607a         	str	r2, [r7, #0x4]
; 		prio += _IRQ_PRIO_OFFSET;
 800ee9e: 68bb         	ldr	r3, [r7, #0x8]
 800eea0: 3301         	adds	r3, #0x1
 800eea2: 60bb         	str	r3, [r7, #0x8]
; 	NVIC_SetPriority((IRQn_Type)irq, prio);
 800eea4: 68fb         	ldr	r3, [r7, #0xc]
 800eea6: b25b         	sxtb	r3, r3
 800eea8: 68b9         	ldr	r1, [r7, #0x8]
 800eeaa: 4618         	mov	r0, r3
 800eeac: f7f4 f930    	bl	0x8003110 <__NVIC_SetPriority> @ imm = #-0xbda0
; }
 800eeb0: bf00         	nop
 800eeb2: 3710         	adds	r7, #0x10
 800eeb4: 46bd         	mov	sp, r7
 800eeb6: bd80         	pop	{r7, pc}

0800eeb8 <z_irq_spurious>:
; {
 800eeb8: b580         	push	{r7, lr}
 800eeba: b082         	sub	sp, #0x8
 800eebc: af00         	add	r7, sp, #0x0
 800eebe: 6078         	str	r0, [r7, #0x4]
; 	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
 800eec0: 2100         	movs	r1, #0x0
 800eec2: 2001         	movs	r0, #0x1
 800eec4: f7f3 f948    	bl	0x8002158 <z_arm_fatal_error> @ imm = #-0xcd70
; }
 800eec8: bf00         	nop
 800eeca: 3708         	adds	r7, #0x8
 800eecc: 46bd         	mov	sp, r7
 800eece: bd80         	pop	{r7, pc}

0800eed0 <z_prep_c>:
; {
 800eed0: b580         	push	{r7, lr}
 800eed2: af00         	add	r7, sp, #0x0
; 	relocate_vector_table();
 800eed4: f7f4 f946    	bl	0x8003164 <relocate_vector_table> @ imm = #-0xbd74
; 	z_arm_floating_point_init();
 800eed8: f7f4 f95e    	bl	0x8003198 <z_arm_floating_point_init> @ imm = #-0xbd44
; 	z_bss_zero();
 800eedc: f7fa f9ae    	bl	0x800923c <z_bss_zero>  @ imm = #-0x5ca4
; 	z_data_copy();
 800eee0: f7fd f858    	bl	0x800bf94 <z_data_copy> @ imm = #-0x2f50
; 	z_arm_interrupt_init();
 800eee4: f000 f83d    	bl	0x800ef62 <z_arm_interrupt_init> @ imm = #0x7a
; 	z_cstart();
 800eee8: f7fa fae2    	bl	0x80094b0 <z_cstart>    @ imm = #-0x5a3c

0800eeec <z_arm_prepare_switch_to_main>:
; {
 800eeec: b480         	push	{r7}
 800eeee: af00         	add	r7, sp, #0x0
; }
 800eef0: bf00         	nop
 800eef2: 46bd         	mov	sp, r7
 800eef4: bc80         	pop	{r7}
 800eef6: 4770         	bx	lr

0800eef8 <arch_irq_unlock_outlined>:
; {
 800eef8: b480         	push	{r7}
 800eefa: b085         	sub	sp, #0x14
 800eefc: af00         	add	r7, sp, #0x0
 800eefe: 6078         	str	r0, [r7, #0x4]
;   __ASM volatile ("cpsie f" : : : "memory");
 800ef00: b661         	cpsie f
; }
 800ef02: bf00         	nop
;   __ASM volatile ("cpsie i" : : : "memory");
 800ef04: b662         	cpsie i
; }
 800ef06: bf00         	nop
 800ef08: 687b         	ldr	r3, [r7, #0x4]
 800ef0a: 60fb         	str	r3, [r7, #0xc]
 800ef0c: 68fb         	ldr	r3, [r7, #0xc]
 800ef0e: 60bb         	str	r3, [r7, #0x8]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800ef10: 68bb         	ldr	r3, [r7, #0x8]
 800ef12: f383 8811    	msr	basepri, r3
; }
 800ef16: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800ef18: f3bf 8f6f    	isb	sy
; }
 800ef1c: bf00         	nop
; }
 800ef1e: bf00         	nop
; }
 800ef20: bf00         	nop
 800ef22: 3714         	adds	r7, #0x14
 800ef24: 46bd         	mov	sp, r7
 800ef26: bc80         	pop	{r7}
 800ef28: 4770         	bx	lr

0800ef2a <arch_cpu_idle>:
; {
 800ef2a: b480         	push	{r7}
 800ef2c: b083         	sub	sp, #0xc
 800ef2e: af00         	add	r7, sp, #0x0
;   __ASM volatile ("cpsid i" : : : "memory");
 800ef30: b672         	cpsid i
; }
 800ef32: bf00         	nop
 800ef34: 2300         	movs	r3, #0x0
 800ef36: 607b         	str	r3, [r7, #0x4]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800ef38: 687b         	ldr	r3, [r7, #0x4]
 800ef3a: f383 8811    	msr	basepri, r3
; }
 800ef3e: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800ef40: f3bf 8f6f    	isb	sy
; }
 800ef44: bf00         	nop
;   __ASM volatile ("dsb 0xF":::"memory");
 800ef46: f3bf 8f4f    	dsb	sy
; }
 800ef4a: bf00         	nop
; 	SLEEP_IF_ALLOWED(__WFI);
 800ef4c: bf30         	wfi
;   __ASM volatile ("cpsie i" : : : "memory");
 800ef4e: b662         	cpsie i
; }
 800ef50: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 800ef52: f3bf 8f6f    	isb	sy
; }
 800ef56: bf00         	nop
; }
 800ef58: bf00         	nop
 800ef5a: 370c         	adds	r7, #0xc
 800ef5c: 46bd         	mov	sp, r7
 800ef5e: bc80         	pop	{r7}
 800ef60: 4770         	bx	lr

0800ef62 <z_arm_interrupt_init>:
; {
 800ef62: b580         	push	{r7, lr}
 800ef64: b082         	sub	sp, #0x8
 800ef66: af00         	add	r7, sp, #0x0
; 	int irq = 0;
 800ef68: 2300         	movs	r3, #0x0
 800ef6a: 607b         	str	r3, [r7, #0x4]
; 	for (; irq < CONFIG_NUM_IRQS; irq++) {
 800ef6c: e008         	b	0x800ef80 <z_arm_interrupt_init+0x1e> @ imm = #0x10
; 		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
 800ef6e: 687b         	ldr	r3, [r7, #0x4]
 800ef70: b25b         	sxtb	r3, r3
 800ef72: 2101         	movs	r1, #0x1
 800ef74: 4618         	mov	r0, r3
 800ef76: f7f4 f99d    	bl	0x80032b4 <__NVIC_SetPriority> @ imm = #-0xbcc6
; 	for (; irq < CONFIG_NUM_IRQS; irq++) {
 800ef7a: 687b         	ldr	r3, [r7, #0x4]
 800ef7c: 3301         	adds	r3, #0x1
 800ef7e: 607b         	str	r3, [r7, #0x4]
 800ef80: 687b         	ldr	r3, [r7, #0x4]
 800ef82: 2b51         	cmp	r3, #0x51
 800ef84: ddf3         	ble	0x800ef6e <z_arm_interrupt_init+0xc> @ imm = #-0x1a
; }
 800ef86: bf00         	nop
 800ef88: bf00         	nop
 800ef8a: 3708         	adds	r7, #0x8
 800ef8c: 46bd         	mov	sp, r7
 800ef8e: bd80         	pop	{r7, pc}

0800ef90 <cbputc>:
; {
 800ef90: b580         	push	{r7, lr}
 800ef92: b084         	sub	sp, #0x10
 800ef94: af00         	add	r7, sp, #0x0
 800ef96: 4603         	mov	r3, r0
 800ef98: 6039         	str	r1, [r7]
 800ef9a: 71fb         	strb	r3, [r7, #0x7]
; 	struct cb_bits *s = (struct cb_bits *) _s;
 800ef9c: 683b         	ldr	r3, [r7]
 800ef9e: 60fb         	str	r3, [r7, #0xc]
; 	(*s->out) (c, s->ctx);
 800efa0: 68fb         	ldr	r3, [r7, #0xc]
 800efa2: 691b         	ldr	r3, [r3, #0x10]
 800efa4: 79f8         	ldrb	r0, [r7, #0x7]
 800efa6: 68fa         	ldr	r2, [r7, #0xc]
 800efa8: 6952         	ldr	r2, [r2, #0x14]
 800efaa: 4611         	mov	r1, r2
 800efac: 4798         	blx	r3
; 	return 0;
 800efae: 2300         	movs	r3, #0x0
; }
 800efb0: 4618         	mov	r0, r3
 800efb2: 3710         	adds	r7, #0x10
 800efb4: 46bd         	mov	sp, r7
 800efb6: bd80         	pop	{r7, pc}

0800efb8 <zephyr_fputc>:
; {
 800efb8: b580         	push	{r7, lr}
 800efba: b082         	sub	sp, #0x8
 800efbc: af00         	add	r7, sp, #0x0
 800efbe: 6078         	str	r0, [r7, #0x4]
 800efc0: 6039         	str	r1, [r7]
; 	return z_impl_zephyr_fputc(c, stream);
 800efc2: 6839         	ldr	r1, [r7]
 800efc4: 6878         	ldr	r0, [r7, #0x4]
 800efc6: f7f4 f9e3    	bl	0x8003390 <z_impl_zephyr_fputc> @ imm = #-0xbc3a
 800efca: 4603         	mov	r3, r0
; }
 800efcc: 4618         	mov	r0, r3
 800efce: 3708         	adds	r7, #0x8
 800efd0: 46bd         	mov	sp, r7
 800efd2: bd80         	pop	{r7, pc}

0800efd4 <picolibc_put>:
; {
 800efd4: b580         	push	{r7, lr}
 800efd6: b082         	sub	sp, #0x8
 800efd8: af00         	add	r7, sp, #0x0
 800efda: 4603         	mov	r3, r0
 800efdc: 6039         	str	r1, [r7]
 800efde: 71fb         	strb	r3, [r7, #0x7]
; 	zephyr_fputc(a, f);
 800efe0: 79fb         	ldrb	r3, [r7, #0x7]
 800efe2: 6839         	ldr	r1, [r7]
 800efe4: 4618         	mov	r0, r3
 800efe6: f7ff ffe7    	bl	0x800efb8 <zephyr_fputc> @ imm = #-0x32
; 	return 0;
 800efea: 2300         	movs	r3, #0x0
; }
 800efec: 4618         	mov	r0, r3
 800efee: 3708         	adds	r7, #0x8
 800eff0: 46bd         	mov	sp, r7
 800eff2: bd80         	pop	{r7, pc}

0800eff4 <clock_control_on>:
; {
 800eff4: b580         	push	{r7, lr}
 800eff6: b084         	sub	sp, #0x10
 800eff8: af00         	add	r7, sp, #0x0
 800effa: 6078         	str	r0, [r7, #0x4]
 800effc: 6039         	str	r1, [r7]
; 	const struct clock_control_driver_api *api =
 800effe: 687b         	ldr	r3, [r7, #0x4]
 800f000: 689b         	ldr	r3, [r3, #0x8]
 800f002: 60fb         	str	r3, [r7, #0xc]
; 	return api->on(dev, sys);
 800f004: 68fb         	ldr	r3, [r7, #0xc]
 800f006: 681b         	ldr	r3, [r3]
 800f008: 6839         	ldr	r1, [r7]
 800f00a: 6878         	ldr	r0, [r7, #0x4]
 800f00c: 4798         	blx	r3
 800f00e: 4603         	mov	r3, r0
; }
 800f010: 4618         	mov	r0, r3
 800f012: 3710         	adds	r7, #0x10
 800f014: 46bd         	mov	sp, r7
 800f016: bd80         	pop	{r7, pc}

0800f018 <z_stm32_hsem_lock>:
; {
 800f018: b480         	push	{r7}
 800f01a: b083         	sub	sp, #0xc
 800f01c: af00         	add	r7, sp, #0x0
 800f01e: 6078         	str	r0, [r7, #0x4]
 800f020: 6039         	str	r1, [r7]
; }
 800f022: bf00         	nop
 800f024: 370c         	adds	r7, #0xc
 800f026: 46bd         	mov	sp, r7
 800f028: bc80         	pop	{r7}
 800f02a: 4770         	bx	lr

0800f02c <z_stm32_hsem_unlock>:
; {
 800f02c: b480         	push	{r7}
 800f02e: b083         	sub	sp, #0xc
 800f030: af00         	add	r7, sp, #0x0
 800f032: 6078         	str	r0, [r7, #0x4]
; }
 800f034: bf00         	nop
 800f036: 370c         	adds	r7, #0xc
 800f038: 46bd         	mov	sp, r7
 800f03a: bc80         	pop	{r7}
 800f03c: 4770         	bx	lr

0800f03e <stm32_exti_linenum_to_src_cfg_line>:
; {
 800f03e: b480         	push	{r7}
 800f040: b083         	sub	sp, #0xc
 800f042: af00         	add	r7, sp, #0x0
 800f044: 4603         	mov	r3, r0
 800f046: 71fb         	strb	r3, [r7, #0x7]
; 	return (0xF << ((linenum % 4 * 4) + 16)) | (linenum / 4);
 800f048: 79fb         	ldrb	r3, [r7, #0x7]
 800f04a: f003 0303    	and	r3, r3, #0x3
 800f04e: 3304         	adds	r3, #0x4
 800f050: 009b         	lsls	r3, r3, #0x2
 800f052: 220f         	movs	r2, #0xf
 800f054: fa02 f303    	lsl.w	r3, r2, r3
 800f058: 79fa         	ldrb	r2, [r7, #0x7]
 800f05a: 0892         	lsrs	r2, r2, #0x2
 800f05c: b2d2         	uxtb	r2, r2
 800f05e: 4313         	orrs	r3, r2
; }
 800f060: 4618         	mov	r0, r3
 800f062: 370c         	adds	r7, #0xc
 800f064: 46bd         	mov	sp, r7
 800f066: bc80         	pop	{r7}
 800f068: 4770         	bx	lr

0800f06a <stm32_exti_is_pending>:
; {
 800f06a: b580         	push	{r7, lr}
 800f06c: b082         	sub	sp, #0x8
 800f06e: af00         	add	r7, sp, #0x0
 800f070: 6078         	str	r0, [r7, #0x4]
; 	return LL_EXTI_IsActiveFlag_0_31(line);
 800f072: 6878         	ldr	r0, [r7, #0x4]
 800f074: f7f4 fa42    	bl	0x80034fc <LL_EXTI_IsActiveFlag_0_31> @ imm = #-0xbb7c
 800f078: 4603         	mov	r3, r0
; }
 800f07a: 4618         	mov	r0, r3
 800f07c: 3708         	adds	r7, #0x8
 800f07e: 46bd         	mov	sp, r7
 800f080: bd80         	pop	{r7, pc}

0800f082 <stm32_exti_clear_pending>:
; {
 800f082: b580         	push	{r7, lr}
 800f084: b082         	sub	sp, #0x8
 800f086: af00         	add	r7, sp, #0x0
 800f088: 6078         	str	r0, [r7, #0x4]
; 	LL_EXTI_ClearFlag_0_31(line);
 800f08a: 6878         	ldr	r0, [r7, #0x4]
 800f08c: f7f4 fa4c    	bl	0x8003528 <LL_EXTI_ClearFlag_0_31> @ imm = #-0xbb68
; }
 800f090: bf00         	nop
 800f092: 3708         	adds	r7, #0x8
 800f094: 46bd         	mov	sp, r7
 800f096: bd80         	pop	{r7, pc}

0800f098 <linenum_to_ll_exti_line>:
; {
 800f098: b480         	push	{r7}
 800f09a: b083         	sub	sp, #0xc
 800f09c: af00         	add	r7, sp, #0x0
 800f09e: 4603         	mov	r3, r0
 800f0a0: 71fb         	strb	r3, [r7, #0x7]
; 	return BIT(linenum);
 800f0a2: 79fb         	ldrb	r3, [r7, #0x7]
 800f0a4: 2201         	movs	r2, #0x1
 800f0a6: fa02 f303    	lsl.w	r3, r2, r3
; }
 800f0aa: 4618         	mov	r0, r3
 800f0ac: 370c         	adds	r7, #0xc
 800f0ae: 46bd         	mov	sp, r7
 800f0b0: bc80         	pop	{r7}
 800f0b2: 4770         	bx	lr

0800f0b4 <ll_exti_line_to_linenum>:
; {
 800f0b4: b480         	push	{r7}
 800f0b6: b083         	sub	sp, #0xc
 800f0b8: af00         	add	r7, sp, #0x0
 800f0ba: 6078         	str	r0, [r7, #0x4]
; 	return LOG2(line);
 800f0bc: 687b         	ldr	r3, [r7, #0x4]
 800f0be: 2b00         	cmp	r3, #0x0
 800f0c0: d007         	beq	0x800f0d2 <ll_exti_line_to_linenum+0x1e> @ imm = #0xe
 800f0c2: 687b         	ldr	r3, [r7, #0x4]
 800f0c4: fab3 f383    	clz	r3, r3
 800f0c8: b2db         	uxtb	r3, r3
 800f0ca: f1c3 031f    	rsb.w	r3, r3, #0x1f
 800f0ce: b2db         	uxtb	r3, r3
 800f0d0: e000         	b	0x800f0d4 <ll_exti_line_to_linenum+0x20> @ imm = #0x0
 800f0d2: 23ff         	movs	r3, #0xff
; }
 800f0d4: 4618         	mov	r0, r3
 800f0d6: 370c         	adds	r7, #0xc
 800f0d8: 46bd         	mov	sp, r7
 800f0da: bc80         	pop	{r7}
 800f0dc: 4770         	bx	lr

0800f0de <stm32_gpio_intc_get_pin_irq_line>:
; {
 800f0de: b580         	push	{r7, lr}
 800f0e0: b082         	sub	sp, #0x8
 800f0e2: af00         	add	r7, sp, #0x0
 800f0e4: 6078         	str	r0, [r7, #0x4]
 800f0e6: 460b         	mov	r3, r1
 800f0e8: 70fb         	strb	r3, [r7, #0x3]
; 	return linenum_to_ll_exti_line(pin);
 800f0ea: 78fb         	ldrb	r3, [r7, #0x3]
 800f0ec: 4618         	mov	r0, r3
 800f0ee: f7ff ffd3    	bl	0x800f098 <linenum_to_ll_exti_line> @ imm = #-0x5a
 800f0f2: 4603         	mov	r3, r0
; }
 800f0f4: 4618         	mov	r0, r3
 800f0f6: 3708         	adds	r7, #0x8
 800f0f8: 46bd         	mov	sp, r7
 800f0fa: bd80         	pop	{r7, pc}

0800f0fc <stm32_gpio_intc_disable_line>:
; {
 800f0fc: b580         	push	{r7, lr}
 800f0fe: b082         	sub	sp, #0x8
 800f100: af00         	add	r7, sp, #0x0
 800f102: 6078         	str	r0, [r7, #0x4]
; 	LL_EXTI_DisableIT_0_31(line);
 800f104: 6878         	ldr	r0, [r7, #0x4]
 800f106: f7f4 f99f    	bl	0x8003448 <LL_EXTI_DisableIT_0_31> @ imm = #-0xbcc2
; }
 800f10a: bf00         	nop
 800f10c: 3708         	adds	r7, #0x8
 800f10e: 46bd         	mov	sp, r7
 800f110: bd80         	pop	{r7, pc}

0800f112 <stm32_exti_set_line_src_port>:
; {
 800f112: b580         	push	{r7, lr}
 800f114: b084         	sub	sp, #0x10
 800f116: af00         	add	r7, sp, #0x0
 800f118: 4603         	mov	r3, r0
 800f11a: 6039         	str	r1, [r7]
 800f11c: 71fb         	strb	r3, [r7, #0x7]
; 	uint32_t ll_line = stm32_exti_linenum_to_src_cfg_line(line);
 800f11e: 79fb         	ldrb	r3, [r7, #0x7]
 800f120: 4618         	mov	r0, r3
 800f122: f7ff ff8c    	bl	0x800f03e <stm32_exti_linenum_to_src_cfg_line> @ imm = #-0xe8
 800f126: 60f8         	str	r0, [r7, #0xc]
; 	z_stm32_hsem_lock(CFG_HW_EXTI_SEMID, HSEM_LOCK_DEFAULT_RETRY);
 800f128: f44f 1180    	mov.w	r1, #0x100000
 800f12c: 2000         	movs	r0, #0x0
 800f12e: f7ff ff73    	bl	0x800f018 <z_stm32_hsem_lock> @ imm = #-0x11a
; 	LL_SYSCFG_SetEXTISource(port, ll_line);
 800f132: 68f9         	ldr	r1, [r7, #0xc]
 800f134: 6838         	ldr	r0, [r7]
 800f136: f7f4 fa05    	bl	0x8003544 <LL_SYSCFG_SetEXTISource> @ imm = #-0xbbf6
; 	z_stm32_hsem_unlock(CFG_HW_EXTI_SEMID);
 800f13a: 2000         	movs	r0, #0x0
 800f13c: f7ff ff76    	bl	0x800f02c <z_stm32_hsem_unlock> @ imm = #-0x114
; }
 800f140: bf00         	nop
 800f142: 3710         	adds	r7, #0x10
 800f144: 46bd         	mov	sp, r7
 800f146: bd80         	pop	{r7, pc}

0800f148 <stm32_exti_get_line_src_port>:
; {
 800f148: b580         	push	{r7, lr}
 800f14a: b084         	sub	sp, #0x10
 800f14c: af00         	add	r7, sp, #0x0
 800f14e: 4603         	mov	r3, r0
 800f150: 71fb         	strb	r3, [r7, #0x7]
; 	uint32_t ll_line = stm32_exti_linenum_to_src_cfg_line(line);
 800f152: 79fb         	ldrb	r3, [r7, #0x7]
 800f154: 4618         	mov	r0, r3
 800f156: f7ff ff72    	bl	0x800f03e <stm32_exti_linenum_to_src_cfg_line> @ imm = #-0x11c
 800f15a: 60f8         	str	r0, [r7, #0xc]
; 	port = LL_SYSCFG_GetEXTISource(ll_line);
 800f15c: 68f8         	ldr	r0, [r7, #0xc]
 800f15e: f7f4 fa25    	bl	0x80035ac <LL_SYSCFG_GetEXTISource> @ imm = #-0xbbb6
 800f162: 60b8         	str	r0, [r7, #0x8]
; 	return port;
 800f164: 68bb         	ldr	r3, [r7, #0x8]
; }
 800f166: 4618         	mov	r0, r3
 800f168: 3710         	adds	r7, #0x10
 800f16a: 46bd         	mov	sp, r7
 800f16c: bd80         	pop	{r7, pc}

0800f16e <k_sem_init>:
; {
 800f16e: b580         	push	{r7, lr}
 800f170: b084         	sub	sp, #0x10
 800f172: af00         	add	r7, sp, #0x0
 800f174: 60f8         	str	r0, [r7, #0xc]
 800f176: 60b9         	str	r1, [r7, #0x8]
 800f178: 607a         	str	r2, [r7, #0x4]
; 	return z_impl_k_sem_init(sem, initial_count, limit);
 800f17a: 687a         	ldr	r2, [r7, #0x4]
 800f17c: 68b9         	ldr	r1, [r7, #0x8]
 800f17e: 68f8         	ldr	r0, [r7, #0xc]
 800f180: f004 f8fe    	bl	0x8013380 <z_impl_k_sem_init> @ imm = #0x41fc
 800f184: 4603         	mov	r3, r0
; }
 800f186: 4618         	mov	r0, r3
 800f188: 3710         	adds	r7, #0x10
 800f18a: 46bd         	mov	sp, r7
 800f18c: bd80         	pop	{r7, pc}

0800f18e <k_sem_take>:
; {
 800f18e: b580         	push	{r7, lr}
 800f190: b084         	sub	sp, #0x10
 800f192: af00         	add	r7, sp, #0x0
 800f194: 60f8         	str	r0, [r7, #0xc]
 800f196: e9c7 2300    	strd	r2, r3, [r7]
; 	return z_impl_k_sem_take(sem, timeout);
 800f19a: e9d7 2300    	ldrd	r2, r3, [r7]
 800f19e: 68f8         	ldr	r0, [r7, #0xc]
 800f1a0: f7fa ffc4    	bl	0x800a12c <z_impl_k_sem_take> @ imm = #-0x5078
 800f1a4: 4603         	mov	r3, r0
; }
 800f1a6: 4618         	mov	r0, r3
 800f1a8: 3710         	adds	r7, #0x10
 800f1aa: 46bd         	mov	sp, r7
 800f1ac: bd80         	pop	{r7, pc}

0800f1ae <k_sem_give>:
; {
 800f1ae: b580         	push	{r7, lr}
 800f1b0: b082         	sub	sp, #0x8
 800f1b2: af00         	add	r7, sp, #0x0
 800f1b4: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_sem_give(sem);
 800f1b6: 6878         	ldr	r0, [r7, #0x4]
 800f1b8: f7fa ff2a    	bl	0x800a010 <z_impl_k_sem_give> @ imm = #-0x51ac
; }
 800f1bc: bf00         	nop
 800f1be: 3708         	adds	r7, #0x8
 800f1c0: 46bd         	mov	sp, r7
 800f1c2: bd80         	pop	{r7, pc}

0800f1c4 <k_msgq_put>:
; {
 800f1c4: b580         	push	{r7, lr}
 800f1c6: b084         	sub	sp, #0x10
 800f1c8: af00         	add	r7, sp, #0x0
 800f1ca: 60f8         	str	r0, [r7, #0xc]
 800f1cc: 60b9         	str	r1, [r7, #0x8]
 800f1ce: e9c7 2300    	strd	r2, r3, [r7]
; 	return z_impl_k_msgq_put(msgq, data, timeout);
 800f1d2: e9d7 2300    	ldrd	r2, r3, [r7]
 800f1d6: 68b9         	ldr	r1, [r7, #0x8]
 800f1d8: 68f8         	ldr	r0, [r7, #0xc]
 800f1da: f7fa f9d3    	bl	0x8009584 <z_impl_k_msgq_put> @ imm = #-0x5c5a
 800f1de: 4603         	mov	r3, r0
; }
 800f1e0: 4618         	mov	r0, r3
 800f1e2: 3710         	adds	r7, #0x10
 800f1e4: 46bd         	mov	sp, r7
 800f1e6: bd80         	pop	{r7, pc}

0800f1e8 <z_impl_can_get_core_clock>:
; {
 800f1e8: b580         	push	{r7, lr}
 800f1ea: b084         	sub	sp, #0x10
 800f1ec: af00         	add	r7, sp, #0x0
 800f1ee: 6078         	str	r0, [r7, #0x4]
 800f1f0: 6039         	str	r1, [r7]
; 	const struct can_driver_api *api = (const struct can_driver_api *)dev->api;
 800f1f2: 687b         	ldr	r3, [r7, #0x4]
 800f1f4: 689b         	ldr	r3, [r3, #0x8]
 800f1f6: 60fb         	str	r3, [r7, #0xc]
; 	return api->get_core_clock(dev, rate);
 800f1f8: 68fb         	ldr	r3, [r7, #0xc]
 800f1fa: 6a9b         	ldr	r3, [r3, #0x28]
 800f1fc: 6839         	ldr	r1, [r7]
 800f1fe: 6878         	ldr	r0, [r7, #0x4]
 800f200: 4798         	blx	r3
 800f202: 4603         	mov	r3, r0
; }
 800f204: 4618         	mov	r0, r3
 800f206: 3710         	adds	r7, #0x10
 800f208: 46bd         	mov	sp, r7
 800f20a: bd80         	pop	{r7, pc}

0800f20c <z_impl_can_get_timing_min>:
; {
 800f20c: b480         	push	{r7}
 800f20e: b085         	sub	sp, #0x14
 800f210: af00         	add	r7, sp, #0x0
 800f212: 6078         	str	r0, [r7, #0x4]
; 	const struct can_driver_api *api = (const struct can_driver_api *)dev->api;
 800f214: 687b         	ldr	r3, [r7, #0x4]
 800f216: 689b         	ldr	r3, [r3, #0x8]
 800f218: 60fb         	str	r3, [r7, #0xc]
; 	return &api->timing_min;
 800f21a: 68fb         	ldr	r3, [r7, #0xc]
 800f21c: 3330         	adds	r3, #0x30
; }
 800f21e: 4618         	mov	r0, r3
 800f220: 3714         	adds	r7, #0x14
 800f222: 46bd         	mov	sp, r7
 800f224: bc80         	pop	{r7}
 800f226: 4770         	bx	lr

0800f228 <z_impl_can_get_timing_max>:
; {
 800f228: b480         	push	{r7}
 800f22a: b085         	sub	sp, #0x14
 800f22c: af00         	add	r7, sp, #0x0
 800f22e: 6078         	str	r0, [r7, #0x4]
; 	const struct can_driver_api *api = (const struct can_driver_api *)dev->api;
 800f230: 687b         	ldr	r3, [r7, #0x4]
 800f232: 689b         	ldr	r3, [r3, #0x8]
 800f234: 60fb         	str	r3, [r7, #0xc]
; 	return &api->timing_max;
 800f236: 68fb         	ldr	r3, [r7, #0xc]
 800f238: 333a         	adds	r3, #0x3a
; }
 800f23a: 4618         	mov	r0, r3
 800f23c: 3714         	adds	r7, #0x14
 800f23e: 46bd         	mov	sp, r7
 800f240: bc80         	pop	{r7}
 800f242: 4770         	bx	lr

0800f244 <can_get_core_clock>:
; {
 800f244: b580         	push	{r7, lr}
 800f246: b082         	sub	sp, #0x8
 800f248: af00         	add	r7, sp, #0x0
 800f24a: 6078         	str	r0, [r7, #0x4]
 800f24c: 6039         	str	r1, [r7]
; 	return z_impl_can_get_core_clock(dev, rate);
 800f24e: 6839         	ldr	r1, [r7]
 800f250: 6878         	ldr	r0, [r7, #0x4]
 800f252: f7ff ffc9    	bl	0x800f1e8 <z_impl_can_get_core_clock> @ imm = #-0x6e
 800f256: 4603         	mov	r3, r0
; }
 800f258: 4618         	mov	r0, r3
 800f25a: 3708         	adds	r7, #0x8
 800f25c: 46bd         	mov	sp, r7
 800f25e: bd80         	pop	{r7, pc}

0800f260 <can_get_timing_min>:
; {
 800f260: b580         	push	{r7, lr}
 800f262: b082         	sub	sp, #0x8
 800f264: af00         	add	r7, sp, #0x0
 800f266: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_can_get_timing_min(dev);
 800f268: 6878         	ldr	r0, [r7, #0x4]
 800f26a: f7ff ffcf    	bl	0x800f20c <z_impl_can_get_timing_min> @ imm = #-0x62
 800f26e: 4603         	mov	r3, r0
; }
 800f270: 4618         	mov	r0, r3
 800f272: 3708         	adds	r7, #0x8
 800f274: 46bd         	mov	sp, r7
 800f276: bd80         	pop	{r7, pc}

0800f278 <can_get_timing_max>:
; {
 800f278: b580         	push	{r7, lr}
 800f27a: b082         	sub	sp, #0x8
 800f27c: af00         	add	r7, sp, #0x0
 800f27e: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_can_get_timing_max(dev);
 800f280: 6878         	ldr	r0, [r7, #0x4]
 800f282: f7ff ffd1    	bl	0x800f228 <z_impl_can_get_timing_max> @ imm = #-0x5e
 800f286: 4603         	mov	r3, r0
; }
 800f288: 4618         	mov	r0, r3
 800f28a: 3708         	adds	r7, #0x8
 800f28c: 46bd         	mov	sp, r7
 800f28e: bd80         	pop	{r7, pc}

0800f290 <z_log_msg_runtime_create>:
; {
 800f290: b580         	push	{r7, lr}
 800f292: b08a         	sub	sp, #0x28
 800f294: af04         	add	r7, sp, #0x10
 800f296: 60b9         	str	r1, [r7, #0x8]
 800f298: 607b         	str	r3, [r7, #0x4]
 800f29a: 4603         	mov	r3, r0
 800f29c: 73fb         	strb	r3, [r7, #0xf]
 800f29e: 4613         	mov	r3, r2
 800f2a0: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 800f2a2: f107 032c    	add.w	r3, r7, #0x2c
 800f2a6: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 800f2a8: 7bba         	ldrb	r2, [r7, #0xe]
 800f2aa: 7bf8         	ldrb	r0, [r7, #0xf]
 800f2ac: 697b         	ldr	r3, [r7, #0x14]
 800f2ae: 9303         	str	r3, [sp, #0xc]
 800f2b0: 6abb         	ldr	r3, [r7, #0x28]
 800f2b2: 9302         	str	r3, [sp, #0x8]
 800f2b4: 6a7b         	ldr	r3, [r7, #0x24]
 800f2b6: 9301         	str	r3, [sp, #0x4]
 800f2b8: 6a3b         	ldr	r3, [r7, #0x20]
 800f2ba: 9300         	str	r3, [sp]
 800f2bc: 687b         	ldr	r3, [r7, #0x4]
 800f2be: 68b9         	ldr	r1, [r7, #0x8]
 800f2c0: f7f2 fac0    	bl	0x8001844 <z_log_msg_runtime_vcreate> @ imm = #-0xda80
; }
 800f2c4: bf00         	nop
 800f2c6: 3718         	adds	r7, #0x18
 800f2c8: 46bd         	mov	sp, r7
 800f2ca: bd80         	pop	{r7, pc}

0800f2cc <can_tx_default_cb>:
; {
 800f2cc: b580         	push	{r7, lr}
 800f2ce: b086         	sub	sp, #0x18
 800f2d0: af00         	add	r7, sp, #0x0
 800f2d2: 60f8         	str	r0, [r7, #0xc]
 800f2d4: 60b9         	str	r1, [r7, #0x8]
 800f2d6: 607a         	str	r2, [r7, #0x4]
; 	struct can_tx_default_cb_ctx *ctx = user_data;
 800f2d8: 687b         	ldr	r3, [r7, #0x4]
 800f2da: 617b         	str	r3, [r7, #0x14]
; 	ctx->status = error;
 800f2dc: 697b         	ldr	r3, [r7, #0x14]
 800f2de: 68ba         	ldr	r2, [r7, #0x8]
 800f2e0: 611a         	str	r2, [r3, #0x10]
; 	k_sem_give(&ctx->done);
 800f2e2: 697b         	ldr	r3, [r7, #0x14]
 800f2e4: 4618         	mov	r0, r3
 800f2e6: f7ff ff62    	bl	0x800f1ae <k_sem_give>  @ imm = #-0x13c
; }
 800f2ea: bf00         	nop
 800f2ec: 3718         	adds	r7, #0x18
 800f2ee: 46bd         	mov	sp, r7
 800f2f0: bd80         	pop	{r7, pc}

0800f2f2 <check_timing_in_range>:
; {
 800f2f2: b480         	push	{r7}
 800f2f4: b085         	sub	sp, #0x14
 800f2f6: af00         	add	r7, sp, #0x0
 800f2f8: 60f8         	str	r0, [r7, #0xc]
 800f2fa: 60b9         	str	r1, [r7, #0x8]
 800f2fc: 607a         	str	r2, [r7, #0x4]
; 	if (!IN_RANGE(timing->sjw, min->sjw, max->sjw) ||
 800f2fe: 68fb         	ldr	r3, [r7, #0xc]
 800f300: 881a         	ldrh	r2, [r3]
 800f302: 68bb         	ldr	r3, [r7, #0x8]
 800f304: 881b         	ldrh	r3, [r3]
 800f306: 429a         	cmp	r2, r3
 800f308: d335         	blo	0x800f376 <check_timing_in_range+0x84> @ imm = #0x6a
 800f30a: 68fb         	ldr	r3, [r7, #0xc]
 800f30c: 881a         	ldrh	r2, [r3]
 800f30e: 687b         	ldr	r3, [r7, #0x4]
 800f310: 881b         	ldrh	r3, [r3]
 800f312: 429a         	cmp	r2, r3
 800f314: d82f         	bhi	0x800f376 <check_timing_in_range+0x84> @ imm = #0x5e
; 	    !IN_RANGE(timing->prop_seg, min->prop_seg, max->prop_seg) ||
 800f316: 68fb         	ldr	r3, [r7, #0xc]
 800f318: 885a         	ldrh	r2, [r3, #0x2]
 800f31a: 68bb         	ldr	r3, [r7, #0x8]
 800f31c: 885b         	ldrh	r3, [r3, #0x2]
; 	if (!IN_RANGE(timing->sjw, min->sjw, max->sjw) ||
 800f31e: 429a         	cmp	r2, r3
 800f320: d329         	blo	0x800f376 <check_timing_in_range+0x84> @ imm = #0x52
; 	    !IN_RANGE(timing->prop_seg, min->prop_seg, max->prop_seg) ||
 800f322: 68fb         	ldr	r3, [r7, #0xc]
 800f324: 885a         	ldrh	r2, [r3, #0x2]
 800f326: 687b         	ldr	r3, [r7, #0x4]
 800f328: 885b         	ldrh	r3, [r3, #0x2]
 800f32a: 429a         	cmp	r2, r3
 800f32c: d823         	bhi	0x800f376 <check_timing_in_range+0x84> @ imm = #0x46
; 	    !IN_RANGE(timing->phase_seg1, min->phase_seg1, max->phase_seg1) ||
 800f32e: 68fb         	ldr	r3, [r7, #0xc]
 800f330: 889a         	ldrh	r2, [r3, #0x4]
 800f332: 68bb         	ldr	r3, [r7, #0x8]
 800f334: 889b         	ldrh	r3, [r3, #0x4]
; 	    !IN_RANGE(timing->prop_seg, min->prop_seg, max->prop_seg) ||
 800f336: 429a         	cmp	r2, r3
 800f338: d31d         	blo	0x800f376 <check_timing_in_range+0x84> @ imm = #0x3a
; 	    !IN_RANGE(timing->phase_seg1, min->phase_seg1, max->phase_seg1) ||
 800f33a: 68fb         	ldr	r3, [r7, #0xc]
 800f33c: 889a         	ldrh	r2, [r3, #0x4]
 800f33e: 687b         	ldr	r3, [r7, #0x4]
 800f340: 889b         	ldrh	r3, [r3, #0x4]
 800f342: 429a         	cmp	r2, r3
 800f344: d817         	bhi	0x800f376 <check_timing_in_range+0x84> @ imm = #0x2e
; 	    !IN_RANGE(timing->phase_seg2, min->phase_seg2, max->phase_seg2) ||
 800f346: 68fb         	ldr	r3, [r7, #0xc]
 800f348: 88da         	ldrh	r2, [r3, #0x6]
 800f34a: 68bb         	ldr	r3, [r7, #0x8]
 800f34c: 88db         	ldrh	r3, [r3, #0x6]
; 	    !IN_RANGE(timing->phase_seg1, min->phase_seg1, max->phase_seg1) ||
 800f34e: 429a         	cmp	r2, r3
 800f350: d311         	blo	0x800f376 <check_timing_in_range+0x84> @ imm = #0x22
; 	    !IN_RANGE(timing->phase_seg2, min->phase_seg2, max->phase_seg2) ||
 800f352: 68fb         	ldr	r3, [r7, #0xc]
 800f354: 88da         	ldrh	r2, [r3, #0x6]
 800f356: 687b         	ldr	r3, [r7, #0x4]
 800f358: 88db         	ldrh	r3, [r3, #0x6]
 800f35a: 429a         	cmp	r2, r3
 800f35c: d80b         	bhi	0x800f376 <check_timing_in_range+0x84> @ imm = #0x16
; 	    !IN_RANGE(timing->prescaler, min->prescaler, max->prescaler)) {
 800f35e: 68fb         	ldr	r3, [r7, #0xc]
 800f360: 891a         	ldrh	r2, [r3, #0x8]
 800f362: 68bb         	ldr	r3, [r7, #0x8]
 800f364: 891b         	ldrh	r3, [r3, #0x8]
; 	    !IN_RANGE(timing->phase_seg2, min->phase_seg2, max->phase_seg2) ||
 800f366: 429a         	cmp	r2, r3
 800f368: d305         	blo	0x800f376 <check_timing_in_range+0x84> @ imm = #0xa
; 	    !IN_RANGE(timing->prescaler, min->prescaler, max->prescaler)) {
 800f36a: 68fb         	ldr	r3, [r7, #0xc]
 800f36c: 891a         	ldrh	r2, [r3, #0x8]
 800f36e: 687b         	ldr	r3, [r7, #0x4]
 800f370: 891b         	ldrh	r3, [r3, #0x8]
 800f372: 429a         	cmp	r2, r3
 800f374: d902         	bls	0x800f37c <check_timing_in_range+0x8a> @ imm = #0x4
; 		return -ENOTSUP;
 800f376: f06f 0385    	mvn	r3, #0x85
 800f37a: e00f         	b	0x800f39c <check_timing_in_range+0xaa> @ imm = #0x1e
; 	if ((timing->sjw > timing->phase_seg1) || (timing->sjw > timing->phase_seg2)) {
 800f37c: 68fb         	ldr	r3, [r7, #0xc]
 800f37e: 881a         	ldrh	r2, [r3]
 800f380: 68fb         	ldr	r3, [r7, #0xc]
 800f382: 889b         	ldrh	r3, [r3, #0x4]
 800f384: 429a         	cmp	r2, r3
 800f386: d805         	bhi	0x800f394 <check_timing_in_range+0xa2> @ imm = #0xa
 800f388: 68fb         	ldr	r3, [r7, #0xc]
 800f38a: 881a         	ldrh	r2, [r3]
 800f38c: 68fb         	ldr	r3, [r7, #0xc]
 800f38e: 88db         	ldrh	r3, [r3, #0x6]
 800f390: 429a         	cmp	r2, r3
 800f392: d902         	bls	0x800f39a <check_timing_in_range+0xa8> @ imm = #0x4
; 		return -ENOTSUP;
 800f394: f06f 0385    	mvn	r3, #0x85
 800f398: e000         	b	0x800f39c <check_timing_in_range+0xaa> @ imm = #0x0
; 	return 0;
 800f39a: 2300         	movs	r3, #0x0
; }
 800f39c: 4618         	mov	r0, r3
 800f39e: 3714         	adds	r7, #0x14
 800f3a0: 46bd         	mov	sp, r7
 800f3a2: bc80         	pop	{r7}
 800f3a4: 4770         	bx	lr

0800f3a6 <z_impl_can_set_timing>:
; {
 800f3a6: b580         	push	{r7, lr}
 800f3a8: b086         	sub	sp, #0x18
 800f3aa: af00         	add	r7, sp, #0x0
 800f3ac: 6078         	str	r0, [r7, #0x4]
 800f3ae: 6039         	str	r1, [r7]
; 	const struct can_driver_api *api = (const struct can_driver_api *)dev->api;
 800f3b0: 687b         	ldr	r3, [r7, #0x4]
 800f3b2: 689b         	ldr	r3, [r3, #0x8]
 800f3b4: 617b         	str	r3, [r7, #0x14]
; 	const struct can_timing *min = can_get_timing_min(dev);
 800f3b6: 6878         	ldr	r0, [r7, #0x4]
 800f3b8: f7ff ff52    	bl	0x800f260 <can_get_timing_min> @ imm = #-0x15c
 800f3bc: 6138         	str	r0, [r7, #0x10]
; 	const struct can_timing *max = can_get_timing_max(dev);
 800f3be: 6878         	ldr	r0, [r7, #0x4]
 800f3c0: f7ff ff5a    	bl	0x800f278 <can_get_timing_max> @ imm = #-0x14c
 800f3c4: 60f8         	str	r0, [r7, #0xc]
; 	err = check_timing_in_range(timing, min, max);
 800f3c6: 68fa         	ldr	r2, [r7, #0xc]
 800f3c8: 6939         	ldr	r1, [r7, #0x10]
 800f3ca: 6838         	ldr	r0, [r7]
 800f3cc: f7ff ff91    	bl	0x800f2f2 <check_timing_in_range> @ imm = #-0xde
 800f3d0: 60b8         	str	r0, [r7, #0x8]
; 	if (err != 0) {
 800f3d2: 68bb         	ldr	r3, [r7, #0x8]
 800f3d4: 2b00         	cmp	r3, #0x0
 800f3d6: d001         	beq	0x800f3dc <z_impl_can_set_timing+0x36> @ imm = #0x2
; 		return err;
 800f3d8: 68bb         	ldr	r3, [r7, #0x8]
 800f3da: e005         	b	0x800f3e8 <z_impl_can_set_timing+0x42> @ imm = #0xa
; 	return api->set_timing(dev, timing);
 800f3dc: 697b         	ldr	r3, [r7, #0x14]
 800f3de: 691b         	ldr	r3, [r3, #0x10]
 800f3e0: 6839         	ldr	r1, [r7]
 800f3e2: 6878         	ldr	r0, [r7, #0x4]
 800f3e4: 4798         	blx	r3
 800f3e6: 4603         	mov	r3, r0
; }
 800f3e8: 4618         	mov	r0, r3
 800f3ea: 3718         	adds	r7, #0x18
 800f3ec: 46bd         	mov	sp, r7
 800f3ee: bd80         	pop	{r7, pc}

0800f3f0 <device_is_ready>:
; {
 800f3f0: b580         	push	{r7, lr}
 800f3f2: b082         	sub	sp, #0x8
 800f3f4: af00         	add	r7, sp, #0x0
 800f3f6: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 800f3f8: 6878         	ldr	r0, [r7, #0x4]
 800f3fa: f003 fb8a    	bl	0x8012b12 <z_impl_device_is_ready> @ imm = #0x3714
 800f3fe: 4603         	mov	r3, r0
; }
 800f400: 4618         	mov	r0, r3
 800f402: 3708         	adds	r7, #0x8
 800f404: 46bd         	mov	sp, r7
 800f406: bd80         	pop	{r7, pc}

0800f408 <arch_k_cycle_get_32>:
; {
 800f408: b580         	push	{r7, lr}
 800f40a: af00         	add	r7, sp, #0x0
; 	return sys_clock_cycle_get_32();
 800f40c: f7f8 fb4c    	bl	0x8007aa8 <sys_clock_cycle_get_32> @ imm = #-0x7968
 800f410: 4603         	mov	r3, r0
; }
 800f412: 4618         	mov	r0, r3
 800f414: bd80         	pop	{r7, pc}

0800f416 <k_cycle_get_32>:
; {
 800f416: b580         	push	{r7, lr}
 800f418: af00         	add	r7, sp, #0x0
; 	return arch_k_cycle_get_32();
 800f41a: f7ff fff5    	bl	0x800f408 <arch_k_cycle_get_32> @ imm = #-0x16
 800f41e: 4603         	mov	r3, r0
; }
 800f420: 4618         	mov	r0, r3
 800f422: bd80         	pop	{r7, pc}

0800f424 <k_mutex_init>:
; {
 800f424: b580         	push	{r7, lr}
 800f426: b082         	sub	sp, #0x8
 800f428: af00         	add	r7, sp, #0x0
 800f42a: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_k_mutex_init(mutex);
 800f42c: 6878         	ldr	r0, [r7, #0x4]
 800f42e: f003 fed3    	bl	0x80131d8 <z_impl_k_mutex_init> @ imm = #0x3da6
 800f432: 4603         	mov	r3, r0
; }
 800f434: 4618         	mov	r0, r3
 800f436: 3708         	adds	r7, #0x8
 800f438: 46bd         	mov	sp, r7
 800f43a: bd80         	pop	{r7, pc}

0800f43c <k_mutex_lock>:
; {
 800f43c: b580         	push	{r7, lr}
 800f43e: b084         	sub	sp, #0x10
 800f440: af00         	add	r7, sp, #0x0
 800f442: 60f8         	str	r0, [r7, #0xc]
 800f444: e9c7 2300    	strd	r2, r3, [r7]
; 	return z_impl_k_mutex_lock(mutex, timeout);
 800f448: e9d7 2300    	ldrd	r2, r3, [r7]
 800f44c: 68f8         	ldr	r0, [r7, #0xc]
 800f44e: f7fa fa9b    	bl	0x8009988 <z_impl_k_mutex_lock> @ imm = #-0x5aca
 800f452: 4603         	mov	r3, r0
; }
 800f454: 4618         	mov	r0, r3
 800f456: 3710         	adds	r7, #0x10
 800f458: 46bd         	mov	sp, r7
 800f45a: bd80         	pop	{r7, pc}

0800f45c <k_mutex_unlock>:
; {
 800f45c: b580         	push	{r7, lr}
 800f45e: b082         	sub	sp, #0x8
 800f460: af00         	add	r7, sp, #0x0
 800f462: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_k_mutex_unlock(mutex);
 800f464: 6878         	ldr	r0, [r7, #0x4]
 800f466: f7fa fcd9    	bl	0x8009e1c <z_impl_k_mutex_unlock> @ imm = #-0x564e
 800f46a: 4603         	mov	r3, r0
; }
 800f46c: 4618         	mov	r0, r3
 800f46e: 3708         	adds	r7, #0x8
 800f470: 46bd         	mov	sp, r7
 800f472: bd80         	pop	{r7, pc}

0800f474 <k_sem_init>:
; {
 800f474: b580         	push	{r7, lr}
 800f476: b084         	sub	sp, #0x10
 800f478: af00         	add	r7, sp, #0x0
 800f47a: 60f8         	str	r0, [r7, #0xc]
 800f47c: 60b9         	str	r1, [r7, #0x8]
 800f47e: 607a         	str	r2, [r7, #0x4]
; 	return z_impl_k_sem_init(sem, initial_count, limit);
 800f480: 687a         	ldr	r2, [r7, #0x4]
 800f482: 68b9         	ldr	r1, [r7, #0x8]
 800f484: 68f8         	ldr	r0, [r7, #0xc]
 800f486: f003 ff7b    	bl	0x8013380 <z_impl_k_sem_init> @ imm = #0x3ef6
 800f48a: 4603         	mov	r3, r0
; }
 800f48c: 4618         	mov	r0, r3
 800f48e: 3710         	adds	r7, #0x10
 800f490: 46bd         	mov	sp, r7
 800f492: bd80         	pop	{r7, pc}

0800f494 <k_sem_take>:
; {
 800f494: b580         	push	{r7, lr}
 800f496: b084         	sub	sp, #0x10
 800f498: af00         	add	r7, sp, #0x0
 800f49a: 60f8         	str	r0, [r7, #0xc]
 800f49c: e9c7 2300    	strd	r2, r3, [r7]
; 	return z_impl_k_sem_take(sem, timeout);
 800f4a0: e9d7 2300    	ldrd	r2, r3, [r7]
 800f4a4: 68f8         	ldr	r0, [r7, #0xc]
 800f4a6: f7fa fe41    	bl	0x800a12c <z_impl_k_sem_take> @ imm = #-0x537e
 800f4aa: 4603         	mov	r3, r0
; }
 800f4ac: 4618         	mov	r0, r3
 800f4ae: 3710         	adds	r7, #0x10
 800f4b0: 46bd         	mov	sp, r7
 800f4b2: bd80         	pop	{r7, pc}

0800f4b4 <k_sem_give>:
; {
 800f4b4: b580         	push	{r7, lr}
 800f4b6: b082         	sub	sp, #0x8
 800f4b8: af00         	add	r7, sp, #0x0
 800f4ba: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_sem_give(sem);
 800f4bc: 6878         	ldr	r0, [r7, #0x4]
 800f4be: f7fa fda7    	bl	0x800a010 <z_impl_k_sem_give> @ imm = #-0x54b2
; }
 800f4c2: bf00         	nop
 800f4c4: 3708         	adds	r7, #0x8
 800f4c6: 46bd         	mov	sp, r7
 800f4c8: bd80         	pop	{r7, pc}

0800f4ca <can_calc_timing>:
; {
 800f4ca: b580         	push	{r7, lr}
 800f4cc: b084         	sub	sp, #0x10
 800f4ce: af00         	add	r7, sp, #0x0
 800f4d0: 60f8         	str	r0, [r7, #0xc]
 800f4d2: 60b9         	str	r1, [r7, #0x8]
 800f4d4: 607a         	str	r2, [r7, #0x4]
 800f4d6: 807b         	strh	r3, [r7, #0x2]
; 	return z_impl_can_calc_timing(dev, res, bitrate, sample_pnt);
 800f4d8: 887b         	ldrh	r3, [r7, #0x2]
 800f4da: 687a         	ldr	r2, [r7, #0x4]
 800f4dc: 68b9         	ldr	r1, [r7, #0x8]
 800f4de: 68f8         	ldr	r0, [r7, #0xc]
 800f4e0: f7f4 fd0e    	bl	0x8003f00 <z_impl_can_calc_timing> @ imm = #-0xb5e4
 800f4e4: 4603         	mov	r3, r0
; }
 800f4e6: 4618         	mov	r0, r3
 800f4e8: 3710         	adds	r7, #0x10
 800f4ea: 46bd         	mov	sp, r7
 800f4ec: bd80         	pop	{r7, pc}

0800f4ee <can_set_timing>:
; {
 800f4ee: b580         	push	{r7, lr}
 800f4f0: b082         	sub	sp, #0x8
 800f4f2: af00         	add	r7, sp, #0x0
 800f4f4: 6078         	str	r0, [r7, #0x4]
 800f4f6: 6039         	str	r1, [r7]
; 	return z_impl_can_set_timing(dev, timing);
 800f4f8: 6839         	ldr	r1, [r7]
 800f4fa: 6878         	ldr	r0, [r7, #0x4]
 800f4fc: f7ff ff53    	bl	0x800f3a6 <z_impl_can_set_timing> @ imm = #-0x15a
 800f500: 4603         	mov	r3, r0
; }
 800f502: 4618         	mov	r0, r3
 800f504: 3708         	adds	r7, #0x8
 800f506: 46bd         	mov	sp, r7
 800f508: bd80         	pop	{r7, pc}

0800f50a <can_transceiver_enable>:
; {
 800f50a: b580         	push	{r7, lr}
 800f50c: b084         	sub	sp, #0x10
 800f50e: af00         	add	r7, sp, #0x0
 800f510: 6078         	str	r0, [r7, #0x4]
 800f512: 6039         	str	r1, [r7]
; 	const struct can_transceiver_driver_api *api =
 800f514: 687b         	ldr	r3, [r7, #0x4]
 800f516: 689b         	ldr	r3, [r3, #0x8]
 800f518: 60fb         	str	r3, [r7, #0xc]
; 	return api->enable(dev, mode);
 800f51a: 68fb         	ldr	r3, [r7, #0xc]
 800f51c: 681b         	ldr	r3, [r3]
 800f51e: 6839         	ldr	r1, [r7]
 800f520: 6878         	ldr	r0, [r7, #0x4]
 800f522: 4798         	blx	r3
 800f524: 4603         	mov	r3, r0
; }
 800f526: 4618         	mov	r0, r3
 800f528: 3710         	adds	r7, #0x10
 800f52a: 46bd         	mov	sp, r7
 800f52c: bd80         	pop	{r7, pc}

0800f52e <can_transceiver_disable>:
; {
 800f52e: b580         	push	{r7, lr}
 800f530: b084         	sub	sp, #0x10
 800f532: af00         	add	r7, sp, #0x0
 800f534: 6078         	str	r0, [r7, #0x4]
; 	const struct can_transceiver_driver_api *api =
 800f536: 687b         	ldr	r3, [r7, #0x4]
 800f538: 689b         	ldr	r3, [r3, #0x8]
 800f53a: 60fb         	str	r3, [r7, #0xc]
; 	return api->disable(dev);
 800f53c: 68fb         	ldr	r3, [r7, #0xc]
 800f53e: 685b         	ldr	r3, [r3, #0x4]
 800f540: 6878         	ldr	r0, [r7, #0x4]
 800f542: 4798         	blx	r3
 800f544: 4603         	mov	r3, r0
; }
 800f546: 4618         	mov	r0, r3
 800f548: 3710         	adds	r7, #0x10
 800f54a: 46bd         	mov	sp, r7
 800f54c: bd80         	pop	{r7, pc}

0800f54e <clock_control_on>:
; {
 800f54e: b580         	push	{r7, lr}
 800f550: b084         	sub	sp, #0x10
 800f552: af00         	add	r7, sp, #0x0
 800f554: 6078         	str	r0, [r7, #0x4]
 800f556: 6039         	str	r1, [r7]
; 	const struct clock_control_driver_api *api =
 800f558: 687b         	ldr	r3, [r7, #0x4]
 800f55a: 689b         	ldr	r3, [r3, #0x8]
 800f55c: 60fb         	str	r3, [r7, #0xc]
; 	return api->on(dev, sys);
 800f55e: 68fb         	ldr	r3, [r7, #0xc]
 800f560: 681b         	ldr	r3, [r3]
 800f562: 6839         	ldr	r1, [r7]
 800f564: 6878         	ldr	r0, [r7, #0x4]
 800f566: 4798         	blx	r3
 800f568: 4603         	mov	r3, r0
; }
 800f56a: 4618         	mov	r0, r3
 800f56c: 3710         	adds	r7, #0x10
 800f56e: 46bd         	mov	sp, r7
 800f570: bd80         	pop	{r7, pc}

0800f572 <clock_control_get_rate>:
; {
 800f572: b580         	push	{r7, lr}
 800f574: b086         	sub	sp, #0x18
 800f576: af00         	add	r7, sp, #0x0
 800f578: 60f8         	str	r0, [r7, #0xc]
 800f57a: 60b9         	str	r1, [r7, #0x8]
 800f57c: 607a         	str	r2, [r7, #0x4]
; 	const struct clock_control_driver_api *api =
 800f57e: 68fb         	ldr	r3, [r7, #0xc]
 800f580: 689b         	ldr	r3, [r3, #0x8]
 800f582: 617b         	str	r3, [r7, #0x14]
; 	if (api->get_rate == NULL) {
 800f584: 697b         	ldr	r3, [r7, #0x14]
 800f586: 68db         	ldr	r3, [r3, #0xc]
 800f588: 2b00         	cmp	r3, #0x0
 800f58a: d102         	bne	0x800f592 <clock_control_get_rate+0x20> @ imm = #0x4
; 		return -ENOSYS;
 800f58c: f06f 0357    	mvn	r3, #0x57
 800f590: e006         	b	0x800f5a0 <clock_control_get_rate+0x2e> @ imm = #0xc
; 	return api->get_rate(dev, sys, rate);
 800f592: 697b         	ldr	r3, [r7, #0x14]
 800f594: 68db         	ldr	r3, [r3, #0xc]
 800f596: 687a         	ldr	r2, [r7, #0x4]
 800f598: 68b9         	ldr	r1, [r7, #0x8]
 800f59a: 68f8         	ldr	r0, [r7, #0xc]
 800f59c: 4798         	blx	r3
 800f59e: 4603         	mov	r3, r0
; }
 800f5a0: 4618         	mov	r0, r3
 800f5a2: 3718         	adds	r7, #0x18
 800f5a4: 46bd         	mov	sp, r7
 800f5a6: bd80         	pop	{r7, pc}

0800f5a8 <pinctrl_apply_state_direct>:
; {
 800f5a8: b580         	push	{r7, lr}
 800f5aa: b084         	sub	sp, #0x10
 800f5ac: af00         	add	r7, sp, #0x0
 800f5ae: 6078         	str	r0, [r7, #0x4]
 800f5b0: 6039         	str	r1, [r7]
; 	reg = PINCTRL_REG_NONE;
 800f5b2: 2300         	movs	r3, #0x0
 800f5b4: 60fb         	str	r3, [r7, #0xc]
; 	return pinctrl_configure_pins(state->pins, state->pin_cnt, reg);
 800f5b6: 683b         	ldr	r3, [r7]
 800f5b8: 6818         	ldr	r0, [r3]
 800f5ba: 683b         	ldr	r3, [r7]
 800f5bc: 791b         	ldrb	r3, [r3, #0x4]
 800f5be: 68fa         	ldr	r2, [r7, #0xc]
 800f5c0: 4619         	mov	r1, r3
 800f5c2: f001 faf5    	bl	0x8010bb0 <pinctrl_configure_pins> @ imm = #0x15ea
 800f5c6: 4603         	mov	r3, r0
; }
 800f5c8: 4618         	mov	r0, r3
 800f5ca: 3710         	adds	r7, #0x10
 800f5cc: 46bd         	mov	sp, r7
 800f5ce: bd80         	pop	{r7, pc}

0800f5d0 <pinctrl_apply_state>:
; {
 800f5d0: b580         	push	{r7, lr}
 800f5d2: b084         	sub	sp, #0x10
 800f5d4: af00         	add	r7, sp, #0x0
 800f5d6: 6078         	str	r0, [r7, #0x4]
 800f5d8: 460b         	mov	r3, r1
 800f5da: 70fb         	strb	r3, [r7, #0x3]
; 	ret = pinctrl_lookup_state(config, id, &state);
 800f5dc: f107 0208    	add.w	r2, r7, #0x8
 800f5e0: 78fb         	ldrb	r3, [r7, #0x3]
 800f5e2: 4619         	mov	r1, r3
 800f5e4: 6878         	ldr	r0, [r7, #0x4]
 800f5e6: f001 faac    	bl	0x8010b42 <pinctrl_lookup_state> @ imm = #0x1558
 800f5ea: 60f8         	str	r0, [r7, #0xc]
; 	if (ret < 0) {
 800f5ec: 68fb         	ldr	r3, [r7, #0xc]
 800f5ee: 2b00         	cmp	r3, #0x0
 800f5f0: da01         	bge	0x800f5f6 <pinctrl_apply_state+0x26> @ imm = #0x2
; 		return ret;
 800f5f2: 68fb         	ldr	r3, [r7, #0xc]
 800f5f4: e005         	b	0x800f602 <pinctrl_apply_state+0x32> @ imm = #0xa
; 	return pinctrl_apply_state_direct(config, state);
 800f5f6: 68bb         	ldr	r3, [r7, #0x8]
 800f5f8: 4619         	mov	r1, r3
 800f5fa: 6878         	ldr	r0, [r7, #0x4]
 800f5fc: f7ff ffd4    	bl	0x800f5a8 <pinctrl_apply_state_direct> @ imm = #-0x58
 800f600: 4603         	mov	r3, r0
; }
 800f602: 4618         	mov	r0, r3
 800f604: 3710         	adds	r7, #0x10
 800f606: 46bd         	mov	sp, r7
 800f608: bd80         	pop	{r7, pc}

0800f60a <z_log_msg_runtime_create>:
; {
 800f60a: b580         	push	{r7, lr}
 800f60c: b08a         	sub	sp, #0x28
 800f60e: af04         	add	r7, sp, #0x10
 800f610: 60b9         	str	r1, [r7, #0x8]
 800f612: 607b         	str	r3, [r7, #0x4]
 800f614: 4603         	mov	r3, r0
 800f616: 73fb         	strb	r3, [r7, #0xf]
 800f618: 4613         	mov	r3, r2
 800f61a: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 800f61c: f107 032c    	add.w	r3, r7, #0x2c
 800f620: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 800f622: 7bba         	ldrb	r2, [r7, #0xe]
 800f624: 7bf8         	ldrb	r0, [r7, #0xf]
 800f626: 697b         	ldr	r3, [r7, #0x14]
 800f628: 9303         	str	r3, [sp, #0xc]
 800f62a: 6abb         	ldr	r3, [r7, #0x28]
 800f62c: 9302         	str	r3, [sp, #0x8]
 800f62e: 6a7b         	ldr	r3, [r7, #0x24]
 800f630: 9301         	str	r3, [sp, #0x4]
 800f632: 6a3b         	ldr	r3, [r7, #0x20]
 800f634: 9300         	str	r3, [sp]
 800f636: 687b         	ldr	r3, [r7, #0x4]
 800f638: 68b9         	ldr	r1, [r7, #0x8]
 800f63a: f7f2 f903    	bl	0x8001844 <z_log_msg_runtime_vcreate> @ imm = #-0xddfa
; }
 800f63e: bf00         	nop
 800f640: 3718         	adds	r7, #0x18
 800f642: 46bd         	mov	sp, r7
 800f644: bd80         	pop	{r7, pc}

0800f646 <can_stm32_signal_tx_complete>:
; {
 800f646: b580         	push	{r7, lr}
 800f648: b086         	sub	sp, #0x18
 800f64a: af00         	add	r7, sp, #0x0
 800f64c: 60f8         	str	r0, [r7, #0xc]
 800f64e: 60b9         	str	r1, [r7, #0x8]
 800f650: 607a         	str	r2, [r7, #0x4]
; 	can_tx_callback_t callback = mb->tx_callback;
 800f652: 68bb         	ldr	r3, [r7, #0x8]
 800f654: 681b         	ldr	r3, [r3]
 800f656: 617b         	str	r3, [r7, #0x14]
; 	if (callback != NULL) {
 800f658: 697b         	ldr	r3, [r7, #0x14]
 800f65a: 2b00         	cmp	r3, #0x0
 800f65c: d008         	beq	0x800f670 <can_stm32_signal_tx_complete+0x2a> @ imm = #0x10
; 		callback(dev, status, mb->callback_arg);
 800f65e: 68bb         	ldr	r3, [r7, #0x8]
 800f660: 685a         	ldr	r2, [r3, #0x4]
 800f662: 697b         	ldr	r3, [r7, #0x14]
 800f664: 6879         	ldr	r1, [r7, #0x4]
 800f666: 68f8         	ldr	r0, [r7, #0xc]
 800f668: 4798         	blx	r3
; 		mb->tx_callback = NULL;
 800f66a: 68bb         	ldr	r3, [r7, #0x8]
 800f66c: 2200         	movs	r2, #0x0
 800f66e: 601a         	str	r2, [r3]
; }
 800f670: bf00         	nop
 800f672: 3718         	adds	r7, #0x18
 800f674: 46bd         	mov	sp, r7
 800f676: bd80         	pop	{r7, pc}

0800f678 <can_stm32_rx_fifo_pop>:
; {
 800f678: b580         	push	{r7, lr}
 800f67a: b082         	sub	sp, #0x8
 800f67c: af00         	add	r7, sp, #0x0
 800f67e: 6078         	str	r0, [r7, #0x4]
 800f680: 6039         	str	r1, [r7]
; 	memset(frame, 0, sizeof(*frame));
 800f682: 2210         	movs	r2, #0x10
 800f684: 2100         	movs	r1, #0x0
 800f686: 6838         	ldr	r0, [r7]
 800f688: f004 fd48    	bl	0x801411c <memset>      @ imm = #0x4a90
; 	if (mbox->RIR & CAN_RI0R_IDE) {
 800f68c: 687b         	ldr	r3, [r7, #0x4]
 800f68e: 681b         	ldr	r3, [r3]
 800f690: f003 0304    	and	r3, r3, #0x4
 800f694: 2b00         	cmp	r3, #0x0
 800f696: d00c         	beq	0x800f6b2 <can_stm32_rx_fifo_pop+0x3a> @ imm = #0x18
; 		frame->id = mbox->RIR >> CAN_RI0R_EXID_Pos;
 800f698: 687b         	ldr	r3, [r7, #0x4]
 800f69a: 681b         	ldr	r3, [r3]
 800f69c: 08da         	lsrs	r2, r3, #0x3
 800f69e: 683b         	ldr	r3, [r7]
 800f6a0: 601a         	str	r2, [r3]
; 		frame->flags |= CAN_FRAME_IDE;
 800f6a2: 683b         	ldr	r3, [r7]
 800f6a4: 795b         	ldrb	r3, [r3, #0x5]
 800f6a6: f043 0301    	orr	r3, r3, #0x1
 800f6aa: b2da         	uxtb	r2, r3
 800f6ac: 683b         	ldr	r3, [r7]
 800f6ae: 715a         	strb	r2, [r3, #0x5]
 800f6b0: e004         	b	0x800f6bc <can_stm32_rx_fifo_pop+0x44> @ imm = #0x8
; 		frame->id = mbox->RIR >> CAN_RI0R_STID_Pos;
 800f6b2: 687b         	ldr	r3, [r7, #0x4]
 800f6b4: 681b         	ldr	r3, [r3]
 800f6b6: 0d5a         	lsrs	r2, r3, #0x15
 800f6b8: 683b         	ldr	r3, [r7]
 800f6ba: 601a         	str	r2, [r3]
; 	if ((mbox->RIR & CAN_RI0R_RTR) != 0) {
 800f6bc: 687b         	ldr	r3, [r7, #0x4]
 800f6be: 681b         	ldr	r3, [r3]
 800f6c0: f003 0302    	and	r3, r3, #0x2
 800f6c4: 2b00         	cmp	r3, #0x0
 800f6c6: d007         	beq	0x800f6d8 <can_stm32_rx_fifo_pop+0x60> @ imm = #0xe
; 		frame->flags |= CAN_FRAME_RTR;
 800f6c8: 683b         	ldr	r3, [r7]
 800f6ca: 795b         	ldrb	r3, [r3, #0x5]
 800f6cc: f043 0302    	orr	r3, r3, #0x2
 800f6d0: b2da         	uxtb	r2, r3
 800f6d2: 683b         	ldr	r3, [r7]
 800f6d4: 715a         	strb	r2, [r3, #0x5]
 800f6d6: e007         	b	0x800f6e8 <can_stm32_rx_fifo_pop+0x70> @ imm = #0xe
; 		frame->data_32[0] = mbox->RDLR;
 800f6d8: 687b         	ldr	r3, [r7, #0x4]
 800f6da: 689a         	ldr	r2, [r3, #0x8]
 800f6dc: 683b         	ldr	r3, [r7]
 800f6de: 609a         	str	r2, [r3, #0x8]
; 		frame->data_32[1] = mbox->RDHR;
 800f6e0: 687b         	ldr	r3, [r7, #0x4]
 800f6e2: 68da         	ldr	r2, [r3, #0xc]
 800f6e4: 683b         	ldr	r3, [r7]
 800f6e6: 60da         	str	r2, [r3, #0xc]
; 	frame->dlc = mbox->RDTR & (CAN_RDT0R_DLC >> CAN_RDT0R_DLC_Pos);
 800f6e8: 687b         	ldr	r3, [r7, #0x4]
 800f6ea: 685b         	ldr	r3, [r3, #0x4]
 800f6ec: b2db         	uxtb	r3, r3
 800f6ee: f003 030f    	and	r3, r3, #0xf
 800f6f2: b2da         	uxtb	r2, r3
 800f6f4: 683b         	ldr	r3, [r7]
 800f6f6: 711a         	strb	r2, [r3, #0x4]
; }
 800f6f8: bf00         	nop
 800f6fa: 3708         	adds	r7, #0x8
 800f6fc: 46bd         	mov	sp, r7
 800f6fe: bd80         	pop	{r7, pc}

0800f700 <can_stm32_get_state>:
; {
 800f700: b480         	push	{r7}
 800f702: b089         	sub	sp, #0x24
 800f704: af00         	add	r7, sp, #0x0
 800f706: 60f8         	str	r0, [r7, #0xc]
 800f708: 60b9         	str	r1, [r7, #0x8]
 800f70a: 607a         	str	r2, [r7, #0x4]
; 	const struct can_stm32_config *cfg = dev->config;
 800f70c: 68fb         	ldr	r3, [r7, #0xc]
 800f70e: 685b         	ldr	r3, [r3, #0x4]
 800f710: 61fb         	str	r3, [r7, #0x1c]
; 	struct can_stm32_data *data = dev->data;
 800f712: 68fb         	ldr	r3, [r7, #0xc]
 800f714: 691b         	ldr	r3, [r3, #0x10]
 800f716: 61bb         	str	r3, [r7, #0x18]
; 	CAN_TypeDef *can = cfg->can;
 800f718: 69fb         	ldr	r3, [r7, #0x1c]
 800f71a: 695b         	ldr	r3, [r3, #0x14]
 800f71c: 617b         	str	r3, [r7, #0x14]
; 	if (state != NULL) {
 800f71e: 68bb         	ldr	r3, [r7, #0x8]
 800f720: 2b00         	cmp	r3, #0x0
 800f722: d02b         	beq	0x800f77c <can_stm32_get_state+0x7c> @ imm = #0x56
; 		if (!data->common.started) {
 800f724: 69bb         	ldr	r3, [r7, #0x18]
 800f726: 791b         	ldrb	r3, [r3, #0x4]
 800f728: f083 0301    	eor	r3, r3, #0x1
 800f72c: b2db         	uxtb	r3, r3
 800f72e: 2b00         	cmp	r3, #0x0
 800f730: d003         	beq	0x800f73a <can_stm32_get_state+0x3a> @ imm = #0x6
; 			*state = CAN_STATE_STOPPED;
 800f732: 68bb         	ldr	r3, [r7, #0x8]
 800f734: 2204         	movs	r2, #0x4
 800f736: 701a         	strb	r2, [r3]
 800f738: e020         	b	0x800f77c <can_stm32_get_state+0x7c> @ imm = #0x40
; 		} else if (can->ESR & CAN_ESR_BOFF) {
 800f73a: 697b         	ldr	r3, [r7, #0x14]
 800f73c: 699b         	ldr	r3, [r3, #0x18]
 800f73e: f003 0304    	and	r3, r3, #0x4
 800f742: 2b00         	cmp	r3, #0x0
 800f744: d003         	beq	0x800f74e <can_stm32_get_state+0x4e> @ imm = #0x6
; 			*state = CAN_STATE_BUS_OFF;
 800f746: 68bb         	ldr	r3, [r7, #0x8]
 800f748: 2203         	movs	r2, #0x3
 800f74a: 701a         	strb	r2, [r3]
 800f74c: e016         	b	0x800f77c <can_stm32_get_state+0x7c> @ imm = #0x2c
; 		} else if (can->ESR & CAN_ESR_EPVF) {
 800f74e: 697b         	ldr	r3, [r7, #0x14]
 800f750: 699b         	ldr	r3, [r3, #0x18]
 800f752: f003 0302    	and	r3, r3, #0x2
 800f756: 2b00         	cmp	r3, #0x0
 800f758: d003         	beq	0x800f762 <can_stm32_get_state+0x62> @ imm = #0x6
; 			*state = CAN_STATE_ERROR_PASSIVE;
 800f75a: 68bb         	ldr	r3, [r7, #0x8]
 800f75c: 2202         	movs	r2, #0x2
 800f75e: 701a         	strb	r2, [r3]
 800f760: e00c         	b	0x800f77c <can_stm32_get_state+0x7c> @ imm = #0x18
; 		} else if (can->ESR & CAN_ESR_EWGF) {
 800f762: 697b         	ldr	r3, [r7, #0x14]
 800f764: 699b         	ldr	r3, [r3, #0x18]
 800f766: f003 0301    	and	r3, r3, #0x1
 800f76a: 2b00         	cmp	r3, #0x0
 800f76c: d003         	beq	0x800f776 <can_stm32_get_state+0x76> @ imm = #0x6
; 			*state = CAN_STATE_ERROR_WARNING;
 800f76e: 68bb         	ldr	r3, [r7, #0x8]
 800f770: 2201         	movs	r2, #0x1
 800f772: 701a         	strb	r2, [r3]
 800f774: e002         	b	0x800f77c <can_stm32_get_state+0x7c> @ imm = #0x4
; 			*state = CAN_STATE_ERROR_ACTIVE;
 800f776: 68bb         	ldr	r3, [r7, #0x8]
 800f778: 2200         	movs	r2, #0x0
 800f77a: 701a         	strb	r2, [r3]
; 	if (err_cnt != NULL) {
 800f77c: 687b         	ldr	r3, [r7, #0x4]
 800f77e: 2b00         	cmp	r3, #0x0
 800f780: d00b         	beq	0x800f79a <can_stm32_get_state+0x9a> @ imm = #0x16
; 			((can->ESR & CAN_ESR_TEC) >> CAN_ESR_TEC_Pos);
 800f782: 697b         	ldr	r3, [r7, #0x14]
 800f784: 699b         	ldr	r3, [r3, #0x18]
 800f786: 0c1b         	lsrs	r3, r3, #0x10
; 		err_cnt->tx_err_cnt =
 800f788: b2da         	uxtb	r2, r3
 800f78a: 687b         	ldr	r3, [r7, #0x4]
 800f78c: 701a         	strb	r2, [r3]
; 			((can->ESR & CAN_ESR_REC) >> CAN_ESR_REC_Pos);
 800f78e: 697b         	ldr	r3, [r7, #0x14]
 800f790: 699b         	ldr	r3, [r3, #0x18]
 800f792: 0e1b         	lsrs	r3, r3, #0x18
; 		err_cnt->rx_err_cnt =
 800f794: b2da         	uxtb	r2, r3
 800f796: 687b         	ldr	r3, [r7, #0x4]
 800f798: 705a         	strb	r2, [r3, #0x1]
; 	return 0;
 800f79a: 2300         	movs	r3, #0x0
; }
 800f79c: 4618         	mov	r0, r3
 800f79e: 3724         	adds	r7, #0x24
 800f7a0: 46bd         	mov	sp, r7
 800f7a2: bc80         	pop	{r7}
 800f7a4: 4770         	bx	lr

0800f7a6 <can_stm32_bus_state_change_isr>:
; {
 800f7a6: b590         	push	{r4, r7, lr}
 800f7a8: b089         	sub	sp, #0x24
 800f7aa: af00         	add	r7, sp, #0x0
 800f7ac: 6078         	str	r0, [r7, #0x4]
; 	struct can_stm32_data *data = dev->data;
 800f7ae: 687b         	ldr	r3, [r7, #0x4]
 800f7b0: 691b         	ldr	r3, [r3, #0x10]
 800f7b2: 61fb         	str	r3, [r7, #0x1c]
; 	const can_state_change_callback_t cb = data->common.state_change_cb;
 800f7b4: 69fb         	ldr	r3, [r7, #0x1c]
 800f7b6: 689b         	ldr	r3, [r3, #0x8]
 800f7b8: 61bb         	str	r3, [r7, #0x18]
; 	void *state_change_cb_data = data->common.state_change_cb_user_data;
 800f7ba: 69fb         	ldr	r3, [r7, #0x1c]
 800f7bc: 68db         	ldr	r3, [r3, #0xc]
 800f7be: 617b         	str	r3, [r7, #0x14]
; 	(void)can_stm32_get_state(dev, &state, &err_cnt);
 800f7c0: f107 0210    	add.w	r2, r7, #0x10
 800f7c4: f107 030f    	add.w	r3, r7, #0xf
 800f7c8: 4619         	mov	r1, r3
 800f7ca: 6878         	ldr	r0, [r7, #0x4]
 800f7cc: f7ff ff98    	bl	0x800f700 <can_stm32_get_state> @ imm = #-0xd0
; 	if (state != data->state) {
 800f7d0: 69fb         	ldr	r3, [r7, #0x1c]
 800f7d2: f893 20f4    	ldrb.w	r2, [r3, #0xf4]
 800f7d6: 7bfb         	ldrb	r3, [r7, #0xf]
 800f7d8: 429a         	cmp	r2, r3
 800f7da: d00c         	beq	0x800f7f6 <can_stm32_bus_state_change_isr+0x50> @ imm = #0x18
; 		data->state = state;
 800f7dc: 7bfa         	ldrb	r2, [r7, #0xf]
 800f7de: 69fb         	ldr	r3, [r7, #0x1c]
 800f7e0: f883 20f4    	strb.w	r2, [r3, #0xf4]
; 		if (cb != NULL) {
 800f7e4: 69bb         	ldr	r3, [r7, #0x18]
 800f7e6: 2b00         	cmp	r3, #0x0
 800f7e8: d005         	beq	0x800f7f6 <can_stm32_bus_state_change_isr+0x50> @ imm = #0xa
; 			cb(dev, state, err_cnt, state_change_cb_data);
 800f7ea: 7bf9         	ldrb	r1, [r7, #0xf]
 800f7ec: 69bc         	ldr	r4, [r7, #0x18]
 800f7ee: 697b         	ldr	r3, [r7, #0x14]
 800f7f0: 693a         	ldr	r2, [r7, #0x10]
 800f7f2: 6878         	ldr	r0, [r7, #0x4]
 800f7f4: 47a0         	blx	r4
; }
 800f7f6: bf00         	nop
 800f7f8: 3724         	adds	r7, #0x24
 800f7fa: 46bd         	mov	sp, r7
 800f7fc: bd90         	pop	{r4, r7, pc}

0800f7fe <can_stm32_tx_isr_handler>:
; {
 800f7fe: b580         	push	{r7, lr}
 800f800: b088         	sub	sp, #0x20
 800f802: af00         	add	r7, sp, #0x0
 800f804: 6078         	str	r0, [r7, #0x4]
; 	struct can_stm32_data *data = dev->data;
 800f806: 687b         	ldr	r3, [r7, #0x4]
 800f808: 691b         	ldr	r3, [r3, #0x10]
 800f80a: 61fb         	str	r3, [r7, #0x1c]
; 	const struct can_stm32_config *cfg = dev->config;
 800f80c: 687b         	ldr	r3, [r7, #0x4]
 800f80e: 685b         	ldr	r3, [r3, #0x4]
 800f810: 61bb         	str	r3, [r7, #0x18]
; 	CAN_TypeDef *can = cfg->can;
 800f812: 69bb         	ldr	r3, [r7, #0x18]
 800f814: 695b         	ldr	r3, [r3, #0x14]
 800f816: 617b         	str	r3, [r7, #0x14]
; 	bus_off = can->ESR & CAN_ESR_BOFF;
 800f818: 697b         	ldr	r3, [r7, #0x14]
 800f81a: 699b         	ldr	r3, [r3, #0x18]
 800f81c: f003 0304    	and	r3, r3, #0x4
 800f820: 613b         	str	r3, [r7, #0x10]
; 	if ((can->TSR & CAN_TSR_RQCP0) | bus_off) {
 800f822: 697b         	ldr	r3, [r7, #0x14]
 800f824: 689b         	ldr	r3, [r3, #0x8]
 800f826: f003 0201    	and	r2, r3, #0x1
 800f82a: 693b         	ldr	r3, [r7, #0x10]
 800f82c: 4313         	orrs	r3, r2
 800f82e: 2b00         	cmp	r3, #0x0
 800f830: d02f         	beq	0x800f892 <can_stm32_tx_isr_handler+0x94> @ imm = #0x5e
; 		status = can->TSR & CAN_TSR_TXOK0 ? 0  :
 800f832: 697b         	ldr	r3, [r7, #0x14]
 800f834: 689b         	ldr	r3, [r3, #0x8]
 800f836: f003 0302    	and	r3, r3, #0x2
 800f83a: 2b00         	cmp	r3, #0x0
 800f83c: d11a         	bne	0x800f874 <can_stm32_tx_isr_handler+0x76> @ imm = #0x34
; 			 can->TSR & CAN_TSR_TERR0 ? -EIO :
 800f83e: 697b         	ldr	r3, [r7, #0x14]
 800f840: 689b         	ldr	r3, [r3, #0x8]
 800f842: f003 0308    	and	r3, r3, #0x8
 800f846: 2b00         	cmp	r3, #0x0
 800f848: d111         	bne	0x800f86e <can_stm32_tx_isr_handler+0x70> @ imm = #0x22
; 			 can->TSR & CAN_TSR_ALST0 ? -EBUSY :
 800f84a: 697b         	ldr	r3, [r7, #0x14]
 800f84c: 689b         	ldr	r3, [r3, #0x8]
 800f84e: f003 0304    	and	r3, r3, #0x4
 800f852: 2b00         	cmp	r3, #0x0
 800f854: d108         	bne	0x800f868 <can_stm32_tx_isr_handler+0x6a> @ imm = #0x10
; 					  bus_off ? -ENETUNREACH :
 800f856: 693b         	ldr	r3, [r7, #0x10]
 800f858: 2b00         	cmp	r3, #0x0
 800f85a: d002         	beq	0x800f862 <can_stm32_tx_isr_handler+0x64> @ imm = #0x4
 800f85c: f06f 0371    	mvn	r3, #0x71
 800f860: e009         	b	0x800f876 <can_stm32_tx_isr_handler+0x78> @ imm = #0x12
 800f862: f06f 0304    	mvn	r3, #0x4
 800f866: e006         	b	0x800f876 <can_stm32_tx_isr_handler+0x78> @ imm = #0xc
; 			 can->TSR & CAN_TSR_ALST0 ? -EBUSY :
 800f868: f06f 030f    	mvn	r3, #0xf
 800f86c: e003         	b	0x800f876 <can_stm32_tx_isr_handler+0x78> @ imm = #0x6
; 			 can->TSR & CAN_TSR_TERR0 ? -EIO :
 800f86e: f06f 0304    	mvn	r3, #0x4
 800f872: e000         	b	0x800f876 <can_stm32_tx_isr_handler+0x78> @ imm = #0x0
; 		status = can->TSR & CAN_TSR_TXOK0 ? 0  :
 800f874: 2300         	movs	r3, #0x0
 800f876: 60fb         	str	r3, [r7, #0xc]
; 		can->TSR |= CAN_TSR_RQCP0;
 800f878: 697b         	ldr	r3, [r7, #0x14]
 800f87a: 689b         	ldr	r3, [r3, #0x8]
 800f87c: f043 0201    	orr	r2, r3, #0x1
 800f880: 697b         	ldr	r3, [r7, #0x14]
 800f882: 609a         	str	r2, [r3, #0x8]
; 		can_stm32_signal_tx_complete(dev, &data->mb0, status);
 800f884: 69fb         	ldr	r3, [r7, #0x1c]
 800f886: 3334         	adds	r3, #0x34
 800f888: 68fa         	ldr	r2, [r7, #0xc]
 800f88a: 4619         	mov	r1, r3
 800f88c: 6878         	ldr	r0, [r7, #0x4]
 800f88e: f7ff feda    	bl	0x800f646 <can_stm32_signal_tx_complete> @ imm = #-0x24c
; 	if ((can->TSR & CAN_TSR_RQCP1) | bus_off) {
 800f892: 697b         	ldr	r3, [r7, #0x14]
 800f894: 689b         	ldr	r3, [r3, #0x8]
 800f896: f403 7280    	and	r2, r3, #0x100
 800f89a: 693b         	ldr	r3, [r7, #0x10]
 800f89c: 4313         	orrs	r3, r2
 800f89e: 2b00         	cmp	r3, #0x0
 800f8a0: d02f         	beq	0x800f902 <can_stm32_tx_isr_handler+0x104> @ imm = #0x5e
; 		status = can->TSR & CAN_TSR_TXOK1 ? 0  :
 800f8a2: 697b         	ldr	r3, [r7, #0x14]
 800f8a4: 689b         	ldr	r3, [r3, #0x8]
 800f8a6: f403 7300    	and	r3, r3, #0x200
 800f8aa: 2b00         	cmp	r3, #0x0
 800f8ac: d11a         	bne	0x800f8e4 <can_stm32_tx_isr_handler+0xe6> @ imm = #0x34
; 			 can->TSR & CAN_TSR_TERR1 ? -EIO :
 800f8ae: 697b         	ldr	r3, [r7, #0x14]
 800f8b0: 689b         	ldr	r3, [r3, #0x8]
 800f8b2: f403 6300    	and	r3, r3, #0x800
 800f8b6: 2b00         	cmp	r3, #0x0
 800f8b8: d111         	bne	0x800f8de <can_stm32_tx_isr_handler+0xe0> @ imm = #0x22
; 			 can->TSR & CAN_TSR_ALST1 ? -EBUSY :
 800f8ba: 697b         	ldr	r3, [r7, #0x14]
 800f8bc: 689b         	ldr	r3, [r3, #0x8]
 800f8be: f403 6380    	and	r3, r3, #0x400
 800f8c2: 2b00         	cmp	r3, #0x0
 800f8c4: d108         	bne	0x800f8d8 <can_stm32_tx_isr_handler+0xda> @ imm = #0x10
; 			 bus_off                  ? -ENETUNREACH :
 800f8c6: 693b         	ldr	r3, [r7, #0x10]
 800f8c8: 2b00         	cmp	r3, #0x0
 800f8ca: d002         	beq	0x800f8d2 <can_stm32_tx_isr_handler+0xd4> @ imm = #0x4
 800f8cc: f06f 0371    	mvn	r3, #0x71
 800f8d0: e009         	b	0x800f8e6 <can_stm32_tx_isr_handler+0xe8> @ imm = #0x12
 800f8d2: f06f 0304    	mvn	r3, #0x4
 800f8d6: e006         	b	0x800f8e6 <can_stm32_tx_isr_handler+0xe8> @ imm = #0xc
; 			 can->TSR & CAN_TSR_ALST1 ? -EBUSY :
 800f8d8: f06f 030f    	mvn	r3, #0xf
 800f8dc: e003         	b	0x800f8e6 <can_stm32_tx_isr_handler+0xe8> @ imm = #0x6
; 			 can->TSR & CAN_TSR_TERR1 ? -EIO :
 800f8de: f06f 0304    	mvn	r3, #0x4
 800f8e2: e000         	b	0x800f8e6 <can_stm32_tx_isr_handler+0xe8> @ imm = #0x0
; 		status = can->TSR & CAN_TSR_TXOK1 ? 0  :
 800f8e4: 2300         	movs	r3, #0x0
 800f8e6: 60fb         	str	r3, [r7, #0xc]
; 		can->TSR |= CAN_TSR_RQCP1;
 800f8e8: 697b         	ldr	r3, [r7, #0x14]
 800f8ea: 689b         	ldr	r3, [r3, #0x8]
 800f8ec: f443 7280    	orr	r2, r3, #0x100
 800f8f0: 697b         	ldr	r3, [r7, #0x14]
 800f8f2: 609a         	str	r2, [r3, #0x8]
; 		can_stm32_signal_tx_complete(dev, &data->mb1, status);
 800f8f4: 69fb         	ldr	r3, [r7, #0x1c]
 800f8f6: 333c         	adds	r3, #0x3c
 800f8f8: 68fa         	ldr	r2, [r7, #0xc]
 800f8fa: 4619         	mov	r1, r3
 800f8fc: 6878         	ldr	r0, [r7, #0x4]
 800f8fe: f7ff fea2    	bl	0x800f646 <can_stm32_signal_tx_complete> @ imm = #-0x2bc
; 	if ((can->TSR & CAN_TSR_RQCP2) | bus_off) {
 800f902: 697b         	ldr	r3, [r7, #0x14]
 800f904: 689b         	ldr	r3, [r3, #0x8]
 800f906: f403 3280    	and	r2, r3, #0x10000
 800f90a: 693b         	ldr	r3, [r7, #0x10]
 800f90c: 4313         	orrs	r3, r2
 800f90e: 2b00         	cmp	r3, #0x0
 800f910: d02f         	beq	0x800f972 <can_stm32_tx_isr_handler+0x174> @ imm = #0x5e
; 		status = can->TSR & CAN_TSR_TXOK2 ? 0  :
 800f912: 697b         	ldr	r3, [r7, #0x14]
 800f914: 689b         	ldr	r3, [r3, #0x8]
 800f916: f403 3300    	and	r3, r3, #0x20000
 800f91a: 2b00         	cmp	r3, #0x0
 800f91c: d11a         	bne	0x800f954 <can_stm32_tx_isr_handler+0x156> @ imm = #0x34
; 			 can->TSR & CAN_TSR_TERR2 ? -EIO :
 800f91e: 697b         	ldr	r3, [r7, #0x14]
 800f920: 689b         	ldr	r3, [r3, #0x8]
 800f922: f403 2300    	and	r3, r3, #0x80000
 800f926: 2b00         	cmp	r3, #0x0
 800f928: d111         	bne	0x800f94e <can_stm32_tx_isr_handler+0x150> @ imm = #0x22
; 			 can->TSR & CAN_TSR_ALST2 ? -EBUSY :
 800f92a: 697b         	ldr	r3, [r7, #0x14]
 800f92c: 689b         	ldr	r3, [r3, #0x8]
 800f92e: f403 2380    	and	r3, r3, #0x40000
 800f932: 2b00         	cmp	r3, #0x0
 800f934: d108         	bne	0x800f948 <can_stm32_tx_isr_handler+0x14a> @ imm = #0x10
; 			 bus_off                  ? -ENETUNREACH :
 800f936: 693b         	ldr	r3, [r7, #0x10]
 800f938: 2b00         	cmp	r3, #0x0
 800f93a: d002         	beq	0x800f942 <can_stm32_tx_isr_handler+0x144> @ imm = #0x4
 800f93c: f06f 0371    	mvn	r3, #0x71
 800f940: e009         	b	0x800f956 <can_stm32_tx_isr_handler+0x158> @ imm = #0x12
 800f942: f06f 0304    	mvn	r3, #0x4
 800f946: e006         	b	0x800f956 <can_stm32_tx_isr_handler+0x158> @ imm = #0xc
; 			 can->TSR & CAN_TSR_ALST2 ? -EBUSY :
 800f948: f06f 030f    	mvn	r3, #0xf
 800f94c: e003         	b	0x800f956 <can_stm32_tx_isr_handler+0x158> @ imm = #0x6
; 			 can->TSR & CAN_TSR_TERR2 ? -EIO :
 800f94e: f06f 0304    	mvn	r3, #0x4
 800f952: e000         	b	0x800f956 <can_stm32_tx_isr_handler+0x158> @ imm = #0x0
; 		status = can->TSR & CAN_TSR_TXOK2 ? 0  :
 800f954: 2300         	movs	r3, #0x0
 800f956: 60fb         	str	r3, [r7, #0xc]
; 		can->TSR |= CAN_TSR_RQCP2;
 800f958: 697b         	ldr	r3, [r7, #0x14]
 800f95a: 689b         	ldr	r3, [r3, #0x8]
 800f95c: f443 3280    	orr	r2, r3, #0x10000
 800f960: 697b         	ldr	r3, [r7, #0x14]
 800f962: 609a         	str	r2, [r3, #0x8]
; 		can_stm32_signal_tx_complete(dev, &data->mb2, status);
 800f964: 69fb         	ldr	r3, [r7, #0x1c]
 800f966: 3344         	adds	r3, #0x44
 800f968: 68fa         	ldr	r2, [r7, #0xc]
 800f96a: 4619         	mov	r1, r3
 800f96c: 6878         	ldr	r0, [r7, #0x4]
 800f96e: f7ff fe6a    	bl	0x800f646 <can_stm32_signal_tx_complete> @ imm = #-0x32c
; 	if (can->TSR & CAN_TSR_TME) {
 800f972: 697b         	ldr	r3, [r7, #0x14]
 800f974: 689b         	ldr	r3, [r3, #0x8]
 800f976: f003 53e0    	and	r3, r3, #0x1c000000
 800f97a: 2b00         	cmp	r3, #0x0
 800f97c: d004         	beq	0x800f988 <can_stm32_tx_isr_handler+0x18a> @ imm = #0x8
; 		k_sem_give(&data->tx_int_sem);
 800f97e: 69fb         	ldr	r3, [r7, #0x1c]
 800f980: 3324         	adds	r3, #0x24
 800f982: 4618         	mov	r0, r3
 800f984: f7ff fd96    	bl	0x800f4b4 <k_sem_give>  @ imm = #-0x4d4
; }
 800f988: bf00         	nop
 800f98a: 3720         	adds	r7, #0x20
 800f98c: 46bd         	mov	sp, r7
 800f98e: bd80         	pop	{r7, pc}

0800f990 <can_stm32_rx_isr>:
; {
 800f990: b580         	push	{r7, lr}
 800f992: b082         	sub	sp, #0x8
 800f994: af00         	add	r7, sp, #0x0
 800f996: 6078         	str	r0, [r7, #0x4]
; 	can_stm32_rx_isr_handler(dev);
 800f998: 6878         	ldr	r0, [r7, #0x4]
 800f99a: f7f4 fad9    	bl	0x8003f50 <can_stm32_rx_isr_handler> @ imm = #-0xba4e
; }
 800f99e: bf00         	nop
 800f9a0: 3708         	adds	r7, #0x8
 800f9a2: 46bd         	mov	sp, r7
 800f9a4: bd80         	pop	{r7, pc}

0800f9a6 <can_stm32_tx_isr>:
; {
 800f9a6: b580         	push	{r7, lr}
 800f9a8: b082         	sub	sp, #0x8
 800f9aa: af00         	add	r7, sp, #0x0
 800f9ac: 6078         	str	r0, [r7, #0x4]
; 	can_stm32_tx_isr_handler(dev);
 800f9ae: 6878         	ldr	r0, [r7, #0x4]
 800f9b0: f7ff ff25    	bl	0x800f7fe <can_stm32_tx_isr_handler> @ imm = #-0x1b6
; }
 800f9b4: bf00         	nop
 800f9b6: 3708         	adds	r7, #0x8
 800f9b8: 46bd         	mov	sp, r7
 800f9ba: bd80         	pop	{r7, pc}

0800f9bc <can_stm32_state_change_isr>:
; {
 800f9bc: b580         	push	{r7, lr}
 800f9be: b084         	sub	sp, #0x10
 800f9c0: af00         	add	r7, sp, #0x0
 800f9c2: 6078         	str	r0, [r7, #0x4]
; 	const struct can_stm32_config *cfg = dev->config;
 800f9c4: 687b         	ldr	r3, [r7, #0x4]
 800f9c6: 685b         	ldr	r3, [r3, #0x4]
 800f9c8: 60fb         	str	r3, [r7, #0xc]
; 	CAN_TypeDef *can = cfg->can;
 800f9ca: 68fb         	ldr	r3, [r7, #0xc]
 800f9cc: 695b         	ldr	r3, [r3, #0x14]
 800f9ce: 60bb         	str	r3, [r7, #0x8]
; 	if (can->MSR & CAN_MSR_ERRI) {
 800f9d0: 68bb         	ldr	r3, [r7, #0x8]
 800f9d2: 685b         	ldr	r3, [r3, #0x4]
 800f9d4: f003 0304    	and	r3, r3, #0x4
 800f9d8: 2b00         	cmp	r3, #0x0
 800f9da: d00b         	beq	0x800f9f4 <can_stm32_state_change_isr+0x38> @ imm = #0x16
; 		can_stm32_tx_isr_handler(dev);
 800f9dc: 6878         	ldr	r0, [r7, #0x4]
 800f9de: f7ff ff0e    	bl	0x800f7fe <can_stm32_tx_isr_handler> @ imm = #-0x1e4
; 		can_stm32_bus_state_change_isr(dev);
 800f9e2: 6878         	ldr	r0, [r7, #0x4]
 800f9e4: f7ff fedf    	bl	0x800f7a6 <can_stm32_bus_state_change_isr> @ imm = #-0x242
; 		can->MSR |= CAN_MSR_ERRI;
 800f9e8: 68bb         	ldr	r3, [r7, #0x8]
 800f9ea: 685b         	ldr	r3, [r3, #0x4]
 800f9ec: f043 0204    	orr	r2, r3, #0x4
 800f9f0: 68bb         	ldr	r3, [r7, #0x8]
 800f9f2: 605a         	str	r2, [r3, #0x4]
; }
 800f9f4: bf00         	nop
 800f9f6: 3710         	adds	r7, #0x10
 800f9f8: 46bd         	mov	sp, r7
 800f9fa: bd80         	pop	{r7, pc}

0800f9fc <can_stm32_get_capabilities>:
; {
 800f9fc: b480         	push	{r7}
 800f9fe: b083         	sub	sp, #0xc
 800fa00: af00         	add	r7, sp, #0x0
 800fa02: 6078         	str	r0, [r7, #0x4]
 800fa04: 6039         	str	r1, [r7]
; 	*cap = CAN_MODE_NORMAL | CAN_MODE_LOOPBACK | CAN_MODE_LISTENONLY | CAN_MODE_ONE_SHOT;
 800fa06: 683b         	ldr	r3, [r7]
 800fa08: 220b         	movs	r2, #0xb
 800fa0a: 601a         	str	r2, [r3]
; 	return 0;
 800fa0c: 2300         	movs	r3, #0x0
; }
 800fa0e: 4618         	mov	r0, r3
 800fa10: 370c         	adds	r7, #0xc
 800fa12: 46bd         	mov	sp, r7
 800fa14: bc80         	pop	{r7}
 800fa16: 4770         	bx	lr

0800fa18 <can_stm32_get_max_filters>:
; {
 800fa18: b480         	push	{r7}
 800fa1a: b083         	sub	sp, #0xc
 800fa1c: af00         	add	r7, sp, #0x0
 800fa1e: 6078         	str	r0, [r7, #0x4]
 800fa20: 460b         	mov	r3, r1
 800fa22: 70fb         	strb	r3, [r7, #0x3]
; 	if (ide) {
 800fa24: 78fb         	ldrb	r3, [r7, #0x3]
 800fa26: 2b00         	cmp	r3, #0x0
 800fa28: d001         	beq	0x800fa2e <can_stm32_get_max_filters+0x16> @ imm = #0x2
; 		return CONFIG_CAN_MAX_EXT_ID_FILTER;
 800fa2a: 2307         	movs	r3, #0x7
 800fa2c: e000         	b	0x800fa30 <can_stm32_get_max_filters+0x18> @ imm = #0x0
; 		return CONFIG_CAN_MAX_STD_ID_FILTER;
 800fa2e: 230e         	movs	r3, #0xe
; }
 800fa30: 4618         	mov	r0, r3
 800fa32: 370c         	adds	r7, #0xc
 800fa34: 46bd         	mov	sp, r7
 800fa36: bc80         	pop	{r7}
 800fa38: 4770         	bx	lr

0800fa3a <can_stm32_set_state_change_callback>:
; {
 800fa3a: b480         	push	{r7}
 800fa3c: b089         	sub	sp, #0x24
 800fa3e: af00         	add	r7, sp, #0x0
 800fa40: 60f8         	str	r0, [r7, #0xc]
 800fa42: 60b9         	str	r1, [r7, #0x8]
 800fa44: 607a         	str	r2, [r7, #0x4]
; 	struct can_stm32_data *data = dev->data;
 800fa46: 68fb         	ldr	r3, [r7, #0xc]
 800fa48: 691b         	ldr	r3, [r3, #0x10]
 800fa4a: 61fb         	str	r3, [r7, #0x1c]
; 	const struct can_stm32_config *cfg = dev->config;
 800fa4c: 68fb         	ldr	r3, [r7, #0xc]
 800fa4e: 685b         	ldr	r3, [r3, #0x4]
 800fa50: 61bb         	str	r3, [r7, #0x18]
; 	CAN_TypeDef *can = cfg->can;
 800fa52: 69bb         	ldr	r3, [r7, #0x18]
 800fa54: 695b         	ldr	r3, [r3, #0x14]
 800fa56: 617b         	str	r3, [r7, #0x14]
; 	data->common.state_change_cb = cb;
 800fa58: 69fb         	ldr	r3, [r7, #0x1c]
 800fa5a: 68ba         	ldr	r2, [r7, #0x8]
 800fa5c: 609a         	str	r2, [r3, #0x8]
; 	data->common.state_change_cb_user_data = user_data;
 800fa5e: 69fb         	ldr	r3, [r7, #0x1c]
 800fa60: 687a         	ldr	r2, [r7, #0x4]
 800fa62: 60da         	str	r2, [r3, #0xc]
; 	if (cb == NULL) {
 800fa64: 68bb         	ldr	r3, [r7, #0x8]
 800fa66: 2b00         	cmp	r3, #0x0
 800fa68: d106         	bne	0x800fa78 <can_stm32_set_state_change_callback+0x3e> @ imm = #0xc
; 		can->IER &= ~(CAN_IER_BOFIE | CAN_IER_EPVIE | CAN_IER_EWGIE);
 800fa6a: 697b         	ldr	r3, [r7, #0x14]
 800fa6c: 695b         	ldr	r3, [r3, #0x14]
 800fa6e: f423 62e0    	bic	r2, r3, #0x700
 800fa72: 697b         	ldr	r3, [r7, #0x14]
 800fa74: 615a         	str	r2, [r3, #0x14]
; }
 800fa76: e005         	b	0x800fa84 <can_stm32_set_state_change_callback+0x4a> @ imm = #0xa
; 		can->IER |= CAN_IER_BOFIE | CAN_IER_EPVIE | CAN_IER_EWGIE;
 800fa78: 697b         	ldr	r3, [r7, #0x14]
 800fa7a: 695b         	ldr	r3, [r3, #0x14]
 800fa7c: f443 62e0    	orr	r2, r3, #0x700
 800fa80: 697b         	ldr	r3, [r7, #0x14]
 800fa82: 615a         	str	r2, [r3, #0x14]
; }
 800fa84: bf00         	nop
 800fa86: 3724         	adds	r7, #0x24
 800fa88: 46bd         	mov	sp, r7
 800fa8a: bc80         	pop	{r7}
 800fa8c: 4770         	bx	lr

0800fa8e <can_stm32_set_filter_bank>:
; {
 800fa8e: b480         	push	{r7}
 800fa90: b085         	sub	sp, #0x14
 800fa92: af00         	add	r7, sp, #0x0
 800fa94: 60f8         	str	r0, [r7, #0xc]
 800fa96: 60b9         	str	r1, [r7, #0x8]
 800fa98: 603b         	str	r3, [r7]
 800fa9a: 4613         	mov	r3, r2
 800fa9c: 71fb         	strb	r3, [r7, #0x7]
; 	if (ide) {
 800fa9e: 79fb         	ldrb	r3, [r7, #0x7]
 800faa0: 2b00         	cmp	r3, #0x0
 800faa2: d006         	beq	0x800fab2 <can_stm32_set_filter_bank+0x24> @ imm = #0xc
; 		filter_reg->FR1 = id;
 800faa4: 68bb         	ldr	r3, [r7, #0x8]
 800faa6: 683a         	ldr	r2, [r7]
 800faa8: 601a         	str	r2, [r3]
; 		filter_reg->FR2 = mask;
 800faaa: 68bb         	ldr	r3, [r7, #0x8]
 800faac: 69ba         	ldr	r2, [r7, #0x18]
 800faae: 605a         	str	r2, [r3, #0x4]
; }
 800fab0: e012         	b	0x800fad8 <can_stm32_set_filter_bank+0x4a> @ imm = #0x24
; 		if ((filter_id - CONFIG_CAN_MAX_EXT_ID_FILTER) % 2 == 0) {
 800fab2: 68fb         	ldr	r3, [r7, #0xc]
 800fab4: 3b07         	subs	r3, #0x7
 800fab6: f003 0301    	and	r3, r3, #0x1
 800faba: 2b00         	cmp	r3, #0x0
 800fabc: d106         	bne	0x800facc <can_stm32_set_filter_bank+0x3e> @ imm = #0xc
; 			filter_reg->FR1 = id | (mask << 16);
 800fabe: 69bb         	ldr	r3, [r7, #0x18]
 800fac0: 041a         	lsls	r2, r3, #0x10
 800fac2: 683b         	ldr	r3, [r7]
 800fac4: 431a         	orrs	r2, r3
 800fac6: 68bb         	ldr	r3, [r7, #0x8]
 800fac8: 601a         	str	r2, [r3]
; }
 800faca: e005         	b	0x800fad8 <can_stm32_set_filter_bank+0x4a> @ imm = #0xa
; 			filter_reg->FR2 = id | (mask << 16);
 800facc: 69bb         	ldr	r3, [r7, #0x18]
 800face: 041a         	lsls	r2, r3, #0x10
 800fad0: 683b         	ldr	r3, [r7]
 800fad2: 431a         	orrs	r2, r3
 800fad4: 68bb         	ldr	r3, [r7, #0x8]
 800fad6: 605a         	str	r2, [r3, #0x4]
; }
 800fad8: bf00         	nop
 800fada: 3714         	adds	r7, #0x14
 800fadc: 46bd         	mov	sp, r7
 800fade: bc80         	pop	{r7}
 800fae0: 4770         	bx	lr

0800fae2 <can_stm32_filter_to_std_mask>:
; {
 800fae2: b480         	push	{r7}
 800fae4: b085         	sub	sp, #0x14
 800fae6: af00         	add	r7, sp, #0x0
 800fae8: 6078         	str	r0, [r7, #0x4]
; 	uint32_t rtr_mask = !IS_ENABLED(CONFIG_CAN_ACCEPT_RTR);
 800faea: 2301         	movs	r3, #0x1
 800faec: 60fb         	str	r3, [r7, #0xc]
; 	return  (filter->mask << CAN_STM32_FIRX_STD_ID_POS) |
 800faee: 687b         	ldr	r3, [r7, #0x4]
 800faf0: 685b         	ldr	r3, [r3, #0x4]
 800faf2: 015a         	lsls	r2, r3, #0x5
; 		(rtr_mask << CAN_STM32_FIRX_STD_RTR_POS) |
 800faf4: 68fb         	ldr	r3, [r7, #0xc]
 800faf6: 011b         	lsls	r3, r3, #0x4
; 	return  (filter->mask << CAN_STM32_FIRX_STD_ID_POS) |
 800faf8: 4313         	orrs	r3, r2
; 		(rtr_mask << CAN_STM32_FIRX_STD_RTR_POS) |
 800fafa: f043 0308    	orr	r3, r3, #0x8
; }
 800fafe: 4618         	mov	r0, r3
 800fb00: 3714         	adds	r7, #0x14
 800fb02: 46bd         	mov	sp, r7
 800fb04: bc80         	pop	{r7}
 800fb06: 4770         	bx	lr

0800fb08 <can_stm32_filter_to_ext_mask>:
; {
 800fb08: b480         	push	{r7}
 800fb0a: b085         	sub	sp, #0x14
 800fb0c: af00         	add	r7, sp, #0x0
 800fb0e: 6078         	str	r0, [r7, #0x4]
; 	uint32_t rtr_mask = !IS_ENABLED(CONFIG_CAN_ACCEPT_RTR);
 800fb10: 2301         	movs	r3, #0x1
 800fb12: 60fb         	str	r3, [r7, #0xc]
; 	return  (filter->mask << CAN_STM32_FIRX_EXT_EXT_ID_POS) |
 800fb14: 687b         	ldr	r3, [r7, #0x4]
 800fb16: 685b         	ldr	r3, [r3, #0x4]
 800fb18: 00da         	lsls	r2, r3, #0x3
; 		(rtr_mask << CAN_STM32_FIRX_EXT_RTR_POS) |
 800fb1a: 68fb         	ldr	r3, [r7, #0xc]
 800fb1c: 005b         	lsls	r3, r3, #0x1
; 	return  (filter->mask << CAN_STM32_FIRX_EXT_EXT_ID_POS) |
 800fb1e: 4313         	orrs	r3, r2
; 		(rtr_mask << CAN_STM32_FIRX_EXT_RTR_POS) |
 800fb20: f043 0304    	orr	r3, r3, #0x4
; }
 800fb24: 4618         	mov	r0, r3
 800fb26: 3714         	adds	r7, #0x14
 800fb28: 46bd         	mov	sp, r7
 800fb2a: bc80         	pop	{r7}
 800fb2c: 4770         	bx	lr

0800fb2e <can_stm32_filter_to_std_id>:
; {
 800fb2e: b480         	push	{r7}
 800fb30: b083         	sub	sp, #0xc
 800fb32: af00         	add	r7, sp, #0x0
 800fb34: 6078         	str	r0, [r7, #0x4]
; 	return  (filter->id  << CAN_STM32_FIRX_STD_ID_POS);
 800fb36: 687b         	ldr	r3, [r7, #0x4]
 800fb38: 681b         	ldr	r3, [r3]
 800fb3a: 015b         	lsls	r3, r3, #0x5
; }
 800fb3c: 4618         	mov	r0, r3
 800fb3e: 370c         	adds	r7, #0xc
 800fb40: 46bd         	mov	sp, r7
 800fb42: bc80         	pop	{r7}
 800fb44: 4770         	bx	lr

0800fb46 <can_stm32_filter_to_ext_id>:
; {
 800fb46: b480         	push	{r7}
 800fb48: b083         	sub	sp, #0xc
 800fb4a: af00         	add	r7, sp, #0x0
 800fb4c: 6078         	str	r0, [r7, #0x4]
; 	return  (filter->id << CAN_STM32_FIRX_EXT_EXT_ID_POS) |
 800fb4e: 687b         	ldr	r3, [r7, #0x4]
 800fb50: 681b         	ldr	r3, [r3]
 800fb52: 00db         	lsls	r3, r3, #0x3
 800fb54: f043 0304    	orr	r3, r3, #0x4
; }
 800fb58: 4618         	mov	r0, r3
 800fb5a: 370c         	adds	r7, #0xc
 800fb5c: 46bd         	mov	sp, r7
 800fb5e: bc80         	pop	{r7}
 800fb60: 4770         	bx	lr

0800fb62 <config_can_0_irq>:
; DT_INST_FOREACH_STATUS_OKAY(CAN_STM32_INST)
 800fb62: b580         	push	{r7, lr}
 800fb64: b082         	sub	sp, #0x8
 800fb66: af00         	add	r7, sp, #0x0
 800fb68: 6078         	str	r0, [r7, #0x4]
 800fb6a: 2200         	movs	r2, #0x0
 800fb6c: 2100         	movs	r1, #0x0
 800fb6e: 2014         	movs	r0, #0x14
 800fb70: f7ff f98f    	bl	0x800ee92 <z_arm_irq_priority_set> @ imm = #-0xce2
 800fb74: 2014         	movs	r0, #0x14
 800fb76: f7ff f97f    	bl	0x800ee78 <arch_irq_enable> @ imm = #-0xd02
 800fb7a: 2200         	movs	r2, #0x0
 800fb7c: 2100         	movs	r1, #0x0
 800fb7e: 2013         	movs	r0, #0x13
 800fb80: f7ff f987    	bl	0x800ee92 <z_arm_irq_priority_set> @ imm = #-0xcf2
 800fb84: 2013         	movs	r0, #0x13
 800fb86: f7ff f977    	bl	0x800ee78 <arch_irq_enable> @ imm = #-0xd12
 800fb8a: 2200         	movs	r2, #0x0
 800fb8c: 2100         	movs	r1, #0x0
 800fb8e: 2016         	movs	r0, #0x16
 800fb90: f7ff f97f    	bl	0x800ee92 <z_arm_irq_priority_set> @ imm = #-0xd02
 800fb94: 2016         	movs	r0, #0x16
 800fb96: f7ff f96f    	bl	0x800ee78 <arch_irq_enable> @ imm = #-0xd22
 800fb9a: 687b         	ldr	r3, [r7, #0x4]
 800fb9c: 695b         	ldr	r3, [r3, #0x14]
 800fb9e: f443 4304    	orr	r3, r3, #0x8400
 800fba2: f043 0313    	orr	r3, r3, #0x13
 800fba6: 687a         	ldr	r2, [r7, #0x4]
 800fba8: 6153         	str	r3, [r2, #0x14]
 800fbaa: 3708         	adds	r7, #0x8
 800fbac: 46bd         	mov	sp, r7
 800fbae: bd80         	pop	{r7, pc}

0800fbb0 <config_can_1_irq>:
 800fbb0: b580         	push	{r7, lr}
 800fbb2: b082         	sub	sp, #0x8
 800fbb4: af00         	add	r7, sp, #0x0
 800fbb6: 6078         	str	r0, [r7, #0x4]
 800fbb8: 2200         	movs	r2, #0x0
 800fbba: 2100         	movs	r1, #0x0
 800fbbc: 2040         	movs	r0, #0x40
 800fbbe: f7ff f968    	bl	0x800ee92 <z_arm_irq_priority_set> @ imm = #-0xd30
 800fbc2: 2040         	movs	r0, #0x40
 800fbc4: f7ff f958    	bl	0x800ee78 <arch_irq_enable> @ imm = #-0xd50
 800fbc8: 2200         	movs	r2, #0x0
 800fbca: 2100         	movs	r1, #0x0
 800fbcc: 203f         	movs	r0, #0x3f
 800fbce: f7ff f960    	bl	0x800ee92 <z_arm_irq_priority_set> @ imm = #-0xd40
 800fbd2: 203f         	movs	r0, #0x3f
 800fbd4: f7ff f950    	bl	0x800ee78 <arch_irq_enable> @ imm = #-0xd60
 800fbd8: 2200         	movs	r2, #0x0
 800fbda: 2100         	movs	r1, #0x0
 800fbdc: 2042         	movs	r0, #0x42
 800fbde: f7ff f958    	bl	0x800ee92 <z_arm_irq_priority_set> @ imm = #-0xd50
 800fbe2: 2042         	movs	r0, #0x42
 800fbe4: f7ff f948    	bl	0x800ee78 <arch_irq_enable> @ imm = #-0xd70
 800fbe8: 687b         	ldr	r3, [r7, #0x4]
 800fbea: 695b         	ldr	r3, [r3, #0x14]
 800fbec: f443 4304    	orr	r3, r3, #0x8400
 800fbf0: f043 0313    	orr	r3, r3, #0x13
 800fbf4: 687a         	ldr	r2, [r7, #0x4]
 800fbf6: 6153         	str	r3, [r2, #0x14]
 800fbf8: 3708         	adds	r7, #0x8
 800fbfa: 46bd         	mov	sp, r7
 800fbfc: bd80         	pop	{r7, pc}

0800fbfe <stm32_clock_control_mco_init>:
; {
 800fbfe: b480         	push	{r7}
 800fc00: af00         	add	r7, sp, #0x0
; }
 800fc02: bf00         	nop
 800fc04: 46bd         	mov	sp, r7
 800fc06: bc80         	pop	{r7}
 800fc08: 4770         	bx	lr

0800fc0a <get_pll_div_frequency>:
; {
 800fc0a: b480         	push	{r7}
 800fc0c: b085         	sub	sp, #0x14
 800fc0e: af00         	add	r7, sp, #0x0
 800fc10: 60f8         	str	r0, [r7, #0xc]
 800fc12: 60b9         	str	r1, [r7, #0x8]
 800fc14: 607a         	str	r2, [r7, #0x4]
 800fc16: 603b         	str	r3, [r7]
; 	return pllsrc_freq / pllm_div * plln_mul / pllout_div;
 800fc18: 68bb         	ldr	r3, [r7, #0x8]
 800fc1a: 68fa         	ldr	r2, [r7, #0xc]
 800fc1c: fbb2 f3f3    	udiv	r3, r2, r3
 800fc20: 687a         	ldr	r2, [r7, #0x4]
 800fc22: fb03 f202    	mul	r2, r3, r2
 800fc26: 683b         	ldr	r3, [r7]
 800fc28: fbb2 f3f3    	udiv	r3, r2, r3
; }
 800fc2c: 4618         	mov	r0, r3
 800fc2e: 3714         	adds	r7, #0x14
 800fc30: 46bd         	mov	sp, r7
 800fc32: bc80         	pop	{r7}
 800fc34: 4770         	bx	lr

0800fc36 <get_bus_clock>:
; {
 800fc36: b480         	push	{r7}
 800fc38: b083         	sub	sp, #0xc
 800fc3a: af00         	add	r7, sp, #0x0
 800fc3c: 6078         	str	r0, [r7, #0x4]
 800fc3e: 6039         	str	r1, [r7]
; 	return clock / prescaler;
 800fc40: 687a         	ldr	r2, [r7, #0x4]
 800fc42: 683b         	ldr	r3, [r7]
 800fc44: fbb2 f3f3    	udiv	r3, r2, r3
; }
 800fc48: 4618         	mov	r0, r3
 800fc4a: 370c         	adds	r7, #0xc
 800fc4c: 46bd         	mov	sp, r7
 800fc4e: bc80         	pop	{r7}
 800fc50: 4770         	bx	lr

0800fc52 <stm32_clock_control_on>:
; {
 800fc52: b480         	push	{r7}
 800fc54: b089         	sub	sp, #0x24
 800fc56: af00         	add	r7, sp, #0x0
 800fc58: 6078         	str	r0, [r7, #0x4]
 800fc5a: 6039         	str	r1, [r7]
; 	struct stm32_pclken *pclken = (struct stm32_pclken *)(sub_system);
 800fc5c: 683b         	ldr	r3, [r7]
 800fc5e: 61fb         	str	r3, [r7, #0x1c]
; 	if (IN_RANGE(pclken->bus, STM32_PERIPH_BUS_MIN, STM32_PERIPH_BUS_MAX) == 0) {
 800fc60: 69fb         	ldr	r3, [r7, #0x1c]
 800fc62: 681b         	ldr	r3, [r3]
 800fc64: 2b2f         	cmp	r3, #0x2f
 800fc66: d905         	bls	0x800fc74 <stm32_clock_control_on+0x22> @ imm = #0xa
 800fc68: 69fb         	ldr	r3, [r7, #0x1c]
 800fc6a: 681b         	ldr	r3, [r3]
 800fc6c: 2ba8         	cmp	r3, #0xa8
 800fc6e: d801         	bhi	0x800fc74 <stm32_clock_control_on+0x22> @ imm = #0x2
 800fc70: 2301         	movs	r3, #0x1
 800fc72: e000         	b	0x800fc76 <stm32_clock_control_on+0x24> @ imm = #0x0
 800fc74: 2300         	movs	r3, #0x0
 800fc76: 2b00         	cmp	r3, #0x0
 800fc78: d102         	bne	0x800fc80 <stm32_clock_control_on+0x2e> @ imm = #0x4
; 		return -ENOTSUP;
 800fc7a: f06f 0385    	mvn	r3, #0x85
 800fc7e: e01e         	b	0x800fcbe <stm32_clock_control_on+0x6c> @ imm = #0x3c
; 	sys_set_bits(DT_REG_ADDR(DT_NODELABEL(rcc)) + pclken->bus,
 800fc80: 69fb         	ldr	r3, [r7, #0x1c]
 800fc82: 681b         	ldr	r3, [r3]
 800fc84: f103 4380    	add.w	r3, r3, #0x40000000
 800fc88: f503 330e    	add.w	r3, r3, #0x23800
 800fc8c: 69fa         	ldr	r2, [r7, #0x1c]
 800fc8e: 6852         	ldr	r2, [r2, #0x4]
 800fc90: 617b         	str	r3, [r7, #0x14]
 800fc92: 613a         	str	r2, [r7, #0x10]
; 	uint32_t temp = *(volatile uint32_t *)addr;
 800fc94: 697b         	ldr	r3, [r7, #0x14]
 800fc96: 681b         	ldr	r3, [r3]
 800fc98: 60fb         	str	r3, [r7, #0xc]
; 	*(volatile uint32_t *)addr = temp | mask;
 800fc9a: 697b         	ldr	r3, [r7, #0x14]
 800fc9c: 6939         	ldr	r1, [r7, #0x10]
 800fc9e: 68fa         	ldr	r2, [r7, #0xc]
 800fca0: 430a         	orrs	r2, r1
 800fca2: 601a         	str	r2, [r3]
; }
 800fca4: bf00         	nop
; 	temp = sys_read32(DT_REG_ADDR(DT_NODELABEL(rcc)) + pclken->bus);
 800fca6: 69fb         	ldr	r3, [r7, #0x1c]
 800fca8: 681b         	ldr	r3, [r3]
 800fcaa: f103 4380    	add.w	r3, r3, #0x40000000
 800fcae: f503 330e    	add.w	r3, r3, #0x23800
 800fcb2: 61bb         	str	r3, [r7, #0x18]
; 	return *(volatile uint32_t *)addr;
 800fcb4: 69bb         	ldr	r3, [r7, #0x18]
 800fcb6: 681b         	ldr	r3, [r3]
; 	temp = sys_read32(DT_REG_ADDR(DT_NODELABEL(rcc)) + pclken->bus);
 800fcb8: 60bb         	str	r3, [r7, #0x8]
; 	UNUSED(temp);
 800fcba: 68bb         	ldr	r3, [r7, #0x8]
; 	return 0;
 800fcbc: 2300         	movs	r3, #0x0
; }
 800fcbe: 4618         	mov	r0, r3
 800fcc0: 3724         	adds	r7, #0x24
 800fcc2: 46bd         	mov	sp, r7
 800fcc4: bc80         	pop	{r7}
 800fcc6: 4770         	bx	lr

0800fcc8 <stm32_clock_control_off>:
; {
 800fcc8: b480         	push	{r7}
 800fcca: b087         	sub	sp, #0x1c
 800fccc: af00         	add	r7, sp, #0x0
 800fcce: 6078         	str	r0, [r7, #0x4]
 800fcd0: 6039         	str	r1, [r7]
; 	struct stm32_pclken *pclken = (struct stm32_pclken *)(sub_system);
 800fcd2: 683b         	ldr	r3, [r7]
 800fcd4: 617b         	str	r3, [r7, #0x14]
; 	if (IN_RANGE(pclken->bus, STM32_PERIPH_BUS_MIN, STM32_PERIPH_BUS_MAX) == 0) {
 800fcd6: 697b         	ldr	r3, [r7, #0x14]
 800fcd8: 681b         	ldr	r3, [r3]
 800fcda: 2b2f         	cmp	r3, #0x2f
 800fcdc: d905         	bls	0x800fcea <stm32_clock_control_off+0x22> @ imm = #0xa
 800fcde: 697b         	ldr	r3, [r7, #0x14]
 800fce0: 681b         	ldr	r3, [r3]
 800fce2: 2ba8         	cmp	r3, #0xa8
 800fce4: d801         	bhi	0x800fcea <stm32_clock_control_off+0x22> @ imm = #0x2
 800fce6: 2301         	movs	r3, #0x1
 800fce8: e000         	b	0x800fcec <stm32_clock_control_off+0x24> @ imm = #0x0
 800fcea: 2300         	movs	r3, #0x0
 800fcec: 2b00         	cmp	r3, #0x0
 800fcee: d102         	bne	0x800fcf6 <stm32_clock_control_off+0x2e> @ imm = #0x4
; 		return -ENOTSUP;
 800fcf0: f06f 0385    	mvn	r3, #0x85
 800fcf4: e014         	b	0x800fd20 <stm32_clock_control_off+0x58> @ imm = #0x28
; 	sys_clear_bits(DT_REG_ADDR(DT_NODELABEL(rcc)) + pclken->bus,
 800fcf6: 697b         	ldr	r3, [r7, #0x14]
 800fcf8: 681b         	ldr	r3, [r3]
 800fcfa: f103 4380    	add.w	r3, r3, #0x40000000
 800fcfe: f503 330e    	add.w	r3, r3, #0x23800
 800fd02: 697a         	ldr	r2, [r7, #0x14]
 800fd04: 6852         	ldr	r2, [r2, #0x4]
 800fd06: 613b         	str	r3, [r7, #0x10]
 800fd08: 60fa         	str	r2, [r7, #0xc]
; 	uint32_t temp = *(volatile uint32_t *)addr;
 800fd0a: 693b         	ldr	r3, [r7, #0x10]
 800fd0c: 681b         	ldr	r3, [r3]
 800fd0e: 60bb         	str	r3, [r7, #0x8]
; 	*(volatile uint32_t *)addr = temp & ~mask;
 800fd10: 68fb         	ldr	r3, [r7, #0xc]
 800fd12: 43d9         	mvns	r1, r3
 800fd14: 693b         	ldr	r3, [r7, #0x10]
 800fd16: 68ba         	ldr	r2, [r7, #0x8]
 800fd18: 400a         	ands	r2, r1
 800fd1a: 601a         	str	r2, [r3]
; }
 800fd1c: bf00         	nop
; 	return 0;
 800fd1e: 2300         	movs	r3, #0x0
; }
 800fd20: 4618         	mov	r0, r3
 800fd22: 371c         	adds	r7, #0x1c
 800fd24: 46bd         	mov	sp, r7
 800fd26: bc80         	pop	{r7}
 800fd28: 4770         	bx	lr

0800fd2a <stm32_clock_control_configure>:
; {
 800fd2a: b580         	push	{r7, lr}
 800fd2c: b08c         	sub	sp, #0x30
 800fd2e: af00         	add	r7, sp, #0x0
 800fd30: 60f8         	str	r0, [r7, #0xc]
 800fd32: 60b9         	str	r1, [r7, #0x8]
 800fd34: 607a         	str	r2, [r7, #0x4]
; 	struct stm32_pclken *pclken = (struct stm32_pclken *)(sub_system);
 800fd36: 68bb         	ldr	r3, [r7, #0x8]
 800fd38: 62fb         	str	r3, [r7, #0x2c]
; 	err = enabled_clock(pclken->bus);
 800fd3a: 6afb         	ldr	r3, [r7, #0x2c]
 800fd3c: 681b         	ldr	r3, [r3]
 800fd3e: 4618         	mov	r0, r3
 800fd40: f7f5 fc44    	bl	0x80055cc <enabled_clock> @ imm = #-0xa778
 800fd44: 62b8         	str	r0, [r7, #0x28]
; 	if (err < 0) {
 800fd46: 6abb         	ldr	r3, [r7, #0x28]
 800fd48: 2b00         	cmp	r3, #0x0
 800fd4a: da01         	bge	0x800fd50 <stm32_clock_control_configure+0x26> @ imm = #0x2
; 		return err;
 800fd4c: 6abb         	ldr	r3, [r7, #0x28]
 800fd4e: e043         	b	0x800fdd8 <stm32_clock_control_configure+0xae> @ imm = #0x86
; 	if (pclken->enr == NO_SEL) {
 800fd50: 6afb         	ldr	r3, [r7, #0x2c]
 800fd52: 685b         	ldr	r3, [r3, #0x4]
 800fd54: 2bff         	cmp	r3, #0xff
 800fd56: d101         	bne	0x800fd5c <stm32_clock_control_configure+0x32> @ imm = #0x2
; 		return 0;
 800fd58: 2300         	movs	r3, #0x0
 800fd5a: e03d         	b	0x800fdd8 <stm32_clock_control_configure+0xae> @ imm = #0x7a
; 	sys_clear_bits(DT_REG_ADDR(DT_NODELABEL(rcc)) + STM32_CLOCK_REG_GET(pclken->enr),
 800fd5c: 6afb         	ldr	r3, [r7, #0x2c]
 800fd5e: 685b         	ldr	r3, [r3, #0x4]
 800fd60: b2db         	uxtb	r3, r3
 800fd62: f103 4380    	add.w	r3, r3, #0x40000000
 800fd66: f503 330e    	add.w	r3, r3, #0x23800
; 		       STM32_CLOCK_MASK_GET(pclken->enr) << STM32_CLOCK_SHIFT_GET(pclken->enr));
 800fd6a: 6afa         	ldr	r2, [r7, #0x2c]
 800fd6c: 6852         	ldr	r2, [r2, #0x4]
 800fd6e: 0b52         	lsrs	r2, r2, #0xd
 800fd70: f002 0107    	and	r1, r2, #0x7
 800fd74: 6afa         	ldr	r2, [r7, #0x2c]
 800fd76: 6852         	ldr	r2, [r2, #0x4]
 800fd78: 0a12         	lsrs	r2, r2, #0x8
 800fd7a: f002 021f    	and	r2, r2, #0x1f
; 	sys_clear_bits(DT_REG_ADDR(DT_NODELABEL(rcc)) + STM32_CLOCK_REG_GET(pclken->enr),
 800fd7e: fa01 f202    	lsl.w	r2, r1, r2
 800fd82: 61bb         	str	r3, [r7, #0x18]
 800fd84: 617a         	str	r2, [r7, #0x14]
; 	uint32_t temp = *(volatile uint32_t *)addr;
 800fd86: 69bb         	ldr	r3, [r7, #0x18]
 800fd88: 681b         	ldr	r3, [r3]
 800fd8a: 613b         	str	r3, [r7, #0x10]
; 	*(volatile uint32_t *)addr = temp & ~mask;
 800fd8c: 697b         	ldr	r3, [r7, #0x14]
 800fd8e: 43d9         	mvns	r1, r3
 800fd90: 69bb         	ldr	r3, [r7, #0x18]
 800fd92: 693a         	ldr	r2, [r7, #0x10]
 800fd94: 400a         	ands	r2, r1
 800fd96: 601a         	str	r2, [r3]
; }
 800fd98: bf00         	nop
; 	sys_set_bits(DT_REG_ADDR(DT_NODELABEL(rcc)) + STM32_CLOCK_REG_GET(pclken->enr),
 800fd9a: 6afb         	ldr	r3, [r7, #0x2c]
 800fd9c: 685b         	ldr	r3, [r3, #0x4]
 800fd9e: b2db         	uxtb	r3, r3
 800fda0: f103 4380    	add.w	r3, r3, #0x40000000
 800fda4: f503 330e    	add.w	r3, r3, #0x23800
; 		     STM32_CLOCK_VAL_GET(pclken->enr) << STM32_CLOCK_SHIFT_GET(pclken->enr));
 800fda8: 6afa         	ldr	r2, [r7, #0x2c]
 800fdaa: 6852         	ldr	r2, [r2, #0x4]
 800fdac: 0c12         	lsrs	r2, r2, #0x10
 800fdae: f002 0107    	and	r1, r2, #0x7
 800fdb2: 6afa         	ldr	r2, [r7, #0x2c]
 800fdb4: 6852         	ldr	r2, [r2, #0x4]
 800fdb6: 0a12         	lsrs	r2, r2, #0x8
 800fdb8: f002 021f    	and	r2, r2, #0x1f
; 	sys_set_bits(DT_REG_ADDR(DT_NODELABEL(rcc)) + STM32_CLOCK_REG_GET(pclken->enr),
 800fdbc: fa01 f202    	lsl.w	r2, r1, r2
 800fdc0: 627b         	str	r3, [r7, #0x24]
 800fdc2: 623a         	str	r2, [r7, #0x20]
; 	uint32_t temp = *(volatile uint32_t *)addr;
 800fdc4: 6a7b         	ldr	r3, [r7, #0x24]
 800fdc6: 681b         	ldr	r3, [r3]
 800fdc8: 61fb         	str	r3, [r7, #0x1c]
; 	*(volatile uint32_t *)addr = temp | mask;
 800fdca: 6a7b         	ldr	r3, [r7, #0x24]
 800fdcc: 6a39         	ldr	r1, [r7, #0x20]
 800fdce: 69fa         	ldr	r2, [r7, #0x1c]
 800fdd0: 430a         	orrs	r2, r1
 800fdd2: 601a         	str	r2, [r3]
; }
 800fdd4: bf00         	nop
; 	return 0;
 800fdd6: 2300         	movs	r3, #0x0
; }
 800fdd8: 4618         	mov	r0, r3
 800fdda: 3730         	adds	r7, #0x30
 800fddc: 46bd         	mov	sp, r7
 800fdde: bd80         	pop	{r7, pc}

0800fde0 <stm32_clock_control_get_status>:
; {
 800fde0: b580         	push	{r7, lr}
 800fde2: b084         	sub	sp, #0x10
 800fde4: af00         	add	r7, sp, #0x0
 800fde6: 6078         	str	r0, [r7, #0x4]
 800fde8: 6039         	str	r1, [r7]
; 	struct stm32_pclken *pclken = (struct stm32_pclken *)sub_system;
 800fdea: 683b         	ldr	r3, [r7]
 800fdec: 60fb         	str	r3, [r7, #0xc]
; 	if (IN_RANGE(pclken->bus, STM32_PERIPH_BUS_MIN, STM32_PERIPH_BUS_MAX) == true) {
 800fdee: 68fb         	ldr	r3, [r7, #0xc]
 800fdf0: 681b         	ldr	r3, [r3]
 800fdf2: 2b2f         	cmp	r3, #0x2f
 800fdf4: d905         	bls	0x800fe02 <stm32_clock_control_get_status+0x22> @ imm = #0xa
 800fdf6: 68fb         	ldr	r3, [r7, #0xc]
 800fdf8: 681b         	ldr	r3, [r3]
 800fdfa: 2ba8         	cmp	r3, #0xa8
 800fdfc: d801         	bhi	0x800fe02 <stm32_clock_control_get_status+0x22> @ imm = #0x2
 800fdfe: 2301         	movs	r3, #0x1
 800fe00: e000         	b	0x800fe04 <stm32_clock_control_get_status+0x24> @ imm = #0x0
 800fe02: 2300         	movs	r3, #0x0
 800fe04: 2b01         	cmp	r3, #0x1
 800fe06: d113         	bne	0x800fe30 <stm32_clock_control_get_status+0x50> @ imm = #0x26
; 		if ((sys_read32(DT_REG_ADDR(DT_NODELABEL(rcc)) + pclken->bus) & pclken->enr)
 800fe08: 68fb         	ldr	r3, [r7, #0xc]
 800fe0a: 681b         	ldr	r3, [r3]
 800fe0c: f103 4380    	add.w	r3, r3, #0x40000000
 800fe10: f503 330e    	add.w	r3, r3, #0x23800
 800fe14: 60bb         	str	r3, [r7, #0x8]
; 	return *(volatile uint32_t *)addr;
 800fe16: 68bb         	ldr	r3, [r7, #0x8]
 800fe18: 681a         	ldr	r2, [r3]
; 		if ((sys_read32(DT_REG_ADDR(DT_NODELABEL(rcc)) + pclken->bus) & pclken->enr)
 800fe1a: 68fb         	ldr	r3, [r7, #0xc]
 800fe1c: 685b         	ldr	r3, [r3, #0x4]
 800fe1e: 401a         	ands	r2, r3
; 		    == pclken->enr) {
 800fe20: 68fb         	ldr	r3, [r7, #0xc]
 800fe22: 685b         	ldr	r3, [r3, #0x4]
; 		if ((sys_read32(DT_REG_ADDR(DT_NODELABEL(rcc)) + pclken->bus) & pclken->enr)
 800fe24: 429a         	cmp	r2, r3
 800fe26: d101         	bne	0x800fe2c <stm32_clock_control_get_status+0x4c> @ imm = #0x2
; 			return CLOCK_CONTROL_STATUS_ON;
 800fe28: 2302         	movs	r3, #0x2
 800fe2a: e00c         	b	0x800fe46 <stm32_clock_control_get_status+0x66> @ imm = #0x18
; 			return CLOCK_CONTROL_STATUS_OFF;
 800fe2c: 2301         	movs	r3, #0x1
 800fe2e: e00a         	b	0x800fe46 <stm32_clock_control_get_status+0x66> @ imm = #0x14
; 		if (enabled_clock(pclken->bus) == 0) {
 800fe30: 68fb         	ldr	r3, [r7, #0xc]
 800fe32: 681b         	ldr	r3, [r3]
 800fe34: 4618         	mov	r0, r3
 800fe36: f7f5 fbc9    	bl	0x80055cc <enabled_clock> @ imm = #-0xa86e
 800fe3a: 4603         	mov	r3, r0
 800fe3c: 2b00         	cmp	r3, #0x0
 800fe3e: d101         	bne	0x800fe44 <stm32_clock_control_get_status+0x64> @ imm = #0x2
; 			return CLOCK_CONTROL_STATUS_ON;
 800fe40: 2302         	movs	r3, #0x2
 800fe42: e000         	b	0x800fe46 <stm32_clock_control_get_status+0x66> @ imm = #0x0
; 			return CLOCK_CONTROL_STATUS_OFF;
 800fe44: 2301         	movs	r3, #0x1
; }
 800fe46: 4618         	mov	r0, r3
 800fe48: 3710         	adds	r7, #0x10
 800fe4a: 46bd         	mov	sp, r7
 800fe4c: bd80         	pop	{r7, pc}

0800fe4e <stm32_clock_switch_to_hsi>:
; {
 800fe4e: b580         	push	{r7, lr}
 800fe50: af00         	add	r7, sp, #0x0
; 	if (LL_RCC_HSI_IsReady() != 1) {
 800fe52: f7f5 faf3    	bl	0x800543c <LL_RCC_HSI_IsReady> @ imm = #-0xaa1a
 800fe56: 4603         	mov	r3, r0
 800fe58: 2b01         	cmp	r3, #0x1
 800fe5a: d007         	beq	0x800fe6c <stm32_clock_switch_to_hsi+0x1e> @ imm = #0xe
; 		LL_RCC_HSI_Enable();
 800fe5c: f7f5 fae0    	bl	0x8005420 <LL_RCC_HSI_Enable> @ imm = #-0xaa40
; 		while (LL_RCC_HSI_IsReady() != 1) {
 800fe60: bf00         	nop
 800fe62: f7f5 faeb    	bl	0x800543c <LL_RCC_HSI_IsReady> @ imm = #-0xaa2a
 800fe66: 4603         	mov	r3, r0
 800fe68: 2b01         	cmp	r3, #0x1
 800fe6a: d1fa         	bne	0x800fe62 <stm32_clock_switch_to_hsi+0x14> @ imm = #-0xc
; 	LL_RCC_SetSysClkSource(LL_RCC_SYS_CLKSOURCE_HSI);
 800fe6c: 2000         	movs	r0, #0x0
 800fe6e: f7f5 fb17    	bl	0x80054a0 <LL_RCC_SetSysClkSource> @ imm = #-0xa9d2
; 	while (LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_HSI) {
 800fe72: bf00         	nop
 800fe74: f7f5 fb28    	bl	0x80054c8 <LL_RCC_GetSysClkSource> @ imm = #-0xa9b0
 800fe78: 4603         	mov	r3, r0
 800fe7a: 2b00         	cmp	r3, #0x0
 800fe7c: d1fa         	bne	0x800fe74 <stm32_clock_switch_to_hsi+0x26> @ imm = #-0xc
; }
 800fe7e: bf00         	nop
 800fe80: bf00         	nop
 800fe82: bd80         	pop	{r7, pc}

0800fe84 <set_up_fixed_clock_sources>:
; {
 800fe84: b580         	push	{r7, lr}
 800fe86: af00         	add	r7, sp, #0x0
; 			LL_RCC_HSE_DisableBypass();
 800fe88: f7f5 fa9c    	bl	0x80053c4 <LL_RCC_HSE_DisableBypass> @ imm = #-0xaac8
; 		LL_RCC_HSE_Enable();
 800fe8c: f7f5 faa8    	bl	0x80053e0 <LL_RCC_HSE_Enable> @ imm = #-0xaab0
; 		while (LL_RCC_HSE_IsReady() != 1) {
 800fe90: bf00         	nop
 800fe92: f7f5 fab3    	bl	0x80053fc <LL_RCC_HSE_IsReady> @ imm = #-0xaa9a
 800fe96: 4603         	mov	r3, r0
 800fe98: 2b01         	cmp	r3, #0x1
 800fe9a: d1fa         	bne	0x800fe92 <set_up_fixed_clock_sources+0xe> @ imm = #-0xc
; 		LL_RCC_LSI_Enable();
 800fe9c: f7f5 fae0    	bl	0x8005460 <LL_RCC_LSI_Enable> @ imm = #-0xaa40
; 		while (LL_RCC_LSI_IsReady() != 1) {
 800fea0: bf00         	nop
 800fea2: f7f5 faeb    	bl	0x800547c <LL_RCC_LSI_IsReady> @ imm = #-0xaa2a
 800fea6: 4603         	mov	r3, r0
 800fea8: 2b01         	cmp	r3, #0x1
 800feaa: d1fa         	bne	0x800fea2 <set_up_fixed_clock_sources+0x1e> @ imm = #-0xc
; }
 800feac: bf00         	nop
 800feae: bf00         	nop
 800feb0: bd80         	pop	{r7, pc}

0800feb2 <config_regulator_voltage>:
; void __weak config_regulator_voltage(uint32_t hclk_freq) {}
 800feb2: b480         	push	{r7}
 800feb4: b083         	sub	sp, #0xc
 800feb6: af00         	add	r7, sp, #0x0
 800feb8: 6078         	str	r0, [r7, #0x4]
 800feba: bf00         	nop
 800febc: 370c         	adds	r7, #0xc
 800febe: 46bd         	mov	sp, r7
 800fec0: bc80         	pop	{r7}
 800fec2: 4770         	bx	lr

0800fec4 <get_pll_source>:
; {
 800fec4: b480         	push	{r7}
 800fec6: af00         	add	r7, sp, #0x0
; 		return LL_RCC_PLLSOURCE_HSE;
 800fec8: f44f 0380    	mov.w	r3, #0x400000
; }
 800fecc: 4618         	mov	r0, r3
 800fece: 46bd         	mov	sp, r7
 800fed0: bc80         	pop	{r7}
 800fed2: 4770         	bx	lr

0800fed4 <config_pll_sysclock>:
; {
 800fed4: b580         	push	{r7, lr}
 800fed6: af00         	add	r7, sp, #0x0
; 	LL_RCC_PLL_ConfigDomain_SYS(get_pll_source(),
 800fed8: f7ff fff4    	bl	0x800fec4 <get_pll_source> @ imm = #-0x18
 800fedc: 2300         	movs	r3, #0x0
 800fede: 22a8         	movs	r2, #0xa8
 800fee0: 2106         	movs	r1, #0x6
 800fee2: f7f5 fd43    	bl	0x800596c <LL_RCC_PLL_ConfigDomain_SYS> @ imm = #-0xa57a
; }
 800fee6: bf00         	nop
 800fee8: bd80         	pop	{r7, pc}

0800feea <config_enable_default_clocks>:
; {
 800feea: b580         	push	{r7, lr}
 800feec: af00         	add	r7, sp, #0x0
; 	LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_PWR);
 800feee: f04f 5080    	mov.w	r0, #0x10000000
 800fef2: f7f5 fd23    	bl	0x800593c <LL_APB1_GRP1_EnableClock> @ imm = #-0xa5ba
; }
 800fef6: bf00         	nop
 800fef8: bd80         	pop	{r7, pc}

0800fefa <device_is_ready>:
; {
 800fefa: b580         	push	{r7, lr}
 800fefc: b082         	sub	sp, #0x8
 800fefe: af00         	add	r7, sp, #0x0
 800ff00: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 800ff02: 6878         	ldr	r0, [r7, #0x4]
 800ff04: f002 fe05    	bl	0x8012b12 <z_impl_device_is_ready> @ imm = #0x2c0a
 800ff08: 4603         	mov	r3, r0
; }
 800ff0a: 4618         	mov	r0, r3
 800ff0c: 3708         	adds	r7, #0x8
 800ff0e: 46bd         	mov	sp, r7
 800ff10: bd80         	pop	{r7, pc}

0800ff12 <z_impl_uart_poll_out>:
; {
 800ff12: b580         	push	{r7, lr}
 800ff14: b084         	sub	sp, #0x10
 800ff16: af00         	add	r7, sp, #0x0
 800ff18: 6078         	str	r0, [r7, #0x4]
 800ff1a: 460b         	mov	r3, r1
 800ff1c: 70fb         	strb	r3, [r7, #0x3]
; 	const struct uart_driver_api *api = (const struct uart_driver_api *)dev->api;
 800ff1e: 687b         	ldr	r3, [r7, #0x4]
 800ff20: 689b         	ldr	r3, [r3, #0x8]
 800ff22: 60fb         	str	r3, [r7, #0xc]
; 	api->poll_out(dev, out_char);
 800ff24: 68fb         	ldr	r3, [r7, #0xc]
 800ff26: 685b         	ldr	r3, [r3, #0x4]
 800ff28: 78fa         	ldrb	r2, [r7, #0x3]
 800ff2a: 4611         	mov	r1, r2
 800ff2c: 6878         	ldr	r0, [r7, #0x4]
 800ff2e: 4798         	blx	r3
; }
 800ff30: bf00         	nop
 800ff32: 3710         	adds	r7, #0x10
 800ff34: 46bd         	mov	sp, r7
 800ff36: bd80         	pop	{r7, pc}

0800ff38 <uart_poll_out>:
; {
 800ff38: b580         	push	{r7, lr}
 800ff3a: b082         	sub	sp, #0x8
 800ff3c: af00         	add	r7, sp, #0x0
 800ff3e: 6078         	str	r0, [r7, #0x4]
 800ff40: 460b         	mov	r3, r1
 800ff42: 70fb         	strb	r3, [r7, #0x3]
; 	z_impl_uart_poll_out(dev, out_char);
 800ff44: 78fb         	ldrb	r3, [r7, #0x3]
 800ff46: 4619         	mov	r1, r3
 800ff48: 6878         	ldr	r0, [r7, #0x4]
 800ff4a: f7ff ffe2    	bl	0x800ff12 <z_impl_uart_poll_out> @ imm = #-0x3c
; }
 800ff4e: bf00         	nop
 800ff50: 3708         	adds	r7, #0x8
 800ff52: 46bd         	mov	sp, r7
 800ff54: bd80         	pop	{r7, pc}

0800ff56 <pm_device_runtime_get>:
; {
 800ff56: b480         	push	{r7}
 800ff58: b083         	sub	sp, #0xc
 800ff5a: af00         	add	r7, sp, #0x0
 800ff5c: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 800ff5e: 2300         	movs	r3, #0x0
; }
 800ff60: 4618         	mov	r0, r3
 800ff62: 370c         	adds	r7, #0xc
 800ff64: 46bd         	mov	sp, r7
 800ff66: bc80         	pop	{r7}
 800ff68: 4770         	bx	lr

0800ff6a <pm_device_runtime_put_async>:
; {
 800ff6a: b480         	push	{r7}
 800ff6c: b085         	sub	sp, #0x14
 800ff6e: af00         	add	r7, sp, #0x0
 800ff70: 60f8         	str	r0, [r7, #0xc]
 800ff72: e9c7 2300    	strd	r2, r3, [r7]
; 	return 0;
 800ff76: 2300         	movs	r3, #0x0
; }
 800ff78: 4618         	mov	r0, r3
 800ff7a: 3714         	adds	r7, #0x14
 800ff7c: 46bd         	mov	sp, r7
 800ff7e: bc80         	pop	{r7}
 800ff80: 4770         	bx	lr

0800ff82 <z_snode_next_peek>:
; {
 800ff82: b480         	push	{r7}
 800ff84: b083         	sub	sp, #0xc
 800ff86: af00         	add	r7, sp, #0x0
 800ff88: 6078         	str	r0, [r7, #0x4]
; 	return node->next;
 800ff8a: 687b         	ldr	r3, [r7, #0x4]
 800ff8c: 681b         	ldr	r3, [r3]
; }
 800ff8e: 4618         	mov	r0, r3
 800ff90: 370c         	adds	r7, #0xc
 800ff92: 46bd         	mov	sp, r7
 800ff94: bc80         	pop	{r7}
 800ff96: 4770         	bx	lr

0800ff98 <z_snode_next_set>:
; {
 800ff98: b480         	push	{r7}
 800ff9a: b083         	sub	sp, #0xc
 800ff9c: af00         	add	r7, sp, #0x0
 800ff9e: 6078         	str	r0, [r7, #0x4]
 800ffa0: 6039         	str	r1, [r7]
; 	parent->next = child;
 800ffa2: 687b         	ldr	r3, [r7, #0x4]
 800ffa4: 683a         	ldr	r2, [r7]
 800ffa6: 601a         	str	r2, [r3]
; }
 800ffa8: bf00         	nop
 800ffaa: 370c         	adds	r7, #0xc
 800ffac: 46bd         	mov	sp, r7
 800ffae: bc80         	pop	{r7}
 800ffb0: 4770         	bx	lr

0800ffb2 <z_slist_head_set>:
; {
 800ffb2: b480         	push	{r7}
 800ffb4: b083         	sub	sp, #0xc
 800ffb6: af00         	add	r7, sp, #0x0
 800ffb8: 6078         	str	r0, [r7, #0x4]
 800ffba: 6039         	str	r1, [r7]
; 	list->head = node;
 800ffbc: 687b         	ldr	r3, [r7, #0x4]
 800ffbe: 683a         	ldr	r2, [r7]
 800ffc0: 601a         	str	r2, [r3]
; }
 800ffc2: bf00         	nop
 800ffc4: 370c         	adds	r7, #0xc
 800ffc6: 46bd         	mov	sp, r7
 800ffc8: bc80         	pop	{r7}
 800ffca: 4770         	bx	lr

0800ffcc <z_slist_tail_set>:
; {
 800ffcc: b480         	push	{r7}
 800ffce: b083         	sub	sp, #0xc
 800ffd0: af00         	add	r7, sp, #0x0
 800ffd2: 6078         	str	r0, [r7, #0x4]
 800ffd4: 6039         	str	r1, [r7]
; 	list->tail = node;
 800ffd6: 687b         	ldr	r3, [r7, #0x4]
 800ffd8: 683a         	ldr	r2, [r7]
 800ffda: 605a         	str	r2, [r3, #0x4]
; }
 800ffdc: bf00         	nop
 800ffde: 370c         	adds	r7, #0xc
 800ffe0: 46bd         	mov	sp, r7
 800ffe2: bc80         	pop	{r7}
 800ffe4: 4770         	bx	lr

0800ffe6 <sys_slist_peek_head>:
; {
 800ffe6: b480         	push	{r7}
 800ffe8: b083         	sub	sp, #0xc
 800ffea: af00         	add	r7, sp, #0x0
 800ffec: 6078         	str	r0, [r7, #0x4]
; 	return list->head;
 800ffee: 687b         	ldr	r3, [r7, #0x4]
 800fff0: 681b         	ldr	r3, [r3]
; }
 800fff2: 4618         	mov	r0, r3
 800fff4: 370c         	adds	r7, #0xc
 800fff6: 46bd         	mov	sp, r7
 800fff8: bc80         	pop	{r7}
 800fffa: 4770         	bx	lr

0800fffc <sys_slist_peek_tail>:
; {
 800fffc: b480         	push	{r7}
 800fffe: b083         	sub	sp, #0xc
 8010000: af00         	add	r7, sp, #0x0
 8010002: 6078         	str	r0, [r7, #0x4]
; 	return list->tail;
 8010004: 687b         	ldr	r3, [r7, #0x4]
 8010006: 685b         	ldr	r3, [r3, #0x4]
; }
 8010008: 4618         	mov	r0, r3
 801000a: 370c         	adds	r7, #0xc
 801000c: 46bd         	mov	sp, r7
 801000e: bc80         	pop	{r7}
 8010010: 4770         	bx	lr

08010012 <sys_slist_is_empty>:
; Z_GENLIST_IS_EMPTY(slist)
 8010012: b580         	push	{r7, lr}
 8010014: b082         	sub	sp, #0x8
 8010016: af00         	add	r7, sp, #0x0
 8010018: 6078         	str	r0, [r7, #0x4]
 801001a: 6878         	ldr	r0, [r7, #0x4]
 801001c: f7ff ffe3    	bl	0x800ffe6 <sys_slist_peek_head> @ imm = #-0x3a
 8010020: 4603         	mov	r3, r0
 8010022: 2b00         	cmp	r3, #0x0
 8010024: bf0c         	ite	eq
 8010026: 2301         	moveq	r3, #0x1
 8010028: 2300         	movne	r3, #0x0
 801002a: b2db         	uxtb	r3, r3
 801002c: 4618         	mov	r0, r3
 801002e: 3708         	adds	r7, #0x8
 8010030: 46bd         	mov	sp, r7
 8010032: bd80         	pop	{r7, pc}

08010034 <sys_slist_peek_next_no_check>:
; Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
 8010034: b580         	push	{r7, lr}
 8010036: b082         	sub	sp, #0x8
 8010038: af00         	add	r7, sp, #0x0
 801003a: 6078         	str	r0, [r7, #0x4]
 801003c: 6878         	ldr	r0, [r7, #0x4]
 801003e: f7ff ffa0    	bl	0x800ff82 <z_snode_next_peek> @ imm = #-0xc0
 8010042: 4603         	mov	r3, r0
 8010044: 4618         	mov	r0, r3
 8010046: 3708         	adds	r7, #0x8
 8010048: 46bd         	mov	sp, r7
 801004a: bd80         	pop	{r7, pc}

0801004c <sys_slist_peek_next>:
; Z_GENLIST_PEEK_NEXT(slist, snode)
 801004c: b580         	push	{r7, lr}
 801004e: b082         	sub	sp, #0x8
 8010050: af00         	add	r7, sp, #0x0
 8010052: 6078         	str	r0, [r7, #0x4]
 8010054: 687b         	ldr	r3, [r7, #0x4]
 8010056: 2b00         	cmp	r3, #0x0
 8010058: d004         	beq	0x8010064 <sys_slist_peek_next+0x18> @ imm = #0x8
 801005a: 6878         	ldr	r0, [r7, #0x4]
 801005c: f7ff ffea    	bl	0x8010034 <sys_slist_peek_next_no_check> @ imm = #-0x2c
 8010060: 4603         	mov	r3, r0
 8010062: e000         	b	0x8010066 <sys_slist_peek_next+0x1a> @ imm = #0x0
 8010064: 2300         	movs	r3, #0x0
 8010066: 4618         	mov	r0, r3
 8010068: 3708         	adds	r7, #0x8
 801006a: 46bd         	mov	sp, r7
 801006c: bd80         	pop	{r7, pc}

0801006e <sys_slist_prepend>:
; Z_GENLIST_PREPEND(slist, snode)
 801006e: b580         	push	{r7, lr}
 8010070: b082         	sub	sp, #0x8
 8010072: af00         	add	r7, sp, #0x0
 8010074: 6078         	str	r0, [r7, #0x4]
 8010076: 6039         	str	r1, [r7]
 8010078: 6878         	ldr	r0, [r7, #0x4]
 801007a: f7ff ffb4    	bl	0x800ffe6 <sys_slist_peek_head> @ imm = #-0x98
 801007e: 4603         	mov	r3, r0
 8010080: 4619         	mov	r1, r3
 8010082: 6838         	ldr	r0, [r7]
 8010084: f7ff ff88    	bl	0x800ff98 <z_snode_next_set> @ imm = #-0xf0
 8010088: 6839         	ldr	r1, [r7]
 801008a: 6878         	ldr	r0, [r7, #0x4]
 801008c: f7ff ff91    	bl	0x800ffb2 <z_slist_head_set> @ imm = #-0xde
 8010090: 6878         	ldr	r0, [r7, #0x4]
 8010092: f7ff ffb3    	bl	0x800fffc <sys_slist_peek_tail> @ imm = #-0x9a
 8010096: 4603         	mov	r3, r0
 8010098: 2b00         	cmp	r3, #0x0
 801009a: d107         	bne	0x80100ac <sys_slist_prepend+0x3e> @ imm = #0xe
 801009c: 6878         	ldr	r0, [r7, #0x4]
 801009e: f7ff ffa2    	bl	0x800ffe6 <sys_slist_peek_head> @ imm = #-0xbc
 80100a2: 4603         	mov	r3, r0
 80100a4: 4619         	mov	r1, r3
 80100a6: 6878         	ldr	r0, [r7, #0x4]
 80100a8: f7ff ff90    	bl	0x800ffcc <z_slist_tail_set> @ imm = #-0xe0
 80100ac: 3708         	adds	r7, #0x8
 80100ae: 46bd         	mov	sp, r7
 80100b0: bd80         	pop	{r7, pc}

080100b2 <sys_slist_remove>:
; Z_GENLIST_REMOVE(slist, snode)
 80100b2: b580         	push	{r7, lr}
 80100b4: b084         	sub	sp, #0x10
 80100b6: af00         	add	r7, sp, #0x0
 80100b8: 60f8         	str	r0, [r7, #0xc]
 80100ba: 60b9         	str	r1, [r7, #0x8]
 80100bc: 607a         	str	r2, [r7, #0x4]
 80100be: 68bb         	ldr	r3, [r7, #0x8]
 80100c0: 2b00         	cmp	r3, #0x0
 80100c2: d117         	bne	0x80100f4 <sys_slist_remove+0x42> @ imm = #0x2e
 80100c4: 6878         	ldr	r0, [r7, #0x4]
 80100c6: f7ff ff5c    	bl	0x800ff82 <z_snode_next_peek> @ imm = #-0x148
 80100ca: 4603         	mov	r3, r0
 80100cc: 4619         	mov	r1, r3
 80100ce: 68f8         	ldr	r0, [r7, #0xc]
 80100d0: f7ff ff6f    	bl	0x800ffb2 <z_slist_head_set> @ imm = #-0x122
 80100d4: 68f8         	ldr	r0, [r7, #0xc]
 80100d6: f7ff ff91    	bl	0x800fffc <sys_slist_peek_tail> @ imm = #-0xde
 80100da: 4602         	mov	r2, r0
 80100dc: 687b         	ldr	r3, [r7, #0x4]
 80100de: 4293         	cmp	r3, r2
 80100e0: d11b         	bne	0x801011a <sys_slist_remove+0x68> @ imm = #0x36
 80100e2: 68f8         	ldr	r0, [r7, #0xc]
 80100e4: f7ff ff7f    	bl	0x800ffe6 <sys_slist_peek_head> @ imm = #-0x102
 80100e8: 4603         	mov	r3, r0
 80100ea: 4619         	mov	r1, r3
 80100ec: 68f8         	ldr	r0, [r7, #0xc]
 80100ee: f7ff ff6d    	bl	0x800ffcc <z_slist_tail_set> @ imm = #-0x126
 80100f2: e012         	b	0x801011a <sys_slist_remove+0x68> @ imm = #0x24
 80100f4: 6878         	ldr	r0, [r7, #0x4]
 80100f6: f7ff ff44    	bl	0x800ff82 <z_snode_next_peek> @ imm = #-0x178
 80100fa: 4603         	mov	r3, r0
 80100fc: 4619         	mov	r1, r3
 80100fe: 68b8         	ldr	r0, [r7, #0x8]
 8010100: f7ff ff4a    	bl	0x800ff98 <z_snode_next_set> @ imm = #-0x16c
 8010104: 68f8         	ldr	r0, [r7, #0xc]
 8010106: f7ff ff79    	bl	0x800fffc <sys_slist_peek_tail> @ imm = #-0x10e
 801010a: 4602         	mov	r2, r0
 801010c: 687b         	ldr	r3, [r7, #0x4]
 801010e: 4293         	cmp	r3, r2
 8010110: d103         	bne	0x801011a <sys_slist_remove+0x68> @ imm = #0x6
 8010112: 68b9         	ldr	r1, [r7, #0x8]
 8010114: 68f8         	ldr	r0, [r7, #0xc]
 8010116: f7ff ff59    	bl	0x800ffcc <z_slist_tail_set> @ imm = #-0x14e
 801011a: 2100         	movs	r1, #0x0
 801011c: 6878         	ldr	r0, [r7, #0x4]
 801011e: f7ff ff3b    	bl	0x800ff98 <z_snode_next_set> @ imm = #-0x18a
 8010122: 3710         	adds	r7, #0x10
 8010124: 46bd         	mov	sp, r7
 8010126: bd80         	pop	{r7, pc}

08010128 <sys_slist_find_and_remove>:
; Z_GENLIST_FIND_AND_REMOVE(slist, snode)
 8010128: b580         	push	{r7, lr}
 801012a: b084         	sub	sp, #0x10
 801012c: af00         	add	r7, sp, #0x0
 801012e: 6078         	str	r0, [r7, #0x4]
 8010130: 6039         	str	r1, [r7]
 8010132: 2300         	movs	r3, #0x0
 8010134: 60fb         	str	r3, [r7, #0xc]
 8010136: 6878         	ldr	r0, [r7, #0x4]
 8010138: f7ff ff55    	bl	0x800ffe6 <sys_slist_peek_head> @ imm = #-0x156
 801013c: 60b8         	str	r0, [r7, #0x8]
 801013e: e010         	b	0x8010162 <sys_slist_find_and_remove+0x3a> @ imm = #0x20
 8010140: 68ba         	ldr	r2, [r7, #0x8]
 8010142: 683b         	ldr	r3, [r7]
 8010144: 429a         	cmp	r2, r3
 8010146: d106         	bne	0x8010156 <sys_slist_find_and_remove+0x2e> @ imm = #0xc
 8010148: 683a         	ldr	r2, [r7]
 801014a: 68f9         	ldr	r1, [r7, #0xc]
 801014c: 6878         	ldr	r0, [r7, #0x4]
 801014e: f7ff ffb0    	bl	0x80100b2 <sys_slist_remove> @ imm = #-0xa0
 8010152: 2301         	movs	r3, #0x1
 8010154: e009         	b	0x801016a <sys_slist_find_and_remove+0x42> @ imm = #0x12
 8010156: 68bb         	ldr	r3, [r7, #0x8]
 8010158: 60fb         	str	r3, [r7, #0xc]
 801015a: 68b8         	ldr	r0, [r7, #0x8]
 801015c: f7ff ff76    	bl	0x801004c <sys_slist_peek_next> @ imm = #-0x114
 8010160: 60b8         	str	r0, [r7, #0x8]
 8010162: 68bb         	ldr	r3, [r7, #0x8]
 8010164: 2b00         	cmp	r3, #0x0
 8010166: d1eb         	bne	0x8010140 <sys_slist_find_and_remove+0x18> @ imm = #-0x2a
 8010168: 2300         	movs	r3, #0x0
 801016a: 4618         	mov	r0, r3
 801016c: 3710         	adds	r7, #0x10
 801016e: 46bd         	mov	sp, r7
 8010170: bd80         	pop	{r7, pc}

08010172 <device_is_ready>:
; {
 8010172: b580         	push	{r7, lr}
 8010174: b082         	sub	sp, #0x8
 8010176: af00         	add	r7, sp, #0x0
 8010178: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 801017a: 6878         	ldr	r0, [r7, #0x4]
 801017c: f002 fcc9    	bl	0x8012b12 <z_impl_device_is_ready> @ imm = #0x2992
 8010180: 4603         	mov	r3, r0
; }
 8010182: 4618         	mov	r0, r3
 8010184: 3708         	adds	r7, #0x8
 8010186: 46bd         	mov	sp, r7
 8010188: bd80         	pop	{r7, pc}

0801018a <LL_GPIO_SetPinMode>:
; {
 801018a: b480         	push	{r7}
 801018c: b08b         	sub	sp, #0x2c
 801018e: af00         	add	r7, sp, #0x0
 8010190: 60f8         	str	r0, [r7, #0xc]
 8010192: 60b9         	str	r1, [r7, #0x8]
 8010194: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(GPIOx->MODER, (GPIO_MODER_MODER0 << (POSITION_VAL(Pin) * 2U)), (Mode << (POSITION_VAL(Pin) * 2U)));
 8010196: 68fb         	ldr	r3, [r7, #0xc]
 8010198: 681a         	ldr	r2, [r3]
 801019a: 68bb         	ldr	r3, [r7, #0x8]
 801019c: 617b         	str	r3, [r7, #0x14]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 801019e: 697b         	ldr	r3, [r7, #0x14]
 80101a0: fa93 f3a3    	rbit	r3, r3
 80101a4: 613b         	str	r3, [r7, #0x10]
;   return result;
 80101a6: 693b         	ldr	r3, [r7, #0x10]
 80101a8: 61bb         	str	r3, [r7, #0x18]
;   if (value == 0U)
 80101aa: 69bb         	ldr	r3, [r7, #0x18]
 80101ac: 2b00         	cmp	r3, #0x0
 80101ae: d101         	bne	0x80101b4 <LL_GPIO_SetPinMode+0x2a> @ imm = #0x2
;     return 32U;
 80101b0: 2320         	movs	r3, #0x20
 80101b2: e003         	b	0x80101bc <LL_GPIO_SetPinMode+0x32> @ imm = #0x6
;   return __builtin_clz(value);
 80101b4: 69bb         	ldr	r3, [r7, #0x18]
 80101b6: fab3 f383    	clz	r3, r3
 80101ba: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->MODER, (GPIO_MODER_MODER0 << (POSITION_VAL(Pin) * 2U)), (Mode << (POSITION_VAL(Pin) * 2U)));
 80101bc: 005b         	lsls	r3, r3, #0x1
 80101be: 2103         	movs	r1, #0x3
 80101c0: fa01 f303    	lsl.w	r3, r1, r3
 80101c4: 43db         	mvns	r3, r3
 80101c6: 401a         	ands	r2, r3
 80101c8: 68bb         	ldr	r3, [r7, #0x8]
 80101ca: 623b         	str	r3, [r7, #0x20]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80101cc: 6a3b         	ldr	r3, [r7, #0x20]
 80101ce: fa93 f3a3    	rbit	r3, r3
 80101d2: 61fb         	str	r3, [r7, #0x1c]
;   return result;
 80101d4: 69fb         	ldr	r3, [r7, #0x1c]
 80101d6: 627b         	str	r3, [r7, #0x24]
;   if (value == 0U)
 80101d8: 6a7b         	ldr	r3, [r7, #0x24]
 80101da: 2b00         	cmp	r3, #0x0
 80101dc: d101         	bne	0x80101e2 <LL_GPIO_SetPinMode+0x58> @ imm = #0x2
;     return 32U;
 80101de: 2320         	movs	r3, #0x20
 80101e0: e003         	b	0x80101ea <LL_GPIO_SetPinMode+0x60> @ imm = #0x6
;   return __builtin_clz(value);
 80101e2: 6a7b         	ldr	r3, [r7, #0x24]
 80101e4: fab3 f383    	clz	r3, r3
 80101e8: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->MODER, (GPIO_MODER_MODER0 << (POSITION_VAL(Pin) * 2U)), (Mode << (POSITION_VAL(Pin) * 2U)));
 80101ea: 005b         	lsls	r3, r3, #0x1
 80101ec: 6879         	ldr	r1, [r7, #0x4]
 80101ee: fa01 f303    	lsl.w	r3, r1, r3
 80101f2: 431a         	orrs	r2, r3
 80101f4: 68fb         	ldr	r3, [r7, #0xc]
 80101f6: 601a         	str	r2, [r3]
; }
 80101f8: bf00         	nop
 80101fa: 372c         	adds	r7, #0x2c
 80101fc: 46bd         	mov	sp, r7
 80101fe: bc80         	pop	{r7}
 8010200: 4770         	bx	lr

08010202 <LL_GPIO_SetPinOutputType>:
; {
 8010202: b480         	push	{r7}
 8010204: b085         	sub	sp, #0x14
 8010206: af00         	add	r7, sp, #0x0
 8010208: 60f8         	str	r0, [r7, #0xc]
 801020a: 60b9         	str	r1, [r7, #0x8]
 801020c: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(GPIOx->OTYPER, PinMask, (PinMask * OutputType));
 801020e: 68fb         	ldr	r3, [r7, #0xc]
 8010210: 685a         	ldr	r2, [r3, #0x4]
 8010212: 68bb         	ldr	r3, [r7, #0x8]
 8010214: 43db         	mvns	r3, r3
 8010216: 401a         	ands	r2, r3
 8010218: 68bb         	ldr	r3, [r7, #0x8]
 801021a: 6879         	ldr	r1, [r7, #0x4]
 801021c: fb01 f303    	mul	r3, r1, r3
 8010220: 431a         	orrs	r2, r3
 8010222: 68fb         	ldr	r3, [r7, #0xc]
 8010224: 605a         	str	r2, [r3, #0x4]
; }
 8010226: bf00         	nop
 8010228: 3714         	adds	r7, #0x14
 801022a: 46bd         	mov	sp, r7
 801022c: bc80         	pop	{r7}
 801022e: 4770         	bx	lr

08010230 <LL_GPIO_SetPinSpeed>:
; {
 8010230: b480         	push	{r7}
 8010232: b08b         	sub	sp, #0x2c
 8010234: af00         	add	r7, sp, #0x0
 8010236: 60f8         	str	r0, [r7, #0xc]
 8010238: 60b9         	str	r1, [r7, #0x8]
 801023a: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(GPIOx->OSPEEDR, (GPIO_OSPEEDER_OSPEEDR0 << (POSITION_VAL(Pin) * 2U)),
 801023c: 68fb         	ldr	r3, [r7, #0xc]
 801023e: 689a         	ldr	r2, [r3, #0x8]
 8010240: 68bb         	ldr	r3, [r7, #0x8]
 8010242: 617b         	str	r3, [r7, #0x14]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8010244: 697b         	ldr	r3, [r7, #0x14]
 8010246: fa93 f3a3    	rbit	r3, r3
 801024a: 613b         	str	r3, [r7, #0x10]
;   return result;
 801024c: 693b         	ldr	r3, [r7, #0x10]
 801024e: 61bb         	str	r3, [r7, #0x18]
;   if (value == 0U)
 8010250: 69bb         	ldr	r3, [r7, #0x18]
 8010252: 2b00         	cmp	r3, #0x0
 8010254: d101         	bne	0x801025a <LL_GPIO_SetPinSpeed+0x2a> @ imm = #0x2
;     return 32U;
 8010256: 2320         	movs	r3, #0x20
 8010258: e003         	b	0x8010262 <LL_GPIO_SetPinSpeed+0x32> @ imm = #0x6
;   return __builtin_clz(value);
 801025a: 69bb         	ldr	r3, [r7, #0x18]
 801025c: fab3 f383    	clz	r3, r3
 8010260: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->OSPEEDR, (GPIO_OSPEEDER_OSPEEDR0 << (POSITION_VAL(Pin) * 2U)),
 8010262: 005b         	lsls	r3, r3, #0x1
 8010264: 2103         	movs	r1, #0x3
 8010266: fa01 f303    	lsl.w	r3, r1, r3
 801026a: 43db         	mvns	r3, r3
 801026c: 401a         	ands	r2, r3
 801026e: 68bb         	ldr	r3, [r7, #0x8]
 8010270: 623b         	str	r3, [r7, #0x20]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8010272: 6a3b         	ldr	r3, [r7, #0x20]
 8010274: fa93 f3a3    	rbit	r3, r3
 8010278: 61fb         	str	r3, [r7, #0x1c]
;   return result;
 801027a: 69fb         	ldr	r3, [r7, #0x1c]
 801027c: 627b         	str	r3, [r7, #0x24]
;   if (value == 0U)
 801027e: 6a7b         	ldr	r3, [r7, #0x24]
 8010280: 2b00         	cmp	r3, #0x0
 8010282: d101         	bne	0x8010288 <LL_GPIO_SetPinSpeed+0x58> @ imm = #0x2
;     return 32U;
 8010284: 2320         	movs	r3, #0x20
 8010286: e003         	b	0x8010290 <LL_GPIO_SetPinSpeed+0x60> @ imm = #0x6
;   return __builtin_clz(value);
 8010288: 6a7b         	ldr	r3, [r7, #0x24]
 801028a: fab3 f383    	clz	r3, r3
 801028e: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->OSPEEDR, (GPIO_OSPEEDER_OSPEEDR0 << (POSITION_VAL(Pin) * 2U)),
 8010290: 005b         	lsls	r3, r3, #0x1
 8010292: 6879         	ldr	r1, [r7, #0x4]
 8010294: fa01 f303    	lsl.w	r3, r1, r3
 8010298: 431a         	orrs	r2, r3
 801029a: 68fb         	ldr	r3, [r7, #0xc]
 801029c: 609a         	str	r2, [r3, #0x8]
; }
 801029e: bf00         	nop
 80102a0: 372c         	adds	r7, #0x2c
 80102a2: 46bd         	mov	sp, r7
 80102a4: bc80         	pop	{r7}
 80102a6: 4770         	bx	lr

080102a8 <LL_GPIO_SetPinPull>:
; {
 80102a8: b480         	push	{r7}
 80102aa: b08b         	sub	sp, #0x2c
 80102ac: af00         	add	r7, sp, #0x0
 80102ae: 60f8         	str	r0, [r7, #0xc]
 80102b0: 60b9         	str	r1, [r7, #0x8]
 80102b2: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(GPIOx->PUPDR, (GPIO_PUPDR_PUPDR0 << (POSITION_VAL(Pin) * 2U)), (Pull << (POSITION_VAL(Pin) * 2U)));
 80102b4: 68fb         	ldr	r3, [r7, #0xc]
 80102b6: 68da         	ldr	r2, [r3, #0xc]
 80102b8: 68bb         	ldr	r3, [r7, #0x8]
 80102ba: 617b         	str	r3, [r7, #0x14]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80102bc: 697b         	ldr	r3, [r7, #0x14]
 80102be: fa93 f3a3    	rbit	r3, r3
 80102c2: 613b         	str	r3, [r7, #0x10]
;   return result;
 80102c4: 693b         	ldr	r3, [r7, #0x10]
 80102c6: 61bb         	str	r3, [r7, #0x18]
;   if (value == 0U)
 80102c8: 69bb         	ldr	r3, [r7, #0x18]
 80102ca: 2b00         	cmp	r3, #0x0
 80102cc: d101         	bne	0x80102d2 <LL_GPIO_SetPinPull+0x2a> @ imm = #0x2
;     return 32U;
 80102ce: 2320         	movs	r3, #0x20
 80102d0: e003         	b	0x80102da <LL_GPIO_SetPinPull+0x32> @ imm = #0x6
;   return __builtin_clz(value);
 80102d2: 69bb         	ldr	r3, [r7, #0x18]
 80102d4: fab3 f383    	clz	r3, r3
 80102d8: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->PUPDR, (GPIO_PUPDR_PUPDR0 << (POSITION_VAL(Pin) * 2U)), (Pull << (POSITION_VAL(Pin) * 2U)));
 80102da: 005b         	lsls	r3, r3, #0x1
 80102dc: 2103         	movs	r1, #0x3
 80102de: fa01 f303    	lsl.w	r3, r1, r3
 80102e2: 43db         	mvns	r3, r3
 80102e4: 401a         	ands	r2, r3
 80102e6: 68bb         	ldr	r3, [r7, #0x8]
 80102e8: 623b         	str	r3, [r7, #0x20]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80102ea: 6a3b         	ldr	r3, [r7, #0x20]
 80102ec: fa93 f3a3    	rbit	r3, r3
 80102f0: 61fb         	str	r3, [r7, #0x1c]
;   return result;
 80102f2: 69fb         	ldr	r3, [r7, #0x1c]
 80102f4: 627b         	str	r3, [r7, #0x24]
;   if (value == 0U)
 80102f6: 6a7b         	ldr	r3, [r7, #0x24]
 80102f8: 2b00         	cmp	r3, #0x0
 80102fa: d101         	bne	0x8010300 <LL_GPIO_SetPinPull+0x58> @ imm = #0x2
;     return 32U;
 80102fc: 2320         	movs	r3, #0x20
 80102fe: e003         	b	0x8010308 <LL_GPIO_SetPinPull+0x60> @ imm = #0x6
;   return __builtin_clz(value);
 8010300: 6a7b         	ldr	r3, [r7, #0x24]
 8010302: fab3 f383    	clz	r3, r3
 8010306: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->PUPDR, (GPIO_PUPDR_PUPDR0 << (POSITION_VAL(Pin) * 2U)), (Pull << (POSITION_VAL(Pin) * 2U)));
 8010308: 005b         	lsls	r3, r3, #0x1
 801030a: 6879         	ldr	r1, [r7, #0x4]
 801030c: fa01 f303    	lsl.w	r3, r1, r3
 8010310: 431a         	orrs	r2, r3
 8010312: 68fb         	ldr	r3, [r7, #0xc]
 8010314: 60da         	str	r2, [r3, #0xc]
; }
 8010316: bf00         	nop
 8010318: 372c         	adds	r7, #0x2c
 801031a: 46bd         	mov	sp, r7
 801031c: bc80         	pop	{r7}
 801031e: 4770         	bx	lr

08010320 <LL_GPIO_SetAFPin_0_7>:
; {
 8010320: b480         	push	{r7}
 8010322: b08b         	sub	sp, #0x2c
 8010324: af00         	add	r7, sp, #0x0
 8010326: 60f8         	str	r0, [r7, #0xc]
 8010328: 60b9         	str	r1, [r7, #0x8]
 801032a: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(GPIOx->AFR[0], (GPIO_AFRL_AFSEL0 << (POSITION_VAL(Pin) * 4U)),
 801032c: 68fb         	ldr	r3, [r7, #0xc]
 801032e: 6a1a         	ldr	r2, [r3, #0x20]
 8010330: 68bb         	ldr	r3, [r7, #0x8]
 8010332: 617b         	str	r3, [r7, #0x14]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8010334: 697b         	ldr	r3, [r7, #0x14]
 8010336: fa93 f3a3    	rbit	r3, r3
 801033a: 613b         	str	r3, [r7, #0x10]
;   return result;
 801033c: 693b         	ldr	r3, [r7, #0x10]
 801033e: 61bb         	str	r3, [r7, #0x18]
;   if (value == 0U)
 8010340: 69bb         	ldr	r3, [r7, #0x18]
 8010342: 2b00         	cmp	r3, #0x0
 8010344: d101         	bne	0x801034a <LL_GPIO_SetAFPin_0_7+0x2a> @ imm = #0x2
;     return 32U;
 8010346: 2320         	movs	r3, #0x20
 8010348: e003         	b	0x8010352 <LL_GPIO_SetAFPin_0_7+0x32> @ imm = #0x6
;   return __builtin_clz(value);
 801034a: 69bb         	ldr	r3, [r7, #0x18]
 801034c: fab3 f383    	clz	r3, r3
 8010350: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->AFR[0], (GPIO_AFRL_AFSEL0 << (POSITION_VAL(Pin) * 4U)),
 8010352: 009b         	lsls	r3, r3, #0x2
 8010354: 210f         	movs	r1, #0xf
 8010356: fa01 f303    	lsl.w	r3, r1, r3
 801035a: 43db         	mvns	r3, r3
 801035c: 401a         	ands	r2, r3
 801035e: 68bb         	ldr	r3, [r7, #0x8]
 8010360: 623b         	str	r3, [r7, #0x20]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8010362: 6a3b         	ldr	r3, [r7, #0x20]
 8010364: fa93 f3a3    	rbit	r3, r3
 8010368: 61fb         	str	r3, [r7, #0x1c]
;   return result;
 801036a: 69fb         	ldr	r3, [r7, #0x1c]
 801036c: 627b         	str	r3, [r7, #0x24]
;   if (value == 0U)
 801036e: 6a7b         	ldr	r3, [r7, #0x24]
 8010370: 2b00         	cmp	r3, #0x0
 8010372: d101         	bne	0x8010378 <LL_GPIO_SetAFPin_0_7+0x58> @ imm = #0x2
;     return 32U;
 8010374: 2320         	movs	r3, #0x20
 8010376: e003         	b	0x8010380 <LL_GPIO_SetAFPin_0_7+0x60> @ imm = #0x6
;   return __builtin_clz(value);
 8010378: 6a7b         	ldr	r3, [r7, #0x24]
 801037a: fab3 f383    	clz	r3, r3
 801037e: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->AFR[0], (GPIO_AFRL_AFSEL0 << (POSITION_VAL(Pin) * 4U)),
 8010380: 009b         	lsls	r3, r3, #0x2
 8010382: 6879         	ldr	r1, [r7, #0x4]
 8010384: fa01 f303    	lsl.w	r3, r1, r3
 8010388: 431a         	orrs	r2, r3
 801038a: 68fb         	ldr	r3, [r7, #0xc]
 801038c: 621a         	str	r2, [r3, #0x20]
; }
 801038e: bf00         	nop
 8010390: 372c         	adds	r7, #0x2c
 8010392: 46bd         	mov	sp, r7
 8010394: bc80         	pop	{r7}
 8010396: 4770         	bx	lr

08010398 <LL_GPIO_SetAFPin_8_15>:
; {
 8010398: b480         	push	{r7}
 801039a: b08b         	sub	sp, #0x2c
 801039c: af00         	add	r7, sp, #0x0
 801039e: 60f8         	str	r0, [r7, #0xc]
 80103a0: 60b9         	str	r1, [r7, #0x8]
 80103a2: 607a         	str	r2, [r7, #0x4]
;   MODIFY_REG(GPIOx->AFR[1], (GPIO_AFRH_AFSEL8 << (POSITION_VAL(Pin >> 8U) * 4U)),
 80103a4: 68fb         	ldr	r3, [r7, #0xc]
 80103a6: 6a5a         	ldr	r2, [r3, #0x24]
 80103a8: 68bb         	ldr	r3, [r7, #0x8]
 80103aa: 0a1b         	lsrs	r3, r3, #0x8
 80103ac: 617b         	str	r3, [r7, #0x14]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80103ae: 697b         	ldr	r3, [r7, #0x14]
 80103b0: fa93 f3a3    	rbit	r3, r3
 80103b4: 613b         	str	r3, [r7, #0x10]
;   return result;
 80103b6: 693b         	ldr	r3, [r7, #0x10]
 80103b8: 61bb         	str	r3, [r7, #0x18]
;   if (value == 0U)
 80103ba: 69bb         	ldr	r3, [r7, #0x18]
 80103bc: 2b00         	cmp	r3, #0x0
 80103be: d101         	bne	0x80103c4 <LL_GPIO_SetAFPin_8_15+0x2c> @ imm = #0x2
;     return 32U;
 80103c0: 2320         	movs	r3, #0x20
 80103c2: e003         	b	0x80103cc <LL_GPIO_SetAFPin_8_15+0x34> @ imm = #0x6
;   return __builtin_clz(value);
 80103c4: 69bb         	ldr	r3, [r7, #0x18]
 80103c6: fab3 f383    	clz	r3, r3
 80103ca: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->AFR[1], (GPIO_AFRH_AFSEL8 << (POSITION_VAL(Pin >> 8U) * 4U)),
 80103cc: 009b         	lsls	r3, r3, #0x2
 80103ce: 210f         	movs	r1, #0xf
 80103d0: fa01 f303    	lsl.w	r3, r1, r3
 80103d4: 43db         	mvns	r3, r3
 80103d6: 401a         	ands	r2, r3
 80103d8: 68bb         	ldr	r3, [r7, #0x8]
 80103da: 0a1b         	lsrs	r3, r3, #0x8
 80103dc: 623b         	str	r3, [r7, #0x20]
;    __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80103de: 6a3b         	ldr	r3, [r7, #0x20]
 80103e0: fa93 f3a3    	rbit	r3, r3
 80103e4: 61fb         	str	r3, [r7, #0x1c]
;   return result;
 80103e6: 69fb         	ldr	r3, [r7, #0x1c]
 80103e8: 627b         	str	r3, [r7, #0x24]
;   if (value == 0U)
 80103ea: 6a7b         	ldr	r3, [r7, #0x24]
 80103ec: 2b00         	cmp	r3, #0x0
 80103ee: d101         	bne	0x80103f4 <LL_GPIO_SetAFPin_8_15+0x5c> @ imm = #0x2
;     return 32U;
 80103f0: 2320         	movs	r3, #0x20
 80103f2: e003         	b	0x80103fc <LL_GPIO_SetAFPin_8_15+0x64> @ imm = #0x6
;   return __builtin_clz(value);
 80103f4: 6a7b         	ldr	r3, [r7, #0x24]
 80103f6: fab3 f383    	clz	r3, r3
 80103fa: b2db         	uxtb	r3, r3
;   MODIFY_REG(GPIOx->AFR[1], (GPIO_AFRH_AFSEL8 << (POSITION_VAL(Pin >> 8U) * 4U)),
 80103fc: 009b         	lsls	r3, r3, #0x2
 80103fe: 6879         	ldr	r1, [r7, #0x4]
 8010400: fa01 f303    	lsl.w	r3, r1, r3
 8010404: 431a         	orrs	r2, r3
 8010406: 68fb         	ldr	r3, [r7, #0xc]
 8010408: 625a         	str	r2, [r3, #0x24]
; }
 801040a: bf00         	nop
 801040c: 372c         	adds	r7, #0x2c
 801040e: 46bd         	mov	sp, r7
 8010410: bc80         	pop	{r7}
 8010412: 4770         	bx	lr

08010414 <LL_GPIO_ReadInputPort>:
; {
 8010414: b480         	push	{r7}
 8010416: b083         	sub	sp, #0xc
 8010418: af00         	add	r7, sp, #0x0
 801041a: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_REG(GPIOx->IDR));
 801041c: 687b         	ldr	r3, [r7, #0x4]
 801041e: 691b         	ldr	r3, [r3, #0x10]
; }
 8010420: 4618         	mov	r0, r3
 8010422: 370c         	adds	r7, #0xc
 8010424: 46bd         	mov	sp, r7
 8010426: bc80         	pop	{r7}
 8010428: 4770         	bx	lr

0801042a <LL_GPIO_WriteOutputPort>:
; {
 801042a: b480         	push	{r7}
 801042c: b083         	sub	sp, #0xc
 801042e: af00         	add	r7, sp, #0x0
 8010430: 6078         	str	r0, [r7, #0x4]
 8010432: 6039         	str	r1, [r7]
;   WRITE_REG(GPIOx->ODR, PortValue);
 8010434: 687b         	ldr	r3, [r7, #0x4]
 8010436: 683a         	ldr	r2, [r7]
 8010438: 615a         	str	r2, [r3, #0x14]
; }
 801043a: bf00         	nop
 801043c: 370c         	adds	r7, #0xc
 801043e: 46bd         	mov	sp, r7
 8010440: bc80         	pop	{r7}
 8010442: 4770         	bx	lr

08010444 <LL_GPIO_ReadOutputPort>:
; {
 8010444: b480         	push	{r7}
 8010446: b083         	sub	sp, #0xc
 8010448: af00         	add	r7, sp, #0x0
 801044a: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_REG(GPIOx->ODR));
 801044c: 687b         	ldr	r3, [r7, #0x4]
 801044e: 695b         	ldr	r3, [r3, #0x14]
; }
 8010450: 4618         	mov	r0, r3
 8010452: 370c         	adds	r7, #0xc
 8010454: 46bd         	mov	sp, r7
 8010456: bc80         	pop	{r7}
 8010458: 4770         	bx	lr

0801045a <LL_GPIO_ResetOutputPin>:
; {
 801045a: b480         	push	{r7}
 801045c: b083         	sub	sp, #0xc
 801045e: af00         	add	r7, sp, #0x0
 8010460: 6078         	str	r0, [r7, #0x4]
 8010462: 6039         	str	r1, [r7]
;   WRITE_REG(GPIOx->BSRR, (PinMask << 16));
 8010464: 683b         	ldr	r3, [r7]
 8010466: 041a         	lsls	r2, r3, #0x10
 8010468: 687b         	ldr	r3, [r7, #0x4]
 801046a: 619a         	str	r2, [r3, #0x18]
; }
 801046c: bf00         	nop
 801046e: 370c         	adds	r7, #0xc
 8010470: 46bd         	mov	sp, r7
 8010472: bc80         	pop	{r7}
 8010474: 4770         	bx	lr

08010476 <clock_control_on>:
; {
 8010476: b580         	push	{r7, lr}
 8010478: b084         	sub	sp, #0x10
 801047a: af00         	add	r7, sp, #0x0
 801047c: 6078         	str	r0, [r7, #0x4]
 801047e: 6039         	str	r1, [r7]
; 	const struct clock_control_driver_api *api =
 8010480: 687b         	ldr	r3, [r7, #0x4]
 8010482: 689b         	ldr	r3, [r3, #0x8]
 8010484: 60fb         	str	r3, [r7, #0xc]
; 	return api->on(dev, sys);
 8010486: 68fb         	ldr	r3, [r7, #0xc]
 8010488: 681b         	ldr	r3, [r3]
 801048a: 6839         	ldr	r1, [r7]
 801048c: 6878         	ldr	r0, [r7, #0x4]
 801048e: 4798         	blx	r3
 8010490: 4603         	mov	r3, r0
; }
 8010492: 4618         	mov	r0, r3
 8010494: 3710         	adds	r7, #0x10
 8010496: 46bd         	mov	sp, r7
 8010498: bd80         	pop	{r7, pc}

0801049a <clock_control_off>:
; {
 801049a: b580         	push	{r7, lr}
 801049c: b084         	sub	sp, #0x10
 801049e: af00         	add	r7, sp, #0x0
 80104a0: 6078         	str	r0, [r7, #0x4]
 80104a2: 6039         	str	r1, [r7]
; 	const struct clock_control_driver_api *api =
 80104a4: 687b         	ldr	r3, [r7, #0x4]
 80104a6: 689b         	ldr	r3, [r3, #0x8]
 80104a8: 60fb         	str	r3, [r7, #0xc]
; 	return api->off(dev, sys);
 80104aa: 68fb         	ldr	r3, [r7, #0xc]
 80104ac: 685b         	ldr	r3, [r3, #0x4]
 80104ae: 6839         	ldr	r1, [r7]
 80104b0: 6878         	ldr	r0, [r7, #0x4]
 80104b2: 4798         	blx	r3
 80104b4: 4603         	mov	r3, r0
; }
 80104b6: 4618         	mov	r0, r3
 80104b8: 3710         	adds	r7, #0x10
 80104ba: 46bd         	mov	sp, r7
 80104bc: bd80         	pop	{r7, pc}

080104be <pm_device_runtime_enable>:
; {
 80104be: b480         	push	{r7}
 80104c0: b083         	sub	sp, #0xc
 80104c2: af00         	add	r7, sp, #0x0
 80104c4: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 80104c6: 2300         	movs	r3, #0x0
; }
 80104c8: 4618         	mov	r0, r3
 80104ca: 370c         	adds	r7, #0xc
 80104cc: 46bd         	mov	sp, r7
 80104ce: bc80         	pop	{r7}
 80104d0: 4770         	bx	lr

080104d2 <pm_device_runtime_get>:
; {
 80104d2: b480         	push	{r7}
 80104d4: b083         	sub	sp, #0xc
 80104d6: af00         	add	r7, sp, #0x0
 80104d8: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 80104da: 2300         	movs	r3, #0x0
; }
 80104dc: 4618         	mov	r0, r3
 80104de: 370c         	adds	r7, #0xc
 80104e0: 46bd         	mov	sp, r7
 80104e2: bc80         	pop	{r7}
 80104e4: 4770         	bx	lr

080104e6 <pm_device_runtime_put>:
; {
 80104e6: b480         	push	{r7}
 80104e8: b083         	sub	sp, #0xc
 80104ea: af00         	add	r7, sp, #0x0
 80104ec: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 80104ee: 2300         	movs	r3, #0x0
; }
 80104f0: 4618         	mov	r0, r3
 80104f2: 370c         	adds	r7, #0xc
 80104f4: 46bd         	mov	sp, r7
 80104f6: bc80         	pop	{r7}
 80104f8: 4770         	bx	lr

080104fa <z_stm32_hsem_lock>:
; {
 80104fa: b480         	push	{r7}
 80104fc: b083         	sub	sp, #0xc
 80104fe: af00         	add	r7, sp, #0x0
 8010500: 6078         	str	r0, [r7, #0x4]
 8010502: 6039         	str	r1, [r7]
; }
 8010504: bf00         	nop
 8010506: 370c         	adds	r7, #0xc
 8010508: 46bd         	mov	sp, r7
 801050a: bc80         	pop	{r7}
 801050c: 4770         	bx	lr

0801050e <z_stm32_hsem_unlock>:
; {
 801050e: b480         	push	{r7}
 8010510: b083         	sub	sp, #0xc
 8010512: af00         	add	r7, sp, #0x0
 8010514: 6078         	str	r0, [r7, #0x4]
; }
 8010516: bf00         	nop
 8010518: 370c         	adds	r7, #0xc
 801051a: 46bd         	mov	sp, r7
 801051c: bc80         	pop	{r7}
 801051e: 4770         	bx	lr

08010520 <gpio_manage_callback>:
; {
 8010520: b580         	push	{r7, lr}
 8010522: b084         	sub	sp, #0x10
 8010524: af00         	add	r7, sp, #0x0
 8010526: 60f8         	str	r0, [r7, #0xc]
 8010528: 60b9         	str	r1, [r7, #0x8]
 801052a: 4613         	mov	r3, r2
 801052c: 71fb         	strb	r3, [r7, #0x7]
; 	if (!sys_slist_is_empty(callbacks)) {
 801052e: 68f8         	ldr	r0, [r7, #0xc]
 8010530: f7ff fd6f    	bl	0x8010012 <sys_slist_is_empty> @ imm = #-0x522
 8010534: 4603         	mov	r3, r0
 8010536: f083 0301    	eor	r3, r3, #0x1
 801053a: b2db         	uxtb	r3, r3
 801053c: 2b00         	cmp	r3, #0x0
 801053e: d013         	beq	0x8010568 <gpio_manage_callback+0x48> @ imm = #0x26
; 		if (!sys_slist_find_and_remove(callbacks, &callback->node)) {
 8010540: 68bb         	ldr	r3, [r7, #0x8]
 8010542: 4619         	mov	r1, r3
 8010544: 68f8         	ldr	r0, [r7, #0xc]
 8010546: f7ff fdef    	bl	0x8010128 <sys_slist_find_and_remove> @ imm = #-0x422
 801054a: 4603         	mov	r3, r0
 801054c: f083 0301    	eor	r3, r3, #0x1
 8010550: b2db         	uxtb	r3, r3
 8010552: 2b00         	cmp	r3, #0x0
 8010554: d011         	beq	0x801057a <gpio_manage_callback+0x5a> @ imm = #0x22
; 			if (!set) {
 8010556: 79fb         	ldrb	r3, [r7, #0x7]
 8010558: f083 0301    	eor	r3, r3, #0x1
 801055c: b2db         	uxtb	r3, r3
 801055e: 2b00         	cmp	r3, #0x0
 8010560: d00b         	beq	0x801057a <gpio_manage_callback+0x5a> @ imm = #0x16
; 				return -EINVAL;
 8010562: f06f 0315    	mvn	r3, #0x15
 8010566: e011         	b	0x801058c <gpio_manage_callback+0x6c> @ imm = #0x22
; 	} else if (!set) {
 8010568: 79fb         	ldrb	r3, [r7, #0x7]
 801056a: f083 0301    	eor	r3, r3, #0x1
 801056e: b2db         	uxtb	r3, r3
 8010570: 2b00         	cmp	r3, #0x0
 8010572: d002         	beq	0x801057a <gpio_manage_callback+0x5a> @ imm = #0x4
; 		return -EINVAL;
 8010574: f06f 0315    	mvn	r3, #0x15
 8010578: e008         	b	0x801058c <gpio_manage_callback+0x6c> @ imm = #0x10
; 	if (set) {
 801057a: 79fb         	ldrb	r3, [r7, #0x7]
 801057c: 2b00         	cmp	r3, #0x0
 801057e: d004         	beq	0x801058a <gpio_manage_callback+0x6a> @ imm = #0x8
; 		sys_slist_prepend(callbacks, &callback->node);
 8010580: 68bb         	ldr	r3, [r7, #0x8]
 8010582: 4619         	mov	r1, r3
 8010584: 68f8         	ldr	r0, [r7, #0xc]
 8010586: f7ff fd72    	bl	0x801006e <sys_slist_prepend> @ imm = #-0x51c
; 	return 0;
 801058a: 2300         	movs	r3, #0x0
; }
 801058c: 4618         	mov	r0, r3
 801058e: 3710         	adds	r7, #0x10
 8010590: 46bd         	mov	sp, r7
 8010592: bd80         	pop	{r7, pc}

08010594 <gpio_fire_callbacks>:
; {
 8010594: b580         	push	{r7, lr}
 8010596: b086         	sub	sp, #0x18
 8010598: af00         	add	r7, sp, #0x0
 801059a: 60f8         	str	r0, [r7, #0xc]
 801059c: 60b9         	str	r1, [r7, #0x8]
 801059e: 607a         	str	r2, [r7, #0x4]
; 	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
 80105a0: 68f8         	ldr	r0, [r7, #0xc]
 80105a2: f7ff fd20    	bl	0x800ffe6 <sys_slist_peek_head> @ imm = #-0x5c0
 80105a6: 4603         	mov	r3, r0
 80105a8: 2b00         	cmp	r3, #0x0
 80105aa: d004         	beq	0x80105b6 <gpio_fire_callbacks+0x22> @ imm = #0x8
 80105ac: 68f8         	ldr	r0, [r7, #0xc]
 80105ae: f7ff fd1a    	bl	0x800ffe6 <sys_slist_peek_head> @ imm = #-0x5cc
 80105b2: 4603         	mov	r3, r0
 80105b4: e000         	b	0x80105b8 <gpio_fire_callbacks+0x24> @ imm = #0x0
 80105b6: 2300         	movs	r3, #0x0
 80105b8: 617b         	str	r3, [r7, #0x14]
 80105ba: 697b         	ldr	r3, [r7, #0x14]
 80105bc: 2b00         	cmp	r3, #0x0
 80105be: d00e         	beq	0x80105de <gpio_fire_callbacks+0x4a> @ imm = #0x1c
 80105c0: 697b         	ldr	r3, [r7, #0x14]
 80105c2: 4618         	mov	r0, r3
 80105c4: f7ff fd42    	bl	0x801004c <sys_slist_peek_next> @ imm = #-0x57c
 80105c8: 4603         	mov	r3, r0
 80105ca: 2b00         	cmp	r3, #0x0
 80105cc: d005         	beq	0x80105da <gpio_fire_callbacks+0x46> @ imm = #0xa
 80105ce: 697b         	ldr	r3, [r7, #0x14]
 80105d0: 4618         	mov	r0, r3
 80105d2: f7ff fd3b    	bl	0x801004c <sys_slist_peek_next> @ imm = #-0x58a
 80105d6: 4603         	mov	r3, r0
 80105d8: e002         	b	0x80105e0 <gpio_fire_callbacks+0x4c> @ imm = #0x4
 80105da: 2300         	movs	r3, #0x0
 80105dc: e000         	b	0x80105e0 <gpio_fire_callbacks+0x4c> @ imm = #0x0
 80105de: 2300         	movs	r3, #0x0
 80105e0: 613b         	str	r3, [r7, #0x10]
 80105e2: e024         	b	0x801062e <gpio_fire_callbacks+0x9a> @ imm = #0x48
; 		if (cb->pin_mask & pins) {
 80105e4: 697b         	ldr	r3, [r7, #0x14]
 80105e6: 689a         	ldr	r2, [r3, #0x8]
 80105e8: 687b         	ldr	r3, [r7, #0x4]
 80105ea: 4013         	ands	r3, r2
 80105ec: 2b00         	cmp	r3, #0x0
 80105ee: d008         	beq	0x8010602 <gpio_fire_callbacks+0x6e> @ imm = #0x10
; 			cb->handler(port, cb, cb->pin_mask & pins);
 80105f0: 697b         	ldr	r3, [r7, #0x14]
 80105f2: 685b         	ldr	r3, [r3, #0x4]
 80105f4: 697a         	ldr	r2, [r7, #0x14]
 80105f6: 6891         	ldr	r1, [r2, #0x8]
 80105f8: 687a         	ldr	r2, [r7, #0x4]
 80105fa: 400a         	ands	r2, r1
 80105fc: 6979         	ldr	r1, [r7, #0x14]
 80105fe: 68b8         	ldr	r0, [r7, #0x8]
 8010600: 4798         	blx	r3
; 	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
 8010602: 693b         	ldr	r3, [r7, #0x10]
 8010604: 617b         	str	r3, [r7, #0x14]
 8010606: 697b         	ldr	r3, [r7, #0x14]
 8010608: 2b00         	cmp	r3, #0x0
 801060a: d00e         	beq	0x801062a <gpio_fire_callbacks+0x96> @ imm = #0x1c
 801060c: 697b         	ldr	r3, [r7, #0x14]
 801060e: 4618         	mov	r0, r3
 8010610: f7ff fd1c    	bl	0x801004c <sys_slist_peek_next> @ imm = #-0x5c8
 8010614: 4603         	mov	r3, r0
 8010616: 2b00         	cmp	r3, #0x0
 8010618: d005         	beq	0x8010626 <gpio_fire_callbacks+0x92> @ imm = #0xa
 801061a: 697b         	ldr	r3, [r7, #0x14]
 801061c: 4618         	mov	r0, r3
 801061e: f7ff fd15    	bl	0x801004c <sys_slist_peek_next> @ imm = #-0x5d6
 8010622: 4603         	mov	r3, r0
 8010624: e002         	b	0x801062c <gpio_fire_callbacks+0x98> @ imm = #0x4
 8010626: 2300         	movs	r3, #0x0
 8010628: e000         	b	0x801062c <gpio_fire_callbacks+0x98> @ imm = #0x0
 801062a: 2300         	movs	r3, #0x0
 801062c: 613b         	str	r3, [r7, #0x10]
 801062e: 697b         	ldr	r3, [r7, #0x14]
 8010630: 2b00         	cmp	r3, #0x0
 8010632: d1d7         	bne	0x80105e4 <gpio_fire_callbacks+0x50> @ imm = #-0x52
; }
 8010634: bf00         	nop
 8010636: bf00         	nop
 8010638: 3718         	adds	r7, #0x18
 801063a: 46bd         	mov	sp, r7
 801063c: bd80         	pop	{r7, pc}

0801063e <gpio_stm32_isr>:
; {
 801063e: b580         	push	{r7, lr}
 8010640: b084         	sub	sp, #0x10
 8010642: af00         	add	r7, sp, #0x0
 8010644: 6078         	str	r0, [r7, #0x4]
 8010646: 6039         	str	r1, [r7]
; 	struct gpio_stm32_data *data = arg;
 8010648: 683b         	ldr	r3, [r7]
 801064a: 60fb         	str	r3, [r7, #0xc]
; 	gpio_fire_callbacks(&data->cb, data->dev, pin);
 801064c: 68fb         	ldr	r3, [r7, #0xc]
 801064e: f103 0008    	add.w	r0, r3, #0x8
 8010652: 68fb         	ldr	r3, [r7, #0xc]
 8010654: 685b         	ldr	r3, [r3, #0x4]
 8010656: 687a         	ldr	r2, [r7, #0x4]
 8010658: 4619         	mov	r1, r3
 801065a: f7ff ff9b    	bl	0x8010594 <gpio_fire_callbacks> @ imm = #-0xca
; }
 801065e: bf00         	nop
 8010660: 3710         	adds	r7, #0x10
 8010662: 46bd         	mov	sp, r7
 8010664: bd80         	pop	{r7, pc}

08010666 <gpio_stm32_flags_to_conf>:
; {
 8010666: b480         	push	{r7}
 8010668: b083         	sub	sp, #0xc
 801066a: af00         	add	r7, sp, #0x0
 801066c: 6078         	str	r0, [r7, #0x4]
 801066e: 6039         	str	r1, [r7]
; 	if ((flags & GPIO_OUTPUT) != 0) {
 8010670: 687b         	ldr	r3, [r7, #0x4]
 8010672: f403 3300    	and	r3, r3, #0x20000
 8010676: 2b00         	cmp	r3, #0x0
 8010678: d032         	beq	0x80106e0 <gpio_stm32_flags_to_conf+0x7a> @ imm = #0x64
; 		*pincfg = STM32_PINCFG_MODE_OUTPUT;
 801067a: 683b         	ldr	r3, [r7]
 801067c: 2210         	movs	r2, #0x10
 801067e: 601a         	str	r2, [r3]
; 		if ((flags & GPIO_SINGLE_ENDED) != 0) {
 8010680: 687b         	ldr	r3, [r7, #0x4]
 8010682: f003 0302    	and	r3, r3, #0x2
 8010686: 2b00         	cmp	r3, #0x0
 8010688: d00e         	beq	0x80106a8 <gpio_stm32_flags_to_conf+0x42> @ imm = #0x1c
; 			if (flags & GPIO_LINE_OPEN_DRAIN) {
 801068a: 687b         	ldr	r3, [r7, #0x4]
 801068c: f003 0304    	and	r3, r3, #0x4
 8010690: 2b00         	cmp	r3, #0x0
 8010692: d006         	beq	0x80106a2 <gpio_stm32_flags_to_conf+0x3c> @ imm = #0xc
; 				*pincfg |= STM32_PINCFG_OPEN_DRAIN;
 8010694: 683b         	ldr	r3, [r7]
 8010696: 681b         	ldr	r3, [r3]
 8010698: f043 0240    	orr	r2, r3, #0x40
 801069c: 683b         	ldr	r3, [r7]
 801069e: 601a         	str	r2, [r3]
 80106a0: e006         	b	0x80106b0 <gpio_stm32_flags_to_conf+0x4a> @ imm = #0xc
; 				return -ENOTSUP;
 80106a2: f06f 0385    	mvn	r3, #0x85
 80106a6: e044         	b	0x8010732 <gpio_stm32_flags_to_conf+0xcc> @ imm = #0x88
; 			*pincfg |= STM32_PINCFG_PUSH_PULL;
 80106a8: 683b         	ldr	r3, [r7]
 80106aa: 681a         	ldr	r2, [r3]
 80106ac: 683b         	ldr	r3, [r7]
 80106ae: 601a         	str	r2, [r3]
; 		if ((flags & GPIO_PULL_UP) != 0) {
 80106b0: 687b         	ldr	r3, [r7, #0x4]
 80106b2: f003 0310    	and	r3, r3, #0x10
 80106b6: 2b00         	cmp	r3, #0x0
 80106b8: d006         	beq	0x80106c8 <gpio_stm32_flags_to_conf+0x62> @ imm = #0xc
; 			*pincfg |= STM32_PINCFG_PULL_UP;
 80106ba: 683b         	ldr	r3, [r7]
 80106bc: 681b         	ldr	r3, [r3]
 80106be: f443 7200    	orr	r2, r3, #0x200
 80106c2: 683b         	ldr	r3, [r7]
 80106c4: 601a         	str	r2, [r3]
 80106c6: e033         	b	0x8010730 <gpio_stm32_flags_to_conf+0xca> @ imm = #0x66
; 		} else if ((flags & GPIO_PULL_DOWN) != 0) {
 80106c8: 687b         	ldr	r3, [r7, #0x4]
 80106ca: f003 0320    	and	r3, r3, #0x20
 80106ce: 2b00         	cmp	r3, #0x0
 80106d0: d02e         	beq	0x8010730 <gpio_stm32_flags_to_conf+0xca> @ imm = #0x5c
; 			*pincfg |= STM32_PINCFG_PULL_DOWN;
 80106d2: 683b         	ldr	r3, [r7]
 80106d4: 681b         	ldr	r3, [r3]
 80106d6: f443 6280    	orr	r2, r3, #0x400
 80106da: 683b         	ldr	r3, [r7]
 80106dc: 601a         	str	r2, [r3]
 80106de: e027         	b	0x8010730 <gpio_stm32_flags_to_conf+0xca> @ imm = #0x4e
; 	} else if  ((flags & GPIO_INPUT) != 0) {
 80106e0: 687b         	ldr	r3, [r7, #0x4]
 80106e2: f403 3380    	and	r3, r3, #0x10000
 80106e6: 2b00         	cmp	r3, #0x0
 80106e8: d01f         	beq	0x801072a <gpio_stm32_flags_to_conf+0xc4> @ imm = #0x3e
; 		*pincfg = STM32_PINCFG_MODE_INPUT;
 80106ea: 683b         	ldr	r3, [r7]
 80106ec: 2200         	movs	r2, #0x0
 80106ee: 601a         	str	r2, [r3]
; 		if ((flags & GPIO_PULL_UP) != 0) {
 80106f0: 687b         	ldr	r3, [r7, #0x4]
 80106f2: f003 0310    	and	r3, r3, #0x10
 80106f6: 2b00         	cmp	r3, #0x0
 80106f8: d006         	beq	0x8010708 <gpio_stm32_flags_to_conf+0xa2> @ imm = #0xc
; 			*pincfg |= STM32_PINCFG_PULL_UP;
 80106fa: 683b         	ldr	r3, [r7]
 80106fc: 681b         	ldr	r3, [r3]
 80106fe: f443 7200    	orr	r2, r3, #0x200
 8010702: 683b         	ldr	r3, [r7]
 8010704: 601a         	str	r2, [r3]
 8010706: e013         	b	0x8010730 <gpio_stm32_flags_to_conf+0xca> @ imm = #0x26
; 		} else if ((flags & GPIO_PULL_DOWN) != 0) {
 8010708: 687b         	ldr	r3, [r7, #0x4]
 801070a: f003 0320    	and	r3, r3, #0x20
 801070e: 2b00         	cmp	r3, #0x0
 8010710: d006         	beq	0x8010720 <gpio_stm32_flags_to_conf+0xba> @ imm = #0xc
; 			*pincfg |= STM32_PINCFG_PULL_DOWN;
 8010712: 683b         	ldr	r3, [r7]
 8010714: 681b         	ldr	r3, [r3]
 8010716: f443 6280    	orr	r2, r3, #0x400
 801071a: 683b         	ldr	r3, [r7]
 801071c: 601a         	str	r2, [r3]
 801071e: e007         	b	0x8010730 <gpio_stm32_flags_to_conf+0xca> @ imm = #0xe
; 			*pincfg |= STM32_PINCFG_FLOATING;
 8010720: 683b         	ldr	r3, [r7]
 8010722: 681a         	ldr	r2, [r3]
 8010724: 683b         	ldr	r3, [r7]
 8010726: 601a         	str	r2, [r3]
 8010728: e002         	b	0x8010730 <gpio_stm32_flags_to_conf+0xca> @ imm = #0x4
; 		*pincfg = STM32_PINCFG_MODE_ANALOG;
 801072a: 683b         	ldr	r3, [r7]
 801072c: 2230         	movs	r2, #0x30
 801072e: 601a         	str	r2, [r3]
; 	return 0;
 8010730: 2300         	movs	r3, #0x0
; }
 8010732: 4618         	mov	r0, r3
 8010734: 370c         	adds	r7, #0xc
 8010736: 46bd         	mov	sp, r7
 8010738: bc80         	pop	{r7}
 801073a: 4770         	bx	lr

0801073c <stm32_pinval_get>:
; {
 801073c: b480         	push	{r7}
 801073e: b085         	sub	sp, #0x14
 8010740: af00         	add	r7, sp, #0x0
 8010742: 4603         	mov	r3, r0
 8010744: 71fb         	strb	r3, [r7, #0x7]
; 	pinval = 1 << pin;
 8010746: 79fb         	ldrb	r3, [r7, #0x7]
 8010748: 2201         	movs	r2, #0x1
 801074a: fa02 f303    	lsl.w	r3, r2, r3
 801074e: 60fb         	str	r3, [r7, #0xc]
; 	return pinval;
 8010750: 68fb         	ldr	r3, [r7, #0xc]
; }
 8010752: 4618         	mov	r0, r3
 8010754: 3714         	adds	r7, #0x14
 8010756: 46bd         	mov	sp, r7
 8010758: bc80         	pop	{r7}
 801075a: 4770         	bx	lr

0801075c <ll_gpio_set_pin_pull>:
; {
 801075c: b580         	push	{r7, lr}
 801075e: b084         	sub	sp, #0x10
 8010760: af00         	add	r7, sp, #0x0
 8010762: 60f8         	str	r0, [r7, #0xc]
 8010764: 60b9         	str	r1, [r7, #0x8]
 8010766: 607a         	str	r2, [r7, #0x4]
; 	LL_GPIO_SetPinPull(GPIOx, Pin, Pull);
 8010768: 687a         	ldr	r2, [r7, #0x4]
 801076a: 68b9         	ldr	r1, [r7, #0x8]
 801076c: 68f8         	ldr	r0, [r7, #0xc]
 801076e: f7ff fd9b    	bl	0x80102a8 <LL_GPIO_SetPinPull> @ imm = #-0x4ca
; }
 8010772: bf00         	nop
 8010774: 3710         	adds	r7, #0x10
 8010776: 46bd         	mov	sp, r7
 8010778: bd80         	pop	{r7, pc}

0801077a <gpio_stm32_disable_pin_irqs>:
; {
 801077a: b580         	push	{r7, lr}
 801077c: b084         	sub	sp, #0x10
 801077e: af00         	add	r7, sp, #0x0
 8010780: 6078         	str	r0, [r7, #0x4]
 8010782: 460b         	mov	r3, r1
 8010784: 70fb         	strb	r3, [r7, #0x3]
; 	if (port != stm32_exti_get_line_src_port(pin)) {
 8010786: 78fb         	ldrb	r3, [r7, #0x3]
 8010788: 4618         	mov	r0, r3
 801078a: f7fe fcdd    	bl	0x800f148 <stm32_exti_get_line_src_port> @ imm = #-0x1646
 801078e: 4602         	mov	r2, r0
 8010790: 687b         	ldr	r3, [r7, #0x4]
 8010792: 4293         	cmp	r3, r2
 8010794: d110         	bne	0x80107b8 <gpio_stm32_disable_pin_irqs+0x3e> @ imm = #0x20
; 	stm32_gpio_irq_line_t irq_line = stm32_gpio_intc_get_pin_irq_line(port, pin);
 8010796: 78fb         	ldrb	r3, [r7, #0x3]
 8010798: 4619         	mov	r1, r3
 801079a: 6878         	ldr	r0, [r7, #0x4]
 801079c: f7fe fc9f    	bl	0x800f0de <stm32_gpio_intc_get_pin_irq_line> @ imm = #-0x16c2
 80107a0: 60f8         	str	r0, [r7, #0xc]
; 	stm32_gpio_intc_disable_line(irq_line);
 80107a2: 68f8         	ldr	r0, [r7, #0xc]
 80107a4: f7fe fcaa    	bl	0x800f0fc <stm32_gpio_intc_disable_line> @ imm = #-0x16ac
; 	stm32_gpio_intc_remove_irq_callback(irq_line);
 80107a8: 68f8         	ldr	r0, [r7, #0xc]
 80107aa: f7f3 f8c3    	bl	0x8003934 <stm32_gpio_intc_remove_irq_callback> @ imm = #-0xce7a
; 	stm32_gpio_intc_select_line_trigger(irq_line, STM32_GPIO_IRQ_TRIG_NONE);
 80107ae: 2100         	movs	r1, #0x0
 80107b0: 68f8         	ldr	r0, [r7, #0xc]
 80107b2: f7f3 f847    	bl	0x8003844 <stm32_gpio_intc_select_line_trigger> @ imm = #-0xcf72
 80107b6: e000         	b	0x80107ba <gpio_stm32_disable_pin_irqs+0x40> @ imm = #0x0
; 		return;
 80107b8: bf00         	nop
; }
 80107ba: 3710         	adds	r7, #0x10
 80107bc: 46bd         	mov	sp, r7
 80107be: bd80         	pop	{r7, pc}

080107c0 <gpio_stm32_configure_raw>:
; {
 80107c0: b580         	push	{r7, lr}
 80107c2: b08c         	sub	sp, #0x30
 80107c4: af00         	add	r7, sp, #0x0
 80107c6: 60f8         	str	r0, [r7, #0xc]
 80107c8: 607a         	str	r2, [r7, #0x4]
 80107ca: 603b         	str	r3, [r7]
 80107cc: 460b         	mov	r3, r1
 80107ce: 72fb         	strb	r3, [r7, #0xb]
; 	const struct gpio_stm32_config *cfg = dev->config;
 80107d0: 68fb         	ldr	r3, [r7, #0xc]
 80107d2: 685b         	ldr	r3, [r3, #0x4]
 80107d4: 62fb         	str	r3, [r7, #0x2c]
; 	GPIO_TypeDef *gpio = (GPIO_TypeDef *)cfg->base;
 80107d6: 6afb         	ldr	r3, [r7, #0x2c]
 80107d8: 685b         	ldr	r3, [r3, #0x4]
 80107da: 62bb         	str	r3, [r7, #0x28]
; 	uint32_t pin_ll = stm32_pinval_get(pin);
 80107dc: 7afb         	ldrb	r3, [r7, #0xb]
 80107de: 4618         	mov	r0, r3
 80107e0: f7ff ffac    	bl	0x801073c <stm32_pinval_get> @ imm = #-0xa8
 80107e4: 6278         	str	r0, [r7, #0x24]
; 	mode = conf & (STM32_MODER_MASK << STM32_MODER_SHIFT);
 80107e6: 687b         	ldr	r3, [r7, #0x4]
 80107e8: f003 0330    	and	r3, r3, #0x30
 80107ec: 623b         	str	r3, [r7, #0x20]
; 	otype = conf & (STM32_OTYPER_MASK << STM32_OTYPER_SHIFT);
 80107ee: 687b         	ldr	r3, [r7, #0x4]
 80107f0: f003 0340    	and	r3, r3, #0x40
 80107f4: 61fb         	str	r3, [r7, #0x1c]
; 	ospeed = conf & (STM32_OSPEEDR_MASK << STM32_OSPEEDR_SHIFT);
 80107f6: 687b         	ldr	r3, [r7, #0x4]
 80107f8: f403 73c0    	and	r3, r3, #0x180
 80107fc: 61bb         	str	r3, [r7, #0x18]
; 	pupd = conf & (STM32_PUPDR_MASK << STM32_PUPDR_SHIFT);
 80107fe: 687b         	ldr	r3, [r7, #0x4]
 8010800: f403 63c0    	and	r3, r3, #0x600
 8010804: 617b         	str	r3, [r7, #0x14]
; 	z_stm32_hsem_lock(CFG_HW_GPIO_SEMID, HSEM_LOCK_DEFAULT_RETRY);
 8010806: f44f 1180    	mov.w	r1, #0x100000
 801080a: 2000         	movs	r0, #0x0
 801080c: f7ff fe75    	bl	0x80104fa <z_stm32_hsem_lock> @ imm = #-0x316
; 	LL_GPIO_SetPinOutputType(gpio, pin_ll, otype >> STM32_OTYPER_SHIFT);
 8010810: 69fb         	ldr	r3, [r7, #0x1c]
 8010812: 099b         	lsrs	r3, r3, #0x6
 8010814: 461a         	mov	r2, r3
 8010816: 6a79         	ldr	r1, [r7, #0x24]
 8010818: 6ab8         	ldr	r0, [r7, #0x28]
 801081a: f7ff fcf2    	bl	0x8010202 <LL_GPIO_SetPinOutputType> @ imm = #-0x61c
; 	LL_GPIO_SetPinSpeed(gpio, pin_ll, ospeed >> STM32_OSPEEDR_SHIFT);
 801081e: 69bb         	ldr	r3, [r7, #0x18]
 8010820: 09db         	lsrs	r3, r3, #0x7
 8010822: 461a         	mov	r2, r3
 8010824: 6a79         	ldr	r1, [r7, #0x24]
 8010826: 6ab8         	ldr	r0, [r7, #0x28]
 8010828: f7ff fd02    	bl	0x8010230 <LL_GPIO_SetPinSpeed> @ imm = #-0x5fc
; 	ll_gpio_set_pin_pull(gpio, pin_ll, pupd >> STM32_PUPDR_SHIFT);
 801082c: 697b         	ldr	r3, [r7, #0x14]
 801082e: 0a5b         	lsrs	r3, r3, #0x9
 8010830: 461a         	mov	r2, r3
 8010832: 6a79         	ldr	r1, [r7, #0x24]
 8010834: 6ab8         	ldr	r0, [r7, #0x28]
 8010836: f7ff ff91    	bl	0x801075c <ll_gpio_set_pin_pull> @ imm = #-0xde
; 	if (mode == STM32_MODER_ALT_MODE) {
 801083a: 6a3b         	ldr	r3, [r7, #0x20]
 801083c: 2b20         	cmp	r3, #0x20
 801083e: d10d         	bne	0x801085c <gpio_stm32_configure_raw+0x9c> @ imm = #0x1a
; 		if (pin < 8) {
 8010840: 7afb         	ldrb	r3, [r7, #0xb]
 8010842: 2b07         	cmp	r3, #0x7
 8010844: d805         	bhi	0x8010852 <gpio_stm32_configure_raw+0x92> @ imm = #0xa
; 			LL_GPIO_SetAFPin_0_7(gpio, pin_ll, func);
 8010846: 683a         	ldr	r2, [r7]
 8010848: 6a79         	ldr	r1, [r7, #0x24]
 801084a: 6ab8         	ldr	r0, [r7, #0x28]
 801084c: f7ff fd68    	bl	0x8010320 <LL_GPIO_SetAFPin_0_7> @ imm = #-0x530
 8010850: e004         	b	0x801085c <gpio_stm32_configure_raw+0x9c> @ imm = #0x8
; 			LL_GPIO_SetAFPin_8_15(gpio, pin_ll, func);
 8010852: 683a         	ldr	r2, [r7]
 8010854: 6a79         	ldr	r1, [r7, #0x24]
 8010856: 6ab8         	ldr	r0, [r7, #0x28]
 8010858: f7ff fd9e    	bl	0x8010398 <LL_GPIO_SetAFPin_8_15> @ imm = #-0x4c4
; 	LL_GPIO_SetPinMode(gpio, pin_ll, mode >> STM32_MODER_SHIFT);
 801085c: 6a3b         	ldr	r3, [r7, #0x20]
 801085e: 091b         	lsrs	r3, r3, #0x4
 8010860: 461a         	mov	r2, r3
 8010862: 6a79         	ldr	r1, [r7, #0x24]
 8010864: 6ab8         	ldr	r0, [r7, #0x28]
 8010866: f7ff fc90    	bl	0x801018a <LL_GPIO_SetPinMode> @ imm = #-0x6e0
; 	z_stm32_hsem_unlock(CFG_HW_GPIO_SEMID);
 801086a: 2000         	movs	r0, #0x0
 801086c: f7ff fe4f    	bl	0x801050e <z_stm32_hsem_unlock> @ imm = #-0x362
; }
 8010870: bf00         	nop
 8010872: 3730         	adds	r7, #0x30
 8010874: 46bd         	mov	sp, r7
 8010876: bd80         	pop	{r7, pc}

08010878 <gpio_stm32_port_get_raw>:
; {
 8010878: b580         	push	{r7, lr}
 801087a: b084         	sub	sp, #0x10
 801087c: af00         	add	r7, sp, #0x0
 801087e: 6078         	str	r0, [r7, #0x4]
 8010880: 6039         	str	r1, [r7]
; 	const struct gpio_stm32_config *cfg = dev->config;
 8010882: 687b         	ldr	r3, [r7, #0x4]
 8010884: 685b         	ldr	r3, [r3, #0x4]
 8010886: 60fb         	str	r3, [r7, #0xc]
; 	GPIO_TypeDef *gpio = (GPIO_TypeDef *)cfg->base;
 8010888: 68fb         	ldr	r3, [r7, #0xc]
 801088a: 685b         	ldr	r3, [r3, #0x4]
 801088c: 60bb         	str	r3, [r7, #0x8]
; 	*value = LL_GPIO_ReadInputPort(gpio);
 801088e: 68b8         	ldr	r0, [r7, #0x8]
 8010890: f7ff fdc0    	bl	0x8010414 <LL_GPIO_ReadInputPort> @ imm = #-0x480
 8010894: 4602         	mov	r2, r0
 8010896: 683b         	ldr	r3, [r7]
 8010898: 601a         	str	r2, [r3]
; 	return 0;
 801089a: 2300         	movs	r3, #0x0
; }
 801089c: 4618         	mov	r0, r3
 801089e: 3710         	adds	r7, #0x10
 80108a0: 46bd         	mov	sp, r7
 80108a2: bd80         	pop	{r7, pc}

080108a4 <gpio_stm32_port_set_masked_raw>:
; {
 80108a4: b580         	push	{r7, lr}
 80108a6: b088         	sub	sp, #0x20
 80108a8: af00         	add	r7, sp, #0x0
 80108aa: 60f8         	str	r0, [r7, #0xc]
 80108ac: 60b9         	str	r1, [r7, #0x8]
 80108ae: 607a         	str	r2, [r7, #0x4]
; 	const struct gpio_stm32_config *cfg = dev->config;
 80108b0: 68fb         	ldr	r3, [r7, #0xc]
 80108b2: 685b         	ldr	r3, [r3, #0x4]
 80108b4: 61fb         	str	r3, [r7, #0x1c]
; 	GPIO_TypeDef *gpio = (GPIO_TypeDef *)cfg->base;
 80108b6: 69fb         	ldr	r3, [r7, #0x1c]
 80108b8: 685b         	ldr	r3, [r3, #0x4]
 80108ba: 61bb         	str	r3, [r7, #0x18]
; 	z_stm32_hsem_lock(CFG_HW_GPIO_SEMID, HSEM_LOCK_DEFAULT_RETRY);
 80108bc: f44f 1180    	mov.w	r1, #0x100000
 80108c0: 2000         	movs	r0, #0x0
 80108c2: f7ff fe1a    	bl	0x80104fa <z_stm32_hsem_lock> @ imm = #-0x3cc
; 	port_value = LL_GPIO_ReadOutputPort(gpio);
 80108c6: 69b8         	ldr	r0, [r7, #0x18]
 80108c8: f7ff fdbc    	bl	0x8010444 <LL_GPIO_ReadOutputPort> @ imm = #-0x488
 80108cc: 6178         	str	r0, [r7, #0x14]
; 	LL_GPIO_WriteOutputPort(gpio, (port_value & ~mask) | (mask & value));
 80108ce: 68bb         	ldr	r3, [r7, #0x8]
 80108d0: 43da         	mvns	r2, r3
 80108d2: 697b         	ldr	r3, [r7, #0x14]
 80108d4: 401a         	ands	r2, r3
 80108d6: 68b9         	ldr	r1, [r7, #0x8]
 80108d8: 687b         	ldr	r3, [r7, #0x4]
 80108da: 400b         	ands	r3, r1
 80108dc: 4313         	orrs	r3, r2
 80108de: 4619         	mov	r1, r3
 80108e0: 69b8         	ldr	r0, [r7, #0x18]
 80108e2: f7ff fda2    	bl	0x801042a <LL_GPIO_WriteOutputPort> @ imm = #-0x4bc
; 	z_stm32_hsem_unlock(CFG_HW_GPIO_SEMID);
 80108e6: 2000         	movs	r0, #0x0
 80108e8: f7ff fe11    	bl	0x801050e <z_stm32_hsem_unlock> @ imm = #-0x3de
; 	return 0;
 80108ec: 2300         	movs	r3, #0x0
; }
 80108ee: 4618         	mov	r0, r3
 80108f0: 3720         	adds	r7, #0x20
 80108f2: 46bd         	mov	sp, r7
 80108f4: bd80         	pop	{r7, pc}

080108f6 <gpio_stm32_port_set_bits_raw>:
; {
 80108f6: b480         	push	{r7}
 80108f8: b085         	sub	sp, #0x14
 80108fa: af00         	add	r7, sp, #0x0
 80108fc: 6078         	str	r0, [r7, #0x4]
 80108fe: 6039         	str	r1, [r7]
; 	const struct gpio_stm32_config *cfg = dev->config;
 8010900: 687b         	ldr	r3, [r7, #0x4]
 8010902: 685b         	ldr	r3, [r3, #0x4]
 8010904: 60fb         	str	r3, [r7, #0xc]
; 	GPIO_TypeDef *gpio = (GPIO_TypeDef *)cfg->base;
 8010906: 68fb         	ldr	r3, [r7, #0xc]
 8010908: 685b         	ldr	r3, [r3, #0x4]
 801090a: 60bb         	str	r3, [r7, #0x8]
; 	WRITE_REG(gpio->BSRR, pins);
 801090c: 68bb         	ldr	r3, [r7, #0x8]
 801090e: 683a         	ldr	r2, [r7]
 8010910: 619a         	str	r2, [r3, #0x18]
; 	return 0;
 8010912: 2300         	movs	r3, #0x0
; }
 8010914: 4618         	mov	r0, r3
 8010916: 3714         	adds	r7, #0x14
 8010918: 46bd         	mov	sp, r7
 801091a: bc80         	pop	{r7}
 801091c: 4770         	bx	lr

0801091e <gpio_stm32_port_clear_bits_raw>:
; {
 801091e: b580         	push	{r7, lr}
 8010920: b084         	sub	sp, #0x10
 8010922: af00         	add	r7, sp, #0x0
 8010924: 6078         	str	r0, [r7, #0x4]
 8010926: 6039         	str	r1, [r7]
; 	const struct gpio_stm32_config *cfg = dev->config;
 8010928: 687b         	ldr	r3, [r7, #0x4]
 801092a: 685b         	ldr	r3, [r3, #0x4]
 801092c: 60fb         	str	r3, [r7, #0xc]
; 	GPIO_TypeDef *gpio = (GPIO_TypeDef *)cfg->base;
 801092e: 68fb         	ldr	r3, [r7, #0xc]
 8010930: 685b         	ldr	r3, [r3, #0x4]
 8010932: 60bb         	str	r3, [r7, #0x8]
; 	LL_GPIO_ResetOutputPin(gpio, pins);
 8010934: 6839         	ldr	r1, [r7]
 8010936: 68b8         	ldr	r0, [r7, #0x8]
 8010938: f7ff fd8f    	bl	0x801045a <LL_GPIO_ResetOutputPin> @ imm = #-0x4e2
; 	return 0;
 801093c: 2300         	movs	r3, #0x0
; }
 801093e: 4618         	mov	r0, r3
 8010940: 3710         	adds	r7, #0x10
 8010942: 46bd         	mov	sp, r7
 8010944: bd80         	pop	{r7, pc}

08010946 <gpio_stm32_port_toggle_bits>:
; {
 8010946: b580         	push	{r7, lr}
 8010948: b084         	sub	sp, #0x10
 801094a: af00         	add	r7, sp, #0x0
 801094c: 6078         	str	r0, [r7, #0x4]
 801094e: 6039         	str	r1, [r7]
; 	const struct gpio_stm32_config *cfg = dev->config;
 8010950: 687b         	ldr	r3, [r7, #0x4]
 8010952: 685b         	ldr	r3, [r3, #0x4]
 8010954: 60fb         	str	r3, [r7, #0xc]
; 	GPIO_TypeDef *gpio = (GPIO_TypeDef *)cfg->base;
 8010956: 68fb         	ldr	r3, [r7, #0xc]
 8010958: 685b         	ldr	r3, [r3, #0x4]
 801095a: 60bb         	str	r3, [r7, #0x8]
; 	z_stm32_hsem_lock(CFG_HW_GPIO_SEMID, HSEM_LOCK_DEFAULT_RETRY);
 801095c: f44f 1180    	mov.w	r1, #0x100000
 8010960: 2000         	movs	r0, #0x0
 8010962: f7ff fdca    	bl	0x80104fa <z_stm32_hsem_lock> @ imm = #-0x46c
; 	WRITE_REG(gpio->ODR, READ_REG(gpio->ODR) ^ pins);
 8010966: 68bb         	ldr	r3, [r7, #0x8]
 8010968: 695a         	ldr	r2, [r3, #0x14]
 801096a: 683b         	ldr	r3, [r7]
 801096c: 405a         	eors	r2, r3
 801096e: 68bb         	ldr	r3, [r7, #0x8]
 8010970: 615a         	str	r2, [r3, #0x14]
; 	z_stm32_hsem_unlock(CFG_HW_GPIO_SEMID);
 8010972: 2000         	movs	r0, #0x0
 8010974: f7ff fdcb    	bl	0x801050e <z_stm32_hsem_unlock> @ imm = #-0x46a
; 	return 0;
 8010978: 2300         	movs	r3, #0x0
; }
 801097a: 4618         	mov	r0, r3
 801097c: 3710         	adds	r7, #0x10
 801097e: 46bd         	mov	sp, r7
 8010980: bd80         	pop	{r7, pc}

08010982 <gpio_stm32_configure>:
; {
 8010982: b580         	push	{r7, lr}
 8010984: b086         	sub	sp, #0x18
 8010986: af00         	add	r7, sp, #0x0
 8010988: 60f8         	str	r0, [r7, #0xc]
 801098a: 607a         	str	r2, [r7, #0x4]
 801098c: 603b         	str	r3, [r7]
 801098e: 460b         	mov	r3, r1
 8010990: 72fb         	strb	r3, [r7, #0xb]
; 	ret = pm_device_runtime_get(dev);
 8010992: 68f8         	ldr	r0, [r7, #0xc]
 8010994: f7ff fd9d    	bl	0x80104d2 <pm_device_runtime_get> @ imm = #-0x4c6
 8010998: 6178         	str	r0, [r7, #0x14]
; 	if (ret < 0) {
 801099a: 697b         	ldr	r3, [r7, #0x14]
 801099c: 2b00         	cmp	r3, #0x0
 801099e: da01         	bge	0x80109a4 <gpio_stm32_configure+0x22> @ imm = #0x2
; 		return ret;
 80109a0: 697b         	ldr	r3, [r7, #0x14]
 80109a2: e028         	b	0x80109f6 <gpio_stm32_configure+0x74> @ imm = #0x50
; 	gpio_stm32_configure_raw(dev, pin, conf, func);
 80109a4: 7af9         	ldrb	r1, [r7, #0xb]
 80109a6: 683b         	ldr	r3, [r7]
 80109a8: 687a         	ldr	r2, [r7, #0x4]
 80109aa: 68f8         	ldr	r0, [r7, #0xc]
 80109ac: f7ff ff08    	bl	0x80107c0 <gpio_stm32_configure_raw> @ imm = #-0x1f0
; 	if (func == IS_GPIO_OUT) {
 80109b0: 683b         	ldr	r3, [r7]
 80109b2: 2b11         	cmp	r3, #0x11
 80109b4: d11b         	bne	0x80109ee <gpio_stm32_configure+0x6c> @ imm = #0x36
; 		uint32_t gpio_out = conf & (STM32_ODR_MASK << STM32_ODR_SHIFT);
 80109b6: 687b         	ldr	r3, [r7, #0x4]
 80109b8: f403 6300    	and	r3, r3, #0x800
 80109bc: 613b         	str	r3, [r7, #0x10]
; 		if (gpio_out == STM32_ODR_1) {
 80109be: 693b         	ldr	r3, [r7, #0x10]
 80109c0: f5b3 6f00    	cmp.w	r3, #0x800
 80109c4: d108         	bne	0x80109d8 <gpio_stm32_configure+0x56> @ imm = #0x10
; 			gpio_stm32_port_set_bits_raw(dev, BIT(pin));
 80109c6: 7afb         	ldrb	r3, [r7, #0xb]
 80109c8: 2201         	movs	r2, #0x1
 80109ca: fa02 f303    	lsl.w	r3, r2, r3
 80109ce: 4619         	mov	r1, r3
 80109d0: 68f8         	ldr	r0, [r7, #0xc]
 80109d2: f7ff ff90    	bl	0x80108f6 <gpio_stm32_port_set_bits_raw> @ imm = #-0xe0
 80109d6: e00a         	b	0x80109ee <gpio_stm32_configure+0x6c> @ imm = #0x14
; 		} else if (gpio_out == STM32_ODR_0) {
 80109d8: 693b         	ldr	r3, [r7, #0x10]
 80109da: 2b00         	cmp	r3, #0x0
 80109dc: d107         	bne	0x80109ee <gpio_stm32_configure+0x6c> @ imm = #0xe
; 			gpio_stm32_port_clear_bits_raw(dev, BIT(pin));
 80109de: 7afb         	ldrb	r3, [r7, #0xb]
 80109e0: 2201         	movs	r2, #0x1
 80109e2: fa02 f303    	lsl.w	r3, r2, r3
 80109e6: 4619         	mov	r1, r3
 80109e8: 68f8         	ldr	r0, [r7, #0xc]
 80109ea: f7ff ff98    	bl	0x801091e <gpio_stm32_port_clear_bits_raw> @ imm = #-0xd0
; 	return pm_device_runtime_put(dev);
 80109ee: 68f8         	ldr	r0, [r7, #0xc]
 80109f0: f7ff fd79    	bl	0x80104e6 <pm_device_runtime_put> @ imm = #-0x50e
 80109f4: 4603         	mov	r3, r0
; }
 80109f6: 4618         	mov	r0, r3
 80109f8: 3718         	adds	r7, #0x18
 80109fa: 46bd         	mov	sp, r7
 80109fc: bd80         	pop	{r7, pc}

080109fe <gpio_stm32_config>:
; {
 80109fe: b580         	push	{r7, lr}
 8010a00: b088         	sub	sp, #0x20
 8010a02: af00         	add	r7, sp, #0x0
 8010a04: 60f8         	str	r0, [r7, #0xc]
 8010a06: 460b         	mov	r3, r1
 8010a08: 607a         	str	r2, [r7, #0x4]
 8010a0a: 72fb         	strb	r3, [r7, #0xb]
; 	struct gpio_stm32_data *data = dev->data;
 8010a0c: 68fb         	ldr	r3, [r7, #0xc]
 8010a0e: 691b         	ldr	r3, [r3, #0x10]
 8010a10: 61fb         	str	r3, [r7, #0x1c]
; 	err = gpio_stm32_flags_to_conf(flags, &pincfg);
 8010a12: f107 0314    	add.w	r3, r7, #0x14
 8010a16: 4619         	mov	r1, r3
 8010a18: 6878         	ldr	r0, [r7, #0x4]
 8010a1a: f7ff fe24    	bl	0x8010666 <gpio_stm32_flags_to_conf> @ imm = #-0x3b8
 8010a1e: 61b8         	str	r0, [r7, #0x18]
; 	if (err != 0) {
 8010a20: 69bb         	ldr	r3, [r7, #0x18]
 8010a22: 2b00         	cmp	r3, #0x0
 8010a24: d001         	beq	0x8010a2a <gpio_stm32_config+0x2c> @ imm = #0x2
; 		return err;
 8010a26: 69bb         	ldr	r3, [r7, #0x18]
 8010a28: e071         	b	0x8010b0e <gpio_stm32_config+0x110> @ imm = #0xe2
; 	if ((((flags & GPIO_OUTPUT) != 0) || ((flags & GPIO_INPUT) != 0)) &&
 8010a2a: 687b         	ldr	r3, [r7, #0x4]
 8010a2c: f403 3300    	and	r3, r3, #0x20000
 8010a30: 2b00         	cmp	r3, #0x0
 8010a32: d104         	bne	0x8010a3e <gpio_stm32_config+0x40> @ imm = #0x8
 8010a34: 687b         	ldr	r3, [r7, #0x4]
 8010a36: f403 3380    	and	r3, r3, #0x10000
 8010a3a: 2b00         	cmp	r3, #0x0
 8010a3c: d01a         	beq	0x8010a74 <gpio_stm32_config+0x76> @ imm = #0x34
; 	    !(data->pin_has_clock_enabled & BIT(pin))) {
 8010a3e: 69fb         	ldr	r3, [r7, #0x1c]
 8010a40: 691a         	ldr	r2, [r3, #0x10]
 8010a42: 7afb         	ldrb	r3, [r7, #0xb]
 8010a44: fa22 f303    	lsr.w	r3, r2, r3
 8010a48: f003 0301    	and	r3, r3, #0x1
; 	if ((((flags & GPIO_OUTPUT) != 0) || ((flags & GPIO_INPUT) != 0)) &&
 8010a4c: 2b00         	cmp	r3, #0x0
 8010a4e: d111         	bne	0x8010a74 <gpio_stm32_config+0x76> @ imm = #0x22
; 		err = pm_device_runtime_get(dev);
 8010a50: 68f8         	ldr	r0, [r7, #0xc]
 8010a52: f7ff fd3e    	bl	0x80104d2 <pm_device_runtime_get> @ imm = #-0x584
 8010a56: 61b8         	str	r0, [r7, #0x18]
; 		if (err < 0) {
 8010a58: 69bb         	ldr	r3, [r7, #0x18]
 8010a5a: 2b00         	cmp	r3, #0x0
 8010a5c: da01         	bge	0x8010a62 <gpio_stm32_config+0x64> @ imm = #0x2
; 			return err;
 8010a5e: 69bb         	ldr	r3, [r7, #0x18]
 8010a60: e055         	b	0x8010b0e <gpio_stm32_config+0x110> @ imm = #0xaa
; 		data->pin_has_clock_enabled |= BIT(pin);
 8010a62: 69fb         	ldr	r3, [r7, #0x1c]
 8010a64: 691a         	ldr	r2, [r3, #0x10]
 8010a66: 7afb         	ldrb	r3, [r7, #0xb]
 8010a68: 2101         	movs	r1, #0x1
 8010a6a: fa01 f303    	lsl.w	r3, r1, r3
 8010a6e: 431a         	orrs	r2, r3
 8010a70: 69fb         	ldr	r3, [r7, #0x1c]
 8010a72: 611a         	str	r2, [r3, #0x10]
; 	if ((flags & GPIO_OUTPUT) != 0) {
 8010a74: 687b         	ldr	r3, [r7, #0x4]
 8010a76: f403 3300    	and	r3, r3, #0x20000
 8010a7a: 2b00         	cmp	r3, #0x0
 8010a7c: d01a         	beq	0x8010ab4 <gpio_stm32_config+0xb6> @ imm = #0x34
; 		if ((flags & GPIO_OUTPUT_INIT_HIGH) != 0) {
 8010a7e: 687b         	ldr	r3, [r7, #0x4]
 8010a80: f403 2300    	and	r3, r3, #0x80000
 8010a84: 2b00         	cmp	r3, #0x0
 8010a86: d008         	beq	0x8010a9a <gpio_stm32_config+0x9c> @ imm = #0x10
; 			gpio_stm32_port_set_bits_raw(dev, BIT(pin));
 8010a88: 7afb         	ldrb	r3, [r7, #0xb]
 8010a8a: 2201         	movs	r2, #0x1
 8010a8c: fa02 f303    	lsl.w	r3, r2, r3
 8010a90: 4619         	mov	r1, r3
 8010a92: 68f8         	ldr	r0, [r7, #0xc]
 8010a94: f7ff ff2f    	bl	0x80108f6 <gpio_stm32_port_set_bits_raw> @ imm = #-0x1a2
 8010a98: e00c         	b	0x8010ab4 <gpio_stm32_config+0xb6> @ imm = #0x18
; 		} else if ((flags & GPIO_OUTPUT_INIT_LOW) != 0) {
 8010a9a: 687b         	ldr	r3, [r7, #0x4]
 8010a9c: f403 2380    	and	r3, r3, #0x40000
 8010aa0: 2b00         	cmp	r3, #0x0
 8010aa2: d007         	beq	0x8010ab4 <gpio_stm32_config+0xb6> @ imm = #0xe
; 			gpio_stm32_port_clear_bits_raw(dev, BIT(pin));
 8010aa4: 7afb         	ldrb	r3, [r7, #0xb]
 8010aa6: 2201         	movs	r2, #0x1
 8010aa8: fa02 f303    	lsl.w	r3, r2, r3
 8010aac: 4619         	mov	r1, r3
 8010aae: 68f8         	ldr	r0, [r7, #0xc]
 8010ab0: f7ff ff35    	bl	0x801091e <gpio_stm32_port_clear_bits_raw> @ imm = #-0x196
; 	gpio_stm32_configure_raw(dev, pin, pincfg, 0);
 8010ab4: 697a         	ldr	r2, [r7, #0x14]
 8010ab6: 7af9         	ldrb	r1, [r7, #0xb]
 8010ab8: 2300         	movs	r3, #0x0
 8010aba: 68f8         	ldr	r0, [r7, #0xc]
 8010abc: f7ff fe80    	bl	0x80107c0 <gpio_stm32_configure_raw> @ imm = #-0x300
; 	if (((flags & GPIO_OUTPUT) == 0) && ((flags & GPIO_INPUT) == 0) &&
 8010ac0: 687b         	ldr	r3, [r7, #0x4]
 8010ac2: f403 3300    	and	r3, r3, #0x20000
 8010ac6: 2b00         	cmp	r3, #0x0
 8010ac8: d120         	bne	0x8010b0c <gpio_stm32_config+0x10e> @ imm = #0x40
 8010aca: 687b         	ldr	r3, [r7, #0x4]
 8010acc: f403 3380    	and	r3, r3, #0x10000
 8010ad0: 2b00         	cmp	r3, #0x0
 8010ad2: d11b         	bne	0x8010b0c <gpio_stm32_config+0x10e> @ imm = #0x36
; 	    (data->pin_has_clock_enabled & BIT(pin))) {
 8010ad4: 69fb         	ldr	r3, [r7, #0x1c]
 8010ad6: 691a         	ldr	r2, [r3, #0x10]
; 	if (((flags & GPIO_OUTPUT) == 0) && ((flags & GPIO_INPUT) == 0) &&
 8010ad8: 7afb         	ldrb	r3, [r7, #0xb]
 8010ada: fa22 f303    	lsr.w	r3, r2, r3
 8010ade: f003 0301    	and	r3, r3, #0x1
 8010ae2: 2b00         	cmp	r3, #0x0
 8010ae4: d012         	beq	0x8010b0c <gpio_stm32_config+0x10e> @ imm = #0x24
; 		err = pm_device_runtime_put(dev);
 8010ae6: 68f8         	ldr	r0, [r7, #0xc]
 8010ae8: f7ff fcfd    	bl	0x80104e6 <pm_device_runtime_put> @ imm = #-0x606
 8010aec: 61b8         	str	r0, [r7, #0x18]
; 		if (err < 0) {
 8010aee: 69bb         	ldr	r3, [r7, #0x18]
 8010af0: 2b00         	cmp	r3, #0x0
 8010af2: da01         	bge	0x8010af8 <gpio_stm32_config+0xfa> @ imm = #0x2
; 			return err;
 8010af4: 69bb         	ldr	r3, [r7, #0x18]
 8010af6: e00a         	b	0x8010b0e <gpio_stm32_config+0x110> @ imm = #0x14
; 		data->pin_has_clock_enabled &= ~BIT(pin);
 8010af8: 69fb         	ldr	r3, [r7, #0x1c]
 8010afa: 691a         	ldr	r2, [r3, #0x10]
 8010afc: 7afb         	ldrb	r3, [r7, #0xb]
 8010afe: 2101         	movs	r1, #0x1
 8010b00: fa01 f303    	lsl.w	r3, r1, r3
 8010b04: 43db         	mvns	r3, r3
 8010b06: 401a         	ands	r2, r3
 8010b08: 69fb         	ldr	r3, [r7, #0x1c]
 8010b0a: 611a         	str	r2, [r3, #0x10]
; 	return 0;
 8010b0c: 2300         	movs	r3, #0x0
; }
 8010b0e: 4618         	mov	r0, r3
 8010b10: 3720         	adds	r7, #0x20
 8010b12: 46bd         	mov	sp, r7
 8010b14: bd80         	pop	{r7, pc}

08010b16 <gpio_stm32_manage_callback>:
; {
 8010b16: b580         	push	{r7, lr}
 8010b18: b086         	sub	sp, #0x18
 8010b1a: af00         	add	r7, sp, #0x0
 8010b1c: 60f8         	str	r0, [r7, #0xc]
 8010b1e: 60b9         	str	r1, [r7, #0x8]
 8010b20: 4613         	mov	r3, r2
 8010b22: 71fb         	strb	r3, [r7, #0x7]
; 	struct gpio_stm32_data *data = dev->data;
 8010b24: 68fb         	ldr	r3, [r7, #0xc]
 8010b26: 691b         	ldr	r3, [r3, #0x10]
 8010b28: 617b         	str	r3, [r7, #0x14]
; 	return gpio_manage_callback(&data->cb, callback, set);
 8010b2a: 697b         	ldr	r3, [r7, #0x14]
 8010b2c: 3308         	adds	r3, #0x8
 8010b2e: 79fa         	ldrb	r2, [r7, #0x7]
 8010b30: 68b9         	ldr	r1, [r7, #0x8]
 8010b32: 4618         	mov	r0, r3
 8010b34: f7ff fcf4    	bl	0x8010520 <gpio_manage_callback> @ imm = #-0x618
 8010b38: 4603         	mov	r3, r0
; }
 8010b3a: 4618         	mov	r0, r3
 8010b3c: 3718         	adds	r7, #0x18
 8010b3e: 46bd         	mov	sp, r7
 8010b40: bd80         	pop	{r7, pc}

08010b42 <pinctrl_lookup_state>:
; {
 8010b42: b480         	push	{r7}
 8010b44: b085         	sub	sp, #0x14
 8010b46: af00         	add	r7, sp, #0x0
 8010b48: 60f8         	str	r0, [r7, #0xc]
 8010b4a: 460b         	mov	r3, r1
 8010b4c: 607a         	str	r2, [r7, #0x4]
 8010b4e: 72fb         	strb	r3, [r7, #0xb]
; 	*state = &config->states[0];
 8010b50: 68fb         	ldr	r3, [r7, #0xc]
 8010b52: 681a         	ldr	r2, [r3]
 8010b54: 687b         	ldr	r3, [r7, #0x4]
 8010b56: 601a         	str	r2, [r3]
; 	while (*state < &config->states[config->state_cnt]) {
 8010b58: e00d         	b	0x8010b76 <pinctrl_lookup_state+0x34> @ imm = #0x1a
; 		if (id == (*state)->id) {
 8010b5a: 687b         	ldr	r3, [r7, #0x4]
 8010b5c: 681b         	ldr	r3, [r3]
 8010b5e: 795b         	ldrb	r3, [r3, #0x5]
 8010b60: 7afa         	ldrb	r2, [r7, #0xb]
 8010b62: 429a         	cmp	r2, r3
 8010b64: d101         	bne	0x8010b6a <pinctrl_lookup_state+0x28> @ imm = #0x2
; 			return 0;
 8010b66: 2300         	movs	r3, #0x0
 8010b68: e011         	b	0x8010b8e <pinctrl_lookup_state+0x4c> @ imm = #0x22
; 		(*state)++;
 8010b6a: 687b         	ldr	r3, [r7, #0x4]
 8010b6c: 681b         	ldr	r3, [r3]
 8010b6e: f103 0208    	add.w	r2, r3, #0x8
 8010b72: 687b         	ldr	r3, [r7, #0x4]
 8010b74: 601a         	str	r2, [r3]
; 	while (*state < &config->states[config->state_cnt]) {
 8010b76: 687b         	ldr	r3, [r7, #0x4]
 8010b78: 681a         	ldr	r2, [r3]
 8010b7a: 68fb         	ldr	r3, [r7, #0xc]
 8010b7c: 6819         	ldr	r1, [r3]
 8010b7e: 68fb         	ldr	r3, [r7, #0xc]
 8010b80: 791b         	ldrb	r3, [r3, #0x4]
 8010b82: 00db         	lsls	r3, r3, #0x3
 8010b84: 440b         	add	r3, r1
 8010b86: 429a         	cmp	r2, r3
 8010b88: d3e7         	blo	0x8010b5a <pinctrl_lookup_state+0x18> @ imm = #-0x32
; 	return -ENOENT;
 8010b8a: f06f 0301    	mvn	r3, #0x1
; }
 8010b8e: 4618         	mov	r0, r3
 8010b90: 3714         	adds	r7, #0x14
 8010b92: 46bd         	mov	sp, r7
 8010b94: bc80         	pop	{r7}
 8010b96: 4770         	bx	lr

08010b98 <device_is_ready>:
; {
 8010b98: b580         	push	{r7, lr}
 8010b9a: b082         	sub	sp, #0x8
 8010b9c: af00         	add	r7, sp, #0x0
 8010b9e: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 8010ba0: 6878         	ldr	r0, [r7, #0x4]
 8010ba2: f001 ffb6    	bl	0x8012b12 <z_impl_device_is_ready> @ imm = #0x1f6c
 8010ba6: 4603         	mov	r3, r0
; }
 8010ba8: 4618         	mov	r0, r3
 8010baa: 3708         	adds	r7, #0x8
 8010bac: 46bd         	mov	sp, r7
 8010bae: bd80         	pop	{r7, pc}

08010bb0 <pinctrl_configure_pins>:
; {
 8010bb0: b580         	push	{r7, lr}
 8010bb2: b08a         	sub	sp, #0x28
 8010bb4: af00         	add	r7, sp, #0x0
 8010bb6: 60f8         	str	r0, [r7, #0xc]
 8010bb8: 460b         	mov	r3, r1
 8010bba: 607a         	str	r2, [r7, #0x4]
 8010bbc: 72fb         	strb	r3, [r7, #0xb]
; 	uint32_t pin_cgf = 0;
 8010bbe: 2300         	movs	r3, #0x0
 8010bc0: 627b         	str	r3, [r7, #0x24]
; 	int ret = 0;
 8010bc2: 2300         	movs	r3, #0x0
 8010bc4: 61fb         	str	r3, [r7, #0x1c]
; 	for (uint8_t i = 0U; i < pin_cnt; i++) {
 8010bc6: 2300         	movs	r3, #0x0
 8010bc8: f887 3023    	strb.w	r3, [r7, #0x23]
 8010bcc: e047         	b	0x8010c5e <pinctrl_configure_pins+0xae> @ imm = #0x8e
; 		mux = pins[i].pinmux;
 8010bce: f897 3023    	ldrb.w	r3, [r7, #0x23]
 8010bd2: 00db         	lsls	r3, r3, #0x3
 8010bd4: 68fa         	ldr	r2, [r7, #0xc]
 8010bd6: 4413         	add	r3, r2
 8010bd8: 681b         	ldr	r3, [r3]
 8010bda: 61bb         	str	r3, [r7, #0x18]
; 		if (STM32_DT_PINMUX_FUNC(mux) < STM32_ANALOG) {
 8010bdc: 69bb         	ldr	r3, [r7, #0x18]
 8010bde: f003 0310    	and	r3, r3, #0x10
 8010be2: 2b00         	cmp	r3, #0x0
 8010be4: d109         	bne	0x8010bfa <pinctrl_configure_pins+0x4a> @ imm = #0x12
; 			pin_cgf = pins[i].pincfg | STM32_MODER_ALT_MODE;
 8010be6: f897 3023    	ldrb.w	r3, [r7, #0x23]
 8010bea: 00db         	lsls	r3, r3, #0x3
 8010bec: 68fa         	ldr	r2, [r7, #0xc]
 8010bee: 4413         	add	r3, r2
 8010bf0: 685b         	ldr	r3, [r3, #0x4]
 8010bf2: f043 0320    	orr	r3, r3, #0x20
 8010bf6: 627b         	str	r3, [r7, #0x24]
 8010bf8: e013         	b	0x8010c22 <pinctrl_configure_pins+0x72> @ imm = #0x26
; 		} else if (STM32_DT_PINMUX_FUNC(mux) == STM32_ANALOG) {
 8010bfa: 69bb         	ldr	r3, [r7, #0x18]
 8010bfc: f003 031f    	and	r3, r3, #0x1f
 8010c00: 2b10         	cmp	r3, #0x10
 8010c02: d102         	bne	0x8010c0a <pinctrl_configure_pins+0x5a> @ imm = #0x4
; 			pin_cgf = STM32_MODER_ANALOG_MODE;
 8010c04: 2330         	movs	r3, #0x30
 8010c06: 627b         	str	r3, [r7, #0x24]
 8010c08: e00b         	b	0x8010c22 <pinctrl_configure_pins+0x72> @ imm = #0x16
; 		} else if (STM32_DT_PINMUX_FUNC(mux) == STM32_GPIO) {
 8010c0a: 69bb         	ldr	r3, [r7, #0x18]
 8010c0c: f003 031f    	and	r3, r3, #0x1f
 8010c10: 2b11         	cmp	r3, #0x11
 8010c12: d106         	bne	0x8010c22 <pinctrl_configure_pins+0x72> @ imm = #0xc
; 			pin_cgf = pins[i].pincfg;
 8010c14: f897 3023    	ldrb.w	r3, [r7, #0x23]
 8010c18: 00db         	lsls	r3, r3, #0x3
 8010c1a: 68fa         	ldr	r2, [r7, #0xc]
 8010c1c: 4413         	add	r3, r2
 8010c1e: 685b         	ldr	r3, [r3, #0x4]
 8010c20: 627b         	str	r3, [r7, #0x24]
; 		pin = STM32PIN(STM32_DT_PINMUX_PORT(mux),
 8010c22: 69bb         	ldr	r3, [r7, #0x18]
 8010c24: 0a5b         	lsrs	r3, r3, #0x9
 8010c26: 011b         	lsls	r3, r3, #0x4
 8010c28: f403 72f8    	and	r2, r3, #0x1f0
 8010c2c: 69bb         	ldr	r3, [r7, #0x18]
 8010c2e: 095b         	lsrs	r3, r3, #0x5
 8010c30: f003 030f    	and	r3, r3, #0xf
 8010c34: 4313         	orrs	r3, r2
 8010c36: 617b         	str	r3, [r7, #0x14]
; 		ret = stm32_pin_configure(pin, pin_cgf, STM32_DT_PINMUX_FUNC(mux));
 8010c38: 69bb         	ldr	r3, [r7, #0x18]
 8010c3a: f003 031f    	and	r3, r3, #0x1f
 8010c3e: 461a         	mov	r2, r3
 8010c40: 6a79         	ldr	r1, [r7, #0x24]
 8010c42: 6978         	ldr	r0, [r7, #0x14]
 8010c44: f7f4 ffce    	bl	0x8005be4 <stm32_pin_configure> @ imm = #-0xb064
 8010c48: 61f8         	str	r0, [r7, #0x1c]
; 		if (ret < 0) {
 8010c4a: 69fb         	ldr	r3, [r7, #0x1c]
 8010c4c: 2b00         	cmp	r3, #0x0
 8010c4e: da01         	bge	0x8010c54 <pinctrl_configure_pins+0xa4> @ imm = #0x2
; 			return ret;
 8010c50: 69fb         	ldr	r3, [r7, #0x1c]
 8010c52: e00a         	b	0x8010c6a <pinctrl_configure_pins+0xba> @ imm = #0x14
; 	for (uint8_t i = 0U; i < pin_cnt; i++) {
 8010c54: f897 3023    	ldrb.w	r3, [r7, #0x23]
 8010c58: 3301         	adds	r3, #0x1
 8010c5a: f887 3023    	strb.w	r3, [r7, #0x23]
 8010c5e: f897 2023    	ldrb.w	r2, [r7, #0x23]
 8010c62: 7afb         	ldrb	r3, [r7, #0xb]
 8010c64: 429a         	cmp	r2, r3
 8010c66: d3b2         	blo	0x8010bce <pinctrl_configure_pins+0x1e> @ imm = #-0x9c
; 	return 0;
 8010c68: 2300         	movs	r3, #0x0
; }
 8010c6a: 4618         	mov	r0, r3
 8010c6c: 3728         	adds	r7, #0x28
 8010c6e: 46bd         	mov	sp, r7
 8010c70: bd80         	pop	{r7, pc}

08010c72 <reset_stm32_status>:
; {
 8010c72: b480         	push	{r7}
 8010c74: b089         	sub	sp, #0x24
 8010c76: af00         	add	r7, sp, #0x0
 8010c78: 60f8         	str	r0, [r7, #0xc]
 8010c7a: 60b9         	str	r1, [r7, #0x8]
 8010c7c: 607a         	str	r2, [r7, #0x4]
; 	const struct reset_stm32_config *config = dev->config;
 8010c7e: 68fb         	ldr	r3, [r7, #0xc]
 8010c80: 685b         	ldr	r3, [r3, #0x4]
 8010c82: 61fb         	str	r3, [r7, #0x1c]
; 	*status = !!sys_test_bit(config->base + STM32_RESET_SET_OFFSET(id),
 8010c84: 69fb         	ldr	r3, [r7, #0x1c]
 8010c86: 681a         	ldr	r2, [r3]
 8010c88: 68bb         	ldr	r3, [r7, #0x8]
 8010c8a: 095b         	lsrs	r3, r3, #0x5
 8010c8c: f3c3 030b    	ubfx	r3, r3, #0x0, #0xc
 8010c90: 441a         	add	r2, r3
 8010c92: 68bb         	ldr	r3, [r7, #0x8]
 8010c94: f003 031f    	and	r3, r3, #0x1f
 8010c98: 61ba         	str	r2, [r7, #0x18]
 8010c9a: 617b         	str	r3, [r7, #0x14]
; 	uint32_t temp = *(volatile uint32_t *)addr;
 8010c9c: 69bb         	ldr	r3, [r7, #0x18]
 8010c9e: 681b         	ldr	r3, [r3]
 8010ca0: 613b         	str	r3, [r7, #0x10]
; 	return temp & (1 << bit);
 8010ca2: 2201         	movs	r2, #0x1
 8010ca4: 697b         	ldr	r3, [r7, #0x14]
 8010ca6: fa02 f303    	lsl.w	r3, r2, r3
 8010caa: 461a         	mov	r2, r3
 8010cac: 693b         	ldr	r3, [r7, #0x10]
 8010cae: 4013         	ands	r3, r2
; 	*status = !!sys_test_bit(config->base + STM32_RESET_SET_OFFSET(id),
 8010cb0: 2b00         	cmp	r3, #0x0
 8010cb2: bf14         	ite	ne
 8010cb4: 2301         	movne	r3, #0x1
 8010cb6: 2300         	moveq	r3, #0x0
 8010cb8: b2db         	uxtb	r3, r3
 8010cba: 461a         	mov	r2, r3
 8010cbc: 687b         	ldr	r3, [r7, #0x4]
 8010cbe: 701a         	strb	r2, [r3]
; 	return 0;
 8010cc0: 2300         	movs	r3, #0x0
; }
 8010cc2: 4618         	mov	r0, r3
 8010cc4: 3724         	adds	r7, #0x24
 8010cc6: 46bd         	mov	sp, r7
 8010cc8: bc80         	pop	{r7}
 8010cca: 4770         	bx	lr

08010ccc <reset_stm32_line_assert>:
; {
 8010ccc: b480         	push	{r7}
 8010cce: b087         	sub	sp, #0x1c
 8010cd0: af00         	add	r7, sp, #0x0
 8010cd2: 6078         	str	r0, [r7, #0x4]
 8010cd4: 6039         	str	r1, [r7]
; 	const struct reset_stm32_config *config = dev->config;
 8010cd6: 687b         	ldr	r3, [r7, #0x4]
 8010cd8: 685b         	ldr	r3, [r3, #0x4]
 8010cda: 617b         	str	r3, [r7, #0x14]
; 	sys_set_bit(config->base + STM32_RESET_SET_OFFSET(id),
 8010cdc: 697b         	ldr	r3, [r7, #0x14]
 8010cde: 681a         	ldr	r2, [r3]
 8010ce0: 683b         	ldr	r3, [r7]
 8010ce2: 095b         	lsrs	r3, r3, #0x5
 8010ce4: f3c3 030b    	ubfx	r3, r3, #0x0, #0xc
 8010ce8: 441a         	add	r2, r3
 8010cea: 683b         	ldr	r3, [r7]
 8010cec: f003 031f    	and	r3, r3, #0x1f
 8010cf0: 613a         	str	r2, [r7, #0x10]
 8010cf2: 60fb         	str	r3, [r7, #0xc]
; 	uint32_t temp = *(volatile uint32_t *)addr;
 8010cf4: 693b         	ldr	r3, [r7, #0x10]
 8010cf6: 681b         	ldr	r3, [r3]
 8010cf8: 60bb         	str	r3, [r7, #0x8]
; 	*(volatile uint32_t *)addr = temp | (1 << bit);
 8010cfa: 2201         	movs	r2, #0x1
 8010cfc: 68fb         	ldr	r3, [r7, #0xc]
 8010cfe: fa02 f303    	lsl.w	r3, r2, r3
 8010d02: 4619         	mov	r1, r3
 8010d04: 693b         	ldr	r3, [r7, #0x10]
 8010d06: 68ba         	ldr	r2, [r7, #0x8]
 8010d08: 430a         	orrs	r2, r1
 8010d0a: 601a         	str	r2, [r3]
; }
 8010d0c: bf00         	nop
; 	return 0;
 8010d0e: 2300         	movs	r3, #0x0
; }
 8010d10: 4618         	mov	r0, r3
 8010d12: 371c         	adds	r7, #0x1c
 8010d14: 46bd         	mov	sp, r7
 8010d16: bc80         	pop	{r7}
 8010d18: 4770         	bx	lr

08010d1a <reset_stm32_line_deassert>:
; {
 8010d1a: b480         	push	{r7}
 8010d1c: b087         	sub	sp, #0x1c
 8010d1e: af00         	add	r7, sp, #0x0
 8010d20: 6078         	str	r0, [r7, #0x4]
 8010d22: 6039         	str	r1, [r7]
; 	const struct reset_stm32_config *config = dev->config;
 8010d24: 687b         	ldr	r3, [r7, #0x4]
 8010d26: 685b         	ldr	r3, [r3, #0x4]
 8010d28: 617b         	str	r3, [r7, #0x14]
; 	sys_clear_bit(config->base + STM32_RESET_SET_OFFSET(id),
 8010d2a: 697b         	ldr	r3, [r7, #0x14]
 8010d2c: 681a         	ldr	r2, [r3]
 8010d2e: 683b         	ldr	r3, [r7]
 8010d30: 095b         	lsrs	r3, r3, #0x5
 8010d32: f3c3 030b    	ubfx	r3, r3, #0x0, #0xc
 8010d36: 441a         	add	r2, r3
 8010d38: 683b         	ldr	r3, [r7]
 8010d3a: f003 031f    	and	r3, r3, #0x1f
 8010d3e: 613a         	str	r2, [r7, #0x10]
 8010d40: 60fb         	str	r3, [r7, #0xc]
; 	uint32_t temp = *(volatile uint32_t *)addr;
 8010d42: 693b         	ldr	r3, [r7, #0x10]
 8010d44: 681b         	ldr	r3, [r3]
 8010d46: 60bb         	str	r3, [r7, #0x8]
; 	*(volatile uint32_t *)addr = temp & ~(1 << bit);
 8010d48: 2201         	movs	r2, #0x1
 8010d4a: 68fb         	ldr	r3, [r7, #0xc]
 8010d4c: fa02 f303    	lsl.w	r3, r2, r3
 8010d50: 43db         	mvns	r3, r3
 8010d52: 4619         	mov	r1, r3
 8010d54: 693b         	ldr	r3, [r7, #0x10]
 8010d56: 68ba         	ldr	r2, [r7, #0x8]
 8010d58: 400a         	ands	r2, r1
 8010d5a: 601a         	str	r2, [r3]
; }
 8010d5c: bf00         	nop
; 	return 0;
 8010d5e: 2300         	movs	r3, #0x0
; }
 8010d60: 4618         	mov	r0, r3
 8010d62: 371c         	adds	r7, #0x1c
 8010d64: 46bd         	mov	sp, r7
 8010d66: bc80         	pop	{r7}
 8010d68: 4770         	bx	lr

08010d6a <reset_stm32_line_toggle>:
; {
 8010d6a: b580         	push	{r7, lr}
 8010d6c: b082         	sub	sp, #0x8
 8010d6e: af00         	add	r7, sp, #0x0
 8010d70: 6078         	str	r0, [r7, #0x4]
 8010d72: 6039         	str	r1, [r7]
; 	reset_stm32_line_assert(dev, id);
 8010d74: 6839         	ldr	r1, [r7]
 8010d76: 6878         	ldr	r0, [r7, #0x4]
 8010d78: f7ff ffa8    	bl	0x8010ccc <reset_stm32_line_assert> @ imm = #-0xb0
; 	reset_stm32_line_deassert(dev, id);
 8010d7c: 6839         	ldr	r1, [r7]
 8010d7e: 6878         	ldr	r0, [r7, #0x4]
 8010d80: f7ff ffcb    	bl	0x8010d1a <reset_stm32_line_deassert> @ imm = #-0x6a
; 	return 0;
 8010d84: 2300         	movs	r3, #0x0
; }
 8010d86: 4618         	mov	r0, r3
 8010d88: 3708         	adds	r7, #0x8
 8010d8a: 46bd         	mov	sp, r7
 8010d8c: bd80         	pop	{r7, pc}

08010d8e <device_is_ready>:
; {
 8010d8e: b580         	push	{r7, lr}
 8010d90: b082         	sub	sp, #0x8
 8010d92: af00         	add	r7, sp, #0x0
 8010d94: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 8010d96: 6878         	ldr	r0, [r7, #0x4]
 8010d98: f001 febb    	bl	0x8012b12 <z_impl_device_is_ready> @ imm = #0x1d76
 8010d9c: 4603         	mov	r3, r0
; }
 8010d9e: 4618         	mov	r0, r3
 8010da0: 3708         	adds	r7, #0x8
 8010da2: 46bd         	mov	sp, r7
 8010da4: bd80         	pop	{r7, pc}

08010da6 <clock_control_on>:
; {
 8010da6: b580         	push	{r7, lr}
 8010da8: b084         	sub	sp, #0x10
 8010daa: af00         	add	r7, sp, #0x0
 8010dac: 6078         	str	r0, [r7, #0x4]
 8010dae: 6039         	str	r1, [r7]
; 	const struct clock_control_driver_api *api =
 8010db0: 687b         	ldr	r3, [r7, #0x4]
 8010db2: 689b         	ldr	r3, [r3, #0x8]
 8010db4: 60fb         	str	r3, [r7, #0xc]
; 	return api->on(dev, sys);
 8010db6: 68fb         	ldr	r3, [r7, #0xc]
 8010db8: 681b         	ldr	r3, [r3]
 8010dba: 6839         	ldr	r1, [r7]
 8010dbc: 6878         	ldr	r0, [r7, #0x4]
 8010dbe: 4798         	blx	r3
 8010dc0: 4603         	mov	r3, r0
; }
 8010dc2: 4618         	mov	r0, r3
 8010dc4: 3710         	adds	r7, #0x10
 8010dc6: 46bd         	mov	sp, r7
 8010dc8: bd80         	pop	{r7, pc}

08010dca <clock_control_get_rate>:
; {
 8010dca: b580         	push	{r7, lr}
 8010dcc: b086         	sub	sp, #0x18
 8010dce: af00         	add	r7, sp, #0x0
 8010dd0: 60f8         	str	r0, [r7, #0xc]
 8010dd2: 60b9         	str	r1, [r7, #0x8]
 8010dd4: 607a         	str	r2, [r7, #0x4]
; 	const struct clock_control_driver_api *api =
 8010dd6: 68fb         	ldr	r3, [r7, #0xc]
 8010dd8: 689b         	ldr	r3, [r3, #0x8]
 8010dda: 617b         	str	r3, [r7, #0x14]
; 	if (api->get_rate == NULL) {
 8010ddc: 697b         	ldr	r3, [r7, #0x14]
 8010dde: 68db         	ldr	r3, [r3, #0xc]
 8010de0: 2b00         	cmp	r3, #0x0
 8010de2: d102         	bne	0x8010dea <clock_control_get_rate+0x20> @ imm = #0x4
; 		return -ENOSYS;
 8010de4: f06f 0357    	mvn	r3, #0x57
 8010de8: e006         	b	0x8010df8 <clock_control_get_rate+0x2e> @ imm = #0xc
; 	return api->get_rate(dev, sys, rate);
 8010dea: 697b         	ldr	r3, [r7, #0x14]
 8010dec: 68db         	ldr	r3, [r3, #0xc]
 8010dee: 687a         	ldr	r2, [r7, #0x4]
 8010df0: 68b9         	ldr	r1, [r7, #0x8]
 8010df2: 68f8         	ldr	r0, [r7, #0xc]
 8010df4: 4798         	blx	r3
 8010df6: 4603         	mov	r3, r0
; }
 8010df8: 4618         	mov	r0, r3
 8010dfa: 3718         	adds	r7, #0x18
 8010dfc: 46bd         	mov	sp, r7
 8010dfe: bd80         	pop	{r7, pc}

08010e00 <pinctrl_apply_state_direct>:
; {
 8010e00: b580         	push	{r7, lr}
 8010e02: b084         	sub	sp, #0x10
 8010e04: af00         	add	r7, sp, #0x0
 8010e06: 6078         	str	r0, [r7, #0x4]
 8010e08: 6039         	str	r1, [r7]
; 	reg = PINCTRL_REG_NONE;
 8010e0a: 2300         	movs	r3, #0x0
 8010e0c: 60fb         	str	r3, [r7, #0xc]
; 	return pinctrl_configure_pins(state->pins, state->pin_cnt, reg);
 8010e0e: 683b         	ldr	r3, [r7]
 8010e10: 6818         	ldr	r0, [r3]
 8010e12: 683b         	ldr	r3, [r7]
 8010e14: 791b         	ldrb	r3, [r3, #0x4]
 8010e16: 68fa         	ldr	r2, [r7, #0xc]
 8010e18: 4619         	mov	r1, r3
 8010e1a: f7ff fec9    	bl	0x8010bb0 <pinctrl_configure_pins> @ imm = #-0x26e
 8010e1e: 4603         	mov	r3, r0
; }
 8010e20: 4618         	mov	r0, r3
 8010e22: 3710         	adds	r7, #0x10
 8010e24: 46bd         	mov	sp, r7
 8010e26: bd80         	pop	{r7, pc}

08010e28 <pinctrl_apply_state>:
; {
 8010e28: b580         	push	{r7, lr}
 8010e2a: b084         	sub	sp, #0x10
 8010e2c: af00         	add	r7, sp, #0x0
 8010e2e: 6078         	str	r0, [r7, #0x4]
 8010e30: 460b         	mov	r3, r1
 8010e32: 70fb         	strb	r3, [r7, #0x3]
; 	ret = pinctrl_lookup_state(config, id, &state);
 8010e34: f107 0208    	add.w	r2, r7, #0x8
 8010e38: 78fb         	ldrb	r3, [r7, #0x3]
 8010e3a: 4619         	mov	r1, r3
 8010e3c: 6878         	ldr	r0, [r7, #0x4]
 8010e3e: f7ff fe80    	bl	0x8010b42 <pinctrl_lookup_state> @ imm = #-0x300
 8010e42: 60f8         	str	r0, [r7, #0xc]
; 	if (ret < 0) {
 8010e44: 68fb         	ldr	r3, [r7, #0xc]
 8010e46: 2b00         	cmp	r3, #0x0
 8010e48: da01         	bge	0x8010e4e <pinctrl_apply_state+0x26> @ imm = #0x2
; 		return ret;
 8010e4a: 68fb         	ldr	r3, [r7, #0xc]
 8010e4c: e005         	b	0x8010e5a <pinctrl_apply_state+0x32> @ imm = #0xa
; 	return pinctrl_apply_state_direct(config, state);
 8010e4e: 68bb         	ldr	r3, [r7, #0x8]
 8010e50: 4619         	mov	r1, r3
 8010e52: 6878         	ldr	r0, [r7, #0x4]
 8010e54: f7ff ffd4    	bl	0x8010e00 <pinctrl_apply_state_direct> @ imm = #-0x58
 8010e58: 4603         	mov	r3, r0
; }
 8010e5a: 4618         	mov	r0, r3
 8010e5c: 3710         	adds	r7, #0x10
 8010e5e: 46bd         	mov	sp, r7
 8010e60: bd80         	pop	{r7, pc}

08010e62 <z_impl_reset_line_toggle>:
; {
 8010e62: b580         	push	{r7, lr}
 8010e64: b084         	sub	sp, #0x10
 8010e66: af00         	add	r7, sp, #0x0
 8010e68: 6078         	str	r0, [r7, #0x4]
 8010e6a: 6039         	str	r1, [r7]
; 	const struct reset_driver_api *api = (const struct reset_driver_api *)dev->api;
 8010e6c: 687b         	ldr	r3, [r7, #0x4]
 8010e6e: 689b         	ldr	r3, [r3, #0x8]
 8010e70: 60fb         	str	r3, [r7, #0xc]
; 	if (api->line_toggle == NULL) {
 8010e72: 68fb         	ldr	r3, [r7, #0xc]
 8010e74: 68db         	ldr	r3, [r3, #0xc]
 8010e76: 2b00         	cmp	r3, #0x0
 8010e78: d102         	bne	0x8010e80 <z_impl_reset_line_toggle+0x1e> @ imm = #0x4
; 		return -ENOSYS;
 8010e7a: f06f 0357    	mvn	r3, #0x57
 8010e7e: e005         	b	0x8010e8c <z_impl_reset_line_toggle+0x2a> @ imm = #0xa
; 	return api->line_toggle(dev, id);
 8010e80: 68fb         	ldr	r3, [r7, #0xc]
 8010e82: 68db         	ldr	r3, [r3, #0xc]
 8010e84: 6839         	ldr	r1, [r7]
 8010e86: 6878         	ldr	r0, [r7, #0x4]
 8010e88: 4798         	blx	r3
 8010e8a: 4603         	mov	r3, r0
; }
 8010e8c: 4618         	mov	r0, r3
 8010e8e: 3710         	adds	r7, #0x10
 8010e90: 46bd         	mov	sp, r7
 8010e92: bd80         	pop	{r7, pc}

08010e94 <reset_line_toggle_dt>:
; {
 8010e94: b580         	push	{r7, lr}
 8010e96: b082         	sub	sp, #0x8
 8010e98: af00         	add	r7, sp, #0x0
 8010e9a: 6078         	str	r0, [r7, #0x4]
; 	return reset_line_toggle(spec->dev, spec->id);
 8010e9c: 687b         	ldr	r3, [r7, #0x4]
 8010e9e: 681a         	ldr	r2, [r3]
 8010ea0: 687b         	ldr	r3, [r7, #0x4]
 8010ea2: 685b         	ldr	r3, [r3, #0x4]
 8010ea4: 4619         	mov	r1, r3
 8010ea6: 4610         	mov	r0, r2
 8010ea8: f000 f805    	bl	0x8010eb6 <reset_line_toggle> @ imm = #0xa
 8010eac: 4603         	mov	r3, r0
; }
 8010eae: 4618         	mov	r0, r3
 8010eb0: 3708         	adds	r7, #0x8
 8010eb2: 46bd         	mov	sp, r7
 8010eb4: bd80         	pop	{r7, pc}

08010eb6 <reset_line_toggle>:
; {
 8010eb6: b580         	push	{r7, lr}
 8010eb8: b082         	sub	sp, #0x8
 8010eba: af00         	add	r7, sp, #0x0
 8010ebc: 6078         	str	r0, [r7, #0x4]
 8010ebe: 6039         	str	r1, [r7]
; 	return z_impl_reset_line_toggle(dev, id);
 8010ec0: 6839         	ldr	r1, [r7]
 8010ec2: 6878         	ldr	r0, [r7, #0x4]
 8010ec4: f7ff ffcd    	bl	0x8010e62 <z_impl_reset_line_toggle> @ imm = #-0x66
 8010ec8: 4603         	mov	r3, r0
; }
 8010eca: 4618         	mov	r0, r3
 8010ecc: 3708         	adds	r7, #0x8
 8010ece: 46bd         	mov	sp, r7
 8010ed0: bd80         	pop	{r7, pc}

08010ed2 <LL_USART_Enable>:
; {
 8010ed2: b480         	push	{r7}
 8010ed4: b083         	sub	sp, #0xc
 8010ed6: af00         	add	r7, sp, #0x0
 8010ed8: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(USARTx->CR1, USART_CR1_UE);
 8010eda: 687b         	ldr	r3, [r7, #0x4]
 8010edc: 68db         	ldr	r3, [r3, #0xc]
 8010ede: f443 5200    	orr	r2, r3, #0x2000
 8010ee2: 687b         	ldr	r3, [r7, #0x4]
 8010ee4: 60da         	str	r2, [r3, #0xc]
; }
 8010ee6: bf00         	nop
 8010ee8: 370c         	adds	r7, #0xc
 8010eea: 46bd         	mov	sp, r7
 8010eec: bc80         	pop	{r7}
 8010eee: 4770         	bx	lr

08010ef0 <LL_USART_Disable>:
; {
 8010ef0: b480         	push	{r7}
 8010ef2: b083         	sub	sp, #0xc
 8010ef4: af00         	add	r7, sp, #0x0
 8010ef6: 6078         	str	r0, [r7, #0x4]
;   CLEAR_BIT(USARTx->CR1, USART_CR1_UE);
 8010ef8: 687b         	ldr	r3, [r7, #0x4]
 8010efa: 68db         	ldr	r3, [r3, #0xc]
 8010efc: f423 5200    	bic	r2, r3, #0x2000
 8010f00: 687b         	ldr	r3, [r7, #0x4]
 8010f02: 60da         	str	r2, [r3, #0xc]
; }
 8010f04: bf00         	nop
 8010f06: 370c         	adds	r7, #0xc
 8010f08: 46bd         	mov	sp, r7
 8010f0a: bc80         	pop	{r7}
 8010f0c: 4770         	bx	lr

08010f0e <LL_USART_SetTransferDirection>:
; {
 8010f0e: b480         	push	{r7}
 8010f10: b089         	sub	sp, #0x24
 8010f12: af00         	add	r7, sp, #0x0
 8010f14: 6078         	str	r0, [r7, #0x4]
 8010f16: 6039         	str	r1, [r7]
;   ATOMIC_MODIFY_REG(USARTx->CR1, USART_CR1_RE | USART_CR1_TE, TransferDirection);
 8010f18: 687b         	ldr	r3, [r7, #0x4]
 8010f1a: 330c         	adds	r3, #0xc
 8010f1c: 60fb         	str	r3, [r7, #0xc]
;    __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
 8010f1e: 68fb         	ldr	r3, [r7, #0xc]
 8010f20: e853 3f00    	ldrex	r3, [r3]
 8010f24: 60bb         	str	r3, [r7, #0x8]
;    return(result);
 8010f26: 68bb         	ldr	r3, [r7, #0x8]
;   ATOMIC_MODIFY_REG(USARTx->CR1, USART_CR1_RE | USART_CR1_TE, TransferDirection);
 8010f28: f023 030c    	bic	r3, r3, #0xc
 8010f2c: 683a         	ldr	r2, [r7]
 8010f2e: 4313         	orrs	r3, r2
 8010f30: 61fb         	str	r3, [r7, #0x1c]
 8010f32: 687b         	ldr	r3, [r7, #0x4]
 8010f34: 330c         	adds	r3, #0xc
 8010f36: 69fa         	ldr	r2, [r7, #0x1c]
 8010f38: 61ba         	str	r2, [r7, #0x18]
 8010f3a: 617b         	str	r3, [r7, #0x14]
;    __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
 8010f3c: 6979         	ldr	r1, [r7, #0x14]
 8010f3e: 69ba         	ldr	r2, [r7, #0x18]
 8010f40: e841 2300    	strex	r3, r2, [r1]
 8010f44: 613b         	str	r3, [r7, #0x10]
;    return(result);
 8010f46: 693b         	ldr	r3, [r7, #0x10]
;   ATOMIC_MODIFY_REG(USARTx->CR1, USART_CR1_RE | USART_CR1_TE, TransferDirection);
 8010f48: 2b00         	cmp	r3, #0x0
 8010f4a: d1e5         	bne	0x8010f18 <LL_USART_SetTransferDirection+0xa> @ imm = #-0x36
; }
 8010f4c: bf00         	nop
 8010f4e: bf00         	nop
 8010f50: 3724         	adds	r7, #0x24
 8010f52: 46bd         	mov	sp, r7
 8010f54: bc80         	pop	{r7}
 8010f56: 4770         	bx	lr

08010f58 <LL_USART_SetParity>:
; {
 8010f58: b480         	push	{r7}
 8010f5a: b083         	sub	sp, #0xc
 8010f5c: af00         	add	r7, sp, #0x0
 8010f5e: 6078         	str	r0, [r7, #0x4]
 8010f60: 6039         	str	r1, [r7]
;   MODIFY_REG(USARTx->CR1, USART_CR1_PS | USART_CR1_PCE, Parity);
 8010f62: 687b         	ldr	r3, [r7, #0x4]
 8010f64: 68db         	ldr	r3, [r3, #0xc]
 8010f66: f423 62c0    	bic	r2, r3, #0x600
 8010f6a: 683b         	ldr	r3, [r7]
 8010f6c: 431a         	orrs	r2, r3
 8010f6e: 687b         	ldr	r3, [r7, #0x4]
 8010f70: 60da         	str	r2, [r3, #0xc]
; }
 8010f72: bf00         	nop
 8010f74: 370c         	adds	r7, #0xc
 8010f76: 46bd         	mov	sp, r7
 8010f78: bc80         	pop	{r7}
 8010f7a: 4770         	bx	lr

08010f7c <LL_USART_GetParity>:
; {
 8010f7c: b480         	push	{r7}
 8010f7e: b083         	sub	sp, #0xc
 8010f80: af00         	add	r7, sp, #0x0
 8010f82: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_BIT(USARTx->CR1, USART_CR1_PS | USART_CR1_PCE));
 8010f84: 687b         	ldr	r3, [r7, #0x4]
 8010f86: 68db         	ldr	r3, [r3, #0xc]
 8010f88: f403 63c0    	and	r3, r3, #0x600
; }
 8010f8c: 4618         	mov	r0, r3
 8010f8e: 370c         	adds	r7, #0xc
 8010f90: 46bd         	mov	sp, r7
 8010f92: bc80         	pop	{r7}
 8010f94: 4770         	bx	lr

08010f96 <LL_USART_SetDataWidth>:
; {
 8010f96: b480         	push	{r7}
 8010f98: b083         	sub	sp, #0xc
 8010f9a: af00         	add	r7, sp, #0x0
 8010f9c: 6078         	str	r0, [r7, #0x4]
 8010f9e: 6039         	str	r1, [r7]
;   MODIFY_REG(USARTx->CR1, USART_CR1_M, DataWidth);
 8010fa0: 687b         	ldr	r3, [r7, #0x4]
 8010fa2: 68db         	ldr	r3, [r3, #0xc]
 8010fa4: f423 5280    	bic	r2, r3, #0x1000
 8010fa8: 683b         	ldr	r3, [r7]
 8010faa: 431a         	orrs	r2, r3
 8010fac: 687b         	ldr	r3, [r7, #0x4]
 8010fae: 60da         	str	r2, [r3, #0xc]
; }
 8010fb0: bf00         	nop
 8010fb2: 370c         	adds	r7, #0xc
 8010fb4: 46bd         	mov	sp, r7
 8010fb6: bc80         	pop	{r7}
 8010fb8: 4770         	bx	lr

08010fba <LL_USART_GetDataWidth>:
; {
 8010fba: b480         	push	{r7}
 8010fbc: b083         	sub	sp, #0xc
 8010fbe: af00         	add	r7, sp, #0x0
 8010fc0: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_BIT(USARTx->CR1, USART_CR1_M));
 8010fc2: 687b         	ldr	r3, [r7, #0x4]
 8010fc4: 68db         	ldr	r3, [r3, #0xc]
 8010fc6: f403 5380    	and	r3, r3, #0x1000
; }
 8010fca: 4618         	mov	r0, r3
 8010fcc: 370c         	adds	r7, #0xc
 8010fce: 46bd         	mov	sp, r7
 8010fd0: bc80         	pop	{r7}
 8010fd2: 4770         	bx	lr

08010fd4 <LL_USART_SetOverSampling>:
; {
 8010fd4: b480         	push	{r7}
 8010fd6: b083         	sub	sp, #0xc
 8010fd8: af00         	add	r7, sp, #0x0
 8010fda: 6078         	str	r0, [r7, #0x4]
 8010fdc: 6039         	str	r1, [r7]
;   MODIFY_REG(USARTx->CR1, USART_CR1_OVER8, OverSampling);
 8010fde: 687b         	ldr	r3, [r7, #0x4]
 8010fe0: 68db         	ldr	r3, [r3, #0xc]
 8010fe2: f423 4200    	bic	r2, r3, #0x8000
 8010fe6: 683b         	ldr	r3, [r7]
 8010fe8: 431a         	orrs	r2, r3
 8010fea: 687b         	ldr	r3, [r7, #0x4]
 8010fec: 60da         	str	r2, [r3, #0xc]
; }
 8010fee: bf00         	nop
 8010ff0: 370c         	adds	r7, #0xc
 8010ff2: 46bd         	mov	sp, r7
 8010ff4: bc80         	pop	{r7}
 8010ff6: 4770         	bx	lr

08010ff8 <LL_USART_SetStopBitsLength>:
; {
 8010ff8: b480         	push	{r7}
 8010ffa: b083         	sub	sp, #0xc
 8010ffc: af00         	add	r7, sp, #0x0
 8010ffe: 6078         	str	r0, [r7, #0x4]
 8011000: 6039         	str	r1, [r7]
;   MODIFY_REG(USARTx->CR2, USART_CR2_STOP, StopBits);
 8011002: 687b         	ldr	r3, [r7, #0x4]
 8011004: 691b         	ldr	r3, [r3, #0x10]
 8011006: f423 5240    	bic	r2, r3, #0x3000
 801100a: 683b         	ldr	r3, [r7]
 801100c: 431a         	orrs	r2, r3
 801100e: 687b         	ldr	r3, [r7, #0x4]
 8011010: 611a         	str	r2, [r3, #0x10]
; }
 8011012: bf00         	nop
 8011014: 370c         	adds	r7, #0xc
 8011016: 46bd         	mov	sp, r7
 8011018: bc80         	pop	{r7}
 801101a: 4770         	bx	lr

0801101c <LL_USART_GetStopBitsLength>:
; {
 801101c: b480         	push	{r7}
 801101e: b083         	sub	sp, #0xc
 8011020: af00         	add	r7, sp, #0x0
 8011022: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_BIT(USARTx->CR2, USART_CR2_STOP));
 8011024: 687b         	ldr	r3, [r7, #0x4]
 8011026: 691b         	ldr	r3, [r3, #0x10]
 8011028: f403 5340    	and	r3, r3, #0x3000
; }
 801102c: 4618         	mov	r0, r3
 801102e: 370c         	adds	r7, #0xc
 8011030: 46bd         	mov	sp, r7
 8011032: bc80         	pop	{r7}
 8011034: 4770         	bx	lr

08011036 <LL_USART_ConfigCharacter>:
; {
 8011036: b480         	push	{r7}
 8011038: b085         	sub	sp, #0x14
 801103a: af00         	add	r7, sp, #0x0
 801103c: 60f8         	str	r0, [r7, #0xc]
 801103e: 60b9         	str	r1, [r7, #0x8]
 8011040: 607a         	str	r2, [r7, #0x4]
 8011042: 603b         	str	r3, [r7]
;   MODIFY_REG(USARTx->CR1, USART_CR1_PS | USART_CR1_PCE | USART_CR1_M, Parity | DataWidth);
 8011044: 68fb         	ldr	r3, [r7, #0xc]
 8011046: 68db         	ldr	r3, [r3, #0xc]
 8011048: f423 52b0    	bic	r2, r3, #0x1600
 801104c: 6879         	ldr	r1, [r7, #0x4]
 801104e: 68bb         	ldr	r3, [r7, #0x8]
 8011050: 430b         	orrs	r3, r1
 8011052: 431a         	orrs	r2, r3
 8011054: 68fb         	ldr	r3, [r7, #0xc]
 8011056: 60da         	str	r2, [r3, #0xc]
;   MODIFY_REG(USARTx->CR2, USART_CR2_STOP, StopBits);
 8011058: 68fb         	ldr	r3, [r7, #0xc]
 801105a: 691b         	ldr	r3, [r3, #0x10]
 801105c: f423 5240    	bic	r2, r3, #0x3000
 8011060: 683b         	ldr	r3, [r7]
 8011062: 431a         	orrs	r2, r3
 8011064: 68fb         	ldr	r3, [r7, #0xc]
 8011066: 611a         	str	r2, [r3, #0x10]
; }
 8011068: bf00         	nop
 801106a: 3714         	adds	r7, #0x14
 801106c: 46bd         	mov	sp, r7
 801106e: bc80         	pop	{r7}
 8011070: 4770         	bx	lr

08011072 <LL_USART_SetHWFlowCtrl>:
; {
 8011072: b480         	push	{r7}
 8011074: b083         	sub	sp, #0xc
 8011076: af00         	add	r7, sp, #0x0
 8011078: 6078         	str	r0, [r7, #0x4]
 801107a: 6039         	str	r1, [r7]
;   MODIFY_REG(USARTx->CR3, USART_CR3_RTSE | USART_CR3_CTSE, HardwareFlowControl);
 801107c: 687b         	ldr	r3, [r7, #0x4]
 801107e: 695b         	ldr	r3, [r3, #0x14]
 8011080: f423 7240    	bic	r2, r3, #0x300
 8011084: 683b         	ldr	r3, [r7]
 8011086: 431a         	orrs	r2, r3
 8011088: 687b         	ldr	r3, [r7, #0x4]
 801108a: 615a         	str	r2, [r3, #0x14]
; }
 801108c: bf00         	nop
 801108e: 370c         	adds	r7, #0xc
 8011090: 46bd         	mov	sp, r7
 8011092: bc80         	pop	{r7}
 8011094: 4770         	bx	lr

08011096 <LL_USART_GetHWFlowCtrl>:
; {
 8011096: b480         	push	{r7}
 8011098: b083         	sub	sp, #0xc
 801109a: af00         	add	r7, sp, #0x0
 801109c: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_BIT(USARTx->CR3, USART_CR3_RTSE | USART_CR3_CTSE));
 801109e: 687b         	ldr	r3, [r7, #0x4]
 80110a0: 695b         	ldr	r3, [r3, #0x14]
 80110a2: f403 7340    	and	r3, r3, #0x300
; }
 80110a6: 4618         	mov	r0, r3
 80110a8: 370c         	adds	r7, #0xc
 80110aa: 46bd         	mov	sp, r7
 80110ac: bc80         	pop	{r7}
 80110ae: 4770         	bx	lr

080110b0 <LL_USART_EnableHalfDuplex>:
; {
 80110b0: b480         	push	{r7}
 80110b2: b083         	sub	sp, #0xc
 80110b4: af00         	add	r7, sp, #0x0
 80110b6: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(USARTx->CR3, USART_CR3_HDSEL);
 80110b8: 687b         	ldr	r3, [r7, #0x4]
 80110ba: 695b         	ldr	r3, [r3, #0x14]
 80110bc: f043 0208    	orr	r2, r3, #0x8
 80110c0: 687b         	ldr	r3, [r7, #0x4]
 80110c2: 615a         	str	r2, [r3, #0x14]
; }
 80110c4: bf00         	nop
 80110c6: 370c         	adds	r7, #0xc
 80110c8: 46bd         	mov	sp, r7
 80110ca: bc80         	pop	{r7}
 80110cc: 4770         	bx	lr

080110ce <LL_USART_IsActiveFlag_PE>:
; {
 80110ce: b480         	push	{r7}
 80110d0: b083         	sub	sp, #0xc
 80110d2: af00         	add	r7, sp, #0x0
 80110d4: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->SR, USART_SR_PE) == (USART_SR_PE));
 80110d6: 687b         	ldr	r3, [r7, #0x4]
 80110d8: 681b         	ldr	r3, [r3]
 80110da: f003 0301    	and	r3, r3, #0x1
 80110de: 2b01         	cmp	r3, #0x1
 80110e0: bf0c         	ite	eq
 80110e2: 2301         	moveq	r3, #0x1
 80110e4: 2300         	movne	r3, #0x0
 80110e6: b2db         	uxtb	r3, r3
; }
 80110e8: 4618         	mov	r0, r3
 80110ea: 370c         	adds	r7, #0xc
 80110ec: 46bd         	mov	sp, r7
 80110ee: bc80         	pop	{r7}
 80110f0: 4770         	bx	lr

080110f2 <LL_USART_IsActiveFlag_FE>:
; {
 80110f2: b480         	push	{r7}
 80110f4: b083         	sub	sp, #0xc
 80110f6: af00         	add	r7, sp, #0x0
 80110f8: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->SR, USART_SR_FE) == (USART_SR_FE));
 80110fa: 687b         	ldr	r3, [r7, #0x4]
 80110fc: 681b         	ldr	r3, [r3]
 80110fe: f003 0302    	and	r3, r3, #0x2
 8011102: 2b02         	cmp	r3, #0x2
 8011104: bf0c         	ite	eq
 8011106: 2301         	moveq	r3, #0x1
 8011108: 2300         	movne	r3, #0x0
 801110a: b2db         	uxtb	r3, r3
; }
 801110c: 4618         	mov	r0, r3
 801110e: 370c         	adds	r7, #0xc
 8011110: 46bd         	mov	sp, r7
 8011112: bc80         	pop	{r7}
 8011114: 4770         	bx	lr

08011116 <LL_USART_IsActiveFlag_NE>:
; {
 8011116: b480         	push	{r7}
 8011118: b083         	sub	sp, #0xc
 801111a: af00         	add	r7, sp, #0x0
 801111c: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->SR, USART_SR_NE) == (USART_SR_NE));
 801111e: 687b         	ldr	r3, [r7, #0x4]
 8011120: 681b         	ldr	r3, [r3]
 8011122: f003 0304    	and	r3, r3, #0x4
 8011126: 2b04         	cmp	r3, #0x4
 8011128: bf0c         	ite	eq
 801112a: 2301         	moveq	r3, #0x1
 801112c: 2300         	movne	r3, #0x0
 801112e: b2db         	uxtb	r3, r3
; }
 8011130: 4618         	mov	r0, r3
 8011132: 370c         	adds	r7, #0xc
 8011134: 46bd         	mov	sp, r7
 8011136: bc80         	pop	{r7}
 8011138: 4770         	bx	lr

0801113a <LL_USART_IsActiveFlag_ORE>:
; {
 801113a: b480         	push	{r7}
 801113c: b083         	sub	sp, #0xc
 801113e: af00         	add	r7, sp, #0x0
 8011140: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->SR, USART_SR_ORE) == (USART_SR_ORE));
 8011142: 687b         	ldr	r3, [r7, #0x4]
 8011144: 681b         	ldr	r3, [r3]
 8011146: f003 0308    	and	r3, r3, #0x8
 801114a: 2b08         	cmp	r3, #0x8
 801114c: bf0c         	ite	eq
 801114e: 2301         	moveq	r3, #0x1
 8011150: 2300         	movne	r3, #0x0
 8011152: b2db         	uxtb	r3, r3
; }
 8011154: 4618         	mov	r0, r3
 8011156: 370c         	adds	r7, #0xc
 8011158: 46bd         	mov	sp, r7
 801115a: bc80         	pop	{r7}
 801115c: 4770         	bx	lr

0801115e <LL_USART_IsActiveFlag_RXNE>:
; {
 801115e: b480         	push	{r7}
 8011160: b083         	sub	sp, #0xc
 8011162: af00         	add	r7, sp, #0x0
 8011164: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->SR, USART_SR_RXNE) == (USART_SR_RXNE));
 8011166: 687b         	ldr	r3, [r7, #0x4]
 8011168: 681b         	ldr	r3, [r3]
 801116a: f003 0320    	and	r3, r3, #0x20
 801116e: 2b20         	cmp	r3, #0x20
 8011170: bf0c         	ite	eq
 8011172: 2301         	moveq	r3, #0x1
 8011174: 2300         	movne	r3, #0x0
 8011176: b2db         	uxtb	r3, r3
; }
 8011178: 4618         	mov	r0, r3
 801117a: 370c         	adds	r7, #0xc
 801117c: 46bd         	mov	sp, r7
 801117e: bc80         	pop	{r7}
 8011180: 4770         	bx	lr

08011182 <LL_USART_IsActiveFlag_TXE>:
; {
 8011182: b480         	push	{r7}
 8011184: b083         	sub	sp, #0xc
 8011186: af00         	add	r7, sp, #0x0
 8011188: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->SR, USART_SR_TXE) == (USART_SR_TXE));
 801118a: 687b         	ldr	r3, [r7, #0x4]
 801118c: 681b         	ldr	r3, [r3]
 801118e: f003 0380    	and	r3, r3, #0x80
 8011192: 2b80         	cmp	r3, #0x80
 8011194: bf0c         	ite	eq
 8011196: 2301         	moveq	r3, #0x1
 8011198: 2300         	movne	r3, #0x0
 801119a: b2db         	uxtb	r3, r3
; }
 801119c: 4618         	mov	r0, r3
 801119e: 370c         	adds	r7, #0xc
 80111a0: 46bd         	mov	sp, r7
 80111a2: bc80         	pop	{r7}
 80111a4: 4770         	bx	lr

080111a6 <LL_USART_IsActiveFlag_LBD>:
; {
 80111a6: b480         	push	{r7}
 80111a8: b083         	sub	sp, #0xc
 80111aa: af00         	add	r7, sp, #0x0
 80111ac: 6078         	str	r0, [r7, #0x4]
;   return (READ_BIT(USARTx->SR, USART_SR_LBD) == (USART_SR_LBD));
 80111ae: 687b         	ldr	r3, [r7, #0x4]
 80111b0: 681b         	ldr	r3, [r3]
 80111b2: f403 7380    	and	r3, r3, #0x100
 80111b6: f5b3 7f80    	cmp.w	r3, #0x100
 80111ba: bf0c         	ite	eq
 80111bc: 2301         	moveq	r3, #0x1
 80111be: 2300         	movne	r3, #0x0
 80111c0: b2db         	uxtb	r3, r3
; }
 80111c2: 4618         	mov	r0, r3
 80111c4: 370c         	adds	r7, #0xc
 80111c6: 46bd         	mov	sp, r7
 80111c8: bc80         	pop	{r7}
 80111ca: 4770         	bx	lr

080111cc <LL_USART_ClearFlag_PE>:
; {
 80111cc: b480         	push	{r7}
 80111ce: b085         	sub	sp, #0x14
 80111d0: af00         	add	r7, sp, #0x0
 80111d2: 6078         	str	r0, [r7, #0x4]
;   tmpreg = USARTx->SR;
 80111d4: 687b         	ldr	r3, [r7, #0x4]
 80111d6: 681b         	ldr	r3, [r3]
 80111d8: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 80111da: 68fb         	ldr	r3, [r7, #0xc]
;   tmpreg = USARTx->DR;
 80111dc: 687b         	ldr	r3, [r7, #0x4]
 80111de: 685b         	ldr	r3, [r3, #0x4]
 80111e0: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 80111e2: 68fb         	ldr	r3, [r7, #0xc]
; }
 80111e4: bf00         	nop
 80111e6: 3714         	adds	r7, #0x14
 80111e8: 46bd         	mov	sp, r7
 80111ea: bc80         	pop	{r7}
 80111ec: 4770         	bx	lr

080111ee <LL_USART_ClearFlag_FE>:
; {
 80111ee: b480         	push	{r7}
 80111f0: b085         	sub	sp, #0x14
 80111f2: af00         	add	r7, sp, #0x0
 80111f4: 6078         	str	r0, [r7, #0x4]
;   tmpreg = USARTx->SR;
 80111f6: 687b         	ldr	r3, [r7, #0x4]
 80111f8: 681b         	ldr	r3, [r3]
 80111fa: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 80111fc: 68fb         	ldr	r3, [r7, #0xc]
;   tmpreg = USARTx->DR;
 80111fe: 687b         	ldr	r3, [r7, #0x4]
 8011200: 685b         	ldr	r3, [r3, #0x4]
 8011202: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 8011204: 68fb         	ldr	r3, [r7, #0xc]
; }
 8011206: bf00         	nop
 8011208: 3714         	adds	r7, #0x14
 801120a: 46bd         	mov	sp, r7
 801120c: bc80         	pop	{r7}
 801120e: 4770         	bx	lr

08011210 <LL_USART_ClearFlag_NE>:
; {
 8011210: b480         	push	{r7}
 8011212: b085         	sub	sp, #0x14
 8011214: af00         	add	r7, sp, #0x0
 8011216: 6078         	str	r0, [r7, #0x4]
;   tmpreg = USARTx->SR;
 8011218: 687b         	ldr	r3, [r7, #0x4]
 801121a: 681b         	ldr	r3, [r3]
 801121c: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 801121e: 68fb         	ldr	r3, [r7, #0xc]
;   tmpreg = USARTx->DR;
 8011220: 687b         	ldr	r3, [r7, #0x4]
 8011222: 685b         	ldr	r3, [r3, #0x4]
 8011224: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 8011226: 68fb         	ldr	r3, [r7, #0xc]
; }
 8011228: bf00         	nop
 801122a: 3714         	adds	r7, #0x14
 801122c: 46bd         	mov	sp, r7
 801122e: bc80         	pop	{r7}
 8011230: 4770         	bx	lr

08011232 <LL_USART_ClearFlag_ORE>:
; {
 8011232: b480         	push	{r7}
 8011234: b085         	sub	sp, #0x14
 8011236: af00         	add	r7, sp, #0x0
 8011238: 6078         	str	r0, [r7, #0x4]
;   tmpreg = USARTx->SR;
 801123a: 687b         	ldr	r3, [r7, #0x4]
 801123c: 681b         	ldr	r3, [r3]
 801123e: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 8011240: 68fb         	ldr	r3, [r7, #0xc]
;   tmpreg = USARTx->DR;
 8011242: 687b         	ldr	r3, [r7, #0x4]
 8011244: 685b         	ldr	r3, [r3, #0x4]
 8011246: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 8011248: 68fb         	ldr	r3, [r7, #0xc]
; }
 801124a: bf00         	nop
 801124c: 3714         	adds	r7, #0x14
 801124e: 46bd         	mov	sp, r7
 8011250: bc80         	pop	{r7}
 8011252: 4770         	bx	lr

08011254 <LL_USART_ClearFlag_LBD>:
; {
 8011254: b480         	push	{r7}
 8011256: b083         	sub	sp, #0xc
 8011258: af00         	add	r7, sp, #0x0
 801125a: 6078         	str	r0, [r7, #0x4]
;   WRITE_REG(USARTx->SR, ~(USART_SR_LBD));
 801125c: 687b         	ldr	r3, [r7, #0x4]
 801125e: f46f 7280    	mvn	r2, #0x100
 8011262: 601a         	str	r2, [r3]
; }
 8011264: bf00         	nop
 8011266: 370c         	adds	r7, #0xc
 8011268: 46bd         	mov	sp, r7
 801126a: bc80         	pop	{r7}
 801126c: 4770         	bx	lr

0801126e <LL_USART_ReceiveData8>:
; {
 801126e: b480         	push	{r7}
 8011270: b083         	sub	sp, #0xc
 8011272: af00         	add	r7, sp, #0x0
 8011274: 6078         	str	r0, [r7, #0x4]
;   return (uint8_t)(READ_BIT(USARTx->DR, USART_DR_DR));
 8011276: 687b         	ldr	r3, [r7, #0x4]
 8011278: 685b         	ldr	r3, [r3, #0x4]
 801127a: b2db         	uxtb	r3, r3
; }
 801127c: 4618         	mov	r0, r3
 801127e: 370c         	adds	r7, #0xc
 8011280: 46bd         	mov	sp, r7
 8011282: bc80         	pop	{r7}
 8011284: 4770         	bx	lr

08011286 <LL_USART_TransmitData8>:
; {
 8011286: b480         	push	{r7}
 8011288: b083         	sub	sp, #0xc
 801128a: af00         	add	r7, sp, #0x0
 801128c: 6078         	str	r0, [r7, #0x4]
 801128e: 460b         	mov	r3, r1
 8011290: 70fb         	strb	r3, [r7, #0x3]
;   USARTx->DR = Value;
 8011292: 78fa         	ldrb	r2, [r7, #0x3]
 8011294: 687b         	ldr	r3, [r7, #0x4]
 8011296: 605a         	str	r2, [r3, #0x4]
; }
 8011298: bf00         	nop
 801129a: 370c         	adds	r7, #0xc
 801129c: 46bd         	mov	sp, r7
 801129e: bc80         	pop	{r7}
 80112a0: 4770         	bx	lr

080112a2 <z_log_msg_runtime_create>:
; {
 80112a2: b580         	push	{r7, lr}
 80112a4: b08a         	sub	sp, #0x28
 80112a6: af04         	add	r7, sp, #0x10
 80112a8: 60b9         	str	r1, [r7, #0x8]
 80112aa: 607b         	str	r3, [r7, #0x4]
 80112ac: 4603         	mov	r3, r0
 80112ae: 73fb         	strb	r3, [r7, #0xf]
 80112b0: 4613         	mov	r3, r2
 80112b2: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 80112b4: f107 032c    	add.w	r3, r7, #0x2c
 80112b8: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 80112ba: 7bba         	ldrb	r2, [r7, #0xe]
 80112bc: 7bf8         	ldrb	r0, [r7, #0xf]
 80112be: 697b         	ldr	r3, [r7, #0x14]
 80112c0: 9303         	str	r3, [sp, #0xc]
 80112c2: 6abb         	ldr	r3, [r7, #0x28]
 80112c4: 9302         	str	r3, [sp, #0x8]
 80112c6: 6a7b         	ldr	r3, [r7, #0x24]
 80112c8: 9301         	str	r3, [sp, #0x4]
 80112ca: 6a3b         	ldr	r3, [r7, #0x20]
 80112cc: 9300         	str	r3, [sp]
 80112ce: 687b         	ldr	r3, [r7, #0x4]
 80112d0: 68b9         	ldr	r1, [r7, #0x8]
 80112d2: f7f0 fab7    	bl	0x8001844 <z_log_msg_runtime_vcreate> @ imm = #-0xfa92
; }
 80112d6: bf00         	nop
 80112d8: 3718         	adds	r7, #0x18
 80112da: 46bd         	mov	sp, r7
 80112dc: bd80         	pop	{r7, pc}

080112de <uart_stm32_set_parity>:
; {
 80112de: b580         	push	{r7, lr}
 80112e0: b084         	sub	sp, #0x10
 80112e2: af00         	add	r7, sp, #0x0
 80112e4: 6078         	str	r0, [r7, #0x4]
 80112e6: 6039         	str	r1, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 80112e8: 687b         	ldr	r3, [r7, #0x4]
 80112ea: 685b         	ldr	r3, [r3, #0x4]
 80112ec: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_SetParity(config->usart, parity);
 80112ee: 68fb         	ldr	r3, [r7, #0xc]
 80112f0: 681b         	ldr	r3, [r3]
 80112f2: 6839         	ldr	r1, [r7]
 80112f4: 4618         	mov	r0, r3
 80112f6: f7ff fe2f    	bl	0x8010f58 <LL_USART_SetParity> @ imm = #-0x3a2
; }
 80112fa: bf00         	nop
 80112fc: 3710         	adds	r7, #0x10
 80112fe: 46bd         	mov	sp, r7
 8011300: bd80         	pop	{r7, pc}

08011302 <uart_stm32_get_parity>:
; {
 8011302: b580         	push	{r7, lr}
 8011304: b084         	sub	sp, #0x10
 8011306: af00         	add	r7, sp, #0x0
 8011308: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 801130a: 687b         	ldr	r3, [r7, #0x4]
 801130c: 685b         	ldr	r3, [r3, #0x4]
 801130e: 60fb         	str	r3, [r7, #0xc]
; 	return LL_USART_GetParity(config->usart);
 8011310: 68fb         	ldr	r3, [r7, #0xc]
 8011312: 681b         	ldr	r3, [r3]
 8011314: 4618         	mov	r0, r3
 8011316: f7ff fe31    	bl	0x8010f7c <LL_USART_GetParity> @ imm = #-0x39e
 801131a: 4603         	mov	r3, r0
; }
 801131c: 4618         	mov	r0, r3
 801131e: 3710         	adds	r7, #0x10
 8011320: 46bd         	mov	sp, r7
 8011322: bd80         	pop	{r7, pc}

08011324 <uart_stm32_set_stopbits>:
; {
 8011324: b580         	push	{r7, lr}
 8011326: b084         	sub	sp, #0x10
 8011328: af00         	add	r7, sp, #0x0
 801132a: 6078         	str	r0, [r7, #0x4]
 801132c: 6039         	str	r1, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 801132e: 687b         	ldr	r3, [r7, #0x4]
 8011330: 685b         	ldr	r3, [r3, #0x4]
 8011332: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_SetStopBitsLength(config->usart, stopbits);
 8011334: 68fb         	ldr	r3, [r7, #0xc]
 8011336: 681b         	ldr	r3, [r3]
 8011338: 6839         	ldr	r1, [r7]
 801133a: 4618         	mov	r0, r3
 801133c: f7ff fe5c    	bl	0x8010ff8 <LL_USART_SetStopBitsLength> @ imm = #-0x348
; }
 8011340: bf00         	nop
 8011342: 3710         	adds	r7, #0x10
 8011344: 46bd         	mov	sp, r7
 8011346: bd80         	pop	{r7, pc}

08011348 <uart_stm32_get_stopbits>:
; {
 8011348: b580         	push	{r7, lr}
 801134a: b084         	sub	sp, #0x10
 801134c: af00         	add	r7, sp, #0x0
 801134e: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8011350: 687b         	ldr	r3, [r7, #0x4]
 8011352: 685b         	ldr	r3, [r3, #0x4]
 8011354: 60fb         	str	r3, [r7, #0xc]
; 	return LL_USART_GetStopBitsLength(config->usart);
 8011356: 68fb         	ldr	r3, [r7, #0xc]
 8011358: 681b         	ldr	r3, [r3]
 801135a: 4618         	mov	r0, r3
 801135c: f7ff fe5e    	bl	0x801101c <LL_USART_GetStopBitsLength> @ imm = #-0x344
 8011360: 4603         	mov	r3, r0
; }
 8011362: 4618         	mov	r0, r3
 8011364: 3710         	adds	r7, #0x10
 8011366: 46bd         	mov	sp, r7
 8011368: bd80         	pop	{r7, pc}

0801136a <uart_stm32_set_databits>:
; {
 801136a: b580         	push	{r7, lr}
 801136c: b084         	sub	sp, #0x10
 801136e: af00         	add	r7, sp, #0x0
 8011370: 6078         	str	r0, [r7, #0x4]
 8011372: 6039         	str	r1, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 8011374: 687b         	ldr	r3, [r7, #0x4]
 8011376: 685b         	ldr	r3, [r3, #0x4]
 8011378: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_SetDataWidth(config->usart, databits);
 801137a: 68fb         	ldr	r3, [r7, #0xc]
 801137c: 681b         	ldr	r3, [r3]
 801137e: 6839         	ldr	r1, [r7]
 8011380: 4618         	mov	r0, r3
 8011382: f7ff fe08    	bl	0x8010f96 <LL_USART_SetDataWidth> @ imm = #-0x3f0
; }
 8011386: bf00         	nop
 8011388: 3710         	adds	r7, #0x10
 801138a: 46bd         	mov	sp, r7
 801138c: bd80         	pop	{r7, pc}

0801138e <uart_stm32_get_databits>:
; {
 801138e: b580         	push	{r7, lr}
 8011390: b084         	sub	sp, #0x10
 8011392: af00         	add	r7, sp, #0x0
 8011394: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8011396: 687b         	ldr	r3, [r7, #0x4]
 8011398: 685b         	ldr	r3, [r3, #0x4]
 801139a: 60fb         	str	r3, [r7, #0xc]
; 	return LL_USART_GetDataWidth(config->usart);
 801139c: 68fb         	ldr	r3, [r7, #0xc]
 801139e: 681b         	ldr	r3, [r3]
 80113a0: 4618         	mov	r0, r3
 80113a2: f7ff fe0a    	bl	0x8010fba <LL_USART_GetDataWidth> @ imm = #-0x3ec
 80113a6: 4603         	mov	r3, r0
; }
 80113a8: 4618         	mov	r0, r3
 80113aa: 3710         	adds	r7, #0x10
 80113ac: 46bd         	mov	sp, r7
 80113ae: bd80         	pop	{r7, pc}

080113b0 <uart_stm32_set_hwctrl>:
; {
 80113b0: b580         	push	{r7, lr}
 80113b2: b084         	sub	sp, #0x10
 80113b4: af00         	add	r7, sp, #0x0
 80113b6: 6078         	str	r0, [r7, #0x4]
 80113b8: 6039         	str	r1, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 80113ba: 687b         	ldr	r3, [r7, #0x4]
 80113bc: 685b         	ldr	r3, [r3, #0x4]
 80113be: 60fb         	str	r3, [r7, #0xc]
; 	LL_USART_SetHWFlowCtrl(config->usart, hwctrl);
 80113c0: 68fb         	ldr	r3, [r7, #0xc]
 80113c2: 681b         	ldr	r3, [r3]
 80113c4: 6839         	ldr	r1, [r7]
 80113c6: 4618         	mov	r0, r3
 80113c8: f7ff fe53    	bl	0x8011072 <LL_USART_SetHWFlowCtrl> @ imm = #-0x35a
; }
 80113cc: bf00         	nop
 80113ce: 3710         	adds	r7, #0x10
 80113d0: 46bd         	mov	sp, r7
 80113d2: bd80         	pop	{r7, pc}

080113d4 <uart_stm32_get_hwctrl>:
; {
 80113d4: b580         	push	{r7, lr}
 80113d6: b084         	sub	sp, #0x10
 80113d8: af00         	add	r7, sp, #0x0
 80113da: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 80113dc: 687b         	ldr	r3, [r7, #0x4]
 80113de: 685b         	ldr	r3, [r3, #0x4]
 80113e0: 60fb         	str	r3, [r7, #0xc]
; 	return LL_USART_GetHWFlowCtrl(config->usart);
 80113e2: 68fb         	ldr	r3, [r7, #0xc]
 80113e4: 681b         	ldr	r3, [r3]
 80113e6: 4618         	mov	r0, r3
 80113e8: f7ff fe55    	bl	0x8011096 <LL_USART_GetHWFlowCtrl> @ imm = #-0x356
 80113ec: 4603         	mov	r3, r0
; }
 80113ee: 4618         	mov	r0, r3
 80113f0: 3710         	adds	r7, #0x10
 80113f2: 46bd         	mov	sp, r7
 80113f4: bd80         	pop	{r7, pc}

080113f6 <uart_stm32_cfg2ll_parity>:
; {
 80113f6: b480         	push	{r7}
 80113f8: b083         	sub	sp, #0xc
 80113fa: af00         	add	r7, sp, #0x0
 80113fc: 4603         	mov	r3, r0
 80113fe: 71fb         	strb	r3, [r7, #0x7]
; 	switch (parity) {
 8011400: 79fb         	ldrb	r3, [r7, #0x7]
 8011402: 2b01         	cmp	r3, #0x1
 8011404: d002         	beq	0x801140c <uart_stm32_cfg2ll_parity+0x16> @ imm = #0x4
 8011406: 2b02         	cmp	r3, #0x2
 8011408: d003         	beq	0x8011412 <uart_stm32_cfg2ll_parity+0x1c> @ imm = #0x6
 801140a: e005         	b	0x8011418 <uart_stm32_cfg2ll_parity+0x22> @ imm = #0xa
; 		return LL_USART_PARITY_ODD;
 801140c: f44f 63c0    	mov.w	r3, #0x600
 8011410: e003         	b	0x801141a <uart_stm32_cfg2ll_parity+0x24> @ imm = #0x6
; 		return LL_USART_PARITY_EVEN;
 8011412: f44f 6380    	mov.w	r3, #0x400
 8011416: e000         	b	0x801141a <uart_stm32_cfg2ll_parity+0x24> @ imm = #0x0
; 		return LL_USART_PARITY_NONE;
 8011418: 2300         	movs	r3, #0x0
; }
 801141a: 4618         	mov	r0, r3
 801141c: 370c         	adds	r7, #0xc
 801141e: 46bd         	mov	sp, r7
 8011420: bc80         	pop	{r7}
 8011422: 4770         	bx	lr

08011424 <uart_stm32_ll2cfg_parity>:
; {
 8011424: b480         	push	{r7}
 8011426: b083         	sub	sp, #0xc
 8011428: af00         	add	r7, sp, #0x0
 801142a: 6078         	str	r0, [r7, #0x4]
; 	switch (parity) {
 801142c: 687b         	ldr	r3, [r7, #0x4]
 801142e: f5b3 6f80    	cmp.w	r3, #0x400
 8011432: d005         	beq	0x8011440 <uart_stm32_ll2cfg_parity+0x1c> @ imm = #0xa
 8011434: 687b         	ldr	r3, [r7, #0x4]
 8011436: f5b3 6fc0    	cmp.w	r3, #0x600
 801143a: d103         	bne	0x8011444 <uart_stm32_ll2cfg_parity+0x20> @ imm = #0x6
; 		return UART_CFG_PARITY_ODD;
 801143c: 2301         	movs	r3, #0x1
 801143e: e002         	b	0x8011446 <uart_stm32_ll2cfg_parity+0x22> @ imm = #0x4
; 		return UART_CFG_PARITY_EVEN;
 8011440: 2302         	movs	r3, #0x2
 8011442: e000         	b	0x8011446 <uart_stm32_ll2cfg_parity+0x22> @ imm = #0x0
; 		return UART_CFG_PARITY_NONE;
 8011444: 2300         	movs	r3, #0x0
; }
 8011446: 4618         	mov	r0, r3
 8011448: 370c         	adds	r7, #0xc
 801144a: 46bd         	mov	sp, r7
 801144c: bc80         	pop	{r7}
 801144e: 4770         	bx	lr

08011450 <uart_stm32_cfg2ll_stopbits>:
; {
 8011450: b480         	push	{r7}
 8011452: b083         	sub	sp, #0xc
 8011454: af00         	add	r7, sp, #0x0
 8011456: 6078         	str	r0, [r7, #0x4]
 8011458: 460b         	mov	r3, r1
 801145a: 70fb         	strb	r3, [r7, #0x3]
; 	switch (sb) {
 801145c: 78fb         	ldrb	r3, [r7, #0x3]
 801145e: 2b02         	cmp	r3, #0x2
 8011460: d00b         	beq	0x801147a <uart_stm32_cfg2ll_stopbits+0x2a> @ imm = #0x16
 8011462: 2b02         	cmp	r3, #0x2
 8011464: dc0c         	bgt	0x8011480 <uart_stm32_cfg2ll_stopbits+0x30> @ imm = #0x18
 8011466: 2b00         	cmp	r3, #0x0
 8011468: d002         	beq	0x8011470 <uart_stm32_cfg2ll_stopbits+0x20> @ imm = #0x4
 801146a: 2b01         	cmp	r3, #0x1
 801146c: d003         	beq	0x8011476 <uart_stm32_cfg2ll_stopbits+0x26> @ imm = #0x6
 801146e: e007         	b	0x8011480 <uart_stm32_cfg2ll_stopbits+0x30> @ imm = #0xe
; 		return LL_USART_STOPBITS_0_5;
 8011470: f44f 5380    	mov.w	r3, #0x1000
 8011474: e006         	b	0x8011484 <uart_stm32_cfg2ll_stopbits+0x34> @ imm = #0xc
; 		return LL_USART_STOPBITS_1;
 8011476: 2300         	movs	r3, #0x0
 8011478: e004         	b	0x8011484 <uart_stm32_cfg2ll_stopbits+0x34> @ imm = #0x8
; 		return LL_USART_STOPBITS_1_5;
 801147a: f44f 5340    	mov.w	r3, #0x3000
 801147e: e001         	b	0x8011484 <uart_stm32_cfg2ll_stopbits+0x34> @ imm = #0x2
; 		return LL_USART_STOPBITS_2;
 8011480: f44f 5300    	mov.w	r3, #0x2000
; }
 8011484: 4618         	mov	r0, r3
 8011486: 370c         	adds	r7, #0xc
 8011488: 46bd         	mov	sp, r7
 801148a: bc80         	pop	{r7}
 801148c: 4770         	bx	lr

0801148e <uart_stm32_ll2cfg_stopbits>:
; {
 801148e: b480         	push	{r7}
 8011490: b083         	sub	sp, #0xc
 8011492: af00         	add	r7, sp, #0x0
 8011494: 6078         	str	r0, [r7, #0x4]
; 	switch (sb) {
 8011496: 687b         	ldr	r3, [r7, #0x4]
 8011498: f5b3 5f40    	cmp.w	r3, #0x3000
 801149c: d00e         	beq	0x80114bc <uart_stm32_ll2cfg_stopbits+0x2e> @ imm = #0x1c
 801149e: 687b         	ldr	r3, [r7, #0x4]
 80114a0: f5b3 5f40    	cmp.w	r3, #0x3000
 80114a4: d80c         	bhi	0x80114c0 <uart_stm32_ll2cfg_stopbits+0x32> @ imm = #0x18
 80114a6: 687b         	ldr	r3, [r7, #0x4]
 80114a8: 2b00         	cmp	r3, #0x0
 80114aa: d005         	beq	0x80114b8 <uart_stm32_ll2cfg_stopbits+0x2a> @ imm = #0xa
 80114ac: 687b         	ldr	r3, [r7, #0x4]
 80114ae: f5b3 5f80    	cmp.w	r3, #0x1000
 80114b2: d105         	bne	0x80114c0 <uart_stm32_ll2cfg_stopbits+0x32> @ imm = #0xa
; 		return UART_CFG_STOP_BITS_0_5;
 80114b4: 2300         	movs	r3, #0x0
 80114b6: e004         	b	0x80114c2 <uart_stm32_ll2cfg_stopbits+0x34> @ imm = #0x8
; 		return UART_CFG_STOP_BITS_1;
 80114b8: 2301         	movs	r3, #0x1
 80114ba: e002         	b	0x80114c2 <uart_stm32_ll2cfg_stopbits+0x34> @ imm = #0x4
; 		return UART_CFG_STOP_BITS_1_5;
 80114bc: 2302         	movs	r3, #0x2
 80114be: e000         	b	0x80114c2 <uart_stm32_ll2cfg_stopbits+0x34> @ imm = #0x0
; 		return UART_CFG_STOP_BITS_2;
 80114c0: 2303         	movs	r3, #0x3
; }
 80114c2: 4618         	mov	r0, r3
 80114c4: 370c         	adds	r7, #0xc
 80114c6: 46bd         	mov	sp, r7
 80114c8: bc80         	pop	{r7}
 80114ca: 4770         	bx	lr

080114cc <uart_stm32_cfg2ll_databits>:
; {
 80114cc: b480         	push	{r7}
 80114ce: b083         	sub	sp, #0xc
 80114d0: af00         	add	r7, sp, #0x0
 80114d2: 4603         	mov	r3, r0
 80114d4: 460a         	mov	r2, r1
 80114d6: 71fb         	strb	r3, [r7, #0x7]
 80114d8: 4613         	mov	r3, r2
 80114da: 71bb         	strb	r3, [r7, #0x6]
; 	switch (db) {
 80114dc: 79fb         	ldrb	r3, [r7, #0x7]
 80114de: 2b04         	cmp	r3, #0x4
 80114e0: d102         	bne	0x80114e8 <uart_stm32_cfg2ll_databits+0x1c> @ imm = #0x4
; 		return LL_USART_DATAWIDTH_9B;
 80114e2: f44f 5380    	mov.w	r3, #0x1000
 80114e6: e006         	b	0x80114f6 <uart_stm32_cfg2ll_databits+0x2a> @ imm = #0xc
; 		if (p == UART_CFG_PARITY_NONE) {
 80114e8: 79bb         	ldrb	r3, [r7, #0x6]
 80114ea: 2b00         	cmp	r3, #0x0
 80114ec: d101         	bne	0x80114f2 <uart_stm32_cfg2ll_databits+0x26> @ imm = #0x2
; 			return LL_USART_DATAWIDTH_8B;
 80114ee: 2300         	movs	r3, #0x0
 80114f0: e001         	b	0x80114f6 <uart_stm32_cfg2ll_databits+0x2a> @ imm = #0x2
; 			return LL_USART_DATAWIDTH_9B;
 80114f2: f44f 5380    	mov.w	r3, #0x1000
; }
 80114f6: 4618         	mov	r0, r3
 80114f8: 370c         	adds	r7, #0xc
 80114fa: 46bd         	mov	sp, r7
 80114fc: bc80         	pop	{r7}
 80114fe: 4770         	bx	lr

08011500 <uart_stm32_ll2cfg_databits>:
; {
 8011500: b480         	push	{r7}
 8011502: b083         	sub	sp, #0xc
 8011504: af00         	add	r7, sp, #0x0
 8011506: 6078         	str	r0, [r7, #0x4]
 8011508: 6039         	str	r1, [r7]
; 	switch (db) {
 801150a: 687b         	ldr	r3, [r7, #0x4]
 801150c: f5b3 5f80    	cmp.w	r3, #0x1000
 8011510: d106         	bne	0x8011520 <uart_stm32_ll2cfg_databits+0x20> @ imm = #0xc
; 		if (p == LL_USART_PARITY_NONE) {
 8011512: 683b         	ldr	r3, [r7]
 8011514: 2b00         	cmp	r3, #0x0
 8011516: d101         	bne	0x801151c <uart_stm32_ll2cfg_databits+0x1c> @ imm = #0x2
; 			return UART_CFG_DATA_BITS_9;
 8011518: 2304         	movs	r3, #0x4
 801151a: e007         	b	0x801152c <uart_stm32_ll2cfg_databits+0x2c> @ imm = #0xe
; 			return UART_CFG_DATA_BITS_8;
 801151c: 2303         	movs	r3, #0x3
 801151e: e005         	b	0x801152c <uart_stm32_ll2cfg_databits+0x2c> @ imm = #0xa
; 		if (p == LL_USART_PARITY_NONE) {
 8011520: 683b         	ldr	r3, [r7]
 8011522: 2b00         	cmp	r3, #0x0
 8011524: d101         	bne	0x801152a <uart_stm32_ll2cfg_databits+0x2a> @ imm = #0x2
; 			return UART_CFG_DATA_BITS_8;
 8011526: 2303         	movs	r3, #0x3
 8011528: e000         	b	0x801152c <uart_stm32_ll2cfg_databits+0x2c> @ imm = #0x0
; 			return UART_CFG_DATA_BITS_7;
 801152a: 2302         	movs	r3, #0x2
; }
 801152c: 4618         	mov	r0, r3
 801152e: 370c         	adds	r7, #0xc
 8011530: 46bd         	mov	sp, r7
 8011532: bc80         	pop	{r7}
 8011534: 4770         	bx	lr

08011536 <uart_stm32_cfg2ll_hwctrl>:
; {
 8011536: b480         	push	{r7}
 8011538: b083         	sub	sp, #0xc
 801153a: af00         	add	r7, sp, #0x0
 801153c: 4603         	mov	r3, r0
 801153e: 71fb         	strb	r3, [r7, #0x7]
; 	if (fc == UART_CFG_FLOW_CTRL_RTS_CTS) {
 8011540: 79fb         	ldrb	r3, [r7, #0x7]
 8011542: 2b01         	cmp	r3, #0x1
 8011544: d102         	bne	0x801154c <uart_stm32_cfg2ll_hwctrl+0x16> @ imm = #0x4
; 		return LL_USART_HWCONTROL_RTS_CTS;
 8011546: f44f 7340    	mov.w	r3, #0x300
 801154a: e005         	b	0x8011558 <uart_stm32_cfg2ll_hwctrl+0x22> @ imm = #0xa
; 	} else if (fc == UART_CFG_FLOW_CTRL_RS485) {
 801154c: 79fb         	ldrb	r3, [r7, #0x7]
 801154e: 2b03         	cmp	r3, #0x3
 8011550: d101         	bne	0x8011556 <uart_stm32_cfg2ll_hwctrl+0x20> @ imm = #0x2
; 		return LL_USART_HWCONTROL_NONE;
 8011552: 2300         	movs	r3, #0x0
 8011554: e000         	b	0x8011558 <uart_stm32_cfg2ll_hwctrl+0x22> @ imm = #0x0
; 	return LL_USART_HWCONTROL_NONE;
 8011556: 2300         	movs	r3, #0x0
; }
 8011558: 4618         	mov	r0, r3
 801155a: 370c         	adds	r7, #0xc
 801155c: 46bd         	mov	sp, r7
 801155e: bc80         	pop	{r7}
 8011560: 4770         	bx	lr

08011562 <uart_stm32_ll2cfg_hwctrl>:
; {
 8011562: b480         	push	{r7}
 8011564: b083         	sub	sp, #0xc
 8011566: af00         	add	r7, sp, #0x0
 8011568: 6078         	str	r0, [r7, #0x4]
; 	if (fc == LL_USART_HWCONTROL_RTS_CTS) {
 801156a: 687b         	ldr	r3, [r7, #0x4]
 801156c: f5b3 7f40    	cmp.w	r3, #0x300
 8011570: d101         	bne	0x8011576 <uart_stm32_ll2cfg_hwctrl+0x14> @ imm = #0x2
; 		return UART_CFG_FLOW_CTRL_RTS_CTS;
 8011572: 2301         	movs	r3, #0x1
 8011574: e000         	b	0x8011578 <uart_stm32_ll2cfg_hwctrl+0x16> @ imm = #0x0
; 	return UART_CFG_FLOW_CTRL_NONE;
 8011576: 2300         	movs	r3, #0x0
; }
 8011578: 4618         	mov	r0, r3
 801157a: 370c         	adds	r7, #0xc
 801157c: 46bd         	mov	sp, r7
 801157e: bc80         	pop	{r7}
 8011580: 4770         	bx	lr

08011582 <uart_stm32_parameters_set>:
; {
 8011582: b580         	push	{r7, lr}
 8011584: b08a         	sub	sp, #0x28
 8011586: af00         	add	r7, sp, #0x0
 8011588: 6078         	str	r0, [r7, #0x4]
 801158a: 6039         	str	r1, [r7]
; 	const struct uart_stm32_config *config = dev->config;
 801158c: 687b         	ldr	r3, [r7, #0x4]
 801158e: 685b         	ldr	r3, [r3, #0x4]
 8011590: 627b         	str	r3, [r7, #0x24]
; 	struct uart_stm32_data *data = dev->data;
 8011592: 687b         	ldr	r3, [r7, #0x4]
 8011594: 691b         	ldr	r3, [r3, #0x10]
 8011596: 623b         	str	r3, [r7, #0x20]
; 	struct uart_config *uart_cfg = data->uart_cfg;
 8011598: 6a3b         	ldr	r3, [r7, #0x20]
 801159a: 685b         	ldr	r3, [r3, #0x4]
 801159c: 61fb         	str	r3, [r7, #0x1c]
; 	const uint32_t parity = uart_stm32_cfg2ll_parity(cfg->parity);
 801159e: 683b         	ldr	r3, [r7]
 80115a0: 791b         	ldrb	r3, [r3, #0x4]
 80115a2: 4618         	mov	r0, r3
 80115a4: f7ff ff27    	bl	0x80113f6 <uart_stm32_cfg2ll_parity> @ imm = #-0x1b2
 80115a8: 61b8         	str	r0, [r7, #0x18]
; 	const uint32_t stopbits = uart_stm32_cfg2ll_stopbits(config, cfg->stop_bits);
 80115aa: 683b         	ldr	r3, [r7]
 80115ac: 795b         	ldrb	r3, [r3, #0x5]
 80115ae: 4619         	mov	r1, r3
 80115b0: 6a78         	ldr	r0, [r7, #0x24]
 80115b2: f7ff ff4d    	bl	0x8011450 <uart_stm32_cfg2ll_stopbits> @ imm = #-0x166
 80115b6: 6178         	str	r0, [r7, #0x14]
; 	const uint32_t databits = uart_stm32_cfg2ll_databits(cfg->data_bits,
 80115b8: 683b         	ldr	r3, [r7]
 80115ba: 799a         	ldrb	r2, [r3, #0x6]
; 							     cfg->parity);
 80115bc: 683b         	ldr	r3, [r7]
 80115be: 791b         	ldrb	r3, [r3, #0x4]
; 	const uint32_t databits = uart_stm32_cfg2ll_databits(cfg->data_bits,
 80115c0: 4619         	mov	r1, r3
 80115c2: 4610         	mov	r0, r2
 80115c4: f7ff ff82    	bl	0x80114cc <uart_stm32_cfg2ll_databits> @ imm = #-0xfc
 80115c8: 6138         	str	r0, [r7, #0x10]
; 	const uint32_t flowctrl = uart_stm32_cfg2ll_hwctrl(cfg->flow_ctrl);
 80115ca: 683b         	ldr	r3, [r7]
 80115cc: 79db         	ldrb	r3, [r3, #0x7]
 80115ce: 4618         	mov	r0, r3
 80115d0: f7ff ffb1    	bl	0x8011536 <uart_stm32_cfg2ll_hwctrl> @ imm = #-0x9e
 80115d4: 60f8         	str	r0, [r7, #0xc]
; 	if (cfg == uart_cfg) {
 80115d6: 683a         	ldr	r2, [r7]
 80115d8: 69fb         	ldr	r3, [r7, #0x1c]
 80115da: 429a         	cmp	r2, r3
 80115dc: d111         	bne	0x8011602 <uart_stm32_parameters_set+0x80> @ imm = #0x22
; 		LL_USART_ConfigCharacter(config->usart,
 80115de: 6a7b         	ldr	r3, [r7, #0x24]
 80115e0: 6818         	ldr	r0, [r3]
 80115e2: 697b         	ldr	r3, [r7, #0x14]
 80115e4: 69ba         	ldr	r2, [r7, #0x18]
 80115e6: 6939         	ldr	r1, [r7, #0x10]
 80115e8: f7ff fd25    	bl	0x8011036 <LL_USART_ConfigCharacter> @ imm = #-0x5b6
; 		uart_stm32_set_hwctrl(dev, flowctrl);
 80115ec: 68f9         	ldr	r1, [r7, #0xc]
 80115ee: 6878         	ldr	r0, [r7, #0x4]
 80115f0: f7ff fede    	bl	0x80113b0 <uart_stm32_set_hwctrl> @ imm = #-0x244
; 		uart_stm32_set_baudrate(dev, cfg->baudrate);
 80115f4: 683b         	ldr	r3, [r7]
 80115f6: 681b         	ldr	r3, [r3]
 80115f8: 4619         	mov	r1, r3
 80115fa: 6878         	ldr	r0, [r7, #0x4]
 80115fc: f7f4 fd5a    	bl	0x80060b4 <uart_stm32_set_baudrate> @ imm = #-0xb54c
; }
 8011600: e03b         	b	0x801167a <uart_stm32_parameters_set+0xf8> @ imm = #0x76
; 		if (parity != uart_stm32_get_parity(dev)) {
 8011602: 6878         	ldr	r0, [r7, #0x4]
 8011604: f7ff fe7d    	bl	0x8011302 <uart_stm32_get_parity> @ imm = #-0x306
 8011608: 4602         	mov	r2, r0
 801160a: 69bb         	ldr	r3, [r7, #0x18]
 801160c: 4293         	cmp	r3, r2
 801160e: d003         	beq	0x8011618 <uart_stm32_parameters_set+0x96> @ imm = #0x6
; 			uart_stm32_set_parity(dev, parity);
 8011610: 69b9         	ldr	r1, [r7, #0x18]
 8011612: 6878         	ldr	r0, [r7, #0x4]
 8011614: f7ff fe63    	bl	0x80112de <uart_stm32_set_parity> @ imm = #-0x33a
; 		if (stopbits != uart_stm32_get_stopbits(dev)) {
 8011618: 6878         	ldr	r0, [r7, #0x4]
 801161a: f7ff fe95    	bl	0x8011348 <uart_stm32_get_stopbits> @ imm = #-0x2d6
 801161e: 4602         	mov	r2, r0
 8011620: 697b         	ldr	r3, [r7, #0x14]
 8011622: 4293         	cmp	r3, r2
 8011624: d003         	beq	0x801162e <uart_stm32_parameters_set+0xac> @ imm = #0x6
; 			uart_stm32_set_stopbits(dev, stopbits);
 8011626: 6979         	ldr	r1, [r7, #0x14]
 8011628: 6878         	ldr	r0, [r7, #0x4]
 801162a: f7ff fe7b    	bl	0x8011324 <uart_stm32_set_stopbits> @ imm = #-0x30a
; 		if (databits != uart_stm32_get_databits(dev)) {
 801162e: 6878         	ldr	r0, [r7, #0x4]
 8011630: f7ff fead    	bl	0x801138e <uart_stm32_get_databits> @ imm = #-0x2a6
 8011634: 4602         	mov	r2, r0
 8011636: 693b         	ldr	r3, [r7, #0x10]
 8011638: 4293         	cmp	r3, r2
 801163a: d003         	beq	0x8011644 <uart_stm32_parameters_set+0xc2> @ imm = #0x6
; 			uart_stm32_set_databits(dev, databits);
 801163c: 6939         	ldr	r1, [r7, #0x10]
 801163e: 6878         	ldr	r0, [r7, #0x4]
 8011640: f7ff fe93    	bl	0x801136a <uart_stm32_set_databits> @ imm = #-0x2da
; 		if (flowctrl != uart_stm32_get_hwctrl(dev)) {
 8011644: 6878         	ldr	r0, [r7, #0x4]
 8011646: f7ff fec5    	bl	0x80113d4 <uart_stm32_get_hwctrl> @ imm = #-0x276
 801164a: 4602         	mov	r2, r0
 801164c: 68fb         	ldr	r3, [r7, #0xc]
 801164e: 4293         	cmp	r3, r2
 8011650: d003         	beq	0x801165a <uart_stm32_parameters_set+0xd8> @ imm = #0x6
; 			uart_stm32_set_hwctrl(dev, flowctrl);
 8011652: 68f9         	ldr	r1, [r7, #0xc]
 8011654: 6878         	ldr	r0, [r7, #0x4]
 8011656: f7ff feab    	bl	0x80113b0 <uart_stm32_set_hwctrl> @ imm = #-0x2aa
; 		if (cfg->baudrate != uart_cfg->baudrate) {
 801165a: 683b         	ldr	r3, [r7]
 801165c: 681a         	ldr	r2, [r3]
 801165e: 69fb         	ldr	r3, [r7, #0x1c]
 8011660: 681b         	ldr	r3, [r3]
 8011662: 429a         	cmp	r2, r3
 8011664: d009         	beq	0x801167a <uart_stm32_parameters_set+0xf8> @ imm = #0x12
; 			uart_stm32_set_baudrate(dev, cfg->baudrate);
 8011666: 683b         	ldr	r3, [r7]
 8011668: 681b         	ldr	r3, [r3]
 801166a: 4619         	mov	r1, r3
 801166c: 6878         	ldr	r0, [r7, #0x4]
 801166e: f7f4 fd21    	bl	0x80060b4 <uart_stm32_set_baudrate> @ imm = #-0xb5be
; 			uart_cfg->baudrate = cfg->baudrate;
 8011672: 683b         	ldr	r3, [r7]
 8011674: 681a         	ldr	r2, [r3]
 8011676: 69fb         	ldr	r3, [r7, #0x1c]
 8011678: 601a         	str	r2, [r3]
; }
 801167a: bf00         	nop
 801167c: 3728         	adds	r7, #0x28
 801167e: 46bd         	mov	sp, r7
 8011680: bd80         	pop	{r7, pc}

08011682 <uart_stm32_config_get>:
; {
 8011682: b590         	push	{r4, r7, lr}
 8011684: b085         	sub	sp, #0x14
 8011686: af00         	add	r7, sp, #0x0
 8011688: 6078         	str	r0, [r7, #0x4]
 801168a: 6039         	str	r1, [r7]
; 	struct uart_stm32_data *data = dev->data;
 801168c: 687b         	ldr	r3, [r7, #0x4]
 801168e: 691b         	ldr	r3, [r3, #0x10]
 8011690: 60fb         	str	r3, [r7, #0xc]
; 	struct uart_config *uart_cfg = data->uart_cfg;
 8011692: 68fb         	ldr	r3, [r7, #0xc]
 8011694: 685b         	ldr	r3, [r3, #0x4]
 8011696: 60bb         	str	r3, [r7, #0x8]
; 	cfg->baudrate = uart_cfg->baudrate;
 8011698: 68bb         	ldr	r3, [r7, #0x8]
 801169a: 681a         	ldr	r2, [r3]
 801169c: 683b         	ldr	r3, [r7]
 801169e: 601a         	str	r2, [r3]
; 	cfg->parity = uart_stm32_ll2cfg_parity(uart_stm32_get_parity(dev));
 80116a0: 6878         	ldr	r0, [r7, #0x4]
 80116a2: f7ff fe2e    	bl	0x8011302 <uart_stm32_get_parity> @ imm = #-0x3a4
 80116a6: 4603         	mov	r3, r0
 80116a8: 4618         	mov	r0, r3
 80116aa: f7ff febb    	bl	0x8011424 <uart_stm32_ll2cfg_parity> @ imm = #-0x28a
 80116ae: 4603         	mov	r3, r0
 80116b0: 461a         	mov	r2, r3
 80116b2: 683b         	ldr	r3, [r7]
 80116b4: 711a         	strb	r2, [r3, #0x4]
; 	cfg->stop_bits = uart_stm32_ll2cfg_stopbits(
 80116b6: 6878         	ldr	r0, [r7, #0x4]
 80116b8: f7ff fe46    	bl	0x8011348 <uart_stm32_get_stopbits> @ imm = #-0x374
 80116bc: 4603         	mov	r3, r0
 80116be: 4618         	mov	r0, r3
 80116c0: f7ff fee5    	bl	0x801148e <uart_stm32_ll2cfg_stopbits> @ imm = #-0x236
 80116c4: 4603         	mov	r3, r0
 80116c6: 461a         	mov	r2, r3
 80116c8: 683b         	ldr	r3, [r7]
 80116ca: 715a         	strb	r2, [r3, #0x5]
; 	cfg->data_bits = uart_stm32_ll2cfg_databits(
 80116cc: 6878         	ldr	r0, [r7, #0x4]
 80116ce: f7ff fe5e    	bl	0x801138e <uart_stm32_get_databits> @ imm = #-0x344
 80116d2: 4604         	mov	r4, r0
 80116d4: 6878         	ldr	r0, [r7, #0x4]
 80116d6: f7ff fe14    	bl	0x8011302 <uart_stm32_get_parity> @ imm = #-0x3d8
 80116da: 4603         	mov	r3, r0
 80116dc: 4619         	mov	r1, r3
 80116de: 4620         	mov	r0, r4
 80116e0: f7ff ff0e    	bl	0x8011500 <uart_stm32_ll2cfg_databits> @ imm = #-0x1e4
 80116e4: 4603         	mov	r3, r0
 80116e6: 461a         	mov	r2, r3
 80116e8: 683b         	ldr	r3, [r7]
 80116ea: 719a         	strb	r2, [r3, #0x6]
; 	cfg->flow_ctrl = uart_stm32_ll2cfg_hwctrl(
 80116ec: 6878         	ldr	r0, [r7, #0x4]
 80116ee: f7ff fe71    	bl	0x80113d4 <uart_stm32_get_hwctrl> @ imm = #-0x31e
 80116f2: 4603         	mov	r3, r0
 80116f4: 4618         	mov	r0, r3
 80116f6: f7ff ff34    	bl	0x8011562 <uart_stm32_ll2cfg_hwctrl> @ imm = #-0x198
 80116fa: 4603         	mov	r3, r0
 80116fc: 461a         	mov	r2, r3
 80116fe: 683b         	ldr	r3, [r7]
 8011700: 71da         	strb	r2, [r3, #0x7]
; 	return 0;
 8011702: 2300         	movs	r3, #0x0
; }
 8011704: 4618         	mov	r0, r3
 8011706: 3714         	adds	r7, #0x14
 8011708: 46bd         	mov	sp, r7
 801170a: bd90         	pop	{r4, r7, pc}

0801170c <uart_stm32_poll_in_visitor>:
; {
 801170c: b580         	push	{r7, lr}
 801170e: b086         	sub	sp, #0x18
 8011710: af00         	add	r7, sp, #0x0
 8011712: 60f8         	str	r0, [r7, #0xc]
 8011714: 60b9         	str	r1, [r7, #0x8]
 8011716: 607a         	str	r2, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8011718: 68fb         	ldr	r3, [r7, #0xc]
 801171a: 685b         	ldr	r3, [r3, #0x4]
 801171c: 617b         	str	r3, [r7, #0x14]
; 	USART_TypeDef *usart = config->usart;
 801171e: 697b         	ldr	r3, [r7, #0x14]
 8011720: 681b         	ldr	r3, [r3]
 8011722: 613b         	str	r3, [r7, #0x10]
; 	if (LL_USART_IsActiveFlag_ORE(usart)) {
 8011724: 6938         	ldr	r0, [r7, #0x10]
 8011726: f7ff fd08    	bl	0x801113a <LL_USART_IsActiveFlag_ORE> @ imm = #-0x5f0
 801172a: 4603         	mov	r3, r0
 801172c: 2b00         	cmp	r3, #0x0
 801172e: d002         	beq	0x8011736 <uart_stm32_poll_in_visitor+0x2a> @ imm = #0x4
; 		LL_USART_ClearFlag_ORE(usart);
 8011730: 6938         	ldr	r0, [r7, #0x10]
 8011732: f7ff fd7e    	bl	0x8011232 <LL_USART_ClearFlag_ORE> @ imm = #-0x504
; 	if (!LL_USART_IsActiveFlag_RXNE(usart)) {
 8011736: 6938         	ldr	r0, [r7, #0x10]
 8011738: f7ff fd11    	bl	0x801115e <LL_USART_IsActiveFlag_RXNE> @ imm = #-0x5de
 801173c: 4603         	mov	r3, r0
 801173e: 2b00         	cmp	r3, #0x0
 8011740: d102         	bne	0x8011748 <uart_stm32_poll_in_visitor+0x3c> @ imm = #0x4
; 		return -1;
 8011742: f04f 33ff    	mov.w	r3, #0xffffffff
 8011746: e004         	b	0x8011752 <uart_stm32_poll_in_visitor+0x46> @ imm = #0x8
; 	get_fn(usart, in);
 8011748: 687b         	ldr	r3, [r7, #0x4]
 801174a: 68b9         	ldr	r1, [r7, #0x8]
 801174c: 6938         	ldr	r0, [r7, #0x10]
 801174e: 4798         	blx	r3
; 	return 0;
 8011750: 2300         	movs	r3, #0x0
; }
 8011752: 4618         	mov	r0, r3
 8011754: 3718         	adds	r7, #0x18
 8011756: 46bd         	mov	sp, r7
 8011758: bd80         	pop	{r7, pc}

0801175a <uart_stm32_poll_out_visitor>:
; {
 801175a: b580         	push	{r7, lr}
 801175c: b08e         	sub	sp, #0x38
 801175e: af00         	add	r7, sp, #0x0
 8011760: 60f8         	str	r0, [r7, #0xc]
 8011762: 460b         	mov	r3, r1
 8011764: 607a         	str	r2, [r7, #0x4]
 8011766: 817b         	strh	r3, [r7, #0xa]
; 	const struct uart_stm32_config *config = dev->config;
 8011768: 68fb         	ldr	r3, [r7, #0xc]
 801176a: 685b         	ldr	r3, [r3, #0x4]
 801176c: 637b         	str	r3, [r7, #0x34]
; 	USART_TypeDef *usart = config->usart;
 801176e: 6b7b         	ldr	r3, [r7, #0x34]
 8011770: 681b         	ldr	r3, [r3]
 8011772: 633b         	str	r3, [r7, #0x30]
; 		if (LL_USART_IsActiveFlag_TXE(usart)) {
 8011774: 6b38         	ldr	r0, [r7, #0x30]
 8011776: f7ff fd04    	bl	0x8011182 <LL_USART_IsActiveFlag_TXE> @ imm = #-0x5f8
 801177a: 4603         	mov	r3, r0
 801177c: 2b00         	cmp	r3, #0x0
 801177e: d0f9         	beq	0x8011774 <uart_stm32_poll_out_visitor+0x1a> @ imm = #-0xe
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8011780: f3ef 8311    	mrs	r3, basepri
 8011784: 62bb         	str	r3, [r7, #0x28]
;   return(result);
 8011786: 6abb         	ldr	r3, [r7, #0x28]
; 	key = __get_BASEPRI();
 8011788: 627b         	str	r3, [r7, #0x24]
 801178a: 2310         	movs	r3, #0x10
 801178c: 623b         	str	r3, [r7, #0x20]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 801178e: 6a3b         	ldr	r3, [r7, #0x20]
 8011790: f383 8812    	msr	basepri_max, r3
; }
 8011794: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8011796: f3bf 8f6f    	isb	sy
; }
 801179a: bf00         	nop
; 	return key;
 801179c: 6a7b         	ldr	r3, [r7, #0x24]
; 			key = irq_lock();
 801179e: 62fb         	str	r3, [r7, #0x2c]
; 			if (LL_USART_IsActiveFlag_TXE(usart)) {
 80117a0: 6b38         	ldr	r0, [r7, #0x30]
 80117a2: f7ff fcee    	bl	0x8011182 <LL_USART_IsActiveFlag_TXE> @ imm = #-0x624
 80117a6: 4603         	mov	r3, r0
 80117a8: 2b00         	cmp	r3, #0x0
 80117aa: d10c         	bne	0x80117c6 <uart_stm32_poll_out_visitor+0x6c> @ imm = #0x18
 80117ac: 6afb         	ldr	r3, [r7, #0x2c]
 80117ae: 61fb         	str	r3, [r7, #0x1c]
 80117b0: 69fb         	ldr	r3, [r7, #0x1c]
 80117b2: 61bb         	str	r3, [r7, #0x18]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80117b4: 69bb         	ldr	r3, [r7, #0x18]
 80117b6: f383 8811    	msr	basepri, r3
; }
 80117ba: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80117bc: f3bf 8f6f    	isb	sy
; }
 80117c0: bf00         	nop
; }
 80117c2: bf00         	nop
; 		if (LL_USART_IsActiveFlag_TXE(usart)) {
 80117c4: e7d6         	b	0x8011774 <uart_stm32_poll_out_visitor+0x1a> @ imm = #-0x54
; 				break;
 80117c6: bf00         	nop
; 	set_fn(usart, out);
 80117c8: 897a         	ldrh	r2, [r7, #0xa]
 80117ca: 687b         	ldr	r3, [r7, #0x4]
 80117cc: 4611         	mov	r1, r2
 80117ce: 6b38         	ldr	r0, [r7, #0x30]
 80117d0: 4798         	blx	r3
 80117d2: 6afb         	ldr	r3, [r7, #0x2c]
 80117d4: 617b         	str	r3, [r7, #0x14]
 80117d6: 697b         	ldr	r3, [r7, #0x14]
 80117d8: 613b         	str	r3, [r7, #0x10]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80117da: 693b         	ldr	r3, [r7, #0x10]
 80117dc: f383 8811    	msr	basepri, r3
; }
 80117e0: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80117e2: f3bf 8f6f    	isb	sy
; }
 80117e6: bf00         	nop
; }
 80117e8: bf00         	nop
; }
 80117ea: bf00         	nop
 80117ec: 3738         	adds	r7, #0x38
 80117ee: 46bd         	mov	sp, r7
 80117f0: bd80         	pop	{r7, pc}

080117f2 <poll_in_u8>:
; {
 80117f2: b580         	push	{r7, lr}
 80117f4: b082         	sub	sp, #0x8
 80117f6: af00         	add	r7, sp, #0x0
 80117f8: 6078         	str	r0, [r7, #0x4]
 80117fa: 6039         	str	r1, [r7]
; 	*((unsigned char *)in) = (unsigned char)LL_USART_ReceiveData8(usart);
 80117fc: 6878         	ldr	r0, [r7, #0x4]
 80117fe: f7ff fd36    	bl	0x801126e <LL_USART_ReceiveData8> @ imm = #-0x594
 8011802: 4603         	mov	r3, r0
 8011804: 461a         	mov	r2, r3
 8011806: 683b         	ldr	r3, [r7]
 8011808: 701a         	strb	r2, [r3]
; }
 801180a: bf00         	nop
 801180c: 3708         	adds	r7, #0x8
 801180e: 46bd         	mov	sp, r7
 8011810: bd80         	pop	{r7, pc}

08011812 <poll_out_u8>:
; {
 8011812: b580         	push	{r7, lr}
 8011814: b082         	sub	sp, #0x8
 8011816: af00         	add	r7, sp, #0x0
 8011818: 6078         	str	r0, [r7, #0x4]
 801181a: 460b         	mov	r3, r1
 801181c: 807b         	strh	r3, [r7, #0x2]
; 	LL_USART_TransmitData8(usart, (uint8_t)out);
 801181e: 887b         	ldrh	r3, [r7, #0x2]
 8011820: b2db         	uxtb	r3, r3
 8011822: 4619         	mov	r1, r3
 8011824: 6878         	ldr	r0, [r7, #0x4]
 8011826: f7ff fd2e    	bl	0x8011286 <LL_USART_TransmitData8> @ imm = #-0x5a4
; }
 801182a: bf00         	nop
 801182c: 3708         	adds	r7, #0x8
 801182e: 46bd         	mov	sp, r7
 8011830: bd80         	pop	{r7, pc}

08011832 <uart_stm32_err_check>:
; {
 8011832: b580         	push	{r7, lr}
 8011834: b086         	sub	sp, #0x18
 8011836: af00         	add	r7, sp, #0x0
 8011838: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 801183a: 687b         	ldr	r3, [r7, #0x4]
 801183c: 685b         	ldr	r3, [r3, #0x4]
 801183e: 613b         	str	r3, [r7, #0x10]
; 	USART_TypeDef *usart = config->usart;
 8011840: 693b         	ldr	r3, [r7, #0x10]
 8011842: 681b         	ldr	r3, [r3]
 8011844: 60fb         	str	r3, [r7, #0xc]
; 	uint32_t err = 0U;
 8011846: 2300         	movs	r3, #0x0
 8011848: 617b         	str	r3, [r7, #0x14]
; 	if (LL_USART_IsActiveFlag_ORE(usart)) {
 801184a: 68f8         	ldr	r0, [r7, #0xc]
 801184c: f7ff fc75    	bl	0x801113a <LL_USART_IsActiveFlag_ORE> @ imm = #-0x716
 8011850: 4603         	mov	r3, r0
 8011852: 2b00         	cmp	r3, #0x0
 8011854: d003         	beq	0x801185e <uart_stm32_err_check+0x2c> @ imm = #0x6
; 		err |= UART_ERROR_OVERRUN;
 8011856: 697b         	ldr	r3, [r7, #0x14]
 8011858: f043 0301    	orr	r3, r3, #0x1
 801185c: 617b         	str	r3, [r7, #0x14]
; 	if (LL_USART_IsActiveFlag_PE(usart)) {
 801185e: 68f8         	ldr	r0, [r7, #0xc]
 8011860: f7ff fc35    	bl	0x80110ce <LL_USART_IsActiveFlag_PE> @ imm = #-0x796
 8011864: 4603         	mov	r3, r0
 8011866: 2b00         	cmp	r3, #0x0
 8011868: d003         	beq	0x8011872 <uart_stm32_err_check+0x40> @ imm = #0x6
; 		err |= UART_ERROR_PARITY;
 801186a: 697b         	ldr	r3, [r7, #0x14]
 801186c: f043 0302    	orr	r3, r3, #0x2
 8011870: 617b         	str	r3, [r7, #0x14]
; 	if (LL_USART_IsActiveFlag_FE(usart)) {
 8011872: 68f8         	ldr	r0, [r7, #0xc]
 8011874: f7ff fc3d    	bl	0x80110f2 <LL_USART_IsActiveFlag_FE> @ imm = #-0x786
 8011878: 4603         	mov	r3, r0
 801187a: 2b00         	cmp	r3, #0x0
 801187c: d003         	beq	0x8011886 <uart_stm32_err_check+0x54> @ imm = #0x6
; 		err |= UART_ERROR_FRAMING;
 801187e: 697b         	ldr	r3, [r7, #0x14]
 8011880: f043 0304    	orr	r3, r3, #0x4
 8011884: 617b         	str	r3, [r7, #0x14]
; 	if (LL_USART_IsActiveFlag_NE(usart)) {
 8011886: 68f8         	ldr	r0, [r7, #0xc]
 8011888: f7ff fc45    	bl	0x8011116 <LL_USART_IsActiveFlag_NE> @ imm = #-0x776
 801188c: 4603         	mov	r3, r0
 801188e: 2b00         	cmp	r3, #0x0
 8011890: d003         	beq	0x801189a <uart_stm32_err_check+0x68> @ imm = #0x6
; 		err |= UART_ERROR_NOISE;
 8011892: 697b         	ldr	r3, [r7, #0x14]
 8011894: f043 0320    	orr	r3, r3, #0x20
 8011898: 617b         	str	r3, [r7, #0x14]
; 	if (LL_USART_IsActiveFlag_LBD(usart)) {
 801189a: 68f8         	ldr	r0, [r7, #0xc]
 801189c: f7ff fc83    	bl	0x80111a6 <LL_USART_IsActiveFlag_LBD> @ imm = #-0x6fa
 80118a0: 4603         	mov	r3, r0
 80118a2: 2b00         	cmp	r3, #0x0
 80118a4: d003         	beq	0x80118ae <uart_stm32_err_check+0x7c> @ imm = #0x6
; 		err |= UART_BREAK;
 80118a6: 697b         	ldr	r3, [r7, #0x14]
 80118a8: f043 0308    	orr	r3, r3, #0x8
 80118ac: 617b         	str	r3, [r7, #0x14]
; 	if (err & UART_BREAK) {
 80118ae: 697b         	ldr	r3, [r7, #0x14]
 80118b0: f003 0308    	and	r3, r3, #0x8
 80118b4: 2b00         	cmp	r3, #0x0
 80118b6: d002         	beq	0x80118be <uart_stm32_err_check+0x8c> @ imm = #0x4
; 		LL_USART_ClearFlag_LBD(usart);
 80118b8: 68f8         	ldr	r0, [r7, #0xc]
 80118ba: f7ff fccb    	bl	0x8011254 <LL_USART_ClearFlag_LBD> @ imm = #-0x66a
; 	if (err & UART_ERROR_OVERRUN) {
 80118be: 697b         	ldr	r3, [r7, #0x14]
 80118c0: f003 0301    	and	r3, r3, #0x1
 80118c4: 2b00         	cmp	r3, #0x0
 80118c6: d002         	beq	0x80118ce <uart_stm32_err_check+0x9c> @ imm = #0x4
; 		LL_USART_ClearFlag_ORE(usart);
 80118c8: 68f8         	ldr	r0, [r7, #0xc]
 80118ca: f7ff fcb2    	bl	0x8011232 <LL_USART_ClearFlag_ORE> @ imm = #-0x69c
; 	if (err & UART_ERROR_PARITY) {
 80118ce: 697b         	ldr	r3, [r7, #0x14]
 80118d0: f003 0302    	and	r3, r3, #0x2
 80118d4: 2b00         	cmp	r3, #0x0
 80118d6: d002         	beq	0x80118de <uart_stm32_err_check+0xac> @ imm = #0x4
; 		LL_USART_ClearFlag_PE(usart);
 80118d8: 68f8         	ldr	r0, [r7, #0xc]
 80118da: f7ff fc77    	bl	0x80111cc <LL_USART_ClearFlag_PE> @ imm = #-0x712
; 	if (err & UART_ERROR_FRAMING) {
 80118de: 697b         	ldr	r3, [r7, #0x14]
 80118e0: f003 0304    	and	r3, r3, #0x4
 80118e4: 2b00         	cmp	r3, #0x0
 80118e6: d002         	beq	0x80118ee <uart_stm32_err_check+0xbc> @ imm = #0x4
; 		LL_USART_ClearFlag_FE(usart);
 80118e8: 68f8         	ldr	r0, [r7, #0xc]
 80118ea: f7ff fc80    	bl	0x80111ee <LL_USART_ClearFlag_FE> @ imm = #-0x700
; 	if (err & UART_ERROR_NOISE) {
 80118ee: 697b         	ldr	r3, [r7, #0x14]
 80118f0: f003 0320    	and	r3, r3, #0x20
 80118f4: 2b00         	cmp	r3, #0x0
 80118f6: d002         	beq	0x80118fe <uart_stm32_err_check+0xcc> @ imm = #0x4
; 		LL_USART_ClearFlag_NE(usart);
 80118f8: 68f8         	ldr	r0, [r7, #0xc]
 80118fa: f7ff fc89    	bl	0x8011210 <LL_USART_ClearFlag_NE> @ imm = #-0x6ee
; 	return err;
 80118fe: 697b         	ldr	r3, [r7, #0x14]
; }
 8011900: 4618         	mov	r0, r3
 8011902: 3718         	adds	r7, #0x18
 8011904: 46bd         	mov	sp, r7
 8011906: bd80         	pop	{r7, pc}

08011908 <uart_stm32_init>:
; {
 8011908: b580         	push	{r7, lr}
 801190a: b084         	sub	sp, #0x10
 801190c: af00         	add	r7, sp, #0x0
 801190e: 6078         	str	r0, [r7, #0x4]
; 	const struct uart_stm32_config *config = dev->config;
 8011910: 687b         	ldr	r3, [r7, #0x4]
 8011912: 685b         	ldr	r3, [r3, #0x4]
 8011914: 60fb         	str	r3, [r7, #0xc]
; 	err = uart_stm32_clocks_enable(dev);
 8011916: 6878         	ldr	r0, [r7, #0x4]
 8011918: f7f4 fcda    	bl	0x80062d0 <uart_stm32_clocks_enable> @ imm = #-0xb64c
 801191c: 60b8         	str	r0, [r7, #0x8]
; 	if (err < 0) {
 801191e: 68bb         	ldr	r3, [r7, #0x8]
 8011920: 2b00         	cmp	r3, #0x0
 8011922: da01         	bge	0x8011928 <uart_stm32_init+0x20> @ imm = #0x2
; 		return err;
 8011924: 68bb         	ldr	r3, [r7, #0x8]
 8011926: e015         	b	0x8011954 <uart_stm32_init+0x4c> @ imm = #0x2a
; 	err = pinctrl_apply_state(config->pcfg, PINCTRL_STATE_DEFAULT);
 8011928: 68fb         	ldr	r3, [r7, #0xc]
 801192a: 6a1b         	ldr	r3, [r3, #0x20]
 801192c: 2100         	movs	r1, #0x0
 801192e: 4618         	mov	r0, r3
 8011930: f7ff fa7a    	bl	0x8010e28 <pinctrl_apply_state> @ imm = #-0xb0c
 8011934: 60b8         	str	r0, [r7, #0x8]
; 	if (err < 0) {
 8011936: 68bb         	ldr	r3, [r7, #0x8]
 8011938: 2b00         	cmp	r3, #0x0
 801193a: da01         	bge	0x8011940 <uart_stm32_init+0x38> @ imm = #0x2
; 		return err;
 801193c: 68bb         	ldr	r3, [r7, #0x8]
 801193e: e009         	b	0x8011954 <uart_stm32_init+0x4c> @ imm = #0x12
; 	err = uart_stm32_registers_configure(dev);
 8011940: 6878         	ldr	r0, [r7, #0x4]
 8011942: f7f4 fd2d    	bl	0x80063a0 <uart_stm32_registers_configure> @ imm = #-0xb5a6
 8011946: 60b8         	str	r0, [r7, #0x8]
; 	if (err < 0) {
 8011948: 68bb         	ldr	r3, [r7, #0x8]
 801194a: 2b00         	cmp	r3, #0x0
 801194c: da01         	bge	0x8011952 <uart_stm32_init+0x4a> @ imm = #0x2
; 		return err;
 801194e: 68bb         	ldr	r3, [r7, #0x8]
 8011950: e000         	b	0x8011954 <uart_stm32_init+0x4c> @ imm = #0x0
; 	return 0;
 8011952: 2300         	movs	r3, #0x0
; }
 8011954: 4618         	mov	r0, r3
 8011956: 3710         	adds	r7, #0x10
 8011958: 46bd         	mov	sp, r7
 801195a: bd80         	pop	{r7, pc}

0801195c <device_is_ready>:
; {
 801195c: b580         	push	{r7, lr}
 801195e: b082         	sub	sp, #0x8
 8011960: af00         	add	r7, sp, #0x0
 8011962: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 8011964: 6878         	ldr	r0, [r7, #0x4]
 8011966: f001 f8d4    	bl	0x8012b12 <z_impl_device_is_ready> @ imm = #0x11a8
 801196a: 4603         	mov	r3, r0
; }
 801196c: 4618         	mov	r0, r3
 801196e: 3708         	adds	r7, #0x8
 8011970: 46bd         	mov	sp, r7
 8011972: bd80         	pop	{r7, pc}

08011974 <z_log_msg_runtime_create>:
; {
 8011974: b580         	push	{r7, lr}
 8011976: b08a         	sub	sp, #0x28
 8011978: af04         	add	r7, sp, #0x10
 801197a: 60b9         	str	r1, [r7, #0x8]
 801197c: 607b         	str	r3, [r7, #0x4]
 801197e: 4603         	mov	r3, r0
 8011980: 73fb         	strb	r3, [r7, #0xf]
 8011982: 4613         	mov	r3, r2
 8011984: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 8011986: f107 032c    	add.w	r3, r7, #0x2c
 801198a: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 801198c: 7bba         	ldrb	r2, [r7, #0xe]
 801198e: 7bf8         	ldrb	r0, [r7, #0xf]
 8011990: 697b         	ldr	r3, [r7, #0x14]
 8011992: 9303         	str	r3, [sp, #0xc]
 8011994: 6abb         	ldr	r3, [r7, #0x28]
 8011996: 9302         	str	r3, [sp, #0x8]
 8011998: 6a7b         	ldr	r3, [r7, #0x24]
 801199a: 9301         	str	r3, [sp, #0x4]
 801199c: 6a3b         	ldr	r3, [r7, #0x20]
 801199e: 9300         	str	r3, [sp]
 80119a0: 687b         	ldr	r3, [r7, #0x4]
 80119a2: 68b9         	ldr	r1, [r7, #0x8]
 80119a4: f7ef ff4e    	bl	0x8001844 <z_log_msg_runtime_vcreate> @ imm = #-0x10164
; }
 80119a8: bf00         	nop
 80119aa: 3718         	adds	r7, #0x18
 80119ac: 46bd         	mov	sp, r7
 80119ae: bd80         	pop	{r7, pc}

080119b0 <z_impl_k_sem_count_get>:
; {
 80119b0: b480         	push	{r7}
 80119b2: b083         	sub	sp, #0xc
 80119b4: af00         	add	r7, sp, #0x0
 80119b6: 6078         	str	r0, [r7, #0x4]
; 	return sem->count;
 80119b8: 687b         	ldr	r3, [r7, #0x4]
 80119ba: 689b         	ldr	r3, [r3, #0x8]
; }
 80119bc: 4618         	mov	r0, r3
 80119be: 370c         	adds	r7, #0xc
 80119c0: 46bd         	mov	sp, r7
 80119c2: bc80         	pop	{r7}
 80119c4: 4770         	bx	lr

080119c6 <k_busy_wait>:
; {
 80119c6: b580         	push	{r7, lr}
 80119c8: b082         	sub	sp, #0x8
 80119ca: af00         	add	r7, sp, #0x0
 80119cc: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_busy_wait(usec_to_wait);
 80119ce: 6878         	ldr	r0, [r7, #0x4]
 80119d0: f001 f877    	bl	0x8012ac2 <z_impl_k_busy_wait> @ imm = #0x10ee
; }
 80119d4: bf00         	nop
 80119d6: 3708         	adds	r7, #0x8
 80119d8: 46bd         	mov	sp, r7
 80119da: bd80         	pop	{r7, pc}

080119dc <k_sem_take>:
; {
 80119dc: b580         	push	{r7, lr}
 80119de: b084         	sub	sp, #0x10
 80119e0: af00         	add	r7, sp, #0x0
 80119e2: 60f8         	str	r0, [r7, #0xc]
 80119e4: e9c7 2300    	strd	r2, r3, [r7]
; 	return z_impl_k_sem_take(sem, timeout);
 80119e8: e9d7 2300    	ldrd	r2, r3, [r7]
 80119ec: 68f8         	ldr	r0, [r7, #0xc]
 80119ee: f7f8 fb9d    	bl	0x800a12c <z_impl_k_sem_take> @ imm = #-0x78c6
 80119f2: 4603         	mov	r3, r0
; }
 80119f4: 4618         	mov	r0, r3
 80119f6: 3710         	adds	r7, #0x10
 80119f8: 46bd         	mov	sp, r7
 80119fa: bd80         	pop	{r7, pc}

080119fc <k_sem_give>:
; {
 80119fc: b580         	push	{r7, lr}
 80119fe: b082         	sub	sp, #0x8
 8011a00: af00         	add	r7, sp, #0x0
 8011a02: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_sem_give(sem);
 8011a04: 6878         	ldr	r0, [r7, #0x4]
 8011a06: f7f8 fb03    	bl	0x800a010 <z_impl_k_sem_give> @ imm = #-0x79fa
; }
 8011a0a: bf00         	nop
 8011a0c: 3708         	adds	r7, #0x8
 8011a0e: 46bd         	mov	sp, r7
 8011a10: bd80         	pop	{r7, pc}

08011a12 <k_sem_count_get>:
; {
 8011a12: b580         	push	{r7, lr}
 8011a14: b082         	sub	sp, #0x8
 8011a16: af00         	add	r7, sp, #0x0
 8011a18: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_k_sem_count_get(sem);
 8011a1a: 6878         	ldr	r0, [r7, #0x4]
 8011a1c: f7ff ffc8    	bl	0x80119b0 <z_impl_k_sem_count_get> @ imm = #-0x70
 8011a20: 4603         	mov	r3, r0
; }
 8011a22: 4618         	mov	r0, r3
 8011a24: 3708         	adds	r7, #0x8
 8011a26: 46bd         	mov	sp, r7
 8011a28: bd80         	pop	{r7, pc}

08011a2a <LL_SPI_Enable>:
; {
 8011a2a: b480         	push	{r7}
 8011a2c: b083         	sub	sp, #0xc
 8011a2e: af00         	add	r7, sp, #0x0
 8011a30: 6078         	str	r0, [r7, #0x4]
;   SET_BIT(SPIx->CR1, SPI_CR1_SPE);
 8011a32: 687b         	ldr	r3, [r7, #0x4]
 8011a34: 681b         	ldr	r3, [r3]
 8011a36: f043 0240    	orr	r2, r3, #0x40
 8011a3a: 687b         	ldr	r3, [r7, #0x4]
 8011a3c: 601a         	str	r2, [r3]
; }
 8011a3e: bf00         	nop
 8011a40: 370c         	adds	r7, #0xc
 8011a42: 46bd         	mov	sp, r7
 8011a44: bc80         	pop	{r7}
 8011a46: 4770         	bx	lr

08011a48 <LL_SPI_Disable>:
; {
 8011a48: b480         	push	{r7}
 8011a4a: b083         	sub	sp, #0xc
 8011a4c: af00         	add	r7, sp, #0x0
 8011a4e: 6078         	str	r0, [r7, #0x4]
;   CLEAR_BIT(SPIx->CR1, SPI_CR1_SPE);
 8011a50: 687b         	ldr	r3, [r7, #0x4]
 8011a52: 681b         	ldr	r3, [r3]
 8011a54: f023 0240    	bic	r2, r3, #0x40
 8011a58: 687b         	ldr	r3, [r7, #0x4]
 8011a5a: 601a         	str	r2, [r3]
; }
 8011a5c: bf00         	nop
 8011a5e: 370c         	adds	r7, #0xc
 8011a60: 46bd         	mov	sp, r7
 8011a62: bc80         	pop	{r7}
 8011a64: 4770         	bx	lr

08011a66 <LL_SPI_IsEnabled>:
; {
 8011a66: b480         	push	{r7}
 8011a68: b083         	sub	sp, #0xc
 8011a6a: af00         	add	r7, sp, #0x0
 8011a6c: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(SPIx->CR1, SPI_CR1_SPE) == (SPI_CR1_SPE)) ? 1UL : 0UL);
 8011a6e: 687b         	ldr	r3, [r7, #0x4]
 8011a70: 681b         	ldr	r3, [r3]
 8011a72: f003 0340    	and	r3, r3, #0x40
 8011a76: 2b40         	cmp	r3, #0x40
 8011a78: d101         	bne	0x8011a7e <LL_SPI_IsEnabled+0x18> @ imm = #0x2
 8011a7a: 2301         	movs	r3, #0x1
 8011a7c: e000         	b	0x8011a80 <LL_SPI_IsEnabled+0x1a> @ imm = #0x0
 8011a7e: 2300         	movs	r3, #0x0
; }
 8011a80: 4618         	mov	r0, r3
 8011a82: 370c         	adds	r7, #0xc
 8011a84: 46bd         	mov	sp, r7
 8011a86: bc80         	pop	{r7}
 8011a88: 4770         	bx	lr

08011a8a <LL_SPI_SetMode>:
; {
 8011a8a: b480         	push	{r7}
 8011a8c: b083         	sub	sp, #0xc
 8011a8e: af00         	add	r7, sp, #0x0
 8011a90: 6078         	str	r0, [r7, #0x4]
 8011a92: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CR1, SPI_CR1_MSTR | SPI_CR1_SSI, Mode);
 8011a94: 687b         	ldr	r3, [r7, #0x4]
 8011a96: 681b         	ldr	r3, [r3]
 8011a98: f423 7282    	bic	r2, r3, #0x104
 8011a9c: 683b         	ldr	r3, [r7]
 8011a9e: 431a         	orrs	r2, r3
 8011aa0: 687b         	ldr	r3, [r7, #0x4]
 8011aa2: 601a         	str	r2, [r3]
; }
 8011aa4: bf00         	nop
 8011aa6: 370c         	adds	r7, #0xc
 8011aa8: 46bd         	mov	sp, r7
 8011aaa: bc80         	pop	{r7}
 8011aac: 4770         	bx	lr

08011aae <LL_SPI_GetMode>:
; {
 8011aae: b480         	push	{r7}
 8011ab0: b083         	sub	sp, #0xc
 8011ab2: af00         	add	r7, sp, #0x0
 8011ab4: 6078         	str	r0, [r7, #0x4]
;   return (uint32_t)(READ_BIT(SPIx->CR1, SPI_CR1_MSTR | SPI_CR1_SSI));
 8011ab6: 687b         	ldr	r3, [r7, #0x4]
 8011ab8: 681b         	ldr	r3, [r3]
 8011aba: f403 7382    	and	r3, r3, #0x104
; }
 8011abe: 4618         	mov	r0, r3
 8011ac0: 370c         	adds	r7, #0xc
 8011ac2: 46bd         	mov	sp, r7
 8011ac4: bc80         	pop	{r7}
 8011ac6: 4770         	bx	lr

08011ac8 <LL_SPI_SetStandard>:
; {
 8011ac8: b480         	push	{r7}
 8011aca: b083         	sub	sp, #0xc
 8011acc: af00         	add	r7, sp, #0x0
 8011ace: 6078         	str	r0, [r7, #0x4]
 8011ad0: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CR2, SPI_CR2_FRF, Standard);
 8011ad2: 687b         	ldr	r3, [r7, #0x4]
 8011ad4: 685b         	ldr	r3, [r3, #0x4]
 8011ad6: f023 0210    	bic	r2, r3, #0x10
 8011ada: 683b         	ldr	r3, [r7]
 8011adc: 431a         	orrs	r2, r3
 8011ade: 687b         	ldr	r3, [r7, #0x4]
 8011ae0: 605a         	str	r2, [r3, #0x4]
; }
 8011ae2: bf00         	nop
 8011ae4: 370c         	adds	r7, #0xc
 8011ae6: 46bd         	mov	sp, r7
 8011ae8: bc80         	pop	{r7}
 8011aea: 4770         	bx	lr

08011aec <LL_SPI_SetClockPhase>:
; {
 8011aec: b480         	push	{r7}
 8011aee: b083         	sub	sp, #0xc
 8011af0: af00         	add	r7, sp, #0x0
 8011af2: 6078         	str	r0, [r7, #0x4]
 8011af4: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CR1, SPI_CR1_CPHA, ClockPhase);
 8011af6: 687b         	ldr	r3, [r7, #0x4]
 8011af8: 681b         	ldr	r3, [r3]
 8011afa: f023 0201    	bic	r2, r3, #0x1
 8011afe: 683b         	ldr	r3, [r7]
 8011b00: 431a         	orrs	r2, r3
 8011b02: 687b         	ldr	r3, [r7, #0x4]
 8011b04: 601a         	str	r2, [r3]
; }
 8011b06: bf00         	nop
 8011b08: 370c         	adds	r7, #0xc
 8011b0a: 46bd         	mov	sp, r7
 8011b0c: bc80         	pop	{r7}
 8011b0e: 4770         	bx	lr

08011b10 <LL_SPI_SetClockPolarity>:
; {
 8011b10: b480         	push	{r7}
 8011b12: b083         	sub	sp, #0xc
 8011b14: af00         	add	r7, sp, #0x0
 8011b16: 6078         	str	r0, [r7, #0x4]
 8011b18: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CR1, SPI_CR1_CPOL, ClockPolarity);
 8011b1a: 687b         	ldr	r3, [r7, #0x4]
 8011b1c: 681b         	ldr	r3, [r3]
 8011b1e: f023 0202    	bic	r2, r3, #0x2
 8011b22: 683b         	ldr	r3, [r7]
 8011b24: 431a         	orrs	r2, r3
 8011b26: 687b         	ldr	r3, [r7, #0x4]
 8011b28: 601a         	str	r2, [r3]
; }
 8011b2a: bf00         	nop
 8011b2c: 370c         	adds	r7, #0xc
 8011b2e: 46bd         	mov	sp, r7
 8011b30: bc80         	pop	{r7}
 8011b32: 4770         	bx	lr

08011b34 <LL_SPI_SetBaudRatePrescaler>:
; {
 8011b34: b480         	push	{r7}
 8011b36: b083         	sub	sp, #0xc
 8011b38: af00         	add	r7, sp, #0x0
 8011b3a: 6078         	str	r0, [r7, #0x4]
 8011b3c: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CR1, SPI_CR1_BR, BaudRate);
 8011b3e: 687b         	ldr	r3, [r7, #0x4]
 8011b40: 681b         	ldr	r3, [r3]
 8011b42: f023 0238    	bic	r2, r3, #0x38
 8011b46: 683b         	ldr	r3, [r7]
 8011b48: 431a         	orrs	r2, r3
 8011b4a: 687b         	ldr	r3, [r7, #0x4]
 8011b4c: 601a         	str	r2, [r3]
; }
 8011b4e: bf00         	nop
 8011b50: 370c         	adds	r7, #0xc
 8011b52: 46bd         	mov	sp, r7
 8011b54: bc80         	pop	{r7}
 8011b56: 4770         	bx	lr

08011b58 <LL_SPI_SetTransferBitOrder>:
; {
 8011b58: b480         	push	{r7}
 8011b5a: b083         	sub	sp, #0xc
 8011b5c: af00         	add	r7, sp, #0x0
 8011b5e: 6078         	str	r0, [r7, #0x4]
 8011b60: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CR1, SPI_CR1_LSBFIRST, BitOrder);
 8011b62: 687b         	ldr	r3, [r7, #0x4]
 8011b64: 681b         	ldr	r3, [r3]
 8011b66: f023 0280    	bic	r2, r3, #0x80
 8011b6a: 683b         	ldr	r3, [r7]
 8011b6c: 431a         	orrs	r2, r3
 8011b6e: 687b         	ldr	r3, [r7, #0x4]
 8011b70: 601a         	str	r2, [r3]
; }
 8011b72: bf00         	nop
 8011b74: 370c         	adds	r7, #0xc
 8011b76: 46bd         	mov	sp, r7
 8011b78: bc80         	pop	{r7}
 8011b7a: 4770         	bx	lr

08011b7c <LL_SPI_SetTransferDirection>:
; {
 8011b7c: b480         	push	{r7}
 8011b7e: b083         	sub	sp, #0xc
 8011b80: af00         	add	r7, sp, #0x0
 8011b82: 6078         	str	r0, [r7, #0x4]
 8011b84: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CR1, SPI_CR1_RXONLY | SPI_CR1_BIDIMODE | SPI_CR1_BIDIOE, TransferDirection);
 8011b86: 687b         	ldr	r3, [r7, #0x4]
 8011b88: 681b         	ldr	r3, [r3]
 8011b8a: f423 4244    	bic	r2, r3, #0xc400
 8011b8e: 683b         	ldr	r3, [r7]
 8011b90: 431a         	orrs	r2, r3
 8011b92: 687b         	ldr	r3, [r7, #0x4]
 8011b94: 601a         	str	r2, [r3]
; }
 8011b96: bf00         	nop
 8011b98: 370c         	adds	r7, #0xc
 8011b9a: 46bd         	mov	sp, r7
 8011b9c: bc80         	pop	{r7}
 8011b9e: 4770         	bx	lr

08011ba0 <LL_SPI_SetDataWidth>:
; {
 8011ba0: b480         	push	{r7}
 8011ba2: b083         	sub	sp, #0xc
 8011ba4: af00         	add	r7, sp, #0x0
 8011ba6: 6078         	str	r0, [r7, #0x4]
 8011ba8: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CR1, SPI_CR1_DFF, DataWidth);
 8011baa: 687b         	ldr	r3, [r7, #0x4]
 8011bac: 681b         	ldr	r3, [r3]
 8011bae: f423 6200    	bic	r2, r3, #0x800
 8011bb2: 683b         	ldr	r3, [r7]
 8011bb4: 431a         	orrs	r2, r3
 8011bb6: 687b         	ldr	r3, [r7, #0x4]
 8011bb8: 601a         	str	r2, [r3]
; }
 8011bba: bf00         	nop
 8011bbc: 370c         	adds	r7, #0xc
 8011bbe: 46bd         	mov	sp, r7
 8011bc0: bc80         	pop	{r7}
 8011bc2: 4770         	bx	lr

08011bc4 <LL_SPI_DisableCRC>:
; {
 8011bc4: b480         	push	{r7}
 8011bc6: b083         	sub	sp, #0xc
 8011bc8: af00         	add	r7, sp, #0x0
 8011bca: 6078         	str	r0, [r7, #0x4]
;   CLEAR_BIT(SPIx->CR1, SPI_CR1_CRCEN);
 8011bcc: 687b         	ldr	r3, [r7, #0x4]
 8011bce: 681b         	ldr	r3, [r3]
 8011bd0: f423 5200    	bic	r2, r3, #0x2000
 8011bd4: 687b         	ldr	r3, [r7, #0x4]
 8011bd6: 601a         	str	r2, [r3]
; }
 8011bd8: bf00         	nop
 8011bda: 370c         	adds	r7, #0xc
 8011bdc: 46bd         	mov	sp, r7
 8011bde: bc80         	pop	{r7}
 8011be0: 4770         	bx	lr

08011be2 <LL_SPI_SetNSSMode>:
; {
 8011be2: b480         	push	{r7}
 8011be4: b083         	sub	sp, #0xc
 8011be6: af00         	add	r7, sp, #0x0
 8011be8: 6078         	str	r0, [r7, #0x4]
 8011bea: 6039         	str	r1, [r7]
;   MODIFY_REG(SPIx->CR1, SPI_CR1_SSM,  NSS);
 8011bec: 687b         	ldr	r3, [r7, #0x4]
 8011bee: 681b         	ldr	r3, [r3]
 8011bf0: f423 7200    	bic	r2, r3, #0x200
 8011bf4: 683b         	ldr	r3, [r7]
 8011bf6: 431a         	orrs	r2, r3
 8011bf8: 687b         	ldr	r3, [r7, #0x4]
 8011bfa: 601a         	str	r2, [r3]
;   MODIFY_REG(SPIx->CR2, SPI_CR2_SSOE, ((uint32_t)(NSS >> 16U)));
 8011bfc: 687b         	ldr	r3, [r7, #0x4]
 8011bfe: 685b         	ldr	r3, [r3, #0x4]
 8011c00: f023 0204    	bic	r2, r3, #0x4
 8011c04: 683b         	ldr	r3, [r7]
 8011c06: 0c1b         	lsrs	r3, r3, #0x10
 8011c08: 431a         	orrs	r2, r3
 8011c0a: 687b         	ldr	r3, [r7, #0x4]
 8011c0c: 605a         	str	r2, [r3, #0x4]
; }
 8011c0e: bf00         	nop
 8011c10: 370c         	adds	r7, #0xc
 8011c12: 46bd         	mov	sp, r7
 8011c14: bc80         	pop	{r7}
 8011c16: 4770         	bx	lr

08011c18 <LL_SPI_IsActiveFlag_RXNE>:
; {
 8011c18: b480         	push	{r7}
 8011c1a: b083         	sub	sp, #0xc
 8011c1c: af00         	add	r7, sp, #0x0
 8011c1e: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(SPIx->SR, SPI_SR_RXNE) == (SPI_SR_RXNE)) ? 1UL : 0UL);
 8011c20: 687b         	ldr	r3, [r7, #0x4]
 8011c22: 689b         	ldr	r3, [r3, #0x8]
 8011c24: f003 0301    	and	r3, r3, #0x1
 8011c28: 2b01         	cmp	r3, #0x1
 8011c2a: d101         	bne	0x8011c30 <LL_SPI_IsActiveFlag_RXNE+0x18> @ imm = #0x2
 8011c2c: 2301         	movs	r3, #0x1
 8011c2e: e000         	b	0x8011c32 <LL_SPI_IsActiveFlag_RXNE+0x1a> @ imm = #0x0
 8011c30: 2300         	movs	r3, #0x0
; }
 8011c32: 4618         	mov	r0, r3
 8011c34: 370c         	adds	r7, #0xc
 8011c36: 46bd         	mov	sp, r7
 8011c38: bc80         	pop	{r7}
 8011c3a: 4770         	bx	lr

08011c3c <LL_SPI_IsActiveFlag_TXE>:
; {
 8011c3c: b480         	push	{r7}
 8011c3e: b083         	sub	sp, #0xc
 8011c40: af00         	add	r7, sp, #0x0
 8011c42: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(SPIx->SR, SPI_SR_TXE) == (SPI_SR_TXE)) ? 1UL : 0UL);
 8011c44: 687b         	ldr	r3, [r7, #0x4]
 8011c46: 689b         	ldr	r3, [r3, #0x8]
 8011c48: f003 0302    	and	r3, r3, #0x2
 8011c4c: 2b02         	cmp	r3, #0x2
 8011c4e: d101         	bne	0x8011c54 <LL_SPI_IsActiveFlag_TXE+0x18> @ imm = #0x2
 8011c50: 2301         	movs	r3, #0x1
 8011c52: e000         	b	0x8011c56 <LL_SPI_IsActiveFlag_TXE+0x1a> @ imm = #0x0
 8011c54: 2300         	movs	r3, #0x0
; }
 8011c56: 4618         	mov	r0, r3
 8011c58: 370c         	adds	r7, #0xc
 8011c5a: 46bd         	mov	sp, r7
 8011c5c: bc80         	pop	{r7}
 8011c5e: 4770         	bx	lr

08011c60 <LL_SPI_IsActiveFlag_MODF>:
; {
 8011c60: b480         	push	{r7}
 8011c62: b083         	sub	sp, #0xc
 8011c64: af00         	add	r7, sp, #0x0
 8011c66: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(SPIx->SR, SPI_SR_MODF) == (SPI_SR_MODF)) ? 1UL : 0UL);
 8011c68: 687b         	ldr	r3, [r7, #0x4]
 8011c6a: 689b         	ldr	r3, [r3, #0x8]
 8011c6c: f003 0320    	and	r3, r3, #0x20
 8011c70: 2b20         	cmp	r3, #0x20
 8011c72: d101         	bne	0x8011c78 <LL_SPI_IsActiveFlag_MODF+0x18> @ imm = #0x2
 8011c74: 2301         	movs	r3, #0x1
 8011c76: e000         	b	0x8011c7a <LL_SPI_IsActiveFlag_MODF+0x1a> @ imm = #0x0
 8011c78: 2300         	movs	r3, #0x0
; }
 8011c7a: 4618         	mov	r0, r3
 8011c7c: 370c         	adds	r7, #0xc
 8011c7e: 46bd         	mov	sp, r7
 8011c80: bc80         	pop	{r7}
 8011c82: 4770         	bx	lr

08011c84 <LL_SPI_IsActiveFlag_OVR>:
; {
 8011c84: b480         	push	{r7}
 8011c86: b083         	sub	sp, #0xc
 8011c88: af00         	add	r7, sp, #0x0
 8011c8a: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(SPIx->SR, SPI_SR_OVR) == (SPI_SR_OVR)) ? 1UL : 0UL);
 8011c8c: 687b         	ldr	r3, [r7, #0x4]
 8011c8e: 689b         	ldr	r3, [r3, #0x8]
 8011c90: f003 0340    	and	r3, r3, #0x40
 8011c94: 2b40         	cmp	r3, #0x40
 8011c96: d101         	bne	0x8011c9c <LL_SPI_IsActiveFlag_OVR+0x18> @ imm = #0x2
 8011c98: 2301         	movs	r3, #0x1
 8011c9a: e000         	b	0x8011c9e <LL_SPI_IsActiveFlag_OVR+0x1a> @ imm = #0x0
 8011c9c: 2300         	movs	r3, #0x0
; }
 8011c9e: 4618         	mov	r0, r3
 8011ca0: 370c         	adds	r7, #0xc
 8011ca2: 46bd         	mov	sp, r7
 8011ca4: bc80         	pop	{r7}
 8011ca6: 4770         	bx	lr

08011ca8 <LL_SPI_IsActiveFlag_BSY>:
; {
 8011ca8: b480         	push	{r7}
 8011caa: b083         	sub	sp, #0xc
 8011cac: af00         	add	r7, sp, #0x0
 8011cae: 6078         	str	r0, [r7, #0x4]
;   return ((READ_BIT(SPIx->SR, SPI_SR_BSY) == (SPI_SR_BSY)) ? 1UL : 0UL);
 8011cb0: 687b         	ldr	r3, [r7, #0x4]
 8011cb2: 689b         	ldr	r3, [r3, #0x8]
 8011cb4: f003 0380    	and	r3, r3, #0x80
 8011cb8: 2b80         	cmp	r3, #0x80
 8011cba: d101         	bne	0x8011cc0 <LL_SPI_IsActiveFlag_BSY+0x18> @ imm = #0x2
 8011cbc: 2301         	movs	r3, #0x1
 8011cbe: e000         	b	0x8011cc2 <LL_SPI_IsActiveFlag_BSY+0x1a> @ imm = #0x0
 8011cc0: 2300         	movs	r3, #0x0
; }
 8011cc2: 4618         	mov	r0, r3
 8011cc4: 370c         	adds	r7, #0xc
 8011cc6: 46bd         	mov	sp, r7
 8011cc8: bc80         	pop	{r7}
 8011cca: 4770         	bx	lr

08011ccc <LL_SPI_ClearFlag_MODF>:
; {
 8011ccc: b480         	push	{r7}
 8011cce: b085         	sub	sp, #0x14
 8011cd0: af00         	add	r7, sp, #0x0
 8011cd2: 6078         	str	r0, [r7, #0x4]
;   tmpreg_sr = SPIx->SR;
 8011cd4: 687b         	ldr	r3, [r7, #0x4]
 8011cd6: 689b         	ldr	r3, [r3, #0x8]
 8011cd8: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg_sr;
 8011cda: 68fb         	ldr	r3, [r7, #0xc]
;   CLEAR_BIT(SPIx->CR1, SPI_CR1_SPE);
 8011cdc: 687b         	ldr	r3, [r7, #0x4]
 8011cde: 681b         	ldr	r3, [r3]
 8011ce0: f023 0240    	bic	r2, r3, #0x40
 8011ce4: 687b         	ldr	r3, [r7, #0x4]
 8011ce6: 601a         	str	r2, [r3]
; }
 8011ce8: bf00         	nop
 8011cea: 3714         	adds	r7, #0x14
 8011cec: 46bd         	mov	sp, r7
 8011cee: bc80         	pop	{r7}
 8011cf0: 4770         	bx	lr

08011cf2 <LL_SPI_ClearFlag_OVR>:
; {
 8011cf2: b480         	push	{r7}
 8011cf4: b085         	sub	sp, #0x14
 8011cf6: af00         	add	r7, sp, #0x0
 8011cf8: 6078         	str	r0, [r7, #0x4]
;   tmpreg = SPIx->DR;
 8011cfa: 687b         	ldr	r3, [r7, #0x4]
 8011cfc: 68db         	ldr	r3, [r3, #0xc]
 8011cfe: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 8011d00: 68fb         	ldr	r3, [r7, #0xc]
;   tmpreg = SPIx->SR;
 8011d02: 687b         	ldr	r3, [r7, #0x4]
 8011d04: 689b         	ldr	r3, [r3, #0x8]
 8011d06: 60fb         	str	r3, [r7, #0xc]
;   (void) tmpreg;
 8011d08: 68fb         	ldr	r3, [r7, #0xc]
; }
 8011d0a: bf00         	nop
 8011d0c: 3714         	adds	r7, #0x14
 8011d0e: 46bd         	mov	sp, r7
 8011d10: bc80         	pop	{r7}
 8011d12: 4770         	bx	lr

08011d14 <LL_SPI_DisableIT_TXE>:
; {
 8011d14: b480         	push	{r7}
 8011d16: b083         	sub	sp, #0xc
 8011d18: af00         	add	r7, sp, #0x0
 8011d1a: 6078         	str	r0, [r7, #0x4]
;   CLEAR_BIT(SPIx->CR2, SPI_CR2_TXEIE);
 8011d1c: 687b         	ldr	r3, [r7, #0x4]
 8011d1e: 685b         	ldr	r3, [r3, #0x4]
 8011d20: f023 0280    	bic	r2, r3, #0x80
 8011d24: 687b         	ldr	r3, [r7, #0x4]
 8011d26: 605a         	str	r2, [r3, #0x4]
; }
 8011d28: bf00         	nop
 8011d2a: 370c         	adds	r7, #0xc
 8011d2c: 46bd         	mov	sp, r7
 8011d2e: bc80         	pop	{r7}
 8011d30: 4770         	bx	lr

08011d32 <LL_SPI_ReceiveData8>:
; {
 8011d32: b480         	push	{r7}
 8011d34: b083         	sub	sp, #0xc
 8011d36: af00         	add	r7, sp, #0x0
 8011d38: 6078         	str	r0, [r7, #0x4]
;   return (*((__IO uint8_t *)&SPIx->DR));
 8011d3a: 687b         	ldr	r3, [r7, #0x4]
 8011d3c: 330c         	adds	r3, #0xc
 8011d3e: 781b         	ldrb	r3, [r3]
 8011d40: b2db         	uxtb	r3, r3
; }
 8011d42: 4618         	mov	r0, r3
 8011d44: 370c         	adds	r7, #0xc
 8011d46: 46bd         	mov	sp, r7
 8011d48: bc80         	pop	{r7}
 8011d4a: 4770         	bx	lr

08011d4c <LL_SPI_ReceiveData16>:
; {
 8011d4c: b480         	push	{r7}
 8011d4e: b083         	sub	sp, #0xc
 8011d50: af00         	add	r7, sp, #0x0
 8011d52: 6078         	str	r0, [r7, #0x4]
;   return (uint16_t)(READ_REG(SPIx->DR));
 8011d54: 687b         	ldr	r3, [r7, #0x4]
 8011d56: 68db         	ldr	r3, [r3, #0xc]
 8011d58: b29b         	uxth	r3, r3
; }
 8011d5a: 4618         	mov	r0, r3
 8011d5c: 370c         	adds	r7, #0xc
 8011d5e: 46bd         	mov	sp, r7
 8011d60: bc80         	pop	{r7}
 8011d62: 4770         	bx	lr

08011d64 <LL_SPI_TransmitData8>:
; {
 8011d64: b480         	push	{r7}
 8011d66: b085         	sub	sp, #0x14
 8011d68: af00         	add	r7, sp, #0x0
 8011d6a: 6078         	str	r0, [r7, #0x4]
 8011d6c: 460b         	mov	r3, r1
 8011d6e: 70fb         	strb	r3, [r7, #0x3]
;   __IO uint8_t *spidr = ((__IO uint8_t *)&SPIx->DR);
 8011d70: 687b         	ldr	r3, [r7, #0x4]
 8011d72: 330c         	adds	r3, #0xc
 8011d74: 60fb         	str	r3, [r7, #0xc]
;   *spidr = TxData;
 8011d76: 68fb         	ldr	r3, [r7, #0xc]
 8011d78: 78fa         	ldrb	r2, [r7, #0x3]
 8011d7a: 701a         	strb	r2, [r3]
; }
 8011d7c: bf00         	nop
 8011d7e: 3714         	adds	r7, #0x14
 8011d80: 46bd         	mov	sp, r7
 8011d82: bc80         	pop	{r7}
 8011d84: 4770         	bx	lr

08011d86 <LL_SPI_TransmitData16>:
; {
 8011d86: b480         	push	{r7}
 8011d88: b085         	sub	sp, #0x14
 8011d8a: af00         	add	r7, sp, #0x0
 8011d8c: 6078         	str	r0, [r7, #0x4]
 8011d8e: 460b         	mov	r3, r1
 8011d90: 807b         	strh	r3, [r7, #0x2]
;   __IO uint16_t *spidr = ((__IO uint16_t *)&SPIx->DR);
 8011d92: 687b         	ldr	r3, [r7, #0x4]
 8011d94: 330c         	adds	r3, #0xc
 8011d96: 60fb         	str	r3, [r7, #0xc]
;   *spidr = TxData;
 8011d98: 68fb         	ldr	r3, [r7, #0xc]
 8011d9a: 887a         	ldrh	r2, [r7, #0x2]
 8011d9c: 801a         	strh	r2, [r3]
; }
 8011d9e: bf00         	nop
 8011da0: 3714         	adds	r7, #0x14
 8011da2: 46bd         	mov	sp, r7
 8011da4: bc80         	pop	{r7}
 8011da6: 4770         	bx	lr

08011da8 <z_impl_gpio_pin_configure>:
; {
 8011da8: b580         	push	{r7, lr}
 8011daa: b088         	sub	sp, #0x20
 8011dac: af00         	add	r7, sp, #0x0
 8011dae: 60f8         	str	r0, [r7, #0xc]
 8011db0: 460b         	mov	r3, r1
 8011db2: 607a         	str	r2, [r7, #0x4]
 8011db4: 72fb         	strb	r3, [r7, #0xb]
; 	const struct gpio_driver_api *api =
 8011db6: 68fb         	ldr	r3, [r7, #0xc]
 8011db8: 689b         	ldr	r3, [r3, #0x8]
 8011dba: 61fb         	str	r3, [r7, #0x1c]
; 	__unused const struct gpio_driver_config *const cfg =
 8011dbc: 68fb         	ldr	r3, [r7, #0xc]
 8011dbe: 685b         	ldr	r3, [r3, #0x4]
 8011dc0: 61bb         	str	r3, [r7, #0x18]
; 	struct gpio_driver_data *data =
 8011dc2: 68fb         	ldr	r3, [r7, #0xc]
 8011dc4: 691b         	ldr	r3, [r3, #0x10]
 8011dc6: 617b         	str	r3, [r7, #0x14]
; 	if (((flags & GPIO_OUTPUT_INIT_LOGICAL) != 0)
 8011dc8: 687b         	ldr	r3, [r7, #0x4]
 8011dca: f403 1380    	and	r3, r3, #0x100000
 8011dce: 2b00         	cmp	r3, #0x0
 8011dd0: d00d         	beq	0x8011dee <z_impl_gpio_pin_configure+0x46> @ imm = #0x1a
; 	    && ((flags & (GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH)) != 0)
 8011dd2: 687b         	ldr	r3, [r7, #0x4]
 8011dd4: f403 2340    	and	r3, r3, #0xc0000
 8011dd8: 2b00         	cmp	r3, #0x0
 8011dda: d008         	beq	0x8011dee <z_impl_gpio_pin_configure+0x46> @ imm = #0x10
; 	    && ((flags & GPIO_ACTIVE_LOW) != 0)) {
 8011ddc: 687b         	ldr	r3, [r7, #0x4]
 8011dde: f003 0301    	and	r3, r3, #0x1
 8011de2: 2b00         	cmp	r3, #0x0
 8011de4: d003         	beq	0x8011dee <z_impl_gpio_pin_configure+0x46> @ imm = #0x6
; 		flags ^= GPIO_OUTPUT_INIT_LOW | GPIO_OUTPUT_INIT_HIGH;
 8011de6: 687b         	ldr	r3, [r7, #0x4]
 8011de8: f483 2340    	eor	r3, r3, #0xc0000
 8011dec: 607b         	str	r3, [r7, #0x4]
; 	flags &= ~GPIO_OUTPUT_INIT_LOGICAL;
 8011dee: 687b         	ldr	r3, [r7, #0x4]
 8011df0: f423 1380    	bic	r3, r3, #0x100000
 8011df4: 607b         	str	r3, [r7, #0x4]
; 	if ((flags & GPIO_ACTIVE_LOW) != 0) {
 8011df6: 687b         	ldr	r3, [r7, #0x4]
 8011df8: f003 0301    	and	r3, r3, #0x1
 8011dfc: 2b00         	cmp	r3, #0x0
 8011dfe: d009         	beq	0x8011e14 <z_impl_gpio_pin_configure+0x6c> @ imm = #0x12
; 		data->invert |= (gpio_port_pins_t)BIT(pin);
 8011e00: 697b         	ldr	r3, [r7, #0x14]
 8011e02: 681a         	ldr	r2, [r3]
 8011e04: 7afb         	ldrb	r3, [r7, #0xb]
 8011e06: 2101         	movs	r1, #0x1
 8011e08: fa01 f303    	lsl.w	r3, r1, r3
 8011e0c: 431a         	orrs	r2, r3
 8011e0e: 697b         	ldr	r3, [r7, #0x14]
 8011e10: 601a         	str	r2, [r3]
 8011e12: e009         	b	0x8011e28 <z_impl_gpio_pin_configure+0x80> @ imm = #0x12
; 		data->invert &= ~(gpio_port_pins_t)BIT(pin);
 8011e14: 697b         	ldr	r3, [r7, #0x14]
 8011e16: 681a         	ldr	r2, [r3]
 8011e18: 7afb         	ldrb	r3, [r7, #0xb]
 8011e1a: 2101         	movs	r1, #0x1
 8011e1c: fa01 f303    	lsl.w	r3, r1, r3
 8011e20: 43db         	mvns	r3, r3
 8011e22: 401a         	ands	r2, r3
 8011e24: 697b         	ldr	r3, [r7, #0x14]
 8011e26: 601a         	str	r2, [r3]
; 	return api->pin_configure(port, pin, flags);
 8011e28: 69fb         	ldr	r3, [r7, #0x1c]
 8011e2a: 681b         	ldr	r3, [r3]
 8011e2c: 7af9         	ldrb	r1, [r7, #0xb]
 8011e2e: 687a         	ldr	r2, [r7, #0x4]
 8011e30: 68f8         	ldr	r0, [r7, #0xc]
 8011e32: 4798         	blx	r3
 8011e34: 4603         	mov	r3, r0
; }
 8011e36: 4618         	mov	r0, r3
 8011e38: 3720         	adds	r7, #0x20
 8011e3a: 46bd         	mov	sp, r7
 8011e3c: bd80         	pop	{r7, pc}

08011e3e <gpio_pin_configure_dt>:
; {
 8011e3e: b580         	push	{r7, lr}
 8011e40: b082         	sub	sp, #0x8
 8011e42: af00         	add	r7, sp, #0x0
 8011e44: 6078         	str	r0, [r7, #0x4]
 8011e46: 6039         	str	r1, [r7]
; 	return gpio_pin_configure(spec->port,
 8011e48: 687b         	ldr	r3, [r7, #0x4]
 8011e4a: 6818         	ldr	r0, [r3]
; 				  spec->pin,
 8011e4c: 687b         	ldr	r3, [r7, #0x4]
 8011e4e: 7919         	ldrb	r1, [r3, #0x4]
; 				  spec->dt_flags | extra_flags);
 8011e50: 687b         	ldr	r3, [r7, #0x4]
 8011e52: 88db         	ldrh	r3, [r3, #0x6]
 8011e54: 461a         	mov	r2, r3
; 	return gpio_pin_configure(spec->port,
 8011e56: 683b         	ldr	r3, [r7]
 8011e58: 4313         	orrs	r3, r2
 8011e5a: 461a         	mov	r2, r3
 8011e5c: f000 f888    	bl	0x8011f70 <gpio_pin_configure> @ imm = #0x110
 8011e60: 4603         	mov	r3, r0
; }
 8011e62: 4618         	mov	r0, r3
 8011e64: 3708         	adds	r7, #0x8
 8011e66: 46bd         	mov	sp, r7
 8011e68: bd80         	pop	{r7, pc}

08011e6a <z_impl_gpio_port_set_bits_raw>:
; {
 8011e6a: b580         	push	{r7, lr}
 8011e6c: b084         	sub	sp, #0x10
 8011e6e: af00         	add	r7, sp, #0x0
 8011e70: 6078         	str	r0, [r7, #0x4]
 8011e72: 6039         	str	r1, [r7]
; 	const struct gpio_driver_api *api =
 8011e74: 687b         	ldr	r3, [r7, #0x4]
 8011e76: 689b         	ldr	r3, [r3, #0x8]
 8011e78: 60fb         	str	r3, [r7, #0xc]
; 	return api->port_set_bits_raw(port, pins);
 8011e7a: 68fb         	ldr	r3, [r7, #0xc]
 8011e7c: 68db         	ldr	r3, [r3, #0xc]
 8011e7e: 6839         	ldr	r1, [r7]
 8011e80: 6878         	ldr	r0, [r7, #0x4]
 8011e82: 4798         	blx	r3
 8011e84: 4603         	mov	r3, r0
; }
 8011e86: 4618         	mov	r0, r3
 8011e88: 3710         	adds	r7, #0x10
 8011e8a: 46bd         	mov	sp, r7
 8011e8c: bd80         	pop	{r7, pc}

08011e8e <z_impl_gpio_port_clear_bits_raw>:
; {
 8011e8e: b580         	push	{r7, lr}
 8011e90: b084         	sub	sp, #0x10
 8011e92: af00         	add	r7, sp, #0x0
 8011e94: 6078         	str	r0, [r7, #0x4]
 8011e96: 6039         	str	r1, [r7]
; 	const struct gpio_driver_api *api =
 8011e98: 687b         	ldr	r3, [r7, #0x4]
 8011e9a: 689b         	ldr	r3, [r3, #0x8]
 8011e9c: 60fb         	str	r3, [r7, #0xc]
; 	return api->port_clear_bits_raw(port, pins);
 8011e9e: 68fb         	ldr	r3, [r7, #0xc]
 8011ea0: 691b         	ldr	r3, [r3, #0x10]
 8011ea2: 6839         	ldr	r1, [r7]
 8011ea4: 6878         	ldr	r0, [r7, #0x4]
 8011ea6: 4798         	blx	r3
 8011ea8: 4603         	mov	r3, r0
; }
 8011eaa: 4618         	mov	r0, r3
 8011eac: 3710         	adds	r7, #0x10
 8011eae: 46bd         	mov	sp, r7
 8011eb0: bd80         	pop	{r7, pc}

08011eb2 <gpio_pin_set_raw>:
; {
 8011eb2: b580         	push	{r7, lr}
 8011eb4: b086         	sub	sp, #0x18
 8011eb6: af00         	add	r7, sp, #0x0
 8011eb8: 60f8         	str	r0, [r7, #0xc]
 8011eba: 460b         	mov	r3, r1
 8011ebc: 607a         	str	r2, [r7, #0x4]
 8011ebe: 72fb         	strb	r3, [r7, #0xb]
; 	__unused const struct gpio_driver_config *const cfg =
 8011ec0: 68fb         	ldr	r3, [r7, #0xc]
 8011ec2: 685b         	ldr	r3, [r3, #0x4]
 8011ec4: 613b         	str	r3, [r7, #0x10]
; 	if (value != 0)	{
 8011ec6: 687b         	ldr	r3, [r7, #0x4]
 8011ec8: 2b00         	cmp	r3, #0x0
 8011eca: d009         	beq	0x8011ee0 <gpio_pin_set_raw+0x2e> @ imm = #0x12
; 		ret = gpio_port_set_bits_raw(port, (gpio_port_pins_t)BIT(pin));
 8011ecc: 7afb         	ldrb	r3, [r7, #0xb]
 8011ece: 2201         	movs	r2, #0x1
 8011ed0: fa02 f303    	lsl.w	r3, r2, r3
 8011ed4: 4619         	mov	r1, r3
 8011ed6: 68f8         	ldr	r0, [r7, #0xc]
 8011ed8: f000 f85c    	bl	0x8011f94 <gpio_port_set_bits_raw> @ imm = #0xb8
 8011edc: 6178         	str	r0, [r7, #0x14]
 8011ede: e008         	b	0x8011ef2 <gpio_pin_set_raw+0x40> @ imm = #0x10
; 		ret = gpio_port_clear_bits_raw(port, (gpio_port_pins_t)BIT(pin));
 8011ee0: 7afb         	ldrb	r3, [r7, #0xb]
 8011ee2: 2201         	movs	r2, #0x1
 8011ee4: fa02 f303    	lsl.w	r3, r2, r3
 8011ee8: 4619         	mov	r1, r3
 8011eea: 68f8         	ldr	r0, [r7, #0xc]
 8011eec: f000 f860    	bl	0x8011fb0 <gpio_port_clear_bits_raw> @ imm = #0xc0
 8011ef0: 6178         	str	r0, [r7, #0x14]
; 	return ret;
 8011ef2: 697b         	ldr	r3, [r7, #0x14]
; }
 8011ef4: 4618         	mov	r0, r3
 8011ef6: 3718         	adds	r7, #0x18
 8011ef8: 46bd         	mov	sp, r7
 8011efa: bd80         	pop	{r7, pc}

08011efc <gpio_pin_set>:
; {
 8011efc: b580         	push	{r7, lr}
 8011efe: b086         	sub	sp, #0x18
 8011f00: af00         	add	r7, sp, #0x0
 8011f02: 60f8         	str	r0, [r7, #0xc]
 8011f04: 460b         	mov	r3, r1
 8011f06: 607a         	str	r2, [r7, #0x4]
 8011f08: 72fb         	strb	r3, [r7, #0xb]
; 	__unused const struct gpio_driver_config *const cfg =
 8011f0a: 68fb         	ldr	r3, [r7, #0xc]
 8011f0c: 685b         	ldr	r3, [r3, #0x4]
 8011f0e: 617b         	str	r3, [r7, #0x14]
; 	const struct gpio_driver_data *const data =
 8011f10: 68fb         	ldr	r3, [r7, #0xc]
 8011f12: 691b         	ldr	r3, [r3, #0x10]
 8011f14: 613b         	str	r3, [r7, #0x10]
; 	if (data->invert & (gpio_port_pins_t)BIT(pin)) {
 8011f16: 693b         	ldr	r3, [r7, #0x10]
 8011f18: 681a         	ldr	r2, [r3]
 8011f1a: 7afb         	ldrb	r3, [r7, #0xb]
 8011f1c: 2101         	movs	r1, #0x1
 8011f1e: fa01 f303    	lsl.w	r3, r1, r3
 8011f22: 4013         	ands	r3, r2
 8011f24: 2b00         	cmp	r3, #0x0
 8011f26: d006         	beq	0x8011f36 <gpio_pin_set+0x3a> @ imm = #0xc
; 		value = (value != 0) ? 0 : 1;
 8011f28: 687b         	ldr	r3, [r7, #0x4]
 8011f2a: 2b00         	cmp	r3, #0x0
 8011f2c: bf0c         	ite	eq
 8011f2e: 2301         	moveq	r3, #0x1
 8011f30: 2300         	movne	r3, #0x0
 8011f32: b2db         	uxtb	r3, r3
 8011f34: 607b         	str	r3, [r7, #0x4]
; 	return gpio_pin_set_raw(port, pin, value);
 8011f36: 7afb         	ldrb	r3, [r7, #0xb]
 8011f38: 687a         	ldr	r2, [r7, #0x4]
 8011f3a: 4619         	mov	r1, r3
 8011f3c: 68f8         	ldr	r0, [r7, #0xc]
 8011f3e: f7ff ffb8    	bl	0x8011eb2 <gpio_pin_set_raw> @ imm = #-0x90
 8011f42: 4603         	mov	r3, r0
; }
 8011f44: 4618         	mov	r0, r3
 8011f46: 3718         	adds	r7, #0x18
 8011f48: 46bd         	mov	sp, r7
 8011f4a: bd80         	pop	{r7, pc}

08011f4c <gpio_pin_set_dt>:
; {
 8011f4c: b580         	push	{r7, lr}
 8011f4e: b082         	sub	sp, #0x8
 8011f50: af00         	add	r7, sp, #0x0
 8011f52: 6078         	str	r0, [r7, #0x4]
 8011f54: 6039         	str	r1, [r7]
; 	return gpio_pin_set(spec->port, spec->pin, value);
 8011f56: 687b         	ldr	r3, [r7, #0x4]
 8011f58: 6818         	ldr	r0, [r3]
 8011f5a: 687b         	ldr	r3, [r7, #0x4]
 8011f5c: 791b         	ldrb	r3, [r3, #0x4]
 8011f5e: 683a         	ldr	r2, [r7]
 8011f60: 4619         	mov	r1, r3
 8011f62: f7ff ffcb    	bl	0x8011efc <gpio_pin_set> @ imm = #-0x6a
 8011f66: 4603         	mov	r3, r0
; }
 8011f68: 4618         	mov	r0, r3
 8011f6a: 3708         	adds	r7, #0x8
 8011f6c: 46bd         	mov	sp, r7
 8011f6e: bd80         	pop	{r7, pc}

08011f70 <gpio_pin_configure>:
; {
 8011f70: b580         	push	{r7, lr}
 8011f72: b084         	sub	sp, #0x10
 8011f74: af00         	add	r7, sp, #0x0
 8011f76: 60f8         	str	r0, [r7, #0xc]
 8011f78: 460b         	mov	r3, r1
 8011f7a: 607a         	str	r2, [r7, #0x4]
 8011f7c: 72fb         	strb	r3, [r7, #0xb]
; 	return z_impl_gpio_pin_configure(port, pin, flags);
 8011f7e: 7afb         	ldrb	r3, [r7, #0xb]
 8011f80: 687a         	ldr	r2, [r7, #0x4]
 8011f82: 4619         	mov	r1, r3
 8011f84: 68f8         	ldr	r0, [r7, #0xc]
 8011f86: f7ff ff0f    	bl	0x8011da8 <z_impl_gpio_pin_configure> @ imm = #-0x1e2
 8011f8a: 4603         	mov	r3, r0
; }
 8011f8c: 4618         	mov	r0, r3
 8011f8e: 3710         	adds	r7, #0x10
 8011f90: 46bd         	mov	sp, r7
 8011f92: bd80         	pop	{r7, pc}

08011f94 <gpio_port_set_bits_raw>:
; {
 8011f94: b580         	push	{r7, lr}
 8011f96: b082         	sub	sp, #0x8
 8011f98: af00         	add	r7, sp, #0x0
 8011f9a: 6078         	str	r0, [r7, #0x4]
 8011f9c: 6039         	str	r1, [r7]
; 	return z_impl_gpio_port_set_bits_raw(port, pins);
 8011f9e: 6839         	ldr	r1, [r7]
 8011fa0: 6878         	ldr	r0, [r7, #0x4]
 8011fa2: f7ff ff62    	bl	0x8011e6a <z_impl_gpio_port_set_bits_raw> @ imm = #-0x13c
 8011fa6: 4603         	mov	r3, r0
; }
 8011fa8: 4618         	mov	r0, r3
 8011faa: 3708         	adds	r7, #0x8
 8011fac: 46bd         	mov	sp, r7
 8011fae: bd80         	pop	{r7, pc}

08011fb0 <gpio_port_clear_bits_raw>:
; {
 8011fb0: b580         	push	{r7, lr}
 8011fb2: b082         	sub	sp, #0x8
 8011fb4: af00         	add	r7, sp, #0x0
 8011fb6: 6078         	str	r0, [r7, #0x4]
 8011fb8: 6039         	str	r1, [r7]
; 	return z_impl_gpio_port_clear_bits_raw(port, pins);
 8011fba: 6839         	ldr	r1, [r7]
 8011fbc: 6878         	ldr	r0, [r7, #0x4]
 8011fbe: f7ff ff66    	bl	0x8011e8e <z_impl_gpio_port_clear_bits_raw> @ imm = #-0x134
 8011fc2: 4603         	mov	r3, r0
; }
 8011fc4: 4618         	mov	r0, r3
 8011fc6: 3708         	adds	r7, #0x8
 8011fc8: 46bd         	mov	sp, r7
 8011fca: bd80         	pop	{r7, pc}

08011fcc <spi_cs_is_gpio>:
; {
 8011fcc: b480         	push	{r7}
 8011fce: b083         	sub	sp, #0xc
 8011fd0: af00         	add	r7, sp, #0x0
 8011fd2: 6078         	str	r0, [r7, #0x4]
; 	return config->cs.gpio.port != NULL;
 8011fd4: 687b         	ldr	r3, [r7, #0x4]
 8011fd6: 689b         	ldr	r3, [r3, #0x8]
 8011fd8: 2b00         	cmp	r3, #0x0
 8011fda: bf14         	ite	ne
 8011fdc: 2301         	movne	r3, #0x1
 8011fde: 2300         	moveq	r3, #0x0
 8011fe0: b2db         	uxtb	r3, r3
; }
 8011fe2: 4618         	mov	r0, r3
 8011fe4: 370c         	adds	r7, #0xc
 8011fe6: 46bd         	mov	sp, r7
 8011fe8: bc80         	pop	{r7}
 8011fea: 4770         	bx	lr

08011fec <pinctrl_apply_state_direct>:
; {
 8011fec: b580         	push	{r7, lr}
 8011fee: b084         	sub	sp, #0x10
 8011ff0: af00         	add	r7, sp, #0x0
 8011ff2: 6078         	str	r0, [r7, #0x4]
 8011ff4: 6039         	str	r1, [r7]
; 	reg = PINCTRL_REG_NONE;
 8011ff6: 2300         	movs	r3, #0x0
 8011ff8: 60fb         	str	r3, [r7, #0xc]
; 	return pinctrl_configure_pins(state->pins, state->pin_cnt, reg);
 8011ffa: 683b         	ldr	r3, [r7]
 8011ffc: 6818         	ldr	r0, [r3]
 8011ffe: 683b         	ldr	r3, [r7]
 8012000: 791b         	ldrb	r3, [r3, #0x4]
 8012002: 68fa         	ldr	r2, [r7, #0xc]
 8012004: 4619         	mov	r1, r3
 8012006: f7fe fdd3    	bl	0x8010bb0 <pinctrl_configure_pins> @ imm = #-0x145a
 801200a: 4603         	mov	r3, r0
; }
 801200c: 4618         	mov	r0, r3
 801200e: 3710         	adds	r7, #0x10
 8012010: 46bd         	mov	sp, r7
 8012012: bd80         	pop	{r7, pc}

08012014 <pinctrl_apply_state>:
; {
 8012014: b580         	push	{r7, lr}
 8012016: b084         	sub	sp, #0x10
 8012018: af00         	add	r7, sp, #0x0
 801201a: 6078         	str	r0, [r7, #0x4]
 801201c: 460b         	mov	r3, r1
 801201e: 70fb         	strb	r3, [r7, #0x3]
; 	ret = pinctrl_lookup_state(config, id, &state);
 8012020: f107 0208    	add.w	r2, r7, #0x8
 8012024: 78fb         	ldrb	r3, [r7, #0x3]
 8012026: 4619         	mov	r1, r3
 8012028: 6878         	ldr	r0, [r7, #0x4]
 801202a: f7fe fd8a    	bl	0x8010b42 <pinctrl_lookup_state> @ imm = #-0x14ec
 801202e: 60f8         	str	r0, [r7, #0xc]
; 	if (ret < 0) {
 8012030: 68fb         	ldr	r3, [r7, #0xc]
 8012032: 2b00         	cmp	r3, #0x0
 8012034: da01         	bge	0x801203a <pinctrl_apply_state+0x26> @ imm = #0x2
; 		return ret;
 8012036: 68fb         	ldr	r3, [r7, #0xc]
 8012038: e005         	b	0x8012046 <pinctrl_apply_state+0x32> @ imm = #0xa
; 	return pinctrl_apply_state_direct(config, state);
 801203a: 68bb         	ldr	r3, [r7, #0x8]
 801203c: 4619         	mov	r1, r3
 801203e: 6878         	ldr	r0, [r7, #0x4]
 8012040: f7ff ffd4    	bl	0x8011fec <pinctrl_apply_state_direct> @ imm = #-0x58
 8012044: 4603         	mov	r3, r0
; }
 8012046: 4618         	mov	r0, r3
 8012048: 3710         	adds	r7, #0x10
 801204a: 46bd         	mov	sp, r7
 801204c: bd80         	pop	{r7, pc}

0801204e <pm_device_runtime_enable>:
; {
 801204e: b480         	push	{r7}
 8012050: b083         	sub	sp, #0xc
 8012052: af00         	add	r7, sp, #0x0
 8012054: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 8012056: 2300         	movs	r3, #0x0
; }
 8012058: 4618         	mov	r0, r3
 801205a: 370c         	adds	r7, #0xc
 801205c: 46bd         	mov	sp, r7
 801205e: bc80         	pop	{r7}
 8012060: 4770         	bx	lr

08012062 <clock_control_on>:
; {
 8012062: b580         	push	{r7, lr}
 8012064: b084         	sub	sp, #0x10
 8012066: af00         	add	r7, sp, #0x0
 8012068: 6078         	str	r0, [r7, #0x4]
 801206a: 6039         	str	r1, [r7]
; 	const struct clock_control_driver_api *api =
 801206c: 687b         	ldr	r3, [r7, #0x4]
 801206e: 689b         	ldr	r3, [r3, #0x8]
 8012070: 60fb         	str	r3, [r7, #0xc]
; 	return api->on(dev, sys);
 8012072: 68fb         	ldr	r3, [r7, #0xc]
 8012074: 681b         	ldr	r3, [r3]
 8012076: 6839         	ldr	r1, [r7]
 8012078: 6878         	ldr	r0, [r7, #0x4]
 801207a: 4798         	blx	r3
 801207c: 4603         	mov	r3, r0
; }
 801207e: 4618         	mov	r0, r3
 8012080: 3710         	adds	r7, #0x10
 8012082: 46bd         	mov	sp, r7
 8012084: bd80         	pop	{r7, pc}

08012086 <clock_control_get_rate>:
; {
 8012086: b580         	push	{r7, lr}
 8012088: b086         	sub	sp, #0x18
 801208a: af00         	add	r7, sp, #0x0
 801208c: 60f8         	str	r0, [r7, #0xc]
 801208e: 60b9         	str	r1, [r7, #0x8]
 8012090: 607a         	str	r2, [r7, #0x4]
; 	const struct clock_control_driver_api *api =
 8012092: 68fb         	ldr	r3, [r7, #0xc]
 8012094: 689b         	ldr	r3, [r3, #0x8]
 8012096: 617b         	str	r3, [r7, #0x14]
; 	if (api->get_rate == NULL) {
 8012098: 697b         	ldr	r3, [r7, #0x14]
 801209a: 68db         	ldr	r3, [r3, #0xc]
 801209c: 2b00         	cmp	r3, #0x0
 801209e: d102         	bne	0x80120a6 <clock_control_get_rate+0x20> @ imm = #0x4
; 		return -ENOSYS;
 80120a0: f06f 0357    	mvn	r3, #0x57
 80120a4: e006         	b	0x80120b4 <clock_control_get_rate+0x2e> @ imm = #0xc
; 	return api->get_rate(dev, sys, rate);
 80120a6: 697b         	ldr	r3, [r7, #0x14]
 80120a8: 68db         	ldr	r3, [r3, #0xc]
 80120aa: 687a         	ldr	r2, [r7, #0x4]
 80120ac: 68b9         	ldr	r1, [r7, #0x8]
 80120ae: 68f8         	ldr	r0, [r7, #0xc]
 80120b0: 4798         	blx	r3
 80120b2: 4603         	mov	r3, r0
; }
 80120b4: 4618         	mov	r0, r3
 80120b6: 3718         	adds	r7, #0x18
 80120b8: 46bd         	mov	sp, r7
 80120ba: bd80         	pop	{r7, pc}

080120bc <spi_context_configured>:
; {
 80120bc: b480         	push	{r7}
 80120be: b083         	sub	sp, #0xc
 80120c0: af00         	add	r7, sp, #0x0
 80120c2: 6078         	str	r0, [r7, #0x4]
 80120c4: 6039         	str	r1, [r7]
; 	return !!(ctx->config == config);
 80120c6: 687b         	ldr	r3, [r7, #0x4]
 80120c8: 681b         	ldr	r3, [r3]
 80120ca: 683a         	ldr	r2, [r7]
 80120cc: 429a         	cmp	r2, r3
 80120ce: bf0c         	ite	eq
 80120d0: 2301         	moveq	r3, #0x1
 80120d2: 2300         	movne	r3, #0x0
 80120d4: b2db         	uxtb	r3, r3
; }
 80120d6: 4618         	mov	r0, r3
 80120d8: 370c         	adds	r7, #0xc
 80120da: 46bd         	mov	sp, r7
 80120dc: bc80         	pop	{r7}
 80120de: 4770         	bx	lr

080120e0 <spi_context_lock>:
; {
 80120e0: b580         	push	{r7, lr}
 80120e2: b084         	sub	sp, #0x10
 80120e4: af00         	add	r7, sp, #0x0
 80120e6: 60f8         	str	r0, [r7, #0xc]
 80120e8: 607a         	str	r2, [r7, #0x4]
 80120ea: 603b         	str	r3, [r7]
 80120ec: 460b         	mov	r3, r1
 80120ee: 72fb         	strb	r3, [r7, #0xb]
; 	if ((spi_cfg->operation & SPI_LOCK_ON) &&
 80120f0: 69bb         	ldr	r3, [r7, #0x18]
 80120f2: 889b         	ldrh	r3, [r3, #0x4]
 80120f4: f403 5300    	and	r3, r3, #0x2000
 80120f8: 2b00         	cmp	r3, #0x0
 80120fa: d00d         	beq	0x8012118 <spi_context_lock+0x38> @ imm = #0x1a
; 		(k_sem_count_get(&ctx->lock) == 0) &&
 80120fc: 68fb         	ldr	r3, [r7, #0xc]
 80120fe: 3310         	adds	r3, #0x10
 8012100: 4618         	mov	r0, r3
 8012102: f7ff fc86    	bl	0x8011a12 <k_sem_count_get> @ imm = #-0x6f4
 8012106: 4603         	mov	r3, r0
; 	if ((spi_cfg->operation & SPI_LOCK_ON) &&
 8012108: 2b00         	cmp	r3, #0x0
 801210a: d105         	bne	0x8012118 <spi_context_lock+0x38> @ imm = #0xa
; 		(ctx->owner == spi_cfg)) {
 801210c: 68fb         	ldr	r3, [r7, #0xc]
 801210e: 685b         	ldr	r3, [r3, #0x4]
; 		(k_sem_count_get(&ctx->lock) == 0) &&
 8012110: 69ba         	ldr	r2, [r7, #0x18]
 8012112: 429a         	cmp	r2, r3
 8012114: d100         	bne	0x8012118 <spi_context_lock+0x38> @ imm = #0x0
 8012116: e00c         	b	0x8012132 <spi_context_lock+0x52> @ imm = #0x18
; 	k_sem_take(&ctx->lock, K_FOREVER);
 8012118: 68fb         	ldr	r3, [r7, #0xc]
 801211a: f103 0110    	add.w	r1, r3, #0x10
 801211e: f04f 32ff    	mov.w	r2, #0xffffffff
 8012122: f04f 33ff    	mov.w	r3, #0xffffffff
 8012126: 4608         	mov	r0, r1
 8012128: f7ff fc58    	bl	0x80119dc <k_sem_take>  @ imm = #-0x750
; 	ctx->owner = spi_cfg;
 801212c: 68fb         	ldr	r3, [r7, #0xc]
 801212e: 69ba         	ldr	r2, [r7, #0x18]
 8012130: 605a         	str	r2, [r3, #0x4]
; }
 8012132: 3710         	adds	r7, #0x10
 8012134: 46bd         	mov	sp, r7
 8012136: bd80         	pop	{r7, pc}

08012138 <spi_context_release>:
; {
 8012138: b580         	push	{r7, lr}
 801213a: b082         	sub	sp, #0x8
 801213c: af00         	add	r7, sp, #0x0
 801213e: 6078         	str	r0, [r7, #0x4]
 8012140: 6039         	str	r1, [r7]
; 	if (!(ctx->config->operation & SPI_LOCK_ON)) {
 8012142: 687b         	ldr	r3, [r7, #0x4]
 8012144: 681b         	ldr	r3, [r3]
 8012146: 889b         	ldrh	r3, [r3, #0x4]
 8012148: f403 5300    	and	r3, r3, #0x2000
 801214c: 2b00         	cmp	r3, #0x0
 801214e: d107         	bne	0x8012160 <spi_context_release+0x28> @ imm = #0xe
; 		ctx->owner = NULL;
 8012150: 687b         	ldr	r3, [r7, #0x4]
 8012152: 2200         	movs	r2, #0x0
 8012154: 605a         	str	r2, [r3, #0x4]
; 		k_sem_give(&ctx->lock);
 8012156: 687b         	ldr	r3, [r7, #0x4]
 8012158: 3310         	adds	r3, #0x10
 801215a: 4618         	mov	r0, r3
 801215c: f7ff fc4e    	bl	0x80119fc <k_sem_give>  @ imm = #-0x764
; }
 8012160: bf00         	nop
 8012162: 3708         	adds	r7, #0x8
 8012164: 46bd         	mov	sp, r7
 8012166: bd80         	pop	{r7, pc}

08012168 <_spi_context_cs_control>:
; {
 8012168: b580         	push	{r7, lr}
 801216a: b082         	sub	sp, #0x8
 801216c: af00         	add	r7, sp, #0x0
 801216e: 6078         	str	r0, [r7, #0x4]
 8012170: 460b         	mov	r3, r1
 8012172: 70fb         	strb	r3, [r7, #0x3]
 8012174: 4613         	mov	r3, r2
 8012176: 70bb         	strb	r3, [r7, #0x2]
; 	if (ctx->config && spi_cs_is_gpio(ctx->config)) {
 8012178: 687b         	ldr	r3, [r7, #0x4]
 801217a: 681b         	ldr	r3, [r3]
 801217c: 2b00         	cmp	r3, #0x0
 801217e: d034         	beq	0x80121ea <_spi_context_cs_control+0x82> @ imm = #0x68
 8012180: 687b         	ldr	r3, [r7, #0x4]
 8012182: 681b         	ldr	r3, [r3]
 8012184: 4618         	mov	r0, r3
 8012186: f7ff ff21    	bl	0x8011fcc <spi_cs_is_gpio> @ imm = #-0x1be
 801218a: 4603         	mov	r3, r0
 801218c: 2b00         	cmp	r3, #0x0
 801218e: d02c         	beq	0x80121ea <_spi_context_cs_control+0x82> @ imm = #0x58
; 		if (on) {
 8012190: 78fb         	ldrb	r3, [r7, #0x3]
 8012192: 2b00         	cmp	r3, #0x0
 8012194: d00d         	beq	0x80121b2 <_spi_context_cs_control+0x4a> @ imm = #0x1a
; 			gpio_pin_set_dt(&ctx->config->cs.gpio, 1);
 8012196: 687b         	ldr	r3, [r7, #0x4]
 8012198: 681b         	ldr	r3, [r3]
 801219a: 3308         	adds	r3, #0x8
 801219c: 2101         	movs	r1, #0x1
 801219e: 4618         	mov	r0, r3
 80121a0: f7ff fed4    	bl	0x8011f4c <gpio_pin_set_dt> @ imm = #-0x258
; 			k_busy_wait(ctx->config->cs.delay);
 80121a4: 687b         	ldr	r3, [r7, #0x4]
 80121a6: 681b         	ldr	r3, [r3]
 80121a8: 691b         	ldr	r3, [r3, #0x10]
 80121aa: 4618         	mov	r0, r3
 80121ac: f7ff fc0b    	bl	0x80119c6 <k_busy_wait> @ imm = #-0x7ea
 80121b0: e01b         	b	0x80121ea <_spi_context_cs_control+0x82> @ imm = #0x36
; 			if (!force_off &&
 80121b2: 78bb         	ldrb	r3, [r7, #0x2]
 80121b4: f083 0301    	eor	r3, r3, #0x1
 80121b8: b2db         	uxtb	r3, r3
 80121ba: 2b00         	cmp	r3, #0x0
 80121bc: d006         	beq	0x80121cc <_spi_context_cs_control+0x64> @ imm = #0xc
; 			    ctx->config->operation & SPI_HOLD_ON_CS) {
 80121be: 687b         	ldr	r3, [r7, #0x4]
 80121c0: 681b         	ldr	r3, [r3]
 80121c2: 889b         	ldrh	r3, [r3, #0x4]
 80121c4: f403 5380    	and	r3, r3, #0x1000
; 			if (!force_off &&
 80121c8: 2b00         	cmp	r3, #0x0
 80121ca: d10d         	bne	0x80121e8 <_spi_context_cs_control+0x80> @ imm = #0x1a
; 			k_busy_wait(ctx->config->cs.delay);
 80121cc: 687b         	ldr	r3, [r7, #0x4]
 80121ce: 681b         	ldr	r3, [r3]
 80121d0: 691b         	ldr	r3, [r3, #0x10]
 80121d2: 4618         	mov	r0, r3
 80121d4: f7ff fbf7    	bl	0x80119c6 <k_busy_wait> @ imm = #-0x812
; 			gpio_pin_set_dt(&ctx->config->cs.gpio, 0);
 80121d8: 687b         	ldr	r3, [r7, #0x4]
 80121da: 681b         	ldr	r3, [r3]
 80121dc: 3308         	adds	r3, #0x8
 80121de: 2100         	movs	r1, #0x0
 80121e0: 4618         	mov	r0, r3
 80121e2: f7ff feb3    	bl	0x8011f4c <gpio_pin_set_dt> @ imm = #-0x29a
 80121e6: e000         	b	0x80121ea <_spi_context_cs_control+0x82> @ imm = #0x0
; 				return;
 80121e8: bf00         	nop
; }
 80121ea: 3708         	adds	r7, #0x8
 80121ec: 46bd         	mov	sp, r7
 80121ee: bd80         	pop	{r7, pc}

080121f0 <spi_context_cs_control>:
; {
 80121f0: b580         	push	{r7, lr}
 80121f2: b082         	sub	sp, #0x8
 80121f4: af00         	add	r7, sp, #0x0
 80121f6: 6078         	str	r0, [r7, #0x4]
 80121f8: 460b         	mov	r3, r1
 80121fa: 70fb         	strb	r3, [r7, #0x3]
; 	_spi_context_cs_control(ctx, on, false);
 80121fc: 78fb         	ldrb	r3, [r7, #0x3]
 80121fe: 2200         	movs	r2, #0x0
 8012200: 4619         	mov	r1, r3
 8012202: 6878         	ldr	r0, [r7, #0x4]
 8012204: f7ff ffb0    	bl	0x8012168 <_spi_context_cs_control> @ imm = #-0xa0
; }
 8012208: bf00         	nop
 801220a: 3708         	adds	r7, #0x8
 801220c: 46bd         	mov	sp, r7
 801220e: bd80         	pop	{r7, pc}

08012210 <spi_context_unlock_unconditionally>:
; {
 8012210: b580         	push	{r7, lr}
 8012212: b082         	sub	sp, #0x8
 8012214: af00         	add	r7, sp, #0x0
 8012216: 6078         	str	r0, [r7, #0x4]
; 	_spi_context_cs_control(ctx, false, true);
 8012218: 2201         	movs	r2, #0x1
 801221a: 2100         	movs	r1, #0x0
 801221c: 6878         	ldr	r0, [r7, #0x4]
 801221e: f7ff ffa3    	bl	0x8012168 <_spi_context_cs_control> @ imm = #-0xba
; 	if (!k_sem_count_get(&ctx->lock)) {
 8012222: 687b         	ldr	r3, [r7, #0x4]
 8012224: 3310         	adds	r3, #0x10
 8012226: 4618         	mov	r0, r3
 8012228: f7ff fbf3    	bl	0x8011a12 <k_sem_count_get> @ imm = #-0x81a
 801222c: 4603         	mov	r3, r0
 801222e: 2b00         	cmp	r3, #0x0
 8012230: d107         	bne	0x8012242 <spi_context_unlock_unconditionally+0x32> @ imm = #0xe
; 		ctx->owner = NULL;
 8012232: 687b         	ldr	r3, [r7, #0x4]
 8012234: 2200         	movs	r2, #0x0
 8012236: 605a         	str	r2, [r3, #0x4]
; 		k_sem_give(&ctx->lock);
 8012238: 687b         	ldr	r3, [r7, #0x4]
 801223a: 3310         	adds	r3, #0x10
 801223c: 4618         	mov	r0, r3
 801223e: f7ff fbdd    	bl	0x80119fc <k_sem_give>  @ imm = #-0x846
; }
 8012242: bf00         	nop
 8012244: 3708         	adds	r7, #0x8
 8012246: 46bd         	mov	sp, r7
 8012248: bd80         	pop	{r7, pc}

0801224a <spi_context_get_next_buf>:
; {
 801224a: b480         	push	{r7}
 801224c: b085         	sub	sp, #0x14
 801224e: af00         	add	r7, sp, #0x0
 8012250: 60f8         	str	r0, [r7, #0xc]
 8012252: 60b9         	str	r1, [r7, #0x8]
 8012254: 607a         	str	r2, [r7, #0x4]
 8012256: 70fb         	strb	r3, [r7, #0x3]
; 	while (*count) {
 8012258: e01c         	b	0x8012294 <spi_context_get_next_buf+0x4a> @ imm = #0x38
; 		if (((*current)->len / dfs) != 0) {
 801225a: 68fb         	ldr	r3, [r7, #0xc]
 801225c: 681b         	ldr	r3, [r3]
 801225e: 685a         	ldr	r2, [r3, #0x4]
 8012260: 78fb         	ldrb	r3, [r7, #0x3]
 8012262: 429a         	cmp	r2, r3
 8012264: d30b         	blo	0x801227e <spi_context_get_next_buf+0x34> @ imm = #0x16
; 			*buf_len = (*current)->len / dfs;
 8012266: 68fb         	ldr	r3, [r7, #0xc]
 8012268: 681b         	ldr	r3, [r3]
 801226a: 685a         	ldr	r2, [r3, #0x4]
 801226c: 78fb         	ldrb	r3, [r7, #0x3]
 801226e: fbb2 f2f3    	udiv	r2, r2, r3
 8012272: 687b         	ldr	r3, [r7, #0x4]
 8012274: 601a         	str	r2, [r3]
; 			return (*current)->buf;
 8012276: 68fb         	ldr	r3, [r7, #0xc]
 8012278: 681b         	ldr	r3, [r3]
 801227a: 681b         	ldr	r3, [r3]
 801227c: e012         	b	0x80122a4 <spi_context_get_next_buf+0x5a> @ imm = #0x24
; 		++(*current);
 801227e: 68fb         	ldr	r3, [r7, #0xc]
 8012280: 681b         	ldr	r3, [r3]
 8012282: f103 0208    	add.w	r2, r3, #0x8
 8012286: 68fb         	ldr	r3, [r7, #0xc]
 8012288: 601a         	str	r2, [r3]
; 		--(*count);
 801228a: 68bb         	ldr	r3, [r7, #0x8]
 801228c: 681b         	ldr	r3, [r3]
 801228e: 1e5a         	subs	r2, r3, #0x1
 8012290: 68bb         	ldr	r3, [r7, #0x8]
 8012292: 601a         	str	r2, [r3]
; 	while (*count) {
 8012294: 68bb         	ldr	r3, [r7, #0x8]
 8012296: 681b         	ldr	r3, [r3]
 8012298: 2b00         	cmp	r3, #0x0
 801229a: d1de         	bne	0x801225a <spi_context_get_next_buf+0x10> @ imm = #-0x44
; 	*buf_len = 0;
 801229c: 687b         	ldr	r3, [r7, #0x4]
 801229e: 2200         	movs	r2, #0x0
 80122a0: 601a         	str	r2, [r3]
; 	return NULL;
 80122a2: 2300         	movs	r3, #0x0
; }
 80122a4: 4618         	mov	r0, r3
 80122a6: 3714         	adds	r7, #0x14
 80122a8: 46bd         	mov	sp, r7
 80122aa: bc80         	pop	{r7}
 80122ac: 4770         	bx	lr

080122ae <ll_func_tx_is_not_full>:
; {
 80122ae: b580         	push	{r7, lr}
 80122b0: b082         	sub	sp, #0x8
 80122b2: af00         	add	r7, sp, #0x0
 80122b4: 6078         	str	r0, [r7, #0x4]
; 	return LL_SPI_IsActiveFlag_TXE(spi);
 80122b6: 6878         	ldr	r0, [r7, #0x4]
 80122b8: f7ff fcc0    	bl	0x8011c3c <LL_SPI_IsActiveFlag_TXE> @ imm = #-0x680
 80122bc: 4603         	mov	r3, r0
; }
 80122be: 4618         	mov	r0, r3
 80122c0: 3708         	adds	r7, #0x8
 80122c2: 46bd         	mov	sp, r7
 80122c4: bd80         	pop	{r7, pc}

080122c6 <ll_func_rx_is_not_empty>:
; {
 80122c6: b580         	push	{r7, lr}
 80122c8: b082         	sub	sp, #0x8
 80122ca: af00         	add	r7, sp, #0x0
 80122cc: 6078         	str	r0, [r7, #0x4]
; 	return LL_SPI_IsActiveFlag_RXNE(spi);
 80122ce: 6878         	ldr	r0, [r7, #0x4]
 80122d0: f7ff fca2    	bl	0x8011c18 <LL_SPI_IsActiveFlag_RXNE> @ imm = #-0x6bc
 80122d4: 4603         	mov	r3, r0
; }
 80122d6: 4618         	mov	r0, r3
 80122d8: 3708         	adds	r7, #0x8
 80122da: 46bd         	mov	sp, r7
 80122dc: bd80         	pop	{r7, pc}

080122de <ll_func_disable_int_tx_empty>:
; {
 80122de: b580         	push	{r7, lr}
 80122e0: b082         	sub	sp, #0x8
 80122e2: af00         	add	r7, sp, #0x0
 80122e4: 6078         	str	r0, [r7, #0x4]
; 	LL_SPI_DisableIT_TXE(spi);
 80122e6: 6878         	ldr	r0, [r7, #0x4]
 80122e8: f7ff fd14    	bl	0x8011d14 <LL_SPI_DisableIT_TXE> @ imm = #-0x5d8
; }
 80122ec: bf00         	nop
 80122ee: 3708         	adds	r7, #0x8
 80122f0: 46bd         	mov	sp, r7
 80122f2: bd80         	pop	{r7, pc}

080122f4 <ll_func_spi_is_busy>:
; {
 80122f4: b580         	push	{r7, lr}
 80122f6: b082         	sub	sp, #0x8
 80122f8: af00         	add	r7, sp, #0x0
 80122fa: 6078         	str	r0, [r7, #0x4]
; 	return LL_SPI_IsActiveFlag_BSY(spi);
 80122fc: 6878         	ldr	r0, [r7, #0x4]
 80122fe: f7ff fcd3    	bl	0x8011ca8 <LL_SPI_IsActiveFlag_BSY> @ imm = #-0x65a
 8012302: 4603         	mov	r3, r0
; }
 8012304: 4618         	mov	r0, r3
 8012306: 3708         	adds	r7, #0x8
 8012308: 46bd         	mov	sp, r7
 801230a: bd80         	pop	{r7, pc}

0801230c <ll_func_disable_spi>:
; {
 801230c: b580         	push	{r7, lr}
 801230e: b082         	sub	sp, #0x8
 8012310: af00         	add	r7, sp, #0x0
 8012312: 6078         	str	r0, [r7, #0x4]
; 	LL_SPI_Disable(spi);
 8012314: 6878         	ldr	r0, [r7, #0x4]
 8012316: f7ff fb97    	bl	0x8011a48 <LL_SPI_Disable> @ imm = #-0x8d2
; 	while (LL_SPI_IsEnabled(spi)) {
 801231a: bf00         	nop
 801231c: 6878         	ldr	r0, [r7, #0x4]
 801231e: f7ff fba2    	bl	0x8011a66 <LL_SPI_IsEnabled> @ imm = #-0x8bc
 8012322: 4603         	mov	r3, r0
 8012324: 2b00         	cmp	r3, #0x0
 8012326: d1f9         	bne	0x801231c <ll_func_disable_spi+0x10> @ imm = #-0xe
; }
 8012328: bf00         	nop
 801232a: bf00         	nop
 801232c: 3708         	adds	r7, #0x8
 801232e: 46bd         	mov	sp, r7
 8012330: bd80         	pop	{r7, pc}

08012332 <spi_stm32_pm_policy_state_lock_get>:
; {
 8012332: b480         	push	{r7}
 8012334: b083         	sub	sp, #0xc
 8012336: af00         	add	r7, sp, #0x0
 8012338: 6078         	str	r0, [r7, #0x4]
; }
 801233a: bf00         	nop
 801233c: 370c         	adds	r7, #0xc
 801233e: 46bd         	mov	sp, r7
 8012340: bc80         	pop	{r7}
 8012342: 4770         	bx	lr

08012344 <spi_stm32_pm_policy_state_lock_put>:
; {
 8012344: b480         	push	{r7}
 8012346: b083         	sub	sp, #0xc
 8012348: af00         	add	r7, sp, #0x0
 801234a: 6078         	str	r0, [r7, #0x4]
; }
 801234c: bf00         	nop
 801234e: 370c         	adds	r7, #0xc
 8012350: 46bd         	mov	sp, r7
 8012352: bc80         	pop	{r7}
 8012354: 4770         	bx	lr

08012356 <spi_stm32_transfer_ongoing>:
; {
 8012356: b480         	push	{r7}
 8012358: b085         	sub	sp, #0x14
 801235a: af00         	add	r7, sp, #0x0
 801235c: 6078         	str	r0, [r7, #0x4]
; 	return spi_context_tx_on(&data->ctx) || spi_context_rx_on(&data->ctx);
 801235e: 687b         	ldr	r3, [r7, #0x4]
 8012360: 60fb         	str	r3, [r7, #0xc]
; 	return !!(ctx->tx_len);
 8012362: 68fb         	ldr	r3, [r7, #0xc]
 8012364: 6c9b         	ldr	r3, [r3, #0x48]
 8012366: 2b00         	cmp	r3, #0x0
 8012368: bf14         	ite	ne
 801236a: 2301         	movne	r3, #0x1
 801236c: 2300         	moveq	r3, #0x0
 801236e: b2db         	uxtb	r3, r3
; 	return spi_context_tx_on(&data->ctx) || spi_context_rx_on(&data->ctx);
 8012370: 2b00         	cmp	r3, #0x0
 8012372: d10a         	bne	0x801238a <spi_stm32_transfer_ongoing+0x34> @ imm = #0x14
 8012374: 687b         	ldr	r3, [r7, #0x4]
 8012376: 60bb         	str	r3, [r7, #0x8]
; 	return !!(ctx->rx_len);
 8012378: 68bb         	ldr	r3, [r7, #0x8]
 801237a: 6d1b         	ldr	r3, [r3, #0x50]
 801237c: 2b00         	cmp	r3, #0x0
 801237e: bf14         	ite	ne
 8012380: 2301         	movne	r3, #0x1
 8012382: 2300         	moveq	r3, #0x0
 8012384: b2db         	uxtb	r3, r3
; 	return spi_context_tx_on(&data->ctx) || spi_context_rx_on(&data->ctx);
 8012386: 2b00         	cmp	r3, #0x0
 8012388: d001         	beq	0x801238e <spi_stm32_transfer_ongoing+0x38> @ imm = #0x2
 801238a: 2301         	movs	r3, #0x1
 801238c: e000         	b	0x8012390 <spi_stm32_transfer_ongoing+0x3a> @ imm = #0x0
 801238e: 2300         	movs	r3, #0x0
 8012390: f003 0301    	and	r3, r3, #0x1
 8012394: b2db         	uxtb	r3, r3
; }
 8012396: 4618         	mov	r0, r3
 8012398: 3714         	adds	r7, #0x14
 801239a: 46bd         	mov	sp, r7
 801239c: bc80         	pop	{r7}
 801239e: 4770         	bx	lr

080123a0 <spi_stm32_shift_fifo>:
; {
 80123a0: b580         	push	{r7, lr}
 80123a2: b082         	sub	sp, #0x8
 80123a4: af00         	add	r7, sp, #0x0
 80123a6: 6078         	str	r0, [r7, #0x4]
 80123a8: 6039         	str	r1, [r7]
; 	if (ll_func_rx_is_not_empty(spi)) {
 80123aa: 6878         	ldr	r0, [r7, #0x4]
 80123ac: f7ff ff8b    	bl	0x80122c6 <ll_func_rx_is_not_empty> @ imm = #-0xea
 80123b0: 4603         	mov	r3, r0
 80123b2: 2b00         	cmp	r3, #0x0
 80123b4: d003         	beq	0x80123be <spi_stm32_shift_fifo+0x1e> @ imm = #0x6
; 		spi_stm32_read_next_frame(spi, data);
 80123b6: 6839         	ldr	r1, [r7]
 80123b8: 6878         	ldr	r0, [r7, #0x4]
 80123ba: f7f4 facb    	bl	0x8006954 <spi_stm32_read_next_frame> @ imm = #-0xba6a
; 	if (ll_func_tx_is_not_full(spi)) {
 80123be: 6878         	ldr	r0, [r7, #0x4]
 80123c0: f7ff ff75    	bl	0x80122ae <ll_func_tx_is_not_full> @ imm = #-0x116
 80123c4: 4603         	mov	r3, r0
 80123c6: 2b00         	cmp	r3, #0x0
 80123c8: d003         	beq	0x80123d2 <spi_stm32_shift_fifo+0x32> @ imm = #0x6
; 		spi_stm32_send_next_frame(spi, data);
 80123ca: 6839         	ldr	r1, [r7]
 80123cc: 6878         	ldr	r0, [r7, #0x4]
 80123ce: f7f4 f955    	bl	0x800667c <spi_stm32_send_next_frame> @ imm = #-0xbd56
; }
 80123d2: bf00         	nop
 80123d4: 3708         	adds	r7, #0x8
 80123d6: 46bd         	mov	sp, r7
 80123d8: bd80         	pop	{r7, pc}

080123da <spi_stm32_shift_m>:
; {
 80123da: b580         	push	{r7, lr}
 80123dc: b082         	sub	sp, #0x8
 80123de: af00         	add	r7, sp, #0x0
 80123e0: 6078         	str	r0, [r7, #0x4]
 80123e2: 6039         	str	r1, [r7]
; 	if (cfg->fifo_enabled) {
 80123e4: 687b         	ldr	r3, [r7, #0x4]
 80123e6: 7c1b         	ldrb	r3, [r3, #0x10]
 80123e8: 2b00         	cmp	r3, #0x0
 80123ea: d006         	beq	0x80123fa <spi_stm32_shift_m+0x20> @ imm = #0xc
; 		spi_stm32_shift_fifo(cfg->spi, data);
 80123ec: 687b         	ldr	r3, [r7, #0x4]
 80123ee: 681b         	ldr	r3, [r3]
 80123f0: 6839         	ldr	r1, [r7]
 80123f2: 4618         	mov	r0, r3
 80123f4: f7ff ffd4    	bl	0x80123a0 <spi_stm32_shift_fifo> @ imm = #-0x58
; }
 80123f8: e01d         	b	0x8012436 <spi_stm32_shift_m+0x5c> @ imm = #0x3a
; 		while (!ll_func_tx_is_not_full(cfg->spi)) {
 80123fa: bf00         	nop
 80123fc: 687b         	ldr	r3, [r7, #0x4]
 80123fe: 681b         	ldr	r3, [r3]
 8012400: 4618         	mov	r0, r3
 8012402: f7ff ff54    	bl	0x80122ae <ll_func_tx_is_not_full> @ imm = #-0x158
 8012406: 4603         	mov	r3, r0
 8012408: 2b00         	cmp	r3, #0x0
 801240a: d0f7         	beq	0x80123fc <spi_stm32_shift_m+0x22> @ imm = #-0x12
; 		spi_stm32_send_next_frame(cfg->spi, data);
 801240c: 687b         	ldr	r3, [r7, #0x4]
 801240e: 681b         	ldr	r3, [r3]
 8012410: 6839         	ldr	r1, [r7]
 8012412: 4618         	mov	r0, r3
 8012414: f7f4 f932    	bl	0x800667c <spi_stm32_send_next_frame> @ imm = #-0xbd9c
; 		while (!ll_func_rx_is_not_empty(cfg->spi)) {
 8012418: bf00         	nop
 801241a: 687b         	ldr	r3, [r7, #0x4]
 801241c: 681b         	ldr	r3, [r3]
 801241e: 4618         	mov	r0, r3
 8012420: f7ff ff51    	bl	0x80122c6 <ll_func_rx_is_not_empty> @ imm = #-0x15e
 8012424: 4603         	mov	r3, r0
 8012426: 2b00         	cmp	r3, #0x0
 8012428: d0f7         	beq	0x801241a <spi_stm32_shift_m+0x40> @ imm = #-0x12
; 		spi_stm32_read_next_frame(cfg->spi, data);
 801242a: 687b         	ldr	r3, [r7, #0x4]
 801242c: 681b         	ldr	r3, [r3]
 801242e: 6839         	ldr	r1, [r7]
 8012430: 4618         	mov	r0, r3
 8012432: f7f4 fa8f    	bl	0x8006954 <spi_stm32_read_next_frame> @ imm = #-0xbae2
; }
 8012436: bf00         	nop
 8012438: 3708         	adds	r7, #0x8
 801243a: 46bd         	mov	sp, r7
 801243c: bd80         	pop	{r7, pc}

0801243e <spi_stm32_shift_frames>:
; {
 801243e: b580         	push	{r7, lr}
 8012440: b084         	sub	sp, #0x10
 8012442: af00         	add	r7, sp, #0x0
 8012444: 6078         	str	r0, [r7, #0x4]
 8012446: 6039         	str	r1, [r7]
; 	uint16_t operation = data->ctx.config->operation;
 8012448: 683b         	ldr	r3, [r7]
 801244a: 681b         	ldr	r3, [r3]
 801244c: 889b         	ldrh	r3, [r3, #0x4]
 801244e: 81fb         	strh	r3, [r7, #0xe]
; 	if (SPI_OP_MODE_GET(operation) == SPI_OP_MODE_MASTER) {
 8012450: 89fb         	ldrh	r3, [r7, #0xe]
 8012452: f003 0301    	and	r3, r3, #0x1
 8012456: 2b00         	cmp	r3, #0x0
 8012458: d104         	bne	0x8012464 <spi_stm32_shift_frames+0x26> @ imm = #0x8
; 		spi_stm32_shift_m(cfg, data);
 801245a: 6839         	ldr	r1, [r7]
 801245c: 6878         	ldr	r0, [r7, #0x4]
 801245e: f7ff ffbc    	bl	0x80123da <spi_stm32_shift_m> @ imm = #-0x88
 8012462: e005         	b	0x8012470 <spi_stm32_shift_frames+0x32> @ imm = #0xa
; 		spi_stm32_shift_s(cfg->spi, data);
 8012464: 687b         	ldr	r3, [r7, #0x4]
 8012466: 681b         	ldr	r3, [r3]
 8012468: 6839         	ldr	r1, [r7]
 801246a: 4618         	mov	r0, r3
 801246c: f7f4 fc20    	bl	0x8006cb0 <spi_stm32_shift_s> @ imm = #-0xb7c0
; 	return spi_stm32_get_err(cfg->spi);
 8012470: 687b         	ldr	r3, [r7, #0x4]
 8012472: 681b         	ldr	r3, [r3]
 8012474: 4618         	mov	r0, r3
 8012476: f7f4 fbd7    	bl	0x8006c28 <spi_stm32_get_err> @ imm = #-0xb852
 801247a: 4603         	mov	r3, r0
; }
 801247c: 4618         	mov	r0, r3
 801247e: 3710         	adds	r7, #0x10
 8012480: 46bd         	mov	sp, r7
 8012482: bd80         	pop	{r7, pc}

08012484 <spi_stm32_cs_control>:
; {
 8012484: b580         	push	{r7, lr}
 8012486: b084         	sub	sp, #0x10
 8012488: af00         	add	r7, sp, #0x0
 801248a: 6078         	str	r0, [r7, #0x4]
 801248c: 460b         	mov	r3, r1
 801248e: 70fb         	strb	r3, [r7, #0x3]
; 	struct spi_stm32_data *data = dev->data;
 8012490: 687b         	ldr	r3, [r7, #0x4]
 8012492: 691b         	ldr	r3, [r3, #0x10]
 8012494: 60fb         	str	r3, [r7, #0xc]
; 	spi_context_cs_control(&data->ctx, on);
 8012496: 68fb         	ldr	r3, [r7, #0xc]
 8012498: 78fa         	ldrb	r2, [r7, #0x3]
 801249a: 4611         	mov	r1, r2
 801249c: 4618         	mov	r0, r3
 801249e: f7ff fea7    	bl	0x80121f0 <spi_context_cs_control> @ imm = #-0x2b2
; }
 80124a2: bf00         	nop
 80124a4: 3710         	adds	r7, #0x10
 80124a6: 46bd         	mov	sp, r7
 80124a8: bd80         	pop	{r7, pc}

080124aa <spi_stm32_complete>:
; {
 80124aa: b580         	push	{r7, lr}
 80124ac: b086         	sub	sp, #0x18
 80124ae: af00         	add	r7, sp, #0x0
 80124b0: 6078         	str	r0, [r7, #0x4]
 80124b2: 6039         	str	r1, [r7]
; 	const struct spi_stm32_config *cfg = dev->config;
 80124b4: 687b         	ldr	r3, [r7, #0x4]
 80124b6: 685b         	ldr	r3, [r3, #0x4]
 80124b8: 617b         	str	r3, [r7, #0x14]
; 	SPI_TypeDef *spi = cfg->spi;
 80124ba: 697b         	ldr	r3, [r7, #0x14]
 80124bc: 681b         	ldr	r3, [r3]
 80124be: 613b         	str	r3, [r7, #0x10]
; 	struct spi_stm32_data *data = dev->data;
 80124c0: 687b         	ldr	r3, [r7, #0x4]
 80124c2: 691b         	ldr	r3, [r3, #0x10]
 80124c4: 60fb         	str	r3, [r7, #0xc]
; 	if (LL_SPI_GetMode(spi) == LL_SPI_MODE_MASTER) {
 80124c6: 6938         	ldr	r0, [r7, #0x10]
 80124c8: f7ff faf1    	bl	0x8011aae <LL_SPI_GetMode> @ imm = #-0xa1e
 80124cc: 4603         	mov	r3, r0
 80124ce: f5b3 7f82    	cmp.w	r3, #0x104
 80124d2: d10a         	bne	0x80124ea <spi_stm32_complete+0x40> @ imm = #0x14
; 		while (ll_func_spi_is_busy(spi)) {
 80124d4: bf00         	nop
 80124d6: 6938         	ldr	r0, [r7, #0x10]
 80124d8: f7ff ff0c    	bl	0x80122f4 <ll_func_spi_is_busy> @ imm = #-0x1e8
 80124dc: 4603         	mov	r3, r0
 80124de: 2b00         	cmp	r3, #0x0
 80124e0: d1f9         	bne	0x80124d6 <spi_stm32_complete+0x2c> @ imm = #-0xe
; 		spi_stm32_cs_control(dev, false);
 80124e2: 2100         	movs	r1, #0x0
 80124e4: 6878         	ldr	r0, [r7, #0x4]
 80124e6: f7ff ffcd    	bl	0x8012484 <spi_stm32_cs_control> @ imm = #-0x66
; 	if (LL_SPI_IsActiveFlag_MODF(spi)) {
 80124ea: 6938         	ldr	r0, [r7, #0x10]
 80124ec: f7ff fbb8    	bl	0x8011c60 <LL_SPI_IsActiveFlag_MODF> @ imm = #-0x890
 80124f0: 4603         	mov	r3, r0
 80124f2: 2b00         	cmp	r3, #0x0
 80124f4: d002         	beq	0x80124fc <spi_stm32_complete+0x52> @ imm = #0x4
; 		LL_SPI_ClearFlag_MODF(spi);
 80124f6: 6938         	ldr	r0, [r7, #0x10]
 80124f8: f7ff fbe8    	bl	0x8011ccc <LL_SPI_ClearFlag_MODF> @ imm = #-0x830
; 	if (!(data->ctx.config->operation & SPI_HOLD_ON_CS)) {
 80124fc: 68fb         	ldr	r3, [r7, #0xc]
 80124fe: 681b         	ldr	r3, [r3]
 8012500: 889b         	ldrh	r3, [r3, #0x4]
 8012502: f403 5380    	and	r3, r3, #0x1000
 8012506: 2b00         	cmp	r3, #0x0
 8012508: d102         	bne	0x8012510 <spi_stm32_complete+0x66> @ imm = #0x4
; 		ll_func_disable_spi(spi);
 801250a: 6938         	ldr	r0, [r7, #0x10]
 801250c: f7ff fefe    	bl	0x801230c <ll_func_disable_spi> @ imm = #-0x204
; 	spi_stm32_pm_policy_state_lock_put(dev);
 8012510: 6878         	ldr	r0, [r7, #0x4]
 8012512: f7ff ff17    	bl	0x8012344 <spi_stm32_pm_policy_state_lock_put> @ imm = #-0x1d2
; }
 8012516: bf00         	nop
 8012518: 3718         	adds	r7, #0x18
 801251a: 46bd         	mov	sp, r7
 801251c: bd80         	pop	{r7, pc}

0801251e <spi_stm32_release>:
; {
 801251e: b580         	push	{r7, lr}
 8012520: b084         	sub	sp, #0x10
 8012522: af00         	add	r7, sp, #0x0
 8012524: 6078         	str	r0, [r7, #0x4]
 8012526: 6039         	str	r1, [r7]
; 	struct spi_stm32_data *data = dev->data;
 8012528: 687b         	ldr	r3, [r7, #0x4]
 801252a: 691b         	ldr	r3, [r3, #0x10]
 801252c: 60fb         	str	r3, [r7, #0xc]
; 	const struct spi_stm32_config *cfg = dev->config;
 801252e: 687b         	ldr	r3, [r7, #0x4]
 8012530: 685b         	ldr	r3, [r3, #0x4]
 8012532: 60bb         	str	r3, [r7, #0x8]
; 	spi_context_unlock_unconditionally(&data->ctx);
 8012534: 68fb         	ldr	r3, [r7, #0xc]
 8012536: 4618         	mov	r0, r3
 8012538: f7ff fe6a    	bl	0x8012210 <spi_context_unlock_unconditionally> @ imm = #-0x32c
; 	ll_func_disable_spi(cfg->spi);
 801253c: 68bb         	ldr	r3, [r7, #0x8]
 801253e: 681b         	ldr	r3, [r3]
 8012540: 4618         	mov	r0, r3
 8012542: f7ff fee3    	bl	0x801230c <ll_func_disable_spi> @ imm = #-0x23a
; 	return 0;
 8012546: 2300         	movs	r3, #0x0
; }
 8012548: 4618         	mov	r0, r3
 801254a: 3710         	adds	r7, #0x10
 801254c: 46bd         	mov	sp, r7
 801254e: bd80         	pop	{r7, pc}

08012550 <transceive>:
; {
 8012550: b580         	push	{r7, lr}
 8012552: b08a         	sub	sp, #0x28
 8012554: af02         	add	r7, sp, #0x8
 8012556: 60f8         	str	r0, [r7, #0xc]
 8012558: 60b9         	str	r1, [r7, #0x8]
 801255a: 607a         	str	r2, [r7, #0x4]
 801255c: 603b         	str	r3, [r7]
; 	const struct spi_stm32_config *cfg = dev->config;
 801255e: 68fb         	ldr	r3, [r7, #0xc]
 8012560: 685b         	ldr	r3, [r3, #0x4]
 8012562: 61bb         	str	r3, [r7, #0x18]
; 	struct spi_stm32_data *data = dev->data;
 8012564: 68fb         	ldr	r3, [r7, #0xc]
 8012566: 691b         	ldr	r3, [r3, #0x10]
 8012568: 617b         	str	r3, [r7, #0x14]
; 	SPI_TypeDef *spi = cfg->spi;
 801256a: 69bb         	ldr	r3, [r7, #0x18]
 801256c: 681b         	ldr	r3, [r3]
 801256e: 613b         	str	r3, [r7, #0x10]
; 	if (!tx_bufs && !rx_bufs) {
 8012570: 687b         	ldr	r3, [r7, #0x4]
 8012572: 2b00         	cmp	r3, #0x0
 8012574: d104         	bne	0x8012580 <transceive+0x30> @ imm = #0x8
 8012576: 683b         	ldr	r3, [r7]
 8012578: 2b00         	cmp	r3, #0x0
 801257a: d101         	bne	0x8012580 <transceive+0x30> @ imm = #0x2
; 		return 0;
 801257c: 2300         	movs	r3, #0x0
 801257e: e04f         	b	0x8012620 <transceive+0xd0> @ imm = #0x9e
; 	if (asynchronous) {
 8012580: f897 3028    	ldrb.w	r3, [r7, #0x28]
 8012584: 2b00         	cmp	r3, #0x0
 8012586: d002         	beq	0x801258e <transceive+0x3e> @ imm = #0x4
; 		return -ENOTSUP;
 8012588: f06f 0385    	mvn	r3, #0x85
 801258c: e048         	b	0x8012620 <transceive+0xd0> @ imm = #0x90
; 	spi_context_lock(&data->ctx, asynchronous, cb, userdata, config);
 801258e: 6978         	ldr	r0, [r7, #0x14]
 8012590: f897 1028    	ldrb.w	r1, [r7, #0x28]
 8012594: 68bb         	ldr	r3, [r7, #0x8]
 8012596: 9300         	str	r3, [sp]
 8012598: 6b3b         	ldr	r3, [r7, #0x30]
 801259a: 6afa         	ldr	r2, [r7, #0x2c]
 801259c: f7ff fda0    	bl	0x80120e0 <spi_context_lock> @ imm = #-0x4c0
; 	spi_stm32_pm_policy_state_lock_get(dev);
 80125a0: 68f8         	ldr	r0, [r7, #0xc]
 80125a2: f7ff fec6    	bl	0x8012332 <spi_stm32_pm_policy_state_lock_get> @ imm = #-0x274
; 	ret = spi_stm32_configure(dev, config);
 80125a6: 68b9         	ldr	r1, [r7, #0x8]
 80125a8: 68f8         	ldr	r0, [r7, #0xc]
 80125aa: f7f4 fe3d    	bl	0x8007228 <spi_stm32_configure> @ imm = #-0xb386
 80125ae: 61f8         	str	r0, [r7, #0x1c]
; 	if (ret) {
 80125b0: 69fb         	ldr	r3, [r7, #0x1c]
 80125b2: 2b00         	cmp	r3, #0x0
 80125b4: d12d         	bne	0x8012612 <transceive+0xc2> @ imm = #0x5a
; 	if (SPI_WORD_SIZE_GET(config->operation) == 8) {
 80125b6: 68bb         	ldr	r3, [r7, #0x8]
 80125b8: 889b         	ldrh	r3, [r3, #0x4]
 80125ba: 095b         	lsrs	r3, r3, #0x5
 80125bc: f003 033f    	and	r3, r3, #0x3f
 80125c0: 2b08         	cmp	r3, #0x8
 80125c2: d106         	bne	0x80125d2 <transceive+0x82> @ imm = #0xc
; 		spi_context_buffers_setup(&data->ctx, tx_bufs, rx_bufs, 1);
 80125c4: 6978         	ldr	r0, [r7, #0x14]
 80125c6: 2301         	movs	r3, #0x1
 80125c8: 683a         	ldr	r2, [r7]
 80125ca: 6879         	ldr	r1, [r7, #0x4]
 80125cc: f7f3 ff9c    	bl	0x8006508 <spi_context_buffers_setup> @ imm = #-0xc0c8
 80125d0: e005         	b	0x80125de <transceive+0x8e> @ imm = #0xa
; 		spi_context_buffers_setup(&data->ctx, tx_bufs, rx_bufs, 2);
 80125d2: 6978         	ldr	r0, [r7, #0x14]
 80125d4: 2302         	movs	r3, #0x2
 80125d6: 683a         	ldr	r2, [r7]
 80125d8: 6879         	ldr	r1, [r7, #0x4]
 80125da: f7f3 ff95    	bl	0x8006508 <spi_context_buffers_setup> @ imm = #-0xc0d6
; 	LL_SPI_Enable(spi);
 80125de: 6938         	ldr	r0, [r7, #0x10]
 80125e0: f7ff fa23    	bl	0x8011a2a <LL_SPI_Enable> @ imm = #-0xbba
; 	spi_stm32_cs_control(dev, true);
 80125e4: 2101         	movs	r1, #0x1
 80125e6: 68f8         	ldr	r0, [r7, #0xc]
 80125e8: f7ff ff4c    	bl	0x8012484 <spi_stm32_cs_control> @ imm = #-0x168
; 		ret = spi_stm32_shift_frames(cfg, data);
 80125ec: 6979         	ldr	r1, [r7, #0x14]
 80125ee: 69b8         	ldr	r0, [r7, #0x18]
 80125f0: f7ff ff25    	bl	0x801243e <spi_stm32_shift_frames> @ imm = #-0x1b6
 80125f4: 61f8         	str	r0, [r7, #0x1c]
; 	} while (!ret && spi_stm32_transfer_ongoing(data));
 80125f6: 69fb         	ldr	r3, [r7, #0x1c]
 80125f8: 2b00         	cmp	r3, #0x0
 80125fa: d105         	bne	0x8012608 <transceive+0xb8> @ imm = #0xa
 80125fc: 6978         	ldr	r0, [r7, #0x14]
 80125fe: f7ff feaa    	bl	0x8012356 <spi_stm32_transfer_ongoing> @ imm = #-0x2ac
 8012602: 4603         	mov	r3, r0
 8012604: 2b00         	cmp	r3, #0x0
 8012606: d1f1         	bne	0x80125ec <transceive+0x9c> @ imm = #-0x1e
; 	spi_stm32_complete(dev, ret);
 8012608: 69f9         	ldr	r1, [r7, #0x1c]
 801260a: 68f8         	ldr	r0, [r7, #0xc]
 801260c: f7ff ff4d    	bl	0x80124aa <spi_stm32_complete> @ imm = #-0x166
 8012610: e000         	b	0x8012614 <transceive+0xc4> @ imm = #0x0
; 		goto end;
 8012612: bf00         	nop
; 	spi_context_release(&data->ctx, ret);
 8012614: 697b         	ldr	r3, [r7, #0x14]
 8012616: 69f9         	ldr	r1, [r7, #0x1c]
 8012618: 4618         	mov	r0, r3
 801261a: f7ff fd8d    	bl	0x8012138 <spi_context_release> @ imm = #-0x4e6
; 	return ret;
 801261e: 69fb         	ldr	r3, [r7, #0x1c]
; }
 8012620: 4618         	mov	r0, r3
 8012622: 3720         	adds	r7, #0x20
 8012624: 46bd         	mov	sp, r7
 8012626: bd80         	pop	{r7, pc}

08012628 <spi_stm32_transceive>:
; {
 8012628: b580         	push	{r7, lr}
 801262a: b088         	sub	sp, #0x20
 801262c: af04         	add	r7, sp, #0x10
 801262e: 60f8         	str	r0, [r7, #0xc]
 8012630: 60b9         	str	r1, [r7, #0x8]
 8012632: 607a         	str	r2, [r7, #0x4]
 8012634: 603b         	str	r3, [r7]
; 	return transceive(dev, config, tx_bufs, rx_bufs, false, NULL, NULL);
 8012636: 2300         	movs	r3, #0x0
 8012638: 9302         	str	r3, [sp, #0x8]
 801263a: 2300         	movs	r3, #0x0
 801263c: 9301         	str	r3, [sp, #0x4]
 801263e: 2300         	movs	r3, #0x0
 8012640: 9300         	str	r3, [sp]
 8012642: 683b         	ldr	r3, [r7]
 8012644: 687a         	ldr	r2, [r7, #0x4]
 8012646: 68b9         	ldr	r1, [r7, #0x8]
 8012648: 68f8         	ldr	r0, [r7, #0xc]
 801264a: f7ff ff81    	bl	0x8012550 <transceive>  @ imm = #-0xfe
 801264e: 4603         	mov	r3, r0
; }
 8012650: 4618         	mov	r0, r3
 8012652: 3710         	adds	r7, #0x10
 8012654: 46bd         	mov	sp, r7
 8012656: bd80         	pop	{r7, pc}

08012658 <spi_stm32_is_subghzspi>:
; {
 8012658: b480         	push	{r7}
 801265a: b083         	sub	sp, #0xc
 801265c: af00         	add	r7, sp, #0x0
 801265e: 6078         	str	r0, [r7, #0x4]
; 	return false;
 8012660: 2300         	movs	r3, #0x0
; }
 8012662: 4618         	mov	r0, r3
 8012664: 370c         	adds	r7, #0xc
 8012666: 46bd         	mov	sp, r7
 8012668: bc80         	pop	{r7}
 801266a: 4770         	bx	lr

0801266c <device_is_ready>:
; {
 801266c: b580         	push	{r7, lr}
 801266e: b082         	sub	sp, #0x8
 8012670: af00         	add	r7, sp, #0x0
 8012672: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_device_is_ready(dev);
 8012674: 6878         	ldr	r0, [r7, #0x4]
 8012676: f000 fa4c    	bl	0x8012b12 <z_impl_device_is_ready> @ imm = #0x498
 801267a: 4603         	mov	r3, r0
; }
 801267c: 4618         	mov	r0, r3
 801267e: 3708         	adds	r7, #0x8
 8012680: 46bd         	mov	sp, r7
 8012682: bd80         	pop	{r7, pc}

08012684 <k_sem_init>:
; {
 8012684: b580         	push	{r7, lr}
 8012686: b084         	sub	sp, #0x10
 8012688: af00         	add	r7, sp, #0x0
 801268a: 60f8         	str	r0, [r7, #0xc]
 801268c: 60b9         	str	r1, [r7, #0x8]
 801268e: 607a         	str	r2, [r7, #0x4]
; 	return z_impl_k_sem_init(sem, initial_count, limit);
 8012690: 687a         	ldr	r2, [r7, #0x4]
 8012692: 68b9         	ldr	r1, [r7, #0x8]
 8012694: 68f8         	ldr	r0, [r7, #0xc]
 8012696: f000 fe73    	bl	0x8013380 <z_impl_k_sem_init> @ imm = #0xce6
 801269a: 4603         	mov	r3, r0
; }
 801269c: 4618         	mov	r0, r3
 801269e: 3710         	adds	r7, #0x10
 80126a0: 46bd         	mov	sp, r7
 80126a2: bd80         	pop	{r7, pc}

080126a4 <k_sem_take>:
; {
 80126a4: b580         	push	{r7, lr}
 80126a6: b084         	sub	sp, #0x10
 80126a8: af00         	add	r7, sp, #0x0
 80126aa: 60f8         	str	r0, [r7, #0xc]
 80126ac: e9c7 2300    	strd	r2, r3, [r7]
; 	return z_impl_k_sem_take(sem, timeout);
 80126b0: e9d7 2300    	ldrd	r2, r3, [r7]
 80126b4: 68f8         	ldr	r0, [r7, #0xc]
 80126b6: f7f7 fd39    	bl	0x800a12c <z_impl_k_sem_take> @ imm = #-0x858e
 80126ba: 4603         	mov	r3, r0
; }
 80126bc: 4618         	mov	r0, r3
 80126be: 3710         	adds	r7, #0x10
 80126c0: 46bd         	mov	sp, r7
 80126c2: bd80         	pop	{r7, pc}

080126c4 <k_sem_give>:
; {
 80126c4: b580         	push	{r7, lr}
 80126c6: b082         	sub	sp, #0x8
 80126c8: af00         	add	r7, sp, #0x0
 80126ca: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_sem_give(sem);
 80126cc: 6878         	ldr	r0, [r7, #0x4]
 80126ce: f7f7 fc9f    	bl	0x800a010 <z_impl_k_sem_give> @ imm = #-0x86c2
; }
 80126d2: bf00         	nop
 80126d4: 3708         	adds	r7, #0x8
 80126d6: 46bd         	mov	sp, r7
 80126d8: bd80         	pop	{r7, pc}

080126da <k_msgq_put>:
; {
 80126da: b580         	push	{r7, lr}
 80126dc: b084         	sub	sp, #0x10
 80126de: af00         	add	r7, sp, #0x0
 80126e0: 60f8         	str	r0, [r7, #0xc]
 80126e2: 60b9         	str	r1, [r7, #0x8]
 80126e4: e9c7 2300    	strd	r2, r3, [r7]
; 	return z_impl_k_msgq_put(msgq, data, timeout);
 80126e8: e9d7 2300    	ldrd	r2, r3, [r7]
 80126ec: 68b9         	ldr	r1, [r7, #0x8]
 80126ee: 68f8         	ldr	r0, [r7, #0xc]
 80126f0: f7f6 ff48    	bl	0x8009584 <z_impl_k_msgq_put> @ imm = #-0x9170
 80126f4: 4603         	mov	r3, r0
; }
 80126f6: 4618         	mov	r0, r3
 80126f8: 3710         	adds	r7, #0x10
 80126fa: 46bd         	mov	sp, r7
 80126fc: bd80         	pop	{r7, pc}

080126fe <k_msgq_get>:
; {
 80126fe: b580         	push	{r7, lr}
 8012700: b084         	sub	sp, #0x10
 8012702: af00         	add	r7, sp, #0x0
 8012704: 60f8         	str	r0, [r7, #0xc]
 8012706: 60b9         	str	r1, [r7, #0x8]
 8012708: e9c7 2300    	strd	r2, r3, [r7]
; 	return z_impl_k_msgq_get(msgq, data, timeout);
 801270c: e9d7 2300    	ldrd	r2, r3, [r7]
 8012710: 68b9         	ldr	r1, [r7, #0x8]
 8012712: 68f8         	ldr	r0, [r7, #0xc]
 8012714: f7f7 f802    	bl	0x800971c <z_impl_k_msgq_get> @ imm = #-0x8ffc
 8012718: 4603         	mov	r3, r0
; }
 801271a: 4618         	mov	r0, r3
 801271c: 3710         	adds	r7, #0x10
 801271e: 46bd         	mov	sp, r7
 8012720: bd80         	pop	{r7, pc}

08012722 <z_log_msg_runtime_create>:
; {
 8012722: b580         	push	{r7, lr}
 8012724: b08a         	sub	sp, #0x28
 8012726: af04         	add	r7, sp, #0x10
 8012728: 60b9         	str	r1, [r7, #0x8]
 801272a: 607b         	str	r3, [r7, #0x4]
 801272c: 4603         	mov	r3, r0
 801272e: 73fb         	strb	r3, [r7, #0xf]
 8012730: 4613         	mov	r3, r2
 8012732: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 8012734: f107 032c    	add.w	r3, r7, #0x2c
 8012738: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 801273a: 7bba         	ldrb	r2, [r7, #0xe]
 801273c: 7bf8         	ldrb	r0, [r7, #0xf]
 801273e: 697b         	ldr	r3, [r7, #0x14]
 8012740: 9303         	str	r3, [sp, #0xc]
 8012742: 6abb         	ldr	r3, [r7, #0x28]
 8012744: 9302         	str	r3, [sp, #0x8]
 8012746: 6a7b         	ldr	r3, [r7, #0x24]
 8012748: 9301         	str	r3, [sp, #0x4]
 801274a: 6a3b         	ldr	r3, [r7, #0x20]
 801274c: 9300         	str	r3, [sp]
 801274e: 687b         	ldr	r3, [r7, #0x4]
 8012750: 68b9         	ldr	r1, [r7, #0x8]
 8012752: f7ef f877    	bl	0x8001844 <z_log_msg_runtime_vcreate> @ imm = #-0x10f12
; }
 8012756: bf00         	nop
 8012758: 3718         	adds	r7, #0x18
 801275a: 46bd         	mov	sp, r7
 801275c: bd80         	pop	{r7, pc}

0801275e <z_impl_pid_get_params>:
; static inline const struct pid_single_config *z_impl_pid_get_params(const struct device *dev) {
 801275e: b580         	push	{r7, lr}
 8012760: b084         	sub	sp, #0x10
 8012762: af00         	add	r7, sp, #0x0
 8012764: 6078         	str	r0, [r7, #0x4]
;     const struct pid_driver_api *api = (const struct pid_driver_api *)dev->api;
 8012766: 687b         	ldr	r3, [r7, #0x4]
 8012768: 689b         	ldr	r3, [r3, #0x8]
 801276a: 60fb         	str	r3, [r7, #0xc]
;     if (api->pid_get_params != NULL) {
 801276c: 68fb         	ldr	r3, [r7, #0xc]
 801276e: 695b         	ldr	r3, [r3, #0x14]
 8012770: 2b00         	cmp	r3, #0x0
 8012772: d005         	beq	0x8012780 <z_impl_pid_get_params+0x22> @ imm = #0xa
;         return api->pid_get_params(dev);
 8012774: 68fb         	ldr	r3, [r7, #0xc]
 8012776: 695b         	ldr	r3, [r3, #0x14]
 8012778: 6878         	ldr	r0, [r7, #0x4]
 801277a: 4798         	blx	r3
 801277c: 4603         	mov	r3, r0
 801277e: e000         	b	0x8012782 <z_impl_pid_get_params+0x24> @ imm = #0x0
;     return NULL;
 8012780: 2300         	movs	r3, #0x0
; }
 8012782: 4618         	mov	r0, r3
 8012784: 3710         	adds	r7, #0x10
 8012786: 46bd         	mov	sp, r7
 8012788: bd80         	pop	{r7, pc}

0801278a <pid_get_params>:
; {
 801278a: b580         	push	{r7, lr}
 801278c: b082         	sub	sp, #0x8
 801278e: af00         	add	r7, sp, #0x0
 8012790: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_pid_get_params(dev);
 8012792: 6878         	ldr	r0, [r7, #0x4]
 8012794: f7ff ffe3    	bl	0x801275e <z_impl_pid_get_params> @ imm = #-0x3a
 8012798: 4603         	mov	r3, r0
; }
 801279a: 4618         	mov	r0, r3
 801279c: 3708         	adds	r7, #0x8
 801279e: 46bd         	mov	sp, r7
 80127a0: bd80         	pop	{r7, pc}

080127a2 <z_impl_can_start>:
; {
 80127a2: b580         	push	{r7, lr}
 80127a4: b084         	sub	sp, #0x10
 80127a6: af00         	add	r7, sp, #0x0
 80127a8: 6078         	str	r0, [r7, #0x4]
; 	const struct can_driver_api *api = (const struct can_driver_api *)dev->api;
 80127aa: 687b         	ldr	r3, [r7, #0x4]
 80127ac: 689b         	ldr	r3, [r3, #0x8]
 80127ae: 60fb         	str	r3, [r7, #0xc]
; 	return api->start(dev);
 80127b0: 68fb         	ldr	r3, [r7, #0xc]
 80127b2: 685b         	ldr	r3, [r3, #0x4]
 80127b4: 6878         	ldr	r0, [r7, #0x4]
 80127b6: 4798         	blx	r3
 80127b8: 4603         	mov	r3, r0
; }
 80127ba: 4618         	mov	r0, r3
 80127bc: 3710         	adds	r7, #0x10
 80127be: 46bd         	mov	sp, r7
 80127c0: bd80         	pop	{r7, pc}

080127c2 <can_start>:
; {
 80127c2: b580         	push	{r7, lr}
 80127c4: b082         	sub	sp, #0x8
 80127c6: af00         	add	r7, sp, #0x0
 80127c8: 6078         	str	r0, [r7, #0x4]
; 	return z_impl_can_start(dev);
 80127ca: 6878         	ldr	r0, [r7, #0x4]
 80127cc: f7ff ffe9    	bl	0x80127a2 <z_impl_can_start> @ imm = #-0x2e
 80127d0: 4603         	mov	r3, r0
; }
 80127d2: 4618         	mov	r0, r3
 80127d4: 3708         	adds	r7, #0x8
 80127d6: 46bd         	mov	sp, r7
 80127d8: bd80         	pop	{r7, pc}

080127da <can_send>:
; {
 80127da: b580         	push	{r7, lr}
 80127dc: b086         	sub	sp, #0x18
 80127de: af02         	add	r7, sp, #0x8
 80127e0: 60f8         	str	r0, [r7, #0xc]
 80127e2: 60b9         	str	r1, [r7, #0x8]
 80127e4: e9c7 2300    	strd	r2, r3, [r7]
; 	return z_impl_can_send(dev, frame, timeout, callback, user_data);
 80127e8: 69fb         	ldr	r3, [r7, #0x1c]
 80127ea: 9301         	str	r3, [sp, #0x4]
 80127ec: 69bb         	ldr	r3, [r7, #0x18]
 80127ee: 9300         	str	r3, [sp]
 80127f0: e9d7 2300    	ldrd	r2, r3, [r7]
 80127f4: 68b9         	ldr	r1, [r7, #0x8]
 80127f6: 68f8         	ldr	r0, [r7, #0xc]
 80127f8: f7f1 f8bc    	bl	0x8003974 <z_impl_can_send> @ imm = #-0xee88
 80127fc: 4603         	mov	r3, r0
; }
 80127fe: 4618         	mov	r0, r3
 8012800: 3710         	adds	r7, #0x10
 8012802: 46bd         	mov	sp, r7
 8012804: bd80         	pop	{r7, pc}

08012806 <can_add_rx_filter_msgq>:
; {
 8012806: b580         	push	{r7, lr}
 8012808: b084         	sub	sp, #0x10
 801280a: af00         	add	r7, sp, #0x0
 801280c: 60f8         	str	r0, [r7, #0xc]
 801280e: 60b9         	str	r1, [r7, #0x8]
 8012810: 607a         	str	r2, [r7, #0x4]
; 	return z_impl_can_add_rx_filter_msgq(dev, msgq, filter);
 8012812: 687a         	ldr	r2, [r7, #0x4]
 8012814: 68b9         	ldr	r1, [r7, #0x8]
 8012816: 68f8         	ldr	r0, [r7, #0xc]
 8012818: f7f1 f990    	bl	0x8003b3c <z_impl_can_add_rx_filter_msgq> @ imm = #-0xece0
 801281c: 4603         	mov	r3, r0
; }
 801281e: 4618         	mov	r0, r3
 8012820: 3710         	adds	r7, #0x10
 8012822: 46bd         	mov	sp, r7
 8012824: bd80         	pop	{r7, pc}

08012826 <uint_to_float>:
; static inline float uint_to_float(int x_int, float x_min, float x_max, int bits) {
 8012826: b590         	push	{r4, r7, lr}
 8012828: b087         	sub	sp, #0x1c
 801282a: af00         	add	r7, sp, #0x0
 801282c: 60f8         	str	r0, [r7, #0xc]
 801282e: 60b9         	str	r1, [r7, #0x8]
 8012830: 607a         	str	r2, [r7, #0x4]
 8012832: 603b         	str	r3, [r7]
;     float span   = x_max - x_min;
 8012834: 68b9         	ldr	r1, [r7, #0x8]
 8012836: 6878         	ldr	r0, [r7, #0x4]
 8012838: f7ed fcaa    	bl	0x8000190 <__subsf3>    @ imm = #-0x126ac
 801283c: 4603         	mov	r3, r0
 801283e: 617b         	str	r3, [r7, #0x14]
;     float offset = x_min;
 8012840: 68bb         	ldr	r3, [r7, #0x8]
 8012842: 613b         	str	r3, [r7, #0x10]
;     return ((float)x_int) * span / ((float)((1 << bits) - 1)) + offset;
 8012844: 68f8         	ldr	r0, [r7, #0xc]
 8012846: f7ed fd59    	bl	0x80002fc <__floatsisf> @ imm = #-0x1254e
 801284a: 4603         	mov	r3, r0
 801284c: 6979         	ldr	r1, [r7, #0x14]
 801284e: 4618         	mov	r0, r3
 8012850: f7ed fda8    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x124b0
 8012854: 4603         	mov	r3, r0
 8012856: 461c         	mov	r4, r3
 8012858: 2201         	movs	r2, #0x1
 801285a: 683b         	ldr	r3, [r7]
 801285c: fa02 f303    	lsl.w	r3, r2, r3
 8012860: 3b01         	subs	r3, #0x1
 8012862: 4618         	mov	r0, r3
 8012864: f7ed fd4a    	bl	0x80002fc <__floatsisf> @ imm = #-0x1256c
 8012868: 4603         	mov	r3, r0
 801286a: 4619         	mov	r1, r3
 801286c: 4620         	mov	r0, r4
 801286e: f7ed fe4d    	bl	0x800050c <__divsf3>    @ imm = #-0x12366
 8012872: 4603         	mov	r3, r0
 8012874: 6939         	ldr	r1, [r7, #0x10]
 8012876: 4618         	mov	r0, r3
 8012878: f7ed fc8c    	bl	0x8000194 <__aeabi_fadd> @ imm = #-0x126e8
 801287c: 4603         	mov	r3, r0
; }
 801287e: 4618         	mov	r0, r3
 8012880: 371c         	adds	r7, #0x1c
 8012882: 46bd         	mov	sp, r7
 8012884: bd90         	pop	{r4, r7, pc}

08012886 <float_to_uint>:
; static inline int float_to_uint(float x, float x_min, float x_max, int bits) {
 8012886: b590         	push	{r4, r7, lr}
 8012888: b087         	sub	sp, #0x1c
 801288a: af00         	add	r7, sp, #0x0
 801288c: 60f8         	str	r0, [r7, #0xc]
 801288e: 60b9         	str	r1, [r7, #0x8]
 8012890: 607a         	str	r2, [r7, #0x4]
 8012892: 603b         	str	r3, [r7]
;     float span   = x_max - x_min;
 8012894: 68b9         	ldr	r1, [r7, #0x8]
 8012896: 6878         	ldr	r0, [r7, #0x4]
 8012898: f7ed fc7a    	bl	0x8000190 <__subsf3>    @ imm = #-0x1270c
 801289c: 4603         	mov	r3, r0
 801289e: 617b         	str	r3, [r7, #0x14]
;     float offset = x_min;
 80128a0: 68bb         	ldr	r3, [r7, #0x8]
 80128a2: 613b         	str	r3, [r7, #0x10]
;     return (int)((x - offset) * ((float)((1 << bits) - 1)) / span);
 80128a4: 6939         	ldr	r1, [r7, #0x10]
 80128a6: 68f8         	ldr	r0, [r7, #0xc]
 80128a8: f7ed fc72    	bl	0x8000190 <__subsf3>    @ imm = #-0x1271c
 80128ac: 4603         	mov	r3, r0
 80128ae: 461c         	mov	r4, r3
 80128b0: 2201         	movs	r2, #0x1
 80128b2: 683b         	ldr	r3, [r7]
 80128b4: fa02 f303    	lsl.w	r3, r2, r3
 80128b8: 3b01         	subs	r3, #0x1
 80128ba: 4618         	mov	r0, r3
 80128bc: f7ed fd1e    	bl	0x80002fc <__floatsisf> @ imm = #-0x125c4
 80128c0: 4603         	mov	r3, r0
 80128c2: 4619         	mov	r1, r3
 80128c4: 4620         	mov	r0, r4
 80128c6: f7ed fd6d    	bl	0x80003a4 <__mulsf3>    @ imm = #-0x12526
 80128ca: 4603         	mov	r3, r0
 80128cc: 6979         	ldr	r1, [r7, #0x14]
 80128ce: 4618         	mov	r0, r3
 80128d0: f7ed fe1c    	bl	0x800050c <__divsf3>    @ imm = #-0x123c8
 80128d4: 4603         	mov	r3, r0
 80128d6: 4618         	mov	r0, r3
 80128d8: f7ed ff2a    	bl	0x8000730 <__fixsfsi>   @ imm = #-0x121ac
 80128dc: 4603         	mov	r3, r0
; }
 80128de: 4618         	mov	r0, r3
 80128e0: 371c         	adds	r7, #0x1c
 80128e2: 46bd         	mov	sp, r7
 80128e4: bd90         	pop	{r4, r7, pc}

080128e6 <can_tx_callback>:
; static void can_tx_callback(const struct device *can_dev, int error, void *user_data) {
 80128e6: b580         	push	{r7, lr}
 80128e8: b086         	sub	sp, #0x18
 80128ea: af00         	add	r7, sp, #0x0
 80128ec: 60f8         	str	r0, [r7, #0xc]
 80128ee: 60b9         	str	r1, [r7, #0x8]
 80128f0: 607a         	str	r2, [r7, #0x4]
;     struct k_sem *queue_sem = user_data;
 80128f2: 687b         	ldr	r3, [r7, #0x4]
 80128f4: 617b         	str	r3, [r7, #0x14]
;     if (!error)
 80128f6: 68bb         	ldr	r3, [r7, #0x8]
 80128f8: 2b00         	cmp	r3, #0x0
 80128fa: d102         	bne	0x8012902 <can_tx_callback+0x1c> @ imm = #0x4
;         k_sem_give(queue_sem);
 80128fc: 6978         	ldr	r0, [r7, #0x14]
 80128fe: f7ff fee1    	bl	0x80126c4 <k_sem_give>  @ imm = #-0x23e
; }
 8012902: bf00         	nop
 8012904: 3718         	adds	r7, #0x18
 8012906: 46bd         	mov	sp, r7
 8012908: bd80         	pop	{r7, pc}

0801290a <dm_motor_get_angle>:
; float dm_motor_get_angle(const struct device *dev) {
 801290a: b480         	push	{r7}
 801290c: b085         	sub	sp, #0x14
 801290e: af00         	add	r7, sp, #0x0
 8012910: 6078         	str	r0, [r7, #0x4]
;     struct dm_motor_data *data = dev->data;
 8012912: 687b         	ldr	r3, [r7, #0x4]
 8012914: 691b         	ldr	r3, [r3, #0x10]
 8012916: 60fb         	str	r3, [r7, #0xc]
;     return data->common.angle;
 8012918: 68fb         	ldr	r3, [r7, #0xc]
 801291a: 681b         	ldr	r3, [r3]
; }
 801291c: 4618         	mov	r0, r3
 801291e: 3714         	adds	r7, #0x14
 8012920: 46bd         	mov	sp, r7
 8012922: bc80         	pop	{r7}
 8012924: 4770         	bx	lr

08012926 <dm_motor_get_speed>:
; float dm_motor_get_speed(const struct device *dev) {
 8012926: b480         	push	{r7}
 8012928: b085         	sub	sp, #0x14
 801292a: af00         	add	r7, sp, #0x0
 801292c: 6078         	str	r0, [r7, #0x4]
;     struct dm_motor_data *data = dev->data;
 801292e: 687b         	ldr	r3, [r7, #0x4]
 8012930: 691b         	ldr	r3, [r3, #0x10]
 8012932: 60fb         	str	r3, [r7, #0xc]
;     return data->common.rpm;
 8012934: 68fb         	ldr	r3, [r7, #0xc]
 8012936: 685b         	ldr	r3, [r3, #0x4]
; }
 8012938: 4618         	mov	r0, r3
 801293a: 3714         	adds	r7, #0x14
 801293c: 46bd         	mov	sp, r7
 801293e: bc80         	pop	{r7}
 8012940: 4770         	bx	lr

08012942 <dm_motor_get_torque>:
; float dm_motor_get_torque(const struct device *dev) {
 8012942: b480         	push	{r7}
 8012944: b085         	sub	sp, #0x14
 8012946: af00         	add	r7, sp, #0x0
 8012948: 6078         	str	r0, [r7, #0x4]
;     struct dm_motor_data *data = dev->data;
 801294a: 687b         	ldr	r3, [r7, #0x4]
 801294c: 691b         	ldr	r3, [r3, #0x10]
 801294e: 60fb         	str	r3, [r7, #0xc]
;     return data->common.torque;
 8012950: 68fb         	ldr	r3, [r7, #0xc]
 8012952: 689b         	ldr	r3, [r3, #0x8]
; }
 8012954: 4618         	mov	r0, r3
 8012956: 3714         	adds	r7, #0x14
 8012958: 46bd         	mov	sp, r7
 801295a: bc80         	pop	{r7}
 801295c: 4770         	bx	lr

0801295e <dm_motor_set_torque>:
; int dm_motor_set_torque(const struct device *dev, float torque) {
 801295e: b580         	push	{r7, lr}
 8012960: b086         	sub	sp, #0x18
 8012962: af00         	add	r7, sp, #0x0
 8012964: 6078         	str	r0, [r7, #0x4]
 8012966: 6039         	str	r1, [r7]
;     struct dm_motor_data         *data = dev->data;
 8012968: 687b         	ldr	r3, [r7, #0x4]
 801296a: 691b         	ldr	r3, [r3, #0x10]
 801296c: 617b         	str	r3, [r7, #0x14]
;     const struct dm_motor_config *cfg  = dev->config;
 801296e: 687b         	ldr	r3, [r7, #0x4]
 8012970: 685b         	ldr	r3, [r3, #0x4]
 8012972: 613b         	str	r3, [r7, #0x10]
;     data->target_rpm    = 0;
 8012974: 697b         	ldr	r3, [r7, #0x14]
 8012976: f04f 0200    	mov.w	r2, #0x0
 801297a: 629a         	str	r2, [r3, #0x28]
;     data->target_angle  = 0;
 801297c: 697b         	ldr	r3, [r7, #0x14]
 801297e: f04f 0200    	mov.w	r2, #0x0
 8012982: 625a         	str	r2, [r3, #0x24]
;     float torque_scaled = torque / cfg->gear_ratio;
 8012984: 693b         	ldr	r3, [r7, #0x10]
 8012986: 6d1b         	ldr	r3, [r3, #0x50]
 8012988: 4619         	mov	r1, r3
 801298a: 6838         	ldr	r0, [r7]
 801298c: f7ed fdbe    	bl	0x800050c <__divsf3>    @ imm = #-0x12484
 8012990: 4603         	mov	r3, r0
 8012992: 60fb         	str	r3, [r7, #0xc]
;     data->target_torque = torque_scaled;
 8012994: 697b         	ldr	r3, [r7, #0x14]
 8012996: 68fa         	ldr	r2, [r7, #0xc]
 8012998: 62da         	str	r2, [r3, #0x2c]
;     data->params.k_p    = 0;
 801299a: 697b         	ldr	r3, [r7, #0x14]
 801299c: f04f 0200    	mov.w	r2, #0x0
 80129a0: 631a         	str	r2, [r3, #0x30]
;     data->params.k_d    = 0;
 80129a2: 697b         	ldr	r3, [r7, #0x14]
 80129a4: f04f 0200    	mov.w	r2, #0x0
 80129a8: 639a         	str	r2, [r3, #0x38]
;     return 0;
 80129aa: 2300         	movs	r3, #0x0
; }
 80129ac: 4618         	mov	r0, r3
 80129ae: 3718         	adds	r7, #0x18
 80129b0: 46bd         	mov	sp, r7
 80129b2: bd80         	pop	{r7, pc}

080129b4 <dm_motor_set_speed>:
; int dm_motor_set_speed(const struct device *dev, float speed_rpm) {
 80129b4: b480         	push	{r7}
 80129b6: b085         	sub	sp, #0x14
 80129b8: af00         	add	r7, sp, #0x0
 80129ba: 6078         	str	r0, [r7, #0x4]
 80129bc: 6039         	str	r1, [r7]
;     struct dm_motor_data *data = dev->data;
 80129be: 687b         	ldr	r3, [r7, #0x4]
 80129c0: 691b         	ldr	r3, [r3, #0x10]
 80129c2: 60fb         	str	r3, [r7, #0xc]
;     data->target_rpm = speed_rpm;
 80129c4: 68fb         	ldr	r3, [r7, #0xc]
 80129c6: 683a         	ldr	r2, [r7]
 80129c8: 629a         	str	r2, [r3, #0x28]
;     return 0;
 80129ca: 2300         	movs	r3, #0x0
; }
 80129cc: 4618         	mov	r0, r3
 80129ce: 3714         	adds	r7, #0x14
 80129d0: 46bd         	mov	sp, r7
 80129d2: bc80         	pop	{r7}
 80129d4: 4770         	bx	lr

080129d6 <dm_motor_set_angle>:
; int dm_motor_set_angle(const struct device *dev, float angle) {
 80129d6: b480         	push	{r7}
 80129d8: b085         	sub	sp, #0x14
 80129da: af00         	add	r7, sp, #0x0
 80129dc: 6078         	str	r0, [r7, #0x4]
 80129de: 6039         	str	r1, [r7]
;     struct dm_motor_data *data = dev->data;
 80129e0: 687b         	ldr	r3, [r7, #0x4]
 80129e2: 691b         	ldr	r3, [r3, #0x10]
 80129e4: 60fb         	str	r3, [r7, #0xc]
;     data->target_angle = angle;
 80129e6: 68fb         	ldr	r3, [r7, #0xc]
 80129e8: 683a         	ldr	r2, [r7]
 80129ea: 625a         	str	r2, [r3, #0x24]
;     return 0;
 80129ec: 2300         	movs	r3, #0x0
; }
 80129ee: 4618         	mov	r0, r3
 80129f0: 3714         	adds	r7, #0x14
 80129f2: 46bd         	mov	sp, r7
 80129f4: bc80         	pop	{r7}
 80129f6: 4770         	bx	lr

080129f8 <pid_mit_get_params>:
; static const struct pid_single_config *pid_mit_get_params(const struct device *pid_dev) {
 80129f8: b480         	push	{r7}
 80129fa: b083         	sub	sp, #0xc
 80129fc: af00         	add	r7, sp, #0x0
 80129fe: 6078         	str	r0, [r7, #0x4]
;     return &((struct pid_mit_config *)pid_dev->config)->common;
 8012a00: 687b         	ldr	r3, [r7, #0x4]
 8012a02: 685b         	ldr	r3, [r3, #0x4]
; }
 8012a04: 4618         	mov	r0, r3
 8012a06: 370c         	adds	r7, #0xc
 8012a08: 46bd         	mov	sp, r7
 8012a0a: bc80         	pop	{r7}
 8012a0c: 4770         	bx	lr

08012a0e <pid_mit_reg_input>:
; static void pid_mit_reg_input(const struct device *pid_dev, float *curr, float *ref) {
 8012a0e: b480         	push	{r7}
 8012a10: b087         	sub	sp, #0x1c
 8012a12: af00         	add	r7, sp, #0x0
 8012a14: 60f8         	str	r0, [r7, #0xc]
 8012a16: 60b9         	str	r1, [r7, #0x8]
 8012a18: 607a         	str	r2, [r7, #0x4]
;     struct pid_mit_data *pid_data = pid_dev->data;
 8012a1a: 68fb         	ldr	r3, [r7, #0xc]
 8012a1c: 691b         	ldr	r3, [r3, #0x10]
 8012a1e: 617b         	str	r3, [r7, #0x14]
;     pid_data->curr                = curr;
 8012a20: 697b         	ldr	r3, [r7, #0x14]
 8012a22: 68ba         	ldr	r2, [r7, #0x8]
 8012a24: 609a         	str	r2, [r3, #0x8]
;     pid_data->ref                 = ref;
 8012a26: 697b         	ldr	r3, [r7, #0x14]
 8012a28: 687a         	ldr	r2, [r7, #0x4]
 8012a2a: 601a         	str	r2, [r3]
;     return;
 8012a2c: bf00         	nop
; }
 8012a2e: 371c         	adds	r7, #0x1c
 8012a30: 46bd         	mov	sp, r7
 8012a32: bc80         	pop	{r7}
 8012a34: 4770         	bx	lr

08012a36 <pid_mit_reg_detri>:
; static void pid_mit_reg_detri(const struct device *pid_dev, float *curr, float *ref) {
 8012a36: b480         	push	{r7}
 8012a38: b087         	sub	sp, #0x1c
 8012a3a: af00         	add	r7, sp, #0x0
 8012a3c: 60f8         	str	r0, [r7, #0xc]
 8012a3e: 60b9         	str	r1, [r7, #0x8]
 8012a40: 607a         	str	r2, [r7, #0x4]
;     struct pid_mit_data *pid_data = pid_dev->data;
 8012a42: 68fb         	ldr	r3, [r7, #0xc]
 8012a44: 691b         	ldr	r3, [r3, #0x10]
 8012a46: 617b         	str	r3, [r7, #0x14]
;     pid_data->detri_curr          = curr;
 8012a48: 697b         	ldr	r3, [r7, #0x14]
 8012a4a: 68ba         	ldr	r2, [r7, #0x8]
 8012a4c: 60da         	str	r2, [r3, #0xc]
;     pid_data->detri_ref           = ref;
 8012a4e: 697b         	ldr	r3, [r7, #0x14]
 8012a50: 687a         	ldr	r2, [r7, #0x4]
 8012a52: 605a         	str	r2, [r3, #0x4]
;     return;
 8012a54: bf00         	nop
; }
 8012a56: 371c         	adds	r7, #0x1c
 8012a58: 46bd         	mov	sp, r7
 8012a5a: bc80         	pop	{r7}
 8012a5c: 4770         	bx	lr

08012a5e <pid_mit_reg_time>:
;                              uint32_t *prev_time) {
 8012a5e: b480         	push	{r7}
 8012a60: b087         	sub	sp, #0x1c
 8012a62: af00         	add	r7, sp, #0x0
 8012a64: 60f8         	str	r0, [r7, #0xc]
 8012a66: 60b9         	str	r1, [r7, #0x8]
 8012a68: 607a         	str	r2, [r7, #0x4]
;     struct pid_mit_data *pid_data = pid_dev->data;
 8012a6a: 68fb         	ldr	r3, [r7, #0xc]
 8012a6c: 691b         	ldr	r3, [r3, #0x10]
 8012a6e: 617b         	str	r3, [r7, #0x14]
;     pid_data->curr_time           = curr_time;
 8012a70: 697b         	ldr	r3, [r7, #0x14]
 8012a72: 68ba         	ldr	r2, [r7, #0x8]
 8012a74: 61da         	str	r2, [r3, #0x1c]
;     pid_data->prev_time           = prev_time;
 8012a76: 697b         	ldr	r3, [r7, #0x14]
 8012a78: 687a         	ldr	r2, [r7, #0x4]
 8012a7a: 621a         	str	r2, [r3, #0x20]
;     return;
 8012a7c: bf00         	nop
; }
 8012a7e: 371c         	adds	r7, #0x1c
 8012a80: 46bd         	mov	sp, r7
 8012a82: bc80         	pop	{r7}
 8012a84: 4770         	bx	lr

08012a86 <pid_mit_reg_output>:
; static void pid_mit_reg_output(const struct device *pid_dev, float *output) {
 8012a86: b480         	push	{r7}
 8012a88: b085         	sub	sp, #0x14
 8012a8a: af00         	add	r7, sp, #0x0
 8012a8c: 6078         	str	r0, [r7, #0x4]
 8012a8e: 6039         	str	r1, [r7]
;     struct pid_mit_data *pid_data = pid_dev->data;
 8012a90: 687b         	ldr	r3, [r7, #0x4]
 8012a92: 691b         	ldr	r3, [r3, #0x10]
 8012a94: 60fb         	str	r3, [r7, #0xc]
;     pid_data->output              = output;
 8012a96: 68fb         	ldr	r3, [r7, #0xc]
 8012a98: 683a         	ldr	r2, [r7]
 8012a9a: 625a         	str	r2, [r3, #0x24]
;     return;
 8012a9c: bf00         	nop
; }
 8012a9e: 3714         	adds	r7, #0x14
 8012aa0: 46bd         	mov	sp, r7
 8012aa2: bc80         	pop	{r7}
 8012aa4: 4770         	bx	lr

08012aa6 <arch_k_cycle_get_32>:
; {
 8012aa6: b580         	push	{r7, lr}
 8012aa8: af00         	add	r7, sp, #0x0
; 	return sys_clock_cycle_get_32();
 8012aaa: f7f4 fffd    	bl	0x8007aa8 <sys_clock_cycle_get_32> @ imm = #-0xb006
 8012aae: 4603         	mov	r3, r0
; }
 8012ab0: 4618         	mov	r0, r3
 8012ab2: bd80         	pop	{r7, pc}

08012ab4 <k_cycle_get_32>:
; {
 8012ab4: b580         	push	{r7, lr}
 8012ab6: af00         	add	r7, sp, #0x0
; 	return arch_k_cycle_get_32();
 8012ab8: f7ff fff5    	bl	0x8012aa6 <arch_k_cycle_get_32> @ imm = #-0x16
 8012abc: 4603         	mov	r3, r0
; }
 8012abe: 4618         	mov	r0, r3
 8012ac0: bd80         	pop	{r7, pc}

08012ac2 <z_impl_k_busy_wait>:
; {
 8012ac2: b580         	push	{r7, lr}
 8012ac4: b086         	sub	sp, #0x18
 8012ac6: af00         	add	r7, sp, #0x0
 8012ac8: 6078         	str	r0, [r7, #0x4]
; 	if (usec_to_wait == 0U) {
 8012aca: 687b         	ldr	r3, [r7, #0x4]
 8012acc: 2b00         	cmp	r3, #0x0
 8012ace: d011         	beq	0x8012af4 <z_impl_k_busy_wait+0x32> @ imm = #0x22
; 	uint32_t start_cycles = k_cycle_get_32();
 8012ad0: f7ff fff0    	bl	0x8012ab4 <k_cycle_get_32> @ imm = #-0x20
 8012ad4: 6178         	str	r0, [r7, #0x14]
; 	uint32_t cycles_to_wait = k_us_to_cyc_ceil32(usec_to_wait);
 8012ad6: 687b         	ldr	r3, [r7, #0x4]
 8012ad8: 22a8         	movs	r2, #0xa8
 8012ada: fb02 f303    	mul	r3, r2, r3
 8012ade: 613b         	str	r3, [r7, #0x10]
; 		uint32_t current_cycles = k_cycle_get_32();
 8012ae0: f7ff ffe8    	bl	0x8012ab4 <k_cycle_get_32> @ imm = #-0x30
 8012ae4: 60f8         	str	r0, [r7, #0xc]
; 		if ((current_cycles - start_cycles) >= cycles_to_wait) {
 8012ae6: 68fa         	ldr	r2, [r7, #0xc]
 8012ae8: 697b         	ldr	r3, [r7, #0x14]
 8012aea: 1ad3         	subs	r3, r2, r3
 8012aec: 693a         	ldr	r2, [r7, #0x10]
 8012aee: 429a         	cmp	r2, r3
 8012af0: d902         	bls	0x8012af8 <z_impl_k_busy_wait+0x36> @ imm = #0x4
; 	for (;;) {
 8012af2: e7f5         	b	0x8012ae0 <z_impl_k_busy_wait+0x1e> @ imm = #-0x16
; 		return;
 8012af4: bf00         	nop
 8012af6: e000         	b	0x8012afa <z_impl_k_busy_wait+0x38> @ imm = #0x0
; 			break;
 8012af8: bf00         	nop
; }
 8012afa: 3718         	adds	r7, #0x18
 8012afc: 46bd         	mov	sp, r7
 8012afe: bd80         	pop	{r7, pc}

08012b00 <k_object_init>:
; {
 8012b00: b480         	push	{r7}
 8012b02: b083         	sub	sp, #0xc
 8012b04: af00         	add	r7, sp, #0x0
 8012b06: 6078         	str	r0, [r7, #0x4]
; }
 8012b08: bf00         	nop
 8012b0a: 370c         	adds	r7, #0xc
 8012b0c: 46bd         	mov	sp, r7
 8012b0e: bc80         	pop	{r7}
 8012b10: 4770         	bx	lr

08012b12 <z_impl_device_is_ready>:
; {
 8012b12: b480         	push	{r7}
 8012b14: b083         	sub	sp, #0xc
 8012b16: af00         	add	r7, sp, #0x0
 8012b18: 6078         	str	r0, [r7, #0x4]
; 	if (dev == NULL) {
 8012b1a: 687b         	ldr	r3, [r7, #0x4]
 8012b1c: 2b00         	cmp	r3, #0x0
 8012b1e: d101         	bne	0x8012b24 <z_impl_device_is_ready+0x12> @ imm = #0x2
; 		return false;
 8012b20: 2300         	movs	r3, #0x0
 8012b22: e012         	b	0x8012b4a <z_impl_device_is_ready+0x38> @ imm = #0x24
; 	return dev->state->initialized && (dev->state->init_res == 0U);
 8012b24: 687b         	ldr	r3, [r7, #0x4]
 8012b26: 68db         	ldr	r3, [r3, #0xc]
 8012b28: 785b         	ldrb	r3, [r3, #0x1]
 8012b2a: f003 0301    	and	r3, r3, #0x1
 8012b2e: b2db         	uxtb	r3, r3
 8012b30: 2b00         	cmp	r3, #0x0
 8012b32: d006         	beq	0x8012b42 <z_impl_device_is_ready+0x30> @ imm = #0xc
 8012b34: 687b         	ldr	r3, [r7, #0x4]
 8012b36: 68db         	ldr	r3, [r3, #0xc]
 8012b38: 781b         	ldrb	r3, [r3]
 8012b3a: 2b00         	cmp	r3, #0x0
 8012b3c: d101         	bne	0x8012b42 <z_impl_device_is_ready+0x30> @ imm = #0x2
 8012b3e: 2301         	movs	r3, #0x1
 8012b40: e000         	b	0x8012b44 <z_impl_device_is_ready+0x32> @ imm = #0x0
 8012b42: 2300         	movs	r3, #0x0
 8012b44: f003 0301    	and	r3, r3, #0x1
 8012b48: b2db         	uxtb	r3, r3
; }
 8012b4a: 4618         	mov	r0, r3
 8012b4c: 370c         	adds	r7, #0xc
 8012b4e: 46bd         	mov	sp, r7
 8012b50: bc80         	pop	{r7}
 8012b52: 4770         	bx	lr

08012b54 <k_thread_abort>:
; {
 8012b54: b580         	push	{r7, lr}
 8012b56: b082         	sub	sp, #0x8
 8012b58: af00         	add	r7, sp, #0x0
 8012b5a: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_thread_abort(thread);
 8012b5c: 6878         	ldr	r0, [r7, #0x4]
 8012b5e: f7f0 fa0f    	bl	0x8002f80 <z_impl_k_thread_abort> @ imm = #-0xfbe2
; }
 8012b62: bf00         	nop
 8012b64: 3708         	adds	r7, #0x8
 8012b66: 46bd         	mov	sp, r7
 8012b68: bd80         	pop	{r7, pc}

08012b6a <z_log_msg_runtime_create>:
; {
 8012b6a: b580         	push	{r7, lr}
 8012b6c: b08a         	sub	sp, #0x28
 8012b6e: af04         	add	r7, sp, #0x10
 8012b70: 60b9         	str	r1, [r7, #0x8]
 8012b72: 607b         	str	r3, [r7, #0x4]
 8012b74: 4603         	mov	r3, r0
 8012b76: 73fb         	strb	r3, [r7, #0xf]
 8012b78: 4613         	mov	r3, r2
 8012b7a: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 8012b7c: f107 032c    	add.w	r3, r7, #0x2c
 8012b80: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 8012b82: 7bba         	ldrb	r2, [r7, #0xe]
 8012b84: 7bf8         	ldrb	r0, [r7, #0xf]
 8012b86: 697b         	ldr	r3, [r7, #0x14]
 8012b88: 9303         	str	r3, [sp, #0xc]
 8012b8a: 6abb         	ldr	r3, [r7, #0x28]
 8012b8c: 9302         	str	r3, [sp, #0x8]
 8012b8e: 6a7b         	ldr	r3, [r7, #0x24]
 8012b90: 9301         	str	r3, [sp, #0x4]
 8012b92: 6a3b         	ldr	r3, [r7, #0x20]
 8012b94: 9300         	str	r3, [sp]
 8012b96: 687b         	ldr	r3, [r7, #0x4]
 8012b98: 68b9         	ldr	r1, [r7, #0x8]
 8012b9a: f7ee fe53    	bl	0x8001844 <z_log_msg_runtime_vcreate> @ imm = #-0x1135a
; }
 8012b9e: bf00         	nop
 8012ba0: 3718         	adds	r7, #0x18
 8012ba2: 46bd         	mov	sp, r7
 8012ba4: bd80         	pop	{r7, pc}

08012ba6 <log_panic>:
; {
 8012ba6: b580         	push	{r7, lr}
 8012ba8: af00         	add	r7, sp, #0x0
; 	z_impl_log_panic();
 8012baa: f7ee fcd1    	bl	0x8001550 <z_impl_log_panic> @ imm = #-0x1165e
; }
 8012bae: bf00         	nop
 8012bb0: bd80         	pop	{r7, pc}

08012bb2 <coredump>:
; {
 8012bb2: b480         	push	{r7}
 8012bb4: b085         	sub	sp, #0x14
 8012bb6: af00         	add	r7, sp, #0x0
 8012bb8: 60f8         	str	r0, [r7, #0xc]
 8012bba: 60b9         	str	r1, [r7, #0x8]
 8012bbc: 607a         	str	r2, [r7, #0x4]
; }
 8012bbe: bf00         	nop
 8012bc0: 3714         	adds	r7, #0x14
 8012bc2: 46bd         	mov	sp, r7
 8012bc4: bc80         	pop	{r7}
 8012bc6: 4770         	bx	lr

08012bc8 <arch_system_halt>:
; {
 8012bc8: b480         	push	{r7}
 8012bca: b087         	sub	sp, #0x1c
 8012bcc: af00         	add	r7, sp, #0x0
 8012bce: 6078         	str	r0, [r7, #0x4]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8012bd0: f3ef 8311    	mrs	r3, basepri
 8012bd4: 617b         	str	r3, [r7, #0x14]
;   return(result);
 8012bd6: 697b         	ldr	r3, [r7, #0x14]
; 	key = __get_BASEPRI();
 8012bd8: 613b         	str	r3, [r7, #0x10]
 8012bda: 2310         	movs	r3, #0x10
 8012bdc: 60fb         	str	r3, [r7, #0xc]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8012bde: 68fb         	ldr	r3, [r7, #0xc]
 8012be0: f383 8812    	msr	basepri_max, r3
; }
 8012be4: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8012be6: f3bf 8f6f    	isb	sy
; }
 8012bea: bf00         	nop
; 	for (;;) {
 8012bec: bf00         	nop
 8012bee: e7fd         	b	0x8012bec <arch_system_halt+0x24> @ imm = #-0x6

08012bf0 <K_KERNEL_STACK_BUFFER>:
; {
 8012bf0: b480         	push	{r7}
 8012bf2: b083         	sub	sp, #0xc
 8012bf4: af00         	add	r7, sp, #0x0
 8012bf6: 6078         	str	r0, [r7, #0x4]
; 	return (char *)sym + K_KERNEL_STACK_RESERVED;
 8012bf8: 687b         	ldr	r3, [r7, #0x4]
; }
 8012bfa: 4618         	mov	r0, r3
 8012bfc: 370c         	adds	r7, #0xc
 8012bfe: 46bd         	mov	sp, r7
 8012c00: bc80         	pop	{r7}
 8012c02: 4770         	bx	lr

08012c04 <k_thread_start>:
; {
 8012c04: b580         	push	{r7, lr}
 8012c06: b082         	sub	sp, #0x8
 8012c08: af00         	add	r7, sp, #0x0
 8012c0a: 6078         	str	r0, [r7, #0x4]
; 	k_thread_resume(thread);
 8012c0c: 6878         	ldr	r0, [r7, #0x4]
 8012c0e: f000 f804    	bl	0x8012c1a <k_thread_resume> @ imm = #0x8
; }
 8012c12: bf00         	nop
 8012c14: 3708         	adds	r7, #0x8
 8012c16: 46bd         	mov	sp, r7
 8012c18: bd80         	pop	{r7, pc}

08012c1a <k_thread_resume>:
; {
 8012c1a: b580         	push	{r7, lr}
 8012c1c: b082         	sub	sp, #0x8
 8012c1e: af00         	add	r7, sp, #0x0
 8012c20: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_thread_resume(thread);
 8012c22: 6878         	ldr	r0, [r7, #0x4]
 8012c24: f7f8 f888    	bl	0x800ad38 <z_impl_k_thread_resume> @ imm = #-0x7ef0
; }
 8012c28: bf00         	nop
 8012c2a: 3708         	adds	r7, #0x8
 8012c2c: 46bd         	mov	sp, r7
 8012c2e: bd80         	pop	{r7, pc}

08012c30 <thread_schedule_new>:
; {
 8012c30: b580         	push	{r7, lr}
 8012c32: b084         	sub	sp, #0x10
 8012c34: af00         	add	r7, sp, #0x0
 8012c36: 60f8         	str	r0, [r7, #0xc]
 8012c38: e9c7 2300    	strd	r2, r3, [r7]
; 	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
 8012c3c: e9d7 2300    	ldrd	r2, r3, [r7]
 8012c40: f04f 0000    	mov.w	r0, #0x0
 8012c44: f04f 0100    	mov.w	r1, #0x0
 8012c48: 428b         	cmp	r3, r1
 8012c4a: bf08         	it	eq
 8012c4c: 4282         	cmpeq	r2, r0
 8012c4e: d103         	bne	0x8012c58 <thread_schedule_new+0x28> @ imm = #0x6
; 		k_thread_start(thread);
 8012c50: 68f8         	ldr	r0, [r7, #0xc]
 8012c52: f7ff ffd7    	bl	0x8012c04 <k_thread_start> @ imm = #-0x52
 8012c56: e004         	b	0x8012c62 <thread_schedule_new+0x32> @ imm = #0x8
; 		z_add_thread_timeout(thread, delay);
 8012c58: e9d7 2300    	ldrd	r2, r3, [r7]
 8012c5c: 68f8         	ldr	r0, [r7, #0xc]
 8012c5e: f7f6 fa4b    	bl	0x80090f8 <z_add_thread_timeout> @ imm = #-0x9b6a
; }
 8012c62: bf00         	nop
 8012c64: 3710         	adds	r7, #0x10
 8012c66: 46bd         	mov	sp, r7
 8012c68: bd80         	pop	{r7, pc}

08012c6a <z_mark_thread_as_not_suspended>:
; {
 8012c6a: b480         	push	{r7}
 8012c6c: b083         	sub	sp, #0xc
 8012c6e: af00         	add	r7, sp, #0x0
 8012c70: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state &= ~_THREAD_SUSPENDED;
 8012c72: 687b         	ldr	r3, [r7, #0x4]
 8012c74: 7b5b         	ldrb	r3, [r3, #0xd]
 8012c76: f023 0310    	bic	r3, r3, #0x10
 8012c7a: b2da         	uxtb	r2, r3
 8012c7c: 687b         	ldr	r3, [r7, #0x4]
 8012c7e: 735a         	strb	r2, [r3, #0xd]
; }
 8012c80: bf00         	nop
 8012c82: 370c         	adds	r7, #0xc
 8012c84: 46bd         	mov	sp, r7
 8012c86: bc80         	pop	{r7}
 8012c88: 4770         	bx	lr

08012c8a <z_thread_essential_clear>:
; {
 8012c8a: b480         	push	{r7}
 8012c8c: b083         	sub	sp, #0xc
 8012c8e: af00         	add	r7, sp, #0x0
 8012c90: 6078         	str	r0, [r7, #0x4]
; 	thread->base.user_options &= ~K_ESSENTIAL;
 8012c92: 687b         	ldr	r3, [r7, #0x4]
 8012c94: 7b1b         	ldrb	r3, [r3, #0xc]
 8012c96: f023 0301    	bic	r3, r3, #0x1
 8012c9a: b2da         	uxtb	r2, r3
 8012c9c: 687b         	ldr	r3, [r7, #0x4]
 8012c9e: 731a         	strb	r2, [r3, #0xc]
; }
 8012ca0: bf00         	nop
 8012ca2: 370c         	adds	r7, #0xc
 8012ca4: 46bd         	mov	sp, r7
 8012ca6: bc80         	pop	{r7}
 8012ca8: 4770         	bx	lr

08012caa <gcov_static_init>:
; static inline void gcov_static_init(void) { }
 8012caa: b480         	push	{r7}
 8012cac: af00         	add	r7, sp, #0x0
 8012cae: bf00         	nop
 8012cb0: 46bd         	mov	sp, r7
 8012cb2: bc80         	pop	{r7}
 8012cb4: 4770         	bx	lr

08012cb6 <pm_device_runtime_auto_enable>:
; {
 8012cb6: b480         	push	{r7}
 8012cb8: b083         	sub	sp, #0xc
 8012cba: af00         	add	r7, sp, #0x0
 8012cbc: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 8012cbe: 2300         	movs	r3, #0x0
; }
 8012cc0: 4618         	mov	r0, r3
 8012cc2: 370c         	adds	r7, #0xc
 8012cc4: 46bd         	mov	sp, r7
 8012cc6: bc80         	pop	{r7}
 8012cc8: 4770         	bx	lr

08012cca <z_early_memset>:
; {
 8012cca: b580         	push	{r7, lr}
 8012ccc: b084         	sub	sp, #0x10
 8012cce: af00         	add	r7, sp, #0x0
 8012cd0: 60f8         	str	r0, [r7, #0xc]
 8012cd2: 60b9         	str	r1, [r7, #0x8]
 8012cd4: 607a         	str	r2, [r7, #0x4]
; 	(void) memset(dst, c, n);
 8012cd6: 687a         	ldr	r2, [r7, #0x4]
 8012cd8: 68b9         	ldr	r1, [r7, #0x8]
 8012cda: 68f8         	ldr	r0, [r7, #0xc]
 8012cdc: f001 fa1e    	bl	0x801411c <memset>      @ imm = #0x143c
; }
 8012ce0: bf00         	nop
 8012ce2: 3710         	adds	r7, #0x10
 8012ce4: 46bd         	mov	sp, r7
 8012ce6: bd80         	pop	{r7, pc}

08012ce8 <z_early_memcpy>:
; {
 8012ce8: b580         	push	{r7, lr}
 8012cea: b084         	sub	sp, #0x10
 8012cec: af00         	add	r7, sp, #0x0
 8012cee: 60f8         	str	r0, [r7, #0xc]
 8012cf0: 60b9         	str	r1, [r7, #0x8]
 8012cf2: 607a         	str	r2, [r7, #0x4]
; 	(void) memcpy(dst, src, n);
 8012cf4: 687a         	ldr	r2, [r7, #0x4]
 8012cf6: 68b9         	ldr	r1, [r7, #0x8]
 8012cf8: 68f8         	ldr	r0, [r7, #0xc]
 8012cfa: f001 fa01    	bl	0x8014100 <memcpy>      @ imm = #0x1402
; }
 8012cfe: bf00         	nop
 8012d00: 3710         	adds	r7, #0x10
 8012d02: 46bd         	mov	sp, r7
 8012d04: bd80         	pop	{r7, pc}

08012d06 <do_device_init>:
; {
 8012d06: b580         	push	{r7, lr}
 8012d08: b084         	sub	sp, #0x10
 8012d0a: af00         	add	r7, sp, #0x0
 8012d0c: 6078         	str	r0, [r7, #0x4]
; 	const struct device *dev = entry->dev;
 8012d0e: 687b         	ldr	r3, [r7, #0x4]
 8012d10: 685b         	ldr	r3, [r3, #0x4]
 8012d12: 60bb         	str	r3, [r7, #0x8]
; 	int rc = 0;
 8012d14: 2300         	movs	r3, #0x0
 8012d16: 60fb         	str	r3, [r7, #0xc]
; 	if (entry->init_fn.dev != NULL) {
 8012d18: 687b         	ldr	r3, [r7, #0x4]
 8012d1a: 681b         	ldr	r3, [r3]
 8012d1c: 2b00         	cmp	r3, #0x0
 8012d1e: d017         	beq	0x8012d50 <do_device_init+0x4a> @ imm = #0x2e
; 		rc = entry->init_fn.dev(dev);
 8012d20: 687b         	ldr	r3, [r7, #0x4]
 8012d22: 681b         	ldr	r3, [r3]
 8012d24: 68b8         	ldr	r0, [r7, #0x8]
 8012d26: 4798         	blx	r3
 8012d28: 60f8         	str	r0, [r7, #0xc]
; 		if (rc != 0) {
 8012d2a: 68fb         	ldr	r3, [r7, #0xc]
 8012d2c: 2b00         	cmp	r3, #0x0
 8012d2e: d00f         	beq	0x8012d50 <do_device_init+0x4a> @ imm = #0x1e
; 			if (rc < 0) {
 8012d30: 68fb         	ldr	r3, [r7, #0xc]
 8012d32: 2b00         	cmp	r3, #0x0
 8012d34: da02         	bge	0x8012d3c <do_device_init+0x36> @ imm = #0x4
; 				rc = -rc;
 8012d36: 68fb         	ldr	r3, [r7, #0xc]
 8012d38: 425b         	rsbs	r3, r3, #0
 8012d3a: 60fb         	str	r3, [r7, #0xc]
; 			if (rc > UINT8_MAX) {
 8012d3c: 68fb         	ldr	r3, [r7, #0xc]
 8012d3e: 2bff         	cmp	r3, #0xff
 8012d40: dd01         	ble	0x8012d46 <do_device_init+0x40> @ imm = #0x2
; 				rc = UINT8_MAX;
 8012d42: 23ff         	movs	r3, #0xff
 8012d44: 60fb         	str	r3, [r7, #0xc]
; 			dev->state->init_res = rc;
 8012d46: 68bb         	ldr	r3, [r7, #0x8]
 8012d48: 68db         	ldr	r3, [r3, #0xc]
 8012d4a: 68fa         	ldr	r2, [r7, #0xc]
 8012d4c: b2d2         	uxtb	r2, r2
 8012d4e: 701a         	strb	r2, [r3]
; 	dev->state->initialized = true;
 8012d50: 68bb         	ldr	r3, [r7, #0x8]
 8012d52: 68da         	ldr	r2, [r3, #0xc]
 8012d54: 7853         	ldrb	r3, [r2, #0x1]
 8012d56: f043 0301    	orr	r3, r3, #0x1
 8012d5a: 7053         	strb	r3, [r2, #0x1]
; 	if (rc == 0) {
 8012d5c: 68fb         	ldr	r3, [r7, #0xc]
 8012d5e: 2b00         	cmp	r3, #0x0
 8012d60: d102         	bne	0x8012d68 <do_device_init+0x62> @ imm = #0x4
; 		(void)pm_device_runtime_auto_enable(dev);
 8012d62: 68b8         	ldr	r0, [r7, #0x8]
 8012d64: f7ff ffa7    	bl	0x8012cb6 <pm_device_runtime_auto_enable> @ imm = #-0xb2
; 	return rc;
 8012d68: 68fb         	ldr	r3, [r7, #0xc]
; }
 8012d6a: 4618         	mov	r0, r3
 8012d6c: 3710         	adds	r7, #0x10
 8012d6e: 46bd         	mov	sp, r7
 8012d70: bd80         	pop	{r7, pc}

08012d72 <z_init_static>:
; {
 8012d72: b480         	push	{r7}
 8012d74: af00         	add	r7, sp, #0x0
; }
 8012d76: bf00         	nop
 8012d78: 46bd         	mov	sp, r7
 8012d7a: bc80         	pop	{r7}
 8012d7c: 4770         	bx	lr

08012d7e <k_cpu_idle>:
; {
 8012d7e: b580         	push	{r7, lr}
 8012d80: af00         	add	r7, sp, #0x0
; 	arch_cpu_idle();
 8012d82: f7fc f8d2    	bl	0x800ef2a <arch_cpu_idle> @ imm = #-0x3e5c
; }
 8012d86: bf00         	nop
 8012d88: bd80         	pop	{r7, pc}

08012d8a <idle>:
; {
 8012d8a: b580         	push	{r7, lr}
 8012d8c: b088         	sub	sp, #0x20
 8012d8e: af00         	add	r7, sp, #0x0
 8012d90: 60f8         	str	r0, [r7, #0xc]
 8012d92: 60b9         	str	r1, [r7, #0x8]
 8012d94: 607a         	str	r2, [r7, #0x4]
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8012d96: f3ef 8311    	mrs	r3, basepri
 8012d9a: 61fb         	str	r3, [r7, #0x1c]
;   return(result);
 8012d9c: 69fb         	ldr	r3, [r7, #0x1c]
; 	key = __get_BASEPRI();
 8012d9e: 61bb         	str	r3, [r7, #0x18]
 8012da0: 2310         	movs	r3, #0x10
 8012da2: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 8012da4: 697b         	ldr	r3, [r7, #0x14]
 8012da6: f383 8812    	msr	basepri_max, r3
; }
 8012daa: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8012dac: f3bf 8f6f    	isb	sy
; }
 8012db0: bf00         	nop
; 	return key;
 8012db2: bf00         	nop
; 		k_cpu_idle();
 8012db4: f7ff ffe3    	bl	0x8012d7e <k_cpu_idle>  @ imm = #-0x3a
; 		if (IS_ENABLED(CONFIG_SMP) && !IS_ENABLED(CONFIG_SCHED_IPI_SUPPORTED)) {
 8012db8: e7ed         	b	0x8012d96 <idle+0xc>    @ imm = #-0x26

08012dba <arch_spin_relax>:
; {
 8012dba: b480         	push	{r7}
 8012dbc: af00         	add	r7, sp, #0x0
; 	__asm__ volatile("nop");
 8012dbe: bf00         	nop
; }
 8012dc0: bf00         	nop
; }
 8012dc2: bf00         	nop
 8012dc4: 46bd         	mov	sp, r7
 8012dc6: bc80         	pop	{r7}
 8012dc8: 4770         	bx	lr

08012dca <sys_dnode_init>:
; {
 8012dca: b480         	push	{r7}
 8012dcc: b083         	sub	sp, #0xc
 8012dce: af00         	add	r7, sp, #0x0
 8012dd0: 6078         	str	r0, [r7, #0x4]
; 	node->next = NULL;
 8012dd2: 687b         	ldr	r3, [r7, #0x4]
 8012dd4: 2200         	movs	r2, #0x0
 8012dd6: 601a         	str	r2, [r3]
; 	node->prev = NULL;
 8012dd8: 687b         	ldr	r3, [r7, #0x4]
 8012dda: 2200         	movs	r2, #0x0
 8012ddc: 605a         	str	r2, [r3, #0x4]
; }
 8012dde: bf00         	nop
 8012de0: 370c         	adds	r7, #0xc
 8012de2: 46bd         	mov	sp, r7
 8012de4: bc80         	pop	{r7}
 8012de6: 4770         	bx	lr

08012de8 <sys_dlist_is_empty>:
; {
 8012de8: b480         	push	{r7}
 8012dea: b083         	sub	sp, #0xc
 8012dec: af00         	add	r7, sp, #0x0
 8012dee: 6078         	str	r0, [r7, #0x4]
; 	return list->head == list;
 8012df0: 687b         	ldr	r3, [r7, #0x4]
 8012df2: 681b         	ldr	r3, [r3]
 8012df4: 687a         	ldr	r2, [r7, #0x4]
 8012df6: 429a         	cmp	r2, r3
 8012df8: bf0c         	ite	eq
 8012dfa: 2301         	moveq	r3, #0x1
 8012dfc: 2300         	movne	r3, #0x0
 8012dfe: b2db         	uxtb	r3, r3
; }
 8012e00: 4618         	mov	r0, r3
 8012e02: 370c         	adds	r7, #0xc
 8012e04: 46bd         	mov	sp, r7
 8012e06: bc80         	pop	{r7}
 8012e08: 4770         	bx	lr

08012e0a <sys_dlist_peek_head>:
; {
 8012e0a: b580         	push	{r7, lr}
 8012e0c: b082         	sub	sp, #0x8
 8012e0e: af00         	add	r7, sp, #0x0
 8012e10: 6078         	str	r0, [r7, #0x4]
; 	return sys_dlist_is_empty(list) ? NULL : list->head;
 8012e12: 6878         	ldr	r0, [r7, #0x4]
 8012e14: f7ff ffe8    	bl	0x8012de8 <sys_dlist_is_empty> @ imm = #-0x30
 8012e18: 4603         	mov	r3, r0
 8012e1a: 2b00         	cmp	r3, #0x0
 8012e1c: d102         	bne	0x8012e24 <sys_dlist_peek_head+0x1a> @ imm = #0x4
 8012e1e: 687b         	ldr	r3, [r7, #0x4]
 8012e20: 681b         	ldr	r3, [r3]
 8012e22: e000         	b	0x8012e26 <sys_dlist_peek_head+0x1c> @ imm = #0x0
 8012e24: 2300         	movs	r3, #0x0
; }
 8012e26: 4618         	mov	r0, r3
 8012e28: 3708         	adds	r7, #0x8
 8012e2a: 46bd         	mov	sp, r7
 8012e2c: bd80         	pop	{r7, pc}

08012e2e <sys_dlist_remove>:
; {
 8012e2e: b580         	push	{r7, lr}
 8012e30: b084         	sub	sp, #0x10
 8012e32: af00         	add	r7, sp, #0x0
 8012e34: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_t *const prev = node->prev;
 8012e36: 687b         	ldr	r3, [r7, #0x4]
 8012e38: 685b         	ldr	r3, [r3, #0x4]
 8012e3a: 60fb         	str	r3, [r7, #0xc]
; 	sys_dnode_t *const next = node->next;
 8012e3c: 687b         	ldr	r3, [r7, #0x4]
 8012e3e: 681b         	ldr	r3, [r3]
 8012e40: 60bb         	str	r3, [r7, #0x8]
; 	prev->next = next;
 8012e42: 68fb         	ldr	r3, [r7, #0xc]
 8012e44: 68ba         	ldr	r2, [r7, #0x8]
 8012e46: 601a         	str	r2, [r3]
; 	next->prev = prev;
 8012e48: 68bb         	ldr	r3, [r7, #0x8]
 8012e4a: 68fa         	ldr	r2, [r7, #0xc]
 8012e4c: 605a         	str	r2, [r3, #0x4]
; 	sys_dnode_init(node);
 8012e4e: 6878         	ldr	r0, [r7, #0x4]
 8012e50: f7ff ffbb    	bl	0x8012dca <sys_dnode_init> @ imm = #-0x8a
; }
 8012e54: bf00         	nop
 8012e56: 3710         	adds	r7, #0x10
 8012e58: 46bd         	mov	sp, r7
 8012e5a: bd80         	pop	{r7, pc}

08012e5c <z_abort_thread_timeout>:
; {
 8012e5c: b580         	push	{r7, lr}
 8012e5e: b082         	sub	sp, #0x8
 8012e60: af00         	add	r7, sp, #0x0
 8012e62: 6078         	str	r0, [r7, #0x4]
; 	return z_abort_timeout(&thread->base.timeout);
 8012e64: 687b         	ldr	r3, [r7, #0x4]
 8012e66: 3318         	adds	r3, #0x18
 8012e68: 4618         	mov	r0, r3
 8012e6a: f7f9 f9db    	bl	0x800c224 <z_abort_timeout> @ imm = #-0x6c4a
 8012e6e: 4603         	mov	r3, r0
; }
 8012e70: 4618         	mov	r0, r3
 8012e72: 3708         	adds	r7, #0x8
 8012e74: 46bd         	mov	sp, r7
 8012e76: bd80         	pop	{r7, pc}

08012e78 <z_mark_thread_as_not_pending>:
; {
 8012e78: b480         	push	{r7}
 8012e7a: b083         	sub	sp, #0xc
 8012e7c: af00         	add	r7, sp, #0x0
 8012e7e: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state &= ~_THREAD_PENDING;
 8012e80: 687b         	ldr	r3, [r7, #0x4]
 8012e82: 7b5b         	ldrb	r3, [r3, #0xd]
 8012e84: f023 0302    	bic	r3, r3, #0x2
 8012e88: b2da         	uxtb	r2, r3
 8012e8a: 687b         	ldr	r3, [r7, #0x4]
 8012e8c: 735a         	strb	r2, [r3, #0xd]
; }
 8012e8e: bf00         	nop
 8012e90: 370c         	adds	r7, #0xc
 8012e92: 46bd         	mov	sp, r7
 8012e94: bc80         	pop	{r7}
 8012e96: 4770         	bx	lr

08012e98 <unpend_thread_no_timeout>:
; {
 8012e98: b580         	push	{r7, lr}
 8012e9a: b086         	sub	sp, #0x18
 8012e9c: af00         	add	r7, sp, #0x0
 8012e9e: 6078         	str	r0, [r7, #0x4]
 8012ea0: 687b         	ldr	r3, [r7, #0x4]
 8012ea2: 60fb         	str	r3, [r7, #0xc]
; 	return thread->base.pended_on;
 8012ea4: 68fb         	ldr	r3, [r7, #0xc]
 8012ea6: 689b         	ldr	r3, [r3, #0x8]
 8012ea8: 617b         	str	r3, [r7, #0x14]
 8012eaa: 687b         	ldr	r3, [r7, #0x4]
 8012eac: 613b         	str	r3, [r7, #0x10]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 8012eae: 693b         	ldr	r3, [r7, #0x10]
 8012eb0: 4618         	mov	r0, r3
 8012eb2: f7ff ffbc    	bl	0x8012e2e <sys_dlist_remove> @ imm = #-0x88
; }
 8012eb6: bf00         	nop
; 	z_mark_thread_as_not_pending(thread);
 8012eb8: 6878         	ldr	r0, [r7, #0x4]
 8012eba: f7ff ffdd    	bl	0x8012e78 <z_mark_thread_as_not_pending> @ imm = #-0x46
; 	thread->base.pended_on = NULL;
 8012ebe: 687b         	ldr	r3, [r7, #0x4]
 8012ec0: 2200         	movs	r2, #0x0
 8012ec2: 609a         	str	r2, [r3, #0x8]
; }
 8012ec4: bf00         	nop
 8012ec6: 3718         	adds	r7, #0x18
 8012ec8: 46bd         	mov	sp, r7
 8012eca: bd80         	pop	{r7, pc}

08012ecc <sys_dlist_init>:
; {
 8012ecc: b480         	push	{r7}
 8012ece: b083         	sub	sp, #0xc
 8012ed0: af00         	add	r7, sp, #0x0
 8012ed2: 6078         	str	r0, [r7, #0x4]
; 	list->head = (sys_dnode_t *)list;
 8012ed4: 687b         	ldr	r3, [r7, #0x4]
 8012ed6: 687a         	ldr	r2, [r7, #0x4]
 8012ed8: 601a         	str	r2, [r3]
; 	list->tail = (sys_dnode_t *)list;
 8012eda: 687b         	ldr	r3, [r7, #0x4]
 8012edc: 687a         	ldr	r2, [r7, #0x4]
 8012ede: 605a         	str	r2, [r3, #0x4]
; }
 8012ee0: bf00         	nop
 8012ee2: 370c         	adds	r7, #0xc
 8012ee4: 46bd         	mov	sp, r7
 8012ee6: bc80         	pop	{r7}
 8012ee8: 4770         	bx	lr

08012eea <sys_dnode_init>:
; {
 8012eea: b480         	push	{r7}
 8012eec: b083         	sub	sp, #0xc
 8012eee: af00         	add	r7, sp, #0x0
 8012ef0: 6078         	str	r0, [r7, #0x4]
; 	node->next = NULL;
 8012ef2: 687b         	ldr	r3, [r7, #0x4]
 8012ef4: 2200         	movs	r2, #0x0
 8012ef6: 601a         	str	r2, [r3]
; 	node->prev = NULL;
 8012ef8: 687b         	ldr	r3, [r7, #0x4]
 8012efa: 2200         	movs	r2, #0x0
 8012efc: 605a         	str	r2, [r3, #0x4]
; }
 8012efe: bf00         	nop
 8012f00: 370c         	adds	r7, #0xc
 8012f02: 46bd         	mov	sp, r7
 8012f04: bc80         	pop	{r7}
 8012f06: 4770         	bx	lr

08012f08 <sys_dnode_is_linked>:
; {
 8012f08: b480         	push	{r7}
 8012f0a: b083         	sub	sp, #0xc
 8012f0c: af00         	add	r7, sp, #0x0
 8012f0e: 6078         	str	r0, [r7, #0x4]
; 	return node->next != NULL;
 8012f10: 687b         	ldr	r3, [r7, #0x4]
 8012f12: 681b         	ldr	r3, [r3]
 8012f14: 2b00         	cmp	r3, #0x0
 8012f16: bf14         	ite	ne
 8012f18: 2301         	movne	r3, #0x1
 8012f1a: 2300         	moveq	r3, #0x0
 8012f1c: b2db         	uxtb	r3, r3
; }
 8012f1e: 4618         	mov	r0, r3
 8012f20: 370c         	adds	r7, #0xc
 8012f22: 46bd         	mov	sp, r7
 8012f24: bc80         	pop	{r7}
 8012f26: 4770         	bx	lr

08012f28 <sys_dlist_is_empty>:
; {
 8012f28: b480         	push	{r7}
 8012f2a: b083         	sub	sp, #0xc
 8012f2c: af00         	add	r7, sp, #0x0
 8012f2e: 6078         	str	r0, [r7, #0x4]
; 	return list->head == list;
 8012f30: 687b         	ldr	r3, [r7, #0x4]
 8012f32: 681b         	ldr	r3, [r3]
 8012f34: 687a         	ldr	r2, [r7, #0x4]
 8012f36: 429a         	cmp	r2, r3
 8012f38: bf0c         	ite	eq
 8012f3a: 2301         	moveq	r3, #0x1
 8012f3c: 2300         	movne	r3, #0x0
 8012f3e: b2db         	uxtb	r3, r3
; }
 8012f40: 4618         	mov	r0, r3
 8012f42: 370c         	adds	r7, #0xc
 8012f44: 46bd         	mov	sp, r7
 8012f46: bc80         	pop	{r7}
 8012f48: 4770         	bx	lr

08012f4a <sys_dlist_peek_head>:
; {
 8012f4a: b580         	push	{r7, lr}
 8012f4c: b082         	sub	sp, #0x8
 8012f4e: af00         	add	r7, sp, #0x0
 8012f50: 6078         	str	r0, [r7, #0x4]
; 	return sys_dlist_is_empty(list) ? NULL : list->head;
 8012f52: 6878         	ldr	r0, [r7, #0x4]
 8012f54: f7ff ffe8    	bl	0x8012f28 <sys_dlist_is_empty> @ imm = #-0x30
 8012f58: 4603         	mov	r3, r0
 8012f5a: 2b00         	cmp	r3, #0x0
 8012f5c: d102         	bne	0x8012f64 <sys_dlist_peek_head+0x1a> @ imm = #0x4
 8012f5e: 687b         	ldr	r3, [r7, #0x4]
 8012f60: 681b         	ldr	r3, [r3]
 8012f62: e000         	b	0x8012f66 <sys_dlist_peek_head+0x1c> @ imm = #0x0
 8012f64: 2300         	movs	r3, #0x0
; }
 8012f66: 4618         	mov	r0, r3
 8012f68: 3708         	adds	r7, #0x8
 8012f6a: 46bd         	mov	sp, r7
 8012f6c: bd80         	pop	{r7, pc}

08012f6e <sys_dlist_remove>:
; {
 8012f6e: b580         	push	{r7, lr}
 8012f70: b084         	sub	sp, #0x10
 8012f72: af00         	add	r7, sp, #0x0
 8012f74: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_t *const prev = node->prev;
 8012f76: 687b         	ldr	r3, [r7, #0x4]
 8012f78: 685b         	ldr	r3, [r3, #0x4]
 8012f7a: 60fb         	str	r3, [r7, #0xc]
; 	sys_dnode_t *const next = node->next;
 8012f7c: 687b         	ldr	r3, [r7, #0x4]
 8012f7e: 681b         	ldr	r3, [r3]
 8012f80: 60bb         	str	r3, [r7, #0x8]
; 	prev->next = next;
 8012f82: 68fb         	ldr	r3, [r7, #0xc]
 8012f84: 68ba         	ldr	r2, [r7, #0x8]
 8012f86: 601a         	str	r2, [r3]
; 	next->prev = prev;
 8012f88: 68bb         	ldr	r3, [r7, #0x8]
 8012f8a: 68fa         	ldr	r2, [r7, #0xc]
 8012f8c: 605a         	str	r2, [r3, #0x4]
; 	sys_dnode_init(node);
 8012f8e: 6878         	ldr	r0, [r7, #0x4]
 8012f90: f7ff ffab    	bl	0x8012eea <sys_dnode_init> @ imm = #-0xaa
; }
 8012f94: bf00         	nop
 8012f96: 3710         	adds	r7, #0x10
 8012f98: 46bd         	mov	sp, r7
 8012f9a: bd80         	pop	{r7, pc}

08012f9c <k_object_init>:
; {
 8012f9c: b480         	push	{r7}
 8012f9e: b083         	sub	sp, #0xc
 8012fa0: af00         	add	r7, sp, #0x0
 8012fa2: 6078         	str	r0, [r7, #0x4]
; }
 8012fa4: bf00         	nop
 8012fa6: 370c         	adds	r7, #0xc
 8012fa8: 46bd         	mov	sp, r7
 8012faa: bc80         	pop	{r7}
 8012fac: 4770         	bx	lr

08012fae <z_is_inactive_timeout>:
; {
 8012fae: b580         	push	{r7, lr}
 8012fb0: b082         	sub	sp, #0x8
 8012fb2: af00         	add	r7, sp, #0x0
 8012fb4: 6078         	str	r0, [r7, #0x4]
; 	return !sys_dnode_is_linked(&to->node);
 8012fb6: 687b         	ldr	r3, [r7, #0x4]
 8012fb8: 4618         	mov	r0, r3
 8012fba: f7ff ffa5    	bl	0x8012f08 <sys_dnode_is_linked> @ imm = #-0xb6
 8012fbe: 4603         	mov	r3, r0
 8012fc0: 2b00         	cmp	r3, #0x0
 8012fc2: bf14         	ite	ne
 8012fc4: 2301         	movne	r3, #0x1
 8012fc6: 2300         	moveq	r3, #0x0
 8012fc8: b2db         	uxtb	r3, r3
 8012fca: f083 0301    	eor	r3, r3, #0x1
 8012fce: b2db         	uxtb	r3, r3
 8012fd0: f003 0301    	and	r3, r3, #0x1
 8012fd4: b2db         	uxtb	r3, r3
; }
 8012fd6: 4618         	mov	r0, r3
 8012fd8: 3708         	adds	r7, #0x8
 8012fda: 46bd         	mov	sp, r7
 8012fdc: bd80         	pop	{r7, pc}

08012fde <z_abort_thread_timeout>:
; {
 8012fde: b580         	push	{r7, lr}
 8012fe0: b082         	sub	sp, #0x8
 8012fe2: af00         	add	r7, sp, #0x0
 8012fe4: 6078         	str	r0, [r7, #0x4]
; 	return z_abort_timeout(&thread->base.timeout);
 8012fe6: 687b         	ldr	r3, [r7, #0x4]
 8012fe8: 3318         	adds	r3, #0x18
 8012fea: 4618         	mov	r0, r3
 8012fec: f7f9 f91a    	bl	0x800c224 <z_abort_timeout> @ imm = #-0x6dcc
 8012ff0: 4603         	mov	r3, r0
; }
 8012ff2: 4618         	mov	r0, r3
 8012ff4: 3708         	adds	r7, #0x8
 8012ff6: 46bd         	mov	sp, r7
 8012ff8: bd80         	pop	{r7, pc}

08012ffa <z_is_thread_prevented_from_running>:
; {
 8012ffa: b480         	push	{r7}
 8012ffc: b085         	sub	sp, #0x14
 8012ffe: af00         	add	r7, sp, #0x0
 8013000: 6078         	str	r0, [r7, #0x4]
; 	uint8_t state = thread->base.thread_state;
 8013002: 687b         	ldr	r3, [r7, #0x4]
 8013004: 7b5b         	ldrb	r3, [r3, #0xd]
 8013006: 73fb         	strb	r3, [r7, #0xf]
; 	return (state & (_THREAD_PENDING | _THREAD_DEAD |
 8013008: 7bfb         	ldrb	r3, [r7, #0xf]
 801300a: f003 031b    	and	r3, r3, #0x1b
; 			 _THREAD_DUMMY | _THREAD_SUSPENDED)) != 0U;
 801300e: 2b00         	cmp	r3, #0x0
 8013010: bf14         	ite	ne
 8013012: 2301         	movne	r3, #0x1
 8013014: 2300         	moveq	r3, #0x0
 8013016: b2db         	uxtb	r3, r3
; }
 8013018: 4618         	mov	r0, r3
 801301a: 3714         	adds	r7, #0x14
 801301c: 46bd         	mov	sp, r7
 801301e: bc80         	pop	{r7}
 8013020: 4770         	bx	lr

08013022 <z_is_thread_timeout_active>:
; {
 8013022: b580         	push	{r7, lr}
 8013024: b082         	sub	sp, #0x8
 8013026: af00         	add	r7, sp, #0x0
 8013028: 6078         	str	r0, [r7, #0x4]
; 	return !z_is_inactive_timeout(&thread->base.timeout);
 801302a: 687b         	ldr	r3, [r7, #0x4]
 801302c: 3318         	adds	r3, #0x18
 801302e: 4618         	mov	r0, r3
 8013030: f7ff ffbd    	bl	0x8012fae <z_is_inactive_timeout> @ imm = #-0x86
 8013034: 4603         	mov	r3, r0
 8013036: 2b00         	cmp	r3, #0x0
 8013038: bf14         	ite	ne
 801303a: 2301         	movne	r3, #0x1
 801303c: 2300         	moveq	r3, #0x0
 801303e: b2db         	uxtb	r3, r3
 8013040: f083 0301    	eor	r3, r3, #0x1
 8013044: b2db         	uxtb	r3, r3
 8013046: f003 0301    	and	r3, r3, #0x1
 801304a: b2db         	uxtb	r3, r3
; }
 801304c: 4618         	mov	r0, r3
 801304e: 3708         	adds	r7, #0x8
 8013050: 46bd         	mov	sp, r7
 8013052: bd80         	pop	{r7, pc}

08013054 <z_is_thread_ready>:
; {
 8013054: b580         	push	{r7, lr}
 8013056: b082         	sub	sp, #0x8
 8013058: af00         	add	r7, sp, #0x0
 801305a: 6078         	str	r0, [r7, #0x4]
; 	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
 801305c: 6878         	ldr	r0, [r7, #0x4]
 801305e: f7ff ffcc    	bl	0x8012ffa <z_is_thread_prevented_from_running> @ imm = #-0x68
 8013062: 4603         	mov	r3, r0
 8013064: f083 0301    	eor	r3, r3, #0x1
 8013068: b2db         	uxtb	r3, r3
 801306a: 2b00         	cmp	r3, #0x0
 801306c: d00a         	beq	0x8013084 <z_is_thread_ready+0x30> @ imm = #0x14
; 		 z_is_thread_timeout_active(thread));
 801306e: 6878         	ldr	r0, [r7, #0x4]
 8013070: f7ff ffd7    	bl	0x8013022 <z_is_thread_timeout_active> @ imm = #-0x52
 8013074: 4603         	mov	r3, r0
; 	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
 8013076: f083 0301    	eor	r3, r3, #0x1
 801307a: b2db         	uxtb	r3, r3
 801307c: 2b00         	cmp	r3, #0x0
 801307e: d001         	beq	0x8013084 <z_is_thread_ready+0x30> @ imm = #0x2
 8013080: 2301         	movs	r3, #0x1
 8013082: e000         	b	0x8013086 <z_is_thread_ready+0x32> @ imm = #0x0
 8013084: 2300         	movs	r3, #0x0
 8013086: f003 0301    	and	r3, r3, #0x1
 801308a: b2db         	uxtb	r3, r3
; }
 801308c: 4618         	mov	r0, r3
 801308e: 3708         	adds	r7, #0x8
 8013090: 46bd         	mov	sp, r7
 8013092: bd80         	pop	{r7, pc}

08013094 <z_mark_thread_as_not_pending>:
; {
 8013094: b480         	push	{r7}
 8013096: b083         	sub	sp, #0xc
 8013098: af00         	add	r7, sp, #0x0
 801309a: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state &= ~_THREAD_PENDING;
 801309c: 687b         	ldr	r3, [r7, #0x4]
 801309e: 7b5b         	ldrb	r3, [r3, #0xd]
 80130a0: f023 0302    	bic	r3, r3, #0x2
 80130a4: b2da         	uxtb	r2, r3
 80130a6: 687b         	ldr	r3, [r7, #0x4]
 80130a8: 735a         	strb	r2, [r3, #0xd]
; }
 80130aa: bf00         	nop
 80130ac: 370c         	adds	r7, #0xc
 80130ae: 46bd         	mov	sp, r7
 80130b0: bc80         	pop	{r7}
 80130b2: 4770         	bx	lr

080130b4 <z_is_under_prio_ceiling>:
; {
 80130b4: b480         	push	{r7}
 80130b6: b083         	sub	sp, #0xc
 80130b8: af00         	add	r7, sp, #0x0
 80130ba: 6078         	str	r0, [r7, #0x4]
; 	return prio >= CONFIG_PRIORITY_CEILING;
 80130bc: 687b         	ldr	r3, [r7, #0x4]
 80130be: f113 0f7f    	cmn.w	r3, #0x7f
 80130c2: bfac         	ite	ge
 80130c4: 2301         	movge	r3, #0x1
 80130c6: 2300         	movlt	r3, #0x0
 80130c8: b2db         	uxtb	r3, r3
; }
 80130ca: 4618         	mov	r0, r3
 80130cc: 370c         	adds	r7, #0xc
 80130ce: 46bd         	mov	sp, r7
 80130d0: bc80         	pop	{r7}
 80130d2: 4770         	bx	lr

080130d4 <z_get_new_prio_with_ceiling>:
; {
 80130d4: b580         	push	{r7, lr}
 80130d6: b082         	sub	sp, #0x8
 80130d8: af00         	add	r7, sp, #0x0
 80130da: 6078         	str	r0, [r7, #0x4]
; 	return z_is_under_prio_ceiling(prio) ? prio : CONFIG_PRIORITY_CEILING;
 80130dc: 6878         	ldr	r0, [r7, #0x4]
 80130de: f7ff ffe9    	bl	0x80130b4 <z_is_under_prio_ceiling> @ imm = #-0x2e
 80130e2: 4603         	mov	r3, r0
 80130e4: 2b00         	cmp	r3, #0x0
 80130e6: d001         	beq	0x80130ec <z_get_new_prio_with_ceiling+0x18> @ imm = #0x2
 80130e8: 687b         	ldr	r3, [r7, #0x4]
 80130ea: e001         	b	0x80130f0 <z_get_new_prio_with_ceiling+0x1c> @ imm = #0x2
 80130ec: f06f 037e    	mvn	r3, #0x7e
; }
 80130f0: 4618         	mov	r0, r3
 80130f2: 3708         	adds	r7, #0x8
 80130f4: 46bd         	mov	sp, r7
 80130f6: bd80         	pop	{r7, pc}

080130f8 <z_is_prio1_higher_than_prio2>:
; {
 80130f8: b480         	push	{r7}
 80130fa: b083         	sub	sp, #0xc
 80130fc: af00         	add	r7, sp, #0x0
 80130fe: 6078         	str	r0, [r7, #0x4]
 8013100: 6039         	str	r1, [r7]
; 	return prio1 < prio2;
 8013102: 687a         	ldr	r2, [r7, #0x4]
 8013104: 683b         	ldr	r3, [r7]
 8013106: 429a         	cmp	r2, r3
 8013108: bfb4         	ite	lt
 801310a: 2301         	movlt	r3, #0x1
 801310c: 2300         	movge	r3, #0x0
 801310e: b2db         	uxtb	r3, r3
; }
 8013110: 4618         	mov	r0, r3
 8013112: 370c         	adds	r7, #0xc
 8013114: 46bd         	mov	sp, r7
 8013116: bc80         	pop	{r7}
 8013118: 4770         	bx	lr

0801311a <z_is_prio_higher>:
; {
 801311a: b580         	push	{r7, lr}
 801311c: b082         	sub	sp, #0x8
 801311e: af00         	add	r7, sp, #0x0
 8013120: 6078         	str	r0, [r7, #0x4]
 8013122: 6039         	str	r1, [r7]
; 	return z_is_prio1_higher_than_prio2(prio, test_prio);
 8013124: 6839         	ldr	r1, [r7]
 8013126: 6878         	ldr	r0, [r7, #0x4]
 8013128: f7ff ffe6    	bl	0x80130f8 <z_is_prio1_higher_than_prio2> @ imm = #-0x34
 801312c: 4603         	mov	r3, r0
; }
 801312e: 4618         	mov	r0, r3
 8013130: 3708         	adds	r7, #0x8
 8013132: 46bd         	mov	sp, r7
 8013134: bd80         	pop	{r7, pc}

08013136 <unpend_thread_no_timeout>:
; {
 8013136: b580         	push	{r7, lr}
 8013138: b086         	sub	sp, #0x18
 801313a: af00         	add	r7, sp, #0x0
 801313c: 6078         	str	r0, [r7, #0x4]
 801313e: 687b         	ldr	r3, [r7, #0x4]
 8013140: 60fb         	str	r3, [r7, #0xc]
; 	return thread->base.pended_on;
 8013142: 68fb         	ldr	r3, [r7, #0xc]
 8013144: 689b         	ldr	r3, [r3, #0x8]
 8013146: 617b         	str	r3, [r7, #0x14]
 8013148: 687b         	ldr	r3, [r7, #0x4]
 801314a: 613b         	str	r3, [r7, #0x10]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 801314c: 693b         	ldr	r3, [r7, #0x10]
 801314e: 4618         	mov	r0, r3
 8013150: f7ff ff0d    	bl	0x8012f6e <sys_dlist_remove> @ imm = #-0x1e6
; }
 8013154: bf00         	nop
; 	z_mark_thread_as_not_pending(thread);
 8013156: 6878         	ldr	r0, [r7, #0x4]
 8013158: f7ff ff9c    	bl	0x8013094 <z_mark_thread_as_not_pending> @ imm = #-0xc8
; 	thread->base.pended_on = NULL;
 801315c: 687b         	ldr	r3, [r7, #0x4]
 801315e: 2200         	movs	r2, #0x0
 8013160: 609a         	str	r2, [r3, #0x8]
; }
 8013162: bf00         	nop
 8013164: 3718         	adds	r7, #0x18
 8013166: 46bd         	mov	sp, r7
 8013168: bd80         	pop	{r7, pc}

0801316a <z_waitq_init>:
; {
 801316a: b580         	push	{r7, lr}
 801316c: b082         	sub	sp, #0x8
 801316e: af00         	add	r7, sp, #0x0
 8013170: 6078         	str	r0, [r7, #0x4]
; 	sys_dlist_init(&w->waitq);
 8013172: 687b         	ldr	r3, [r7, #0x4]
 8013174: 4618         	mov	r0, r3
 8013176: f7ff fea9    	bl	0x8012ecc <sys_dlist_init> @ imm = #-0x2ae
; }
 801317a: bf00         	nop
 801317c: 3708         	adds	r7, #0x8
 801317e: 46bd         	mov	sp, r7
 8013180: bd80         	pop	{r7, pc}

08013182 <z_waitq_head>:
; {
 8013182: b580         	push	{r7, lr}
 8013184: b082         	sub	sp, #0x8
 8013186: af00         	add	r7, sp, #0x0
 8013188: 6078         	str	r0, [r7, #0x4]
; 	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
 801318a: 687b         	ldr	r3, [r7, #0x4]
 801318c: 4618         	mov	r0, r3
 801318e: f7ff fedc    	bl	0x8012f4a <sys_dlist_peek_head> @ imm = #-0x248
 8013192: 4603         	mov	r3, r0
; }
 8013194: 4618         	mov	r0, r3
 8013196: 3708         	adds	r7, #0x8
 8013198: 46bd         	mov	sp, r7
 801319a: bd80         	pop	{r7, pc}

0801319c <z_log_msg_runtime_create>:
; {
 801319c: b580         	push	{r7, lr}
 801319e: b08a         	sub	sp, #0x28
 80131a0: af04         	add	r7, sp, #0x10
 80131a2: 60b9         	str	r1, [r7, #0x8]
 80131a4: 607b         	str	r3, [r7, #0x4]
 80131a6: 4603         	mov	r3, r0
 80131a8: 73fb         	strb	r3, [r7, #0xf]
 80131aa: 4613         	mov	r3, r2
 80131ac: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 80131ae: f107 032c    	add.w	r3, r7, #0x2c
 80131b2: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 80131b4: 7bba         	ldrb	r2, [r7, #0xe]
 80131b6: 7bf8         	ldrb	r0, [r7, #0xf]
 80131b8: 697b         	ldr	r3, [r7, #0x14]
 80131ba: 9303         	str	r3, [sp, #0xc]
 80131bc: 6abb         	ldr	r3, [r7, #0x28]
 80131be: 9302         	str	r3, [sp, #0x8]
 80131c0: 6a7b         	ldr	r3, [r7, #0x24]
 80131c2: 9301         	str	r3, [sp, #0x4]
 80131c4: 6a3b         	ldr	r3, [r7, #0x20]
 80131c6: 9300         	str	r3, [sp]
 80131c8: 687b         	ldr	r3, [r7, #0x4]
 80131ca: 68b9         	ldr	r1, [r7, #0x8]
 80131cc: f7ee fb3a    	bl	0x8001844 <z_log_msg_runtime_vcreate> @ imm = #-0x1198c
; }
 80131d0: bf00         	nop
 80131d2: 3718         	adds	r7, #0x18
 80131d4: 46bd         	mov	sp, r7
 80131d6: bd80         	pop	{r7, pc}

080131d8 <z_impl_k_mutex_init>:
; {
 80131d8: b580         	push	{r7, lr}
 80131da: b082         	sub	sp, #0x8
 80131dc: af00         	add	r7, sp, #0x0
 80131de: 6078         	str	r0, [r7, #0x4]
; 	mutex->owner = NULL;
 80131e0: 687b         	ldr	r3, [r7, #0x4]
 80131e2: 2200         	movs	r2, #0x0
 80131e4: 609a         	str	r2, [r3, #0x8]
; 	mutex->lock_count = 0U;
 80131e6: 687b         	ldr	r3, [r7, #0x4]
 80131e8: 2200         	movs	r2, #0x0
 80131ea: 60da         	str	r2, [r3, #0xc]
; 	z_waitq_init(&mutex->wait_q);
 80131ec: 687b         	ldr	r3, [r7, #0x4]
 80131ee: 4618         	mov	r0, r3
 80131f0: f7ff ffbb    	bl	0x801316a <z_waitq_init> @ imm = #-0x8a
; 	k_object_init(mutex);
 80131f4: 6878         	ldr	r0, [r7, #0x4]
 80131f6: f7ff fed1    	bl	0x8012f9c <k_object_init> @ imm = #-0x25e
; 	return 0;
 80131fa: 2300         	movs	r3, #0x0
; }
 80131fc: 4618         	mov	r0, r3
 80131fe: 3708         	adds	r7, #0x8
 8013200: 46bd         	mov	sp, r7
 8013202: bd80         	pop	{r7, pc}

08013204 <new_prio_for_inheritance>:
; {
 8013204: b580         	push	{r7, lr}
 8013206: b084         	sub	sp, #0x10
 8013208: af00         	add	r7, sp, #0x0
 801320a: 6078         	str	r0, [r7, #0x4]
 801320c: 6039         	str	r1, [r7]
; 	int new_prio = z_is_prio_higher(target, limit) ? target : limit;
 801320e: 6839         	ldr	r1, [r7]
 8013210: 6878         	ldr	r0, [r7, #0x4]
 8013212: f7ff ff82    	bl	0x801311a <z_is_prio_higher> @ imm = #-0xfc
 8013216: 4603         	mov	r3, r0
 8013218: 2b00         	cmp	r3, #0x0
 801321a: d001         	beq	0x8013220 <new_prio_for_inheritance+0x1c> @ imm = #0x2
 801321c: 687b         	ldr	r3, [r7, #0x4]
 801321e: e000         	b	0x8013222 <new_prio_for_inheritance+0x1e> @ imm = #0x0
 8013220: 683b         	ldr	r3, [r7]
 8013222: 60fb         	str	r3, [r7, #0xc]
; 	new_prio = z_get_new_prio_with_ceiling(new_prio);
 8013224: 68f8         	ldr	r0, [r7, #0xc]
 8013226: f7ff ff55    	bl	0x80130d4 <z_get_new_prio_with_ceiling> @ imm = #-0x156
 801322a: 60f8         	str	r0, [r7, #0xc]
; 	return new_prio;
 801322c: 68fb         	ldr	r3, [r7, #0xc]
; }
 801322e: 4618         	mov	r0, r3
 8013230: 3710         	adds	r7, #0x10
 8013232: 46bd         	mov	sp, r7
 8013234: bd80         	pop	{r7, pc}

08013236 <sys_dlist_init>:
; {
 8013236: b480         	push	{r7}
 8013238: b083         	sub	sp, #0xc
 801323a: af00         	add	r7, sp, #0x0
 801323c: 6078         	str	r0, [r7, #0x4]
; 	list->head = (sys_dnode_t *)list;
 801323e: 687b         	ldr	r3, [r7, #0x4]
 8013240: 687a         	ldr	r2, [r7, #0x4]
 8013242: 601a         	str	r2, [r3]
; 	list->tail = (sys_dnode_t *)list;
 8013244: 687b         	ldr	r3, [r7, #0x4]
 8013246: 687a         	ldr	r2, [r7, #0x4]
 8013248: 605a         	str	r2, [r3, #0x4]
; }
 801324a: bf00         	nop
 801324c: 370c         	adds	r7, #0xc
 801324e: 46bd         	mov	sp, r7
 8013250: bc80         	pop	{r7}
 8013252: 4770         	bx	lr

08013254 <sys_dnode_init>:
; {
 8013254: b480         	push	{r7}
 8013256: b083         	sub	sp, #0xc
 8013258: af00         	add	r7, sp, #0x0
 801325a: 6078         	str	r0, [r7, #0x4]
; 	node->next = NULL;
 801325c: 687b         	ldr	r3, [r7, #0x4]
 801325e: 2200         	movs	r2, #0x0
 8013260: 601a         	str	r2, [r3]
; 	node->prev = NULL;
 8013262: 687b         	ldr	r3, [r7, #0x4]
 8013264: 2200         	movs	r2, #0x0
 8013266: 605a         	str	r2, [r3, #0x4]
; }
 8013268: bf00         	nop
 801326a: 370c         	adds	r7, #0xc
 801326c: 46bd         	mov	sp, r7
 801326e: bc80         	pop	{r7}
 8013270: 4770         	bx	lr

08013272 <sys_dlist_is_empty>:
; {
 8013272: b480         	push	{r7}
 8013274: b083         	sub	sp, #0xc
 8013276: af00         	add	r7, sp, #0x0
 8013278: 6078         	str	r0, [r7, #0x4]
; 	return list->head == list;
 801327a: 687b         	ldr	r3, [r7, #0x4]
 801327c: 681b         	ldr	r3, [r3]
 801327e: 687a         	ldr	r2, [r7, #0x4]
 8013280: 429a         	cmp	r2, r3
 8013282: bf0c         	ite	eq
 8013284: 2301         	moveq	r3, #0x1
 8013286: 2300         	movne	r3, #0x0
 8013288: b2db         	uxtb	r3, r3
; }
 801328a: 4618         	mov	r0, r3
 801328c: 370c         	adds	r7, #0xc
 801328e: 46bd         	mov	sp, r7
 8013290: bc80         	pop	{r7}
 8013292: 4770         	bx	lr

08013294 <sys_dlist_peek_head>:
; {
 8013294: b580         	push	{r7, lr}
 8013296: b082         	sub	sp, #0x8
 8013298: af00         	add	r7, sp, #0x0
 801329a: 6078         	str	r0, [r7, #0x4]
; 	return sys_dlist_is_empty(list) ? NULL : list->head;
 801329c: 6878         	ldr	r0, [r7, #0x4]
 801329e: f7ff ffe8    	bl	0x8013272 <sys_dlist_is_empty> @ imm = #-0x30
 80132a2: 4603         	mov	r3, r0
 80132a4: 2b00         	cmp	r3, #0x0
 80132a6: d102         	bne	0x80132ae <sys_dlist_peek_head+0x1a> @ imm = #0x4
 80132a8: 687b         	ldr	r3, [r7, #0x4]
 80132aa: 681b         	ldr	r3, [r3]
 80132ac: e000         	b	0x80132b0 <sys_dlist_peek_head+0x1c> @ imm = #0x0
 80132ae: 2300         	movs	r3, #0x0
; }
 80132b0: 4618         	mov	r0, r3
 80132b2: 3708         	adds	r7, #0x8
 80132b4: 46bd         	mov	sp, r7
 80132b6: bd80         	pop	{r7, pc}

080132b8 <sys_dlist_remove>:
; {
 80132b8: b580         	push	{r7, lr}
 80132ba: b084         	sub	sp, #0x10
 80132bc: af00         	add	r7, sp, #0x0
 80132be: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_t *const prev = node->prev;
 80132c0: 687b         	ldr	r3, [r7, #0x4]
 80132c2: 685b         	ldr	r3, [r3, #0x4]
 80132c4: 60fb         	str	r3, [r7, #0xc]
; 	sys_dnode_t *const next = node->next;
 80132c6: 687b         	ldr	r3, [r7, #0x4]
 80132c8: 681b         	ldr	r3, [r3]
 80132ca: 60bb         	str	r3, [r7, #0x8]
; 	prev->next = next;
 80132cc: 68fb         	ldr	r3, [r7, #0xc]
 80132ce: 68ba         	ldr	r2, [r7, #0x8]
 80132d0: 601a         	str	r2, [r3]
; 	next->prev = prev;
 80132d2: 68bb         	ldr	r3, [r7, #0x8]
 80132d4: 68fa         	ldr	r2, [r7, #0xc]
 80132d6: 605a         	str	r2, [r3, #0x4]
; 	sys_dnode_init(node);
 80132d8: 6878         	ldr	r0, [r7, #0x4]
 80132da: f7ff ffbb    	bl	0x8013254 <sys_dnode_init> @ imm = #-0x8a
; }
 80132de: bf00         	nop
 80132e0: 3710         	adds	r7, #0x10
 80132e2: 46bd         	mov	sp, r7
 80132e4: bd80         	pop	{r7, pc}

080132e6 <k_object_init>:
; {
 80132e6: b480         	push	{r7}
 80132e8: b083         	sub	sp, #0xc
 80132ea: af00         	add	r7, sp, #0x0
 80132ec: 6078         	str	r0, [r7, #0x4]
; }
 80132ee: bf00         	nop
 80132f0: 370c         	adds	r7, #0xc
 80132f2: 46bd         	mov	sp, r7
 80132f4: bc80         	pop	{r7}
 80132f6: 4770         	bx	lr

080132f8 <z_abort_thread_timeout>:
; {
 80132f8: b580         	push	{r7, lr}
 80132fa: b082         	sub	sp, #0x8
 80132fc: af00         	add	r7, sp, #0x0
 80132fe: 6078         	str	r0, [r7, #0x4]
; 	return z_abort_timeout(&thread->base.timeout);
 8013300: 687b         	ldr	r3, [r7, #0x4]
 8013302: 3318         	adds	r3, #0x18
 8013304: 4618         	mov	r0, r3
 8013306: f7f8 ff8d    	bl	0x800c224 <z_abort_timeout> @ imm = #-0x70e6
 801330a: 4603         	mov	r3, r0
; }
 801330c: 4618         	mov	r0, r3
 801330e: 3708         	adds	r7, #0x8
 8013310: 46bd         	mov	sp, r7
 8013312: bd80         	pop	{r7, pc}

08013314 <z_waitq_init>:
; {
 8013314: b580         	push	{r7, lr}
 8013316: b082         	sub	sp, #0x8
 8013318: af00         	add	r7, sp, #0x0
 801331a: 6078         	str	r0, [r7, #0x4]
; 	sys_dlist_init(&w->waitq);
 801331c: 687b         	ldr	r3, [r7, #0x4]
 801331e: 4618         	mov	r0, r3
 8013320: f7ff ff89    	bl	0x8013236 <sys_dlist_init> @ imm = #-0xee
; }
 8013324: bf00         	nop
 8013326: 3708         	adds	r7, #0x8
 8013328: 46bd         	mov	sp, r7
 801332a: bd80         	pop	{r7, pc}

0801332c <z_mark_thread_as_not_pending>:
; {
 801332c: b480         	push	{r7}
 801332e: b083         	sub	sp, #0xc
 8013330: af00         	add	r7, sp, #0x0
 8013332: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state &= ~_THREAD_PENDING;
 8013334: 687b         	ldr	r3, [r7, #0x4]
 8013336: 7b5b         	ldrb	r3, [r3, #0xd]
 8013338: f023 0302    	bic	r3, r3, #0x2
 801333c: b2da         	uxtb	r2, r3
 801333e: 687b         	ldr	r3, [r7, #0x4]
 8013340: 735a         	strb	r2, [r3, #0xd]
; }
 8013342: bf00         	nop
 8013344: 370c         	adds	r7, #0xc
 8013346: 46bd         	mov	sp, r7
 8013348: bc80         	pop	{r7}
 801334a: 4770         	bx	lr

0801334c <unpend_thread_no_timeout>:
; {
 801334c: b580         	push	{r7, lr}
 801334e: b086         	sub	sp, #0x18
 8013350: af00         	add	r7, sp, #0x0
 8013352: 6078         	str	r0, [r7, #0x4]
 8013354: 687b         	ldr	r3, [r7, #0x4]
 8013356: 60fb         	str	r3, [r7, #0xc]
; 	return thread->base.pended_on;
 8013358: 68fb         	ldr	r3, [r7, #0xc]
 801335a: 689b         	ldr	r3, [r3, #0x8]
 801335c: 617b         	str	r3, [r7, #0x14]
 801335e: 687b         	ldr	r3, [r7, #0x4]
 8013360: 613b         	str	r3, [r7, #0x10]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 8013362: 693b         	ldr	r3, [r7, #0x10]
 8013364: 4618         	mov	r0, r3
 8013366: f7ff ffa7    	bl	0x80132b8 <sys_dlist_remove> @ imm = #-0xb2
; }
 801336a: bf00         	nop
; 	z_mark_thread_as_not_pending(thread);
 801336c: 6878         	ldr	r0, [r7, #0x4]
 801336e: f7ff ffdd    	bl	0x801332c <z_mark_thread_as_not_pending> @ imm = #-0x46
; 	thread->base.pended_on = NULL;
 8013372: 687b         	ldr	r3, [r7, #0x4]
 8013374: 2200         	movs	r2, #0x0
 8013376: 609a         	str	r2, [r3, #0x8]
; }
 8013378: bf00         	nop
 801337a: 3718         	adds	r7, #0x18
 801337c: 46bd         	mov	sp, r7
 801337e: bd80         	pop	{r7, pc}

08013380 <z_impl_k_sem_init>:
; {
 8013380: b580         	push	{r7, lr}
 8013382: b084         	sub	sp, #0x10
 8013384: af00         	add	r7, sp, #0x0
 8013386: 60f8         	str	r0, [r7, #0xc]
 8013388: 60b9         	str	r1, [r7, #0x8]
 801338a: 607a         	str	r2, [r7, #0x4]
; 	CHECKIF(limit == 0U || initial_count > limit) {
 801338c: 687b         	ldr	r3, [r7, #0x4]
 801338e: 2b00         	cmp	r3, #0x0
 8013390: d003         	beq	0x801339a <z_impl_k_sem_init+0x1a> @ imm = #0x6
 8013392: 68ba         	ldr	r2, [r7, #0x8]
 8013394: 687b         	ldr	r3, [r7, #0x4]
 8013396: 429a         	cmp	r2, r3
 8013398: d902         	bls	0x80133a0 <z_impl_k_sem_init+0x20> @ imm = #0x4
; 		return -EINVAL;
 801339a: f06f 0315    	mvn	r3, #0x15
 801339e: e00d         	b	0x80133bc <z_impl_k_sem_init+0x3c> @ imm = #0x1a
; 	sem->count = initial_count;
 80133a0: 68fb         	ldr	r3, [r7, #0xc]
 80133a2: 68ba         	ldr	r2, [r7, #0x8]
 80133a4: 609a         	str	r2, [r3, #0x8]
; 	sem->limit = limit;
 80133a6: 68fb         	ldr	r3, [r7, #0xc]
 80133a8: 687a         	ldr	r2, [r7, #0x4]
 80133aa: 60da         	str	r2, [r3, #0xc]
; 	z_waitq_init(&sem->wait_q);
 80133ac: 68fb         	ldr	r3, [r7, #0xc]
 80133ae: 4618         	mov	r0, r3
 80133b0: f7ff ffb0    	bl	0x8013314 <z_waitq_init> @ imm = #-0xa0
; 	k_object_init(sem);
 80133b4: 68f8         	ldr	r0, [r7, #0xc]
 80133b6: f7ff ff96    	bl	0x80132e6 <k_object_init> @ imm = #-0xd4
; 	return 0;
 80133ba: 2300         	movs	r3, #0x0
; }
 80133bc: 4618         	mov	r0, r3
 80133be: 3710         	adds	r7, #0x10
 80133c0: 46bd         	mov	sp, r7
 80133c2: bd80         	pop	{r7, pc}

080133c4 <handle_poll_events>:
; {
 80133c4: b480         	push	{r7}
 80133c6: b083         	sub	sp, #0xc
 80133c8: af00         	add	r7, sp, #0x0
 80133ca: 6078         	str	r0, [r7, #0x4]
; 	return false;
 80133cc: 2300         	movs	r3, #0x0
; }
 80133ce: 4618         	mov	r0, r3
 80133d0: 370c         	adds	r7, #0xc
 80133d2: 46bd         	mov	sp, r7
 80133d4: bc80         	pop	{r7}
 80133d6: 4770         	bx	lr

080133d8 <sys_dlist_init>:
; {
 80133d8: b480         	push	{r7}
 80133da: b083         	sub	sp, #0xc
 80133dc: af00         	add	r7, sp, #0x0
 80133de: 6078         	str	r0, [r7, #0x4]
; 	list->head = (sys_dnode_t *)list;
 80133e0: 687b         	ldr	r3, [r7, #0x4]
 80133e2: 687a         	ldr	r2, [r7, #0x4]
 80133e4: 601a         	str	r2, [r3]
; 	list->tail = (sys_dnode_t *)list;
 80133e6: 687b         	ldr	r3, [r7, #0x4]
 80133e8: 687a         	ldr	r2, [r7, #0x4]
 80133ea: 605a         	str	r2, [r3, #0x4]
; }
 80133ec: bf00         	nop
 80133ee: 370c         	adds	r7, #0xc
 80133f0: 46bd         	mov	sp, r7
 80133f2: bc80         	pop	{r7}
 80133f4: 4770         	bx	lr

080133f6 <sys_dnode_init>:
; {
 80133f6: b480         	push	{r7}
 80133f8: b083         	sub	sp, #0xc
 80133fa: af00         	add	r7, sp, #0x0
 80133fc: 6078         	str	r0, [r7, #0x4]
; 	node->next = NULL;
 80133fe: 687b         	ldr	r3, [r7, #0x4]
 8013400: 2200         	movs	r2, #0x0
 8013402: 601a         	str	r2, [r3]
; 	node->prev = NULL;
 8013404: 687b         	ldr	r3, [r7, #0x4]
 8013406: 2200         	movs	r2, #0x0
 8013408: 605a         	str	r2, [r3, #0x4]
; }
 801340a: bf00         	nop
 801340c: 370c         	adds	r7, #0xc
 801340e: 46bd         	mov	sp, r7
 8013410: bc80         	pop	{r7}
 8013412: 4770         	bx	lr

08013414 <K_KERNEL_STACK_BUFFER>:
; {
 8013414: b480         	push	{r7}
 8013416: b083         	sub	sp, #0xc
 8013418: af00         	add	r7, sp, #0x0
 801341a: 6078         	str	r0, [r7, #0x4]
; 	return (char *)sym + K_KERNEL_STACK_RESERVED;
 801341c: 687b         	ldr	r3, [r7, #0x4]
; }
 801341e: 4618         	mov	r0, r3
 8013420: 370c         	adds	r7, #0xc
 8013422: 46bd         	mov	sp, r7
 8013424: bc80         	pop	{r7}
 8013426: 4770         	bx	lr

08013428 <z_init_timeout>:
; {
 8013428: b580         	push	{r7, lr}
 801342a: b082         	sub	sp, #0x8
 801342c: af00         	add	r7, sp, #0x0
 801342e: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_init(&to->node);
 8013430: 687b         	ldr	r3, [r7, #0x4]
 8013432: 4618         	mov	r0, r3
 8013434: f7ff ffdf    	bl	0x80133f6 <sys_dnode_init> @ imm = #-0x42
; }
 8013438: bf00         	nop
 801343a: 3708         	adds	r7, #0x8
 801343c: 46bd         	mov	sp, r7
 801343e: bd80         	pop	{r7, pc}

08013440 <z_init_thread_timeout>:
; {
 8013440: b580         	push	{r7, lr}
 8013442: b082         	sub	sp, #0x8
 8013444: af00         	add	r7, sp, #0x0
 8013446: 6078         	str	r0, [r7, #0x4]
; 	z_init_timeout(&thread_base->timeout);
 8013448: 687b         	ldr	r3, [r7, #0x4]
 801344a: 3318         	adds	r3, #0x18
 801344c: 4618         	mov	r0, r3
 801344e: f7ff ffeb    	bl	0x8013428 <z_init_timeout> @ imm = #-0x2a
; }
 8013452: bf00         	nop
 8013454: 3708         	adds	r7, #0x8
 8013456: 46bd         	mov	sp, r7
 8013458: bd80         	pop	{r7, pc}

0801345a <z_waitq_init>:
; {
 801345a: b580         	push	{r7, lr}
 801345c: b082         	sub	sp, #0x8
 801345e: af00         	add	r7, sp, #0x0
 8013460: 6078         	str	r0, [r7, #0x4]
; 	sys_dlist_init(&w->waitq);
 8013462: 687b         	ldr	r3, [r7, #0x4]
 8013464: 4618         	mov	r0, r3
 8013466: f7ff ffb7    	bl	0x80133d8 <sys_dlist_init> @ imm = #-0x92
; }
 801346a: bf00         	nop
 801346c: 3708         	adds	r7, #0x8
 801346e: 46bd         	mov	sp, r7
 8013470: bd80         	pop	{r7, pc}

08013472 <z_log_msg_runtime_create>:
; {
 8013472: b580         	push	{r7, lr}
 8013474: b08a         	sub	sp, #0x28
 8013476: af04         	add	r7, sp, #0x10
 8013478: 60b9         	str	r1, [r7, #0x8]
 801347a: 607b         	str	r3, [r7, #0x4]
 801347c: 4603         	mov	r3, r0
 801347e: 73fb         	strb	r3, [r7, #0xf]
 8013480: 4613         	mov	r3, r2
 8013482: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 8013484: f107 032c    	add.w	r3, r7, #0x2c
 8013488: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 801348a: 7bba         	ldrb	r2, [r7, #0xe]
 801348c: 7bf8         	ldrb	r0, [r7, #0xf]
 801348e: 697b         	ldr	r3, [r7, #0x14]
 8013490: 9303         	str	r3, [sp, #0xc]
 8013492: 6abb         	ldr	r3, [r7, #0x28]
 8013494: 9302         	str	r3, [sp, #0x8]
 8013496: 6a7b         	ldr	r3, [r7, #0x24]
 8013498: 9301         	str	r3, [sp, #0x4]
 801349a: 6a3b         	ldr	r3, [r7, #0x20]
 801349c: 9300         	str	r3, [sp]
 801349e: 687b         	ldr	r3, [r7, #0x4]
 80134a0: 68b9         	ldr	r1, [r7, #0x8]
 80134a2: f7ee f9cf    	bl	0x8001844 <z_log_msg_runtime_vcreate> @ imm = #-0x11c62
; }
 80134a6: bf00         	nop
 80134a8: 3718         	adds	r7, #0x18
 80134aa: 46bd         	mov	sp, r7
 80134ac: bd80         	pop	{r7, pc}

080134ae <k_thread_name_get>:
; {
 80134ae: b480         	push	{r7}
 80134b0: b083         	sub	sp, #0xc
 80134b2: af00         	add	r7, sp, #0x0
 80134b4: 6078         	str	r0, [r7, #0x4]
; 	return (const char *)thread->name;
 80134b6: 687b         	ldr	r3, [r7, #0x4]
 80134b8: 3394         	adds	r3, #0x94
; }
 80134ba: 4618         	mov	r0, r3
 80134bc: 370c         	adds	r7, #0xc
 80134be: 46bd         	mov	sp, r7
 80134c0: bc80         	pop	{r7}
 80134c2: 4770         	bx	lr

080134c4 <z_init_thread_base>:
; {
 80134c4: b580         	push	{r7, lr}
 80134c6: b084         	sub	sp, #0x10
 80134c8: af00         	add	r7, sp, #0x0
 80134ca: 60f8         	str	r0, [r7, #0xc]
 80134cc: 60b9         	str	r1, [r7, #0x8]
 80134ce: 607a         	str	r2, [r7, #0x4]
 80134d0: 603b         	str	r3, [r7]
; 	thread_base->pended_on = NULL;
 80134d2: 68fb         	ldr	r3, [r7, #0xc]
 80134d4: 2200         	movs	r2, #0x0
 80134d6: 609a         	str	r2, [r3, #0x8]
; 	thread_base->user_options = (uint8_t)options;
 80134d8: 683b         	ldr	r3, [r7]
 80134da: b2da         	uxtb	r2, r3
 80134dc: 68fb         	ldr	r3, [r7, #0xc]
 80134de: 731a         	strb	r2, [r3, #0xc]
; 	thread_base->thread_state = (uint8_t)initial_state;
 80134e0: 687b         	ldr	r3, [r7, #0x4]
 80134e2: b2da         	uxtb	r2, r3
 80134e4: 68fb         	ldr	r3, [r7, #0xc]
 80134e6: 735a         	strb	r2, [r3, #0xd]
; 	thread_base->prio = priority;
 80134e8: 68bb         	ldr	r3, [r7, #0x8]
 80134ea: b25a         	sxtb	r2, r3
 80134ec: 68fb         	ldr	r3, [r7, #0xc]
 80134ee: 739a         	strb	r2, [r3, #0xe]
; 	thread_base->sched_locked = 0U;
 80134f0: 68fb         	ldr	r3, [r7, #0xc]
 80134f2: 2200         	movs	r2, #0x0
 80134f4: 73da         	strb	r2, [r3, #0xf]
; 	z_init_thread_timeout(thread_base);
 80134f6: 68f8         	ldr	r0, [r7, #0xc]
 80134f8: f7ff ffa2    	bl	0x8013440 <z_init_thread_timeout> @ imm = #-0xbc
; }
 80134fc: bf00         	nop
 80134fe: 3710         	adds	r7, #0x10
 8013500: 46bd         	mov	sp, r7
 8013502: bd80         	pop	{r7, pc}

08013504 <z_thread_mark_switched_out>:
; {
 8013504: b580         	push	{r7, lr}
 8013506: af00         	add	r7, sp, #0x0
; 	z_sched_usage_stop();
 8013508: f7f9 f836    	bl	0x800c578 <z_sched_usage_stop> @ imm = #-0x6f94
; }
 801350c: bf00         	nop
 801350e: bd80         	pop	{r7, pc}

08013510 <sys_dlist_init>:
; {
 8013510: b480         	push	{r7}
 8013512: b083         	sub	sp, #0xc
 8013514: af00         	add	r7, sp, #0x0
 8013516: 6078         	str	r0, [r7, #0x4]
; 	list->head = (sys_dnode_t *)list;
 8013518: 687b         	ldr	r3, [r7, #0x4]
 801351a: 687a         	ldr	r2, [r7, #0x4]
 801351c: 601a         	str	r2, [r3]
; 	list->tail = (sys_dnode_t *)list;
 801351e: 687b         	ldr	r3, [r7, #0x4]
 8013520: 687a         	ldr	r2, [r7, #0x4]
 8013522: 605a         	str	r2, [r3, #0x4]
; }
 8013524: bf00         	nop
 8013526: 370c         	adds	r7, #0xc
 8013528: 46bd         	mov	sp, r7
 801352a: bc80         	pop	{r7}
 801352c: 4770         	bx	lr

0801352e <sys_dnode_init>:
; {
 801352e: b480         	push	{r7}
 8013530: b083         	sub	sp, #0xc
 8013532: af00         	add	r7, sp, #0x0
 8013534: 6078         	str	r0, [r7, #0x4]
; 	node->next = NULL;
 8013536: 687b         	ldr	r3, [r7, #0x4]
 8013538: 2200         	movs	r2, #0x0
 801353a: 601a         	str	r2, [r3]
; 	node->prev = NULL;
 801353c: 687b         	ldr	r3, [r7, #0x4]
 801353e: 2200         	movs	r2, #0x0
 8013540: 605a         	str	r2, [r3, #0x4]
; }
 8013542: bf00         	nop
 8013544: 370c         	adds	r7, #0xc
 8013546: 46bd         	mov	sp, r7
 8013548: bc80         	pop	{r7}
 801354a: 4770         	bx	lr

0801354c <sys_dnode_is_linked>:
; {
 801354c: b480         	push	{r7}
 801354e: b083         	sub	sp, #0xc
 8013550: af00         	add	r7, sp, #0x0
 8013552: 6078         	str	r0, [r7, #0x4]
; 	return node->next != NULL;
 8013554: 687b         	ldr	r3, [r7, #0x4]
 8013556: 681b         	ldr	r3, [r3]
 8013558: 2b00         	cmp	r3, #0x0
 801355a: bf14         	ite	ne
 801355c: 2301         	movne	r3, #0x1
 801355e: 2300         	moveq	r3, #0x0
 8013560: b2db         	uxtb	r3, r3
; }
 8013562: 4618         	mov	r0, r3
 8013564: 370c         	adds	r7, #0xc
 8013566: 46bd         	mov	sp, r7
 8013568: bc80         	pop	{r7}
 801356a: 4770         	bx	lr

0801356c <sys_dlist_is_empty>:
; {
 801356c: b480         	push	{r7}
 801356e: b083         	sub	sp, #0xc
 8013570: af00         	add	r7, sp, #0x0
 8013572: 6078         	str	r0, [r7, #0x4]
; 	return list->head == list;
 8013574: 687b         	ldr	r3, [r7, #0x4]
 8013576: 681b         	ldr	r3, [r3]
 8013578: 687a         	ldr	r2, [r7, #0x4]
 801357a: 429a         	cmp	r2, r3
 801357c: bf0c         	ite	eq
 801357e: 2301         	moveq	r3, #0x1
 8013580: 2300         	movne	r3, #0x0
 8013582: b2db         	uxtb	r3, r3
; }
 8013584: 4618         	mov	r0, r3
 8013586: 370c         	adds	r7, #0xc
 8013588: 46bd         	mov	sp, r7
 801358a: bc80         	pop	{r7}
 801358c: 4770         	bx	lr

0801358e <sys_dlist_peek_head>:
; {
 801358e: b580         	push	{r7, lr}
 8013590: b082         	sub	sp, #0x8
 8013592: af00         	add	r7, sp, #0x0
 8013594: 6078         	str	r0, [r7, #0x4]
; 	return sys_dlist_is_empty(list) ? NULL : list->head;
 8013596: 6878         	ldr	r0, [r7, #0x4]
 8013598: f7ff ffe8    	bl	0x801356c <sys_dlist_is_empty> @ imm = #-0x30
 801359c: 4603         	mov	r3, r0
 801359e: 2b00         	cmp	r3, #0x0
 80135a0: d102         	bne	0x80135a8 <sys_dlist_peek_head+0x1a> @ imm = #0x4
 80135a2: 687b         	ldr	r3, [r7, #0x4]
 80135a4: 681b         	ldr	r3, [r3]
 80135a6: e000         	b	0x80135aa <sys_dlist_peek_head+0x1c> @ imm = #0x0
 80135a8: 2300         	movs	r3, #0x0
; }
 80135aa: 4618         	mov	r0, r3
 80135ac: 3708         	adds	r7, #0x8
 80135ae: 46bd         	mov	sp, r7
 80135b0: bd80         	pop	{r7, pc}

080135b2 <sys_dlist_peek_next_no_check>:
; {
 80135b2: b480         	push	{r7}
 80135b4: b083         	sub	sp, #0xc
 80135b6: af00         	add	r7, sp, #0x0
 80135b8: 6078         	str	r0, [r7, #0x4]
 80135ba: 6039         	str	r1, [r7]
; 	return (node == list->tail) ? NULL : node->next;
 80135bc: 687b         	ldr	r3, [r7, #0x4]
 80135be: 685b         	ldr	r3, [r3, #0x4]
 80135c0: 683a         	ldr	r2, [r7]
 80135c2: 429a         	cmp	r2, r3
 80135c4: d002         	beq	0x80135cc <sys_dlist_peek_next_no_check+0x1a> @ imm = #0x4
 80135c6: 683b         	ldr	r3, [r7]
 80135c8: 681b         	ldr	r3, [r3]
 80135ca: e000         	b	0x80135ce <sys_dlist_peek_next_no_check+0x1c> @ imm = #0x0
 80135cc: 2300         	movs	r3, #0x0
; }
 80135ce: 4618         	mov	r0, r3
 80135d0: 370c         	adds	r7, #0xc
 80135d2: 46bd         	mov	sp, r7
 80135d4: bc80         	pop	{r7}
 80135d6: 4770         	bx	lr

080135d8 <sys_dlist_peek_next>:
; {
 80135d8: b580         	push	{r7, lr}
 80135da: b082         	sub	sp, #0x8
 80135dc: af00         	add	r7, sp, #0x0
 80135de: 6078         	str	r0, [r7, #0x4]
 80135e0: 6039         	str	r1, [r7]
; 	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
 80135e2: 683b         	ldr	r3, [r7]
 80135e4: 2b00         	cmp	r3, #0x0
 80135e6: d005         	beq	0x80135f4 <sys_dlist_peek_next+0x1c> @ imm = #0xa
 80135e8: 6839         	ldr	r1, [r7]
 80135ea: 6878         	ldr	r0, [r7, #0x4]
 80135ec: f7ff ffe1    	bl	0x80135b2 <sys_dlist_peek_next_no_check> @ imm = #-0x3e
 80135f0: 4603         	mov	r3, r0
 80135f2: e000         	b	0x80135f6 <sys_dlist_peek_next+0x1e> @ imm = #0x0
 80135f4: 2300         	movs	r3, #0x0
; }
 80135f6: 4618         	mov	r0, r3
 80135f8: 3708         	adds	r7, #0x8
 80135fa: 46bd         	mov	sp, r7
 80135fc: bd80         	pop	{r7, pc}

080135fe <sys_dlist_append>:
; {
 80135fe: b480         	push	{r7}
 8013600: b085         	sub	sp, #0x14
 8013602: af00         	add	r7, sp, #0x0
 8013604: 6078         	str	r0, [r7, #0x4]
 8013606: 6039         	str	r1, [r7]
; 	sys_dnode_t *const tail = list->tail;
 8013608: 687b         	ldr	r3, [r7, #0x4]
 801360a: 685b         	ldr	r3, [r3, #0x4]
 801360c: 60fb         	str	r3, [r7, #0xc]
; 	node->next = list;
 801360e: 683b         	ldr	r3, [r7]
 8013610: 687a         	ldr	r2, [r7, #0x4]
 8013612: 601a         	str	r2, [r3]
; 	node->prev = tail;
 8013614: 683b         	ldr	r3, [r7]
 8013616: 68fa         	ldr	r2, [r7, #0xc]
 8013618: 605a         	str	r2, [r3, #0x4]
; 	tail->next = node;
 801361a: 68fb         	ldr	r3, [r7, #0xc]
 801361c: 683a         	ldr	r2, [r7]
 801361e: 601a         	str	r2, [r3]
; 	list->tail = node;
 8013620: 687b         	ldr	r3, [r7, #0x4]
 8013622: 683a         	ldr	r2, [r7]
 8013624: 605a         	str	r2, [r3, #0x4]
; }
 8013626: bf00         	nop
 8013628: 3714         	adds	r7, #0x14
 801362a: 46bd         	mov	sp, r7
 801362c: bc80         	pop	{r7}
 801362e: 4770         	bx	lr

08013630 <sys_dlist_insert>:
; {
 8013630: b480         	push	{r7}
 8013632: b085         	sub	sp, #0x14
 8013634: af00         	add	r7, sp, #0x0
 8013636: 6078         	str	r0, [r7, #0x4]
 8013638: 6039         	str	r1, [r7]
; 	sys_dnode_t *const prev = successor->prev;
 801363a: 687b         	ldr	r3, [r7, #0x4]
 801363c: 685b         	ldr	r3, [r3, #0x4]
 801363e: 60fb         	str	r3, [r7, #0xc]
; 	node->prev = prev;
 8013640: 683b         	ldr	r3, [r7]
 8013642: 68fa         	ldr	r2, [r7, #0xc]
 8013644: 605a         	str	r2, [r3, #0x4]
; 	node->next = successor;
 8013646: 683b         	ldr	r3, [r7]
 8013648: 687a         	ldr	r2, [r7, #0x4]
 801364a: 601a         	str	r2, [r3]
; 	prev->next = node;
 801364c: 68fb         	ldr	r3, [r7, #0xc]
 801364e: 683a         	ldr	r2, [r7]
 8013650: 601a         	str	r2, [r3]
; 	successor->prev = node;
 8013652: 687b         	ldr	r3, [r7, #0x4]
 8013654: 683a         	ldr	r2, [r7]
 8013656: 605a         	str	r2, [r3, #0x4]
; }
 8013658: bf00         	nop
 801365a: 3714         	adds	r7, #0x14
 801365c: 46bd         	mov	sp, r7
 801365e: bc80         	pop	{r7}
 8013660: 4770         	bx	lr

08013662 <sys_dlist_remove>:
; {
 8013662: b580         	push	{r7, lr}
 8013664: b084         	sub	sp, #0x10
 8013666: af00         	add	r7, sp, #0x0
 8013668: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_t *const prev = node->prev;
 801366a: 687b         	ldr	r3, [r7, #0x4]
 801366c: 685b         	ldr	r3, [r3, #0x4]
 801366e: 60fb         	str	r3, [r7, #0xc]
; 	sys_dnode_t *const next = node->next;
 8013670: 687b         	ldr	r3, [r7, #0x4]
 8013672: 681b         	ldr	r3, [r3]
 8013674: 60bb         	str	r3, [r7, #0x8]
; 	prev->next = next;
 8013676: 68fb         	ldr	r3, [r7, #0xc]
 8013678: 68ba         	ldr	r2, [r7, #0x8]
 801367a: 601a         	str	r2, [r3]
; 	next->prev = prev;
 801367c: 68bb         	ldr	r3, [r7, #0x8]
 801367e: 68fa         	ldr	r2, [r7, #0xc]
 8013680: 605a         	str	r2, [r3, #0x4]
; 	sys_dnode_init(node);
 8013682: 6878         	ldr	r0, [r7, #0x4]
 8013684: f7ff ff53    	bl	0x801352e <sys_dnode_init> @ imm = #-0x15a
; }
 8013688: bf00         	nop
 801368a: 3710         	adds	r7, #0x10
 801368c: 46bd         	mov	sp, r7
 801368e: bd80         	pop	{r7, pc}

08013690 <k_yield>:
; {
 8013690: b580         	push	{r7, lr}
 8013692: af00         	add	r7, sp, #0x0
; 	z_impl_k_yield();
 8013694: f7f7 ff78    	bl	0x800b588 <z_impl_k_yield> @ imm = #-0x8110
; }
 8013698: bf00         	nop
 801369a: bd80         	pop	{r7, pc}

0801369c <k_thread_suspend>:
; {
 801369c: b580         	push	{r7, lr}
 801369e: b082         	sub	sp, #0x8
 80136a0: af00         	add	r7, sp, #0x0
 80136a2: 6078         	str	r0, [r7, #0x4]
; 	z_impl_k_thread_suspend(thread);
 80136a4: 6878         	ldr	r0, [r7, #0x4]
 80136a6: f7f7 fa1f    	bl	0x800aae8 <z_impl_k_thread_suspend> @ imm = #-0x8bc2
; }
 80136aa: bf00         	nop
 80136ac: 3708         	adds	r7, #0x8
 80136ae: 46bd         	mov	sp, r7
 80136b0: bd80         	pop	{r7, pc}

080136b2 <z_is_inactive_timeout>:
; {
 80136b2: b580         	push	{r7, lr}
 80136b4: b082         	sub	sp, #0x8
 80136b6: af00         	add	r7, sp, #0x0
 80136b8: 6078         	str	r0, [r7, #0x4]
; 	return !sys_dnode_is_linked(&to->node);
 80136ba: 687b         	ldr	r3, [r7, #0x4]
 80136bc: 4618         	mov	r0, r3
 80136be: f7ff ff45    	bl	0x801354c <sys_dnode_is_linked> @ imm = #-0x176
 80136c2: 4603         	mov	r3, r0
 80136c4: 2b00         	cmp	r3, #0x0
 80136c6: bf14         	ite	ne
 80136c8: 2301         	movne	r3, #0x1
 80136ca: 2300         	moveq	r3, #0x0
 80136cc: b2db         	uxtb	r3, r3
 80136ce: f083 0301    	eor	r3, r3, #0x1
 80136d2: b2db         	uxtb	r3, r3
 80136d4: f003 0301    	and	r3, r3, #0x1
 80136d8: b2db         	uxtb	r3, r3
; }
 80136da: 4618         	mov	r0, r3
 80136dc: 3708         	adds	r7, #0x8
 80136de: 46bd         	mov	sp, r7
 80136e0: bd80         	pop	{r7, pc}

080136e2 <z_abort_thread_timeout>:
; {
 80136e2: b580         	push	{r7, lr}
 80136e4: b082         	sub	sp, #0x8
 80136e6: af00         	add	r7, sp, #0x0
 80136e8: 6078         	str	r0, [r7, #0x4]
; 	return z_abort_timeout(&thread->base.timeout);
 80136ea: 687b         	ldr	r3, [r7, #0x4]
 80136ec: 3318         	adds	r3, #0x18
 80136ee: 4618         	mov	r0, r3
 80136f0: f7f8 fd98    	bl	0x800c224 <z_abort_timeout> @ imm = #-0x74d0
 80136f4: 4603         	mov	r3, r0
; }
 80136f6: 4618         	mov	r0, r3
 80136f8: 3708         	adds	r7, #0x8
 80136fa: 46bd         	mov	sp, r7
 80136fc: bd80         	pop	{r7, pc}

080136fe <thread_is_preemptible>:
; {
 80136fe: b480         	push	{r7}
 8013700: b083         	sub	sp, #0xc
 8013702: af00         	add	r7, sp, #0x0
 8013704: 6078         	str	r0, [r7, #0x4]
; 	return thread->base.preempt <= _PREEMPT_THRESHOLD;
 8013706: 687b         	ldr	r3, [r7, #0x4]
 8013708: 89db         	ldrh	r3, [r3, #0xe]
 801370a: 2b7f         	cmp	r3, #0x7f
 801370c: bf94         	ite	ls
 801370e: 2301         	movls	r3, #0x1
 8013710: 2300         	movhi	r3, #0x0
 8013712: b2db         	uxtb	r3, r3
; }
 8013714: 4618         	mov	r0, r3
 8013716: 370c         	adds	r7, #0xc
 8013718: 46bd         	mov	sp, r7
 801371a: bc80         	pop	{r7}
 801371c: 4770         	bx	lr

0801371e <thread_is_metairq>:
; {
 801371e: b480         	push	{r7}
 8013720: b083         	sub	sp, #0xc
 8013722: af00         	add	r7, sp, #0x0
 8013724: 6078         	str	r0, [r7, #0x4]
; 	return 0;
 8013726: 2300         	movs	r3, #0x0
; }
 8013728: 4618         	mov	r0, r3
 801372a: 370c         	adds	r7, #0xc
 801372c: 46bd         	mov	sp, r7
 801372e: bc80         	pop	{r7}
 8013730: 4770         	bx	lr

08013732 <z_is_thread_suspended>:
; {
 8013732: b480         	push	{r7}
 8013734: b083         	sub	sp, #0xc
 8013736: af00         	add	r7, sp, #0x0
 8013738: 6078         	str	r0, [r7, #0x4]
; 	return (thread->base.thread_state & _THREAD_SUSPENDED) != 0U;
 801373a: 687b         	ldr	r3, [r7, #0x4]
 801373c: 7b5b         	ldrb	r3, [r3, #0xd]
 801373e: f003 0310    	and	r3, r3, #0x10
 8013742: 2b00         	cmp	r3, #0x0
 8013744: bf14         	ite	ne
 8013746: 2301         	movne	r3, #0x1
 8013748: 2300         	moveq	r3, #0x0
 801374a: b2db         	uxtb	r3, r3
; }
 801374c: 4618         	mov	r0, r3
 801374e: 370c         	adds	r7, #0xc
 8013750: 46bd         	mov	sp, r7
 8013752: bc80         	pop	{r7}
 8013754: 4770         	bx	lr

08013756 <z_is_thread_prevented_from_running>:
; {
 8013756: b480         	push	{r7}
 8013758: b085         	sub	sp, #0x14
 801375a: af00         	add	r7, sp, #0x0
 801375c: 6078         	str	r0, [r7, #0x4]
; 	uint8_t state = thread->base.thread_state;
 801375e: 687b         	ldr	r3, [r7, #0x4]
 8013760: 7b5b         	ldrb	r3, [r3, #0xd]
 8013762: 73fb         	strb	r3, [r7, #0xf]
; 	return (state & (_THREAD_PENDING | _THREAD_DEAD |
 8013764: 7bfb         	ldrb	r3, [r7, #0xf]
 8013766: f003 031b    	and	r3, r3, #0x1b
; 			 _THREAD_DUMMY | _THREAD_SUSPENDED)) != 0U;
 801376a: 2b00         	cmp	r3, #0x0
 801376c: bf14         	ite	ne
 801376e: 2301         	movne	r3, #0x1
 8013770: 2300         	moveq	r3, #0x0
 8013772: b2db         	uxtb	r3, r3
; }
 8013774: 4618         	mov	r0, r3
 8013776: 3714         	adds	r7, #0x14
 8013778: 46bd         	mov	sp, r7
 801377a: bc80         	pop	{r7}
 801377c: 4770         	bx	lr

0801377e <z_is_thread_timeout_active>:
; {
 801377e: b580         	push	{r7, lr}
 8013780: b082         	sub	sp, #0x8
 8013782: af00         	add	r7, sp, #0x0
 8013784: 6078         	str	r0, [r7, #0x4]
; 	return !z_is_inactive_timeout(&thread->base.timeout);
 8013786: 687b         	ldr	r3, [r7, #0x4]
 8013788: 3318         	adds	r3, #0x18
 801378a: 4618         	mov	r0, r3
 801378c: f7ff ff91    	bl	0x80136b2 <z_is_inactive_timeout> @ imm = #-0xde
 8013790: 4603         	mov	r3, r0
 8013792: 2b00         	cmp	r3, #0x0
 8013794: bf14         	ite	ne
 8013796: 2301         	movne	r3, #0x1
 8013798: 2300         	moveq	r3, #0x0
 801379a: b2db         	uxtb	r3, r3
 801379c: f083 0301    	eor	r3, r3, #0x1
 80137a0: b2db         	uxtb	r3, r3
 80137a2: f003 0301    	and	r3, r3, #0x1
 80137a6: b2db         	uxtb	r3, r3
; }
 80137a8: 4618         	mov	r0, r3
 80137aa: 3708         	adds	r7, #0x8
 80137ac: 46bd         	mov	sp, r7
 80137ae: bd80         	pop	{r7, pc}

080137b0 <z_is_thread_ready>:
; {
 80137b0: b580         	push	{r7, lr}
 80137b2: b082         	sub	sp, #0x8
 80137b4: af00         	add	r7, sp, #0x0
 80137b6: 6078         	str	r0, [r7, #0x4]
; 	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
 80137b8: 6878         	ldr	r0, [r7, #0x4]
 80137ba: f7ff ffcc    	bl	0x8013756 <z_is_thread_prevented_from_running> @ imm = #-0x68
 80137be: 4603         	mov	r3, r0
 80137c0: f083 0301    	eor	r3, r3, #0x1
 80137c4: b2db         	uxtb	r3, r3
 80137c6: 2b00         	cmp	r3, #0x0
 80137c8: d00a         	beq	0x80137e0 <z_is_thread_ready+0x30> @ imm = #0x14
; 		 z_is_thread_timeout_active(thread));
 80137ca: 6878         	ldr	r0, [r7, #0x4]
 80137cc: f7ff ffd7    	bl	0x801377e <z_is_thread_timeout_active> @ imm = #-0x52
 80137d0: 4603         	mov	r3, r0
; 	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
 80137d2: f083 0301    	eor	r3, r3, #0x1
 80137d6: b2db         	uxtb	r3, r3
 80137d8: 2b00         	cmp	r3, #0x0
 80137da: d001         	beq	0x80137e0 <z_is_thread_ready+0x30> @ imm = #0x2
 80137dc: 2301         	movs	r3, #0x1
 80137de: e000         	b	0x80137e2 <z_is_thread_ready+0x32> @ imm = #0x0
 80137e0: 2300         	movs	r3, #0x0
 80137e2: f003 0301    	and	r3, r3, #0x1
 80137e6: b2db         	uxtb	r3, r3
; }
 80137e8: 4618         	mov	r0, r3
 80137ea: 3708         	adds	r7, #0x8
 80137ec: 46bd         	mov	sp, r7
 80137ee: bd80         	pop	{r7, pc}

080137f0 <z_is_thread_state_set>:
; {
 80137f0: b480         	push	{r7}
 80137f2: b083         	sub	sp, #0xc
 80137f4: af00         	add	r7, sp, #0x0
 80137f6: 6078         	str	r0, [r7, #0x4]
 80137f8: 6039         	str	r1, [r7]
; 	return (thread->base.thread_state & state) != 0U;
 80137fa: 687b         	ldr	r3, [r7, #0x4]
 80137fc: 7b5b         	ldrb	r3, [r3, #0xd]
 80137fe: 461a         	mov	r2, r3
 8013800: 683b         	ldr	r3, [r7]
 8013802: 4013         	ands	r3, r2
 8013804: 2b00         	cmp	r3, #0x0
 8013806: bf14         	ite	ne
 8013808: 2301         	movne	r3, #0x1
 801380a: 2300         	moveq	r3, #0x0
 801380c: b2db         	uxtb	r3, r3
; }
 801380e: 4618         	mov	r0, r3
 8013810: 370c         	adds	r7, #0xc
 8013812: 46bd         	mov	sp, r7
 8013814: bc80         	pop	{r7}
 8013816: 4770         	bx	lr

08013818 <z_is_thread_queued>:
; {
 8013818: b580         	push	{r7, lr}
 801381a: b082         	sub	sp, #0x8
 801381c: af00         	add	r7, sp, #0x0
 801381e: 6078         	str	r0, [r7, #0x4]
; 	return z_is_thread_state_set(thread, _THREAD_QUEUED);
 8013820: 2180         	movs	r1, #0x80
 8013822: 6878         	ldr	r0, [r7, #0x4]
 8013824: f7ff ffe4    	bl	0x80137f0 <z_is_thread_state_set> @ imm = #-0x38
 8013828: 4603         	mov	r3, r0
; }
 801382a: 4618         	mov	r0, r3
 801382c: 3708         	adds	r7, #0x8
 801382e: 46bd         	mov	sp, r7
 8013830: bd80         	pop	{r7, pc}

08013832 <z_mark_thread_as_suspended>:
; {
 8013832: b480         	push	{r7}
 8013834: b083         	sub	sp, #0xc
 8013836: af00         	add	r7, sp, #0x0
 8013838: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state |= _THREAD_SUSPENDED;
 801383a: 687b         	ldr	r3, [r7, #0x4]
 801383c: 7b5b         	ldrb	r3, [r3, #0xd]
 801383e: f043 0310    	orr	r3, r3, #0x10
 8013842: b2da         	uxtb	r2, r3
 8013844: 687b         	ldr	r3, [r7, #0x4]
 8013846: 735a         	strb	r2, [r3, #0xd]
; }
 8013848: bf00         	nop
 801384a: 370c         	adds	r7, #0xc
 801384c: 46bd         	mov	sp, r7
 801384e: bc80         	pop	{r7}
 8013850: 4770         	bx	lr

08013852 <z_mark_thread_as_not_suspended>:
; {
 8013852: b480         	push	{r7}
 8013854: b083         	sub	sp, #0xc
 8013856: af00         	add	r7, sp, #0x0
 8013858: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state &= ~_THREAD_SUSPENDED;
 801385a: 687b         	ldr	r3, [r7, #0x4]
 801385c: 7b5b         	ldrb	r3, [r3, #0xd]
 801385e: f023 0310    	bic	r3, r3, #0x10
 8013862: b2da         	uxtb	r2, r3
 8013864: 687b         	ldr	r3, [r7, #0x4]
 8013866: 735a         	strb	r2, [r3, #0xd]
; }
 8013868: bf00         	nop
 801386a: 370c         	adds	r7, #0xc
 801386c: 46bd         	mov	sp, r7
 801386e: bc80         	pop	{r7}
 8013870: 4770         	bx	lr

08013872 <z_mark_thread_as_pending>:
; {
 8013872: b480         	push	{r7}
 8013874: b083         	sub	sp, #0xc
 8013876: af00         	add	r7, sp, #0x0
 8013878: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state |= _THREAD_PENDING;
 801387a: 687b         	ldr	r3, [r7, #0x4]
 801387c: 7b5b         	ldrb	r3, [r3, #0xd]
 801387e: f043 0302    	orr	r3, r3, #0x2
 8013882: b2da         	uxtb	r2, r3
 8013884: 687b         	ldr	r3, [r7, #0x4]
 8013886: 735a         	strb	r2, [r3, #0xd]
; }
 8013888: bf00         	nop
 801388a: 370c         	adds	r7, #0xc
 801388c: 46bd         	mov	sp, r7
 801388e: bc80         	pop	{r7}
 8013890: 4770         	bx	lr

08013892 <z_mark_thread_as_not_pending>:
; {
 8013892: b480         	push	{r7}
 8013894: b083         	sub	sp, #0xc
 8013896: af00         	add	r7, sp, #0x0
 8013898: 6078         	str	r0, [r7, #0x4]
; 	thread->base.thread_state &= ~_THREAD_PENDING;
 801389a: 687b         	ldr	r3, [r7, #0x4]
 801389c: 7b5b         	ldrb	r3, [r3, #0xd]
 801389e: f023 0302    	bic	r3, r3, #0x2
 80138a2: b2da         	uxtb	r2, r3
 80138a4: 687b         	ldr	r3, [r7, #0x4]
 80138a6: 735a         	strb	r2, [r3, #0xd]
; }
 80138a8: bf00         	nop
 80138aa: 370c         	adds	r7, #0xc
 80138ac: 46bd         	mov	sp, r7
 80138ae: bc80         	pop	{r7}
 80138b0: 4770         	bx	lr

080138b2 <z_is_thread_essential>:
; {
 80138b2: b480         	push	{r7}
 80138b4: b083         	sub	sp, #0xc
 80138b6: af00         	add	r7, sp, #0x0
 80138b8: 6078         	str	r0, [r7, #0x4]
; 	return (thread->base.user_options & K_ESSENTIAL) == K_ESSENTIAL;
 80138ba: 687b         	ldr	r3, [r7, #0x4]
 80138bc: 7b1b         	ldrb	r3, [r3, #0xc]
 80138be: f003 0301    	and	r3, r3, #0x1
 80138c2: 2b00         	cmp	r3, #0x0
 80138c4: bf14         	ite	ne
 80138c6: 2301         	movne	r3, #0x1
 80138c8: 2300         	moveq	r3, #0x0
 80138ca: b2db         	uxtb	r3, r3
; }
 80138cc: 4618         	mov	r0, r3
 80138ce: 370c         	adds	r7, #0xc
 80138d0: 46bd         	mov	sp, r7
 80138d2: bc80         	pop	{r7}
 80138d4: 4770         	bx	lr

080138d6 <z_reschedule_unlocked>:
; {
 80138d6: b580         	push	{r7, lr}
 80138d8: b084         	sub	sp, #0x10
 80138da: af00         	add	r7, sp, #0x0
;   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80138dc: f3ef 8311    	mrs	r3, basepri
 80138e0: 60fb         	str	r3, [r7, #0xc]
;   return(result);
 80138e2: 68fb         	ldr	r3, [r7, #0xc]
; 	key = __get_BASEPRI();
 80138e4: 60bb         	str	r3, [r7, #0x8]
 80138e6: 2310         	movs	r3, #0x10
 80138e8: 607b         	str	r3, [r7, #0x4]
;   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 80138ea: 687b         	ldr	r3, [r7, #0x4]
 80138ec: f383 8812    	msr	basepri_max, r3
; }
 80138f0: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 80138f2: f3bf 8f6f    	isb	sy
; }
 80138f6: bf00         	nop
; 	return key;
 80138f8: 68bb         	ldr	r3, [r7, #0x8]
; 	(void) z_reschedule_irqlock(arch_irq_lock());
 80138fa: 4618         	mov	r0, r3
 80138fc: f000 f9b0    	bl	0x8013c60 <z_reschedule_irqlock> @ imm = #0x360
; }
 8013900: bf00         	nop
 8013902: 3710         	adds	r7, #0x10
 8013904: 46bd         	mov	sp, r7
 8013906: bd80         	pop	{r7, pc}

08013908 <unpend_thread_no_timeout>:
; {
 8013908: b580         	push	{r7, lr}
 801390a: b086         	sub	sp, #0x18
 801390c: af00         	add	r7, sp, #0x0
 801390e: 6078         	str	r0, [r7, #0x4]
 8013910: 687b         	ldr	r3, [r7, #0x4]
 8013912: 60fb         	str	r3, [r7, #0xc]
; 	return thread->base.pended_on;
 8013914: 68fb         	ldr	r3, [r7, #0xc]
 8013916: 689b         	ldr	r3, [r3, #0x8]
 8013918: 617b         	str	r3, [r7, #0x14]
 801391a: 687b         	ldr	r3, [r7, #0x4]
 801391c: 613b         	str	r3, [r7, #0x10]
; 	sys_dlist_remove(&thread->base.qnode_dlist);
 801391e: 693b         	ldr	r3, [r7, #0x10]
 8013920: 4618         	mov	r0, r3
 8013922: f7ff fe9e    	bl	0x8013662 <sys_dlist_remove> @ imm = #-0x2c4
; }
 8013926: bf00         	nop
; 	z_mark_thread_as_not_pending(thread);
 8013928: 6878         	ldr	r0, [r7, #0x4]
 801392a: f7ff ffb2    	bl	0x8013892 <z_mark_thread_as_not_pending> @ imm = #-0x9c
; 	thread->base.pended_on = NULL;
 801392e: 687b         	ldr	r3, [r7, #0x4]
 8013930: 2200         	movs	r2, #0x0
 8013932: 609a         	str	r2, [r3, #0x8]
; }
 8013934: bf00         	nop
 8013936: 3718         	adds	r7, #0x18
 8013938: 46bd         	mov	sp, r7
 801393a: bd80         	pop	{r7, pc}

0801393c <z_waitq_head>:
; {
 801393c: b580         	push	{r7, lr}
 801393e: b082         	sub	sp, #0x8
 8013940: af00         	add	r7, sp, #0x0
 8013942: 6078         	str	r0, [r7, #0x4]
; 	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
 8013944: 687b         	ldr	r3, [r7, #0x4]
 8013946: 4618         	mov	r0, r3
 8013948: f7ff fe21    	bl	0x801358e <sys_dlist_peek_head> @ imm = #-0x3be
 801394c: 4603         	mov	r3, r0
; }
 801394e: 4618         	mov	r0, r3
 8013950: 3708         	adds	r7, #0x8
 8013952: 46bd         	mov	sp, r7
 8013954: bd80         	pop	{r7, pc}

08013956 <z_swap_irqlock>:
; {
 8013956: b580         	push	{r7, lr}
 8013958: b084         	sub	sp, #0x10
 801395a: af00         	add	r7, sp, #0x0
 801395c: 6078         	str	r0, [r7, #0x4]
; 	ret = arch_swap(key);
 801395e: 6878         	ldr	r0, [r7, #0x4]
 8013960: f7ef fb3c    	bl	0x8002fdc <arch_swap>   @ imm = #-0x10988
 8013964: 60f8         	str	r0, [r7, #0xc]
; 	return ret;
 8013966: 68fb         	ldr	r3, [r7, #0xc]
; }
 8013968: 4618         	mov	r0, r3
 801396a: 3710         	adds	r7, #0x10
 801396c: 46bd         	mov	sp, r7
 801396e: bd80         	pop	{r7, pc}

08013970 <z_log_msg_runtime_create>:
; {
 8013970: b580         	push	{r7, lr}
 8013972: b08a         	sub	sp, #0x28
 8013974: af04         	add	r7, sp, #0x10
 8013976: 60b9         	str	r1, [r7, #0x8]
 8013978: 607b         	str	r3, [r7, #0x4]
 801397a: 4603         	mov	r3, r0
 801397c: 73fb         	strb	r3, [r7, #0xf]
 801397e: 4613         	mov	r3, r2
 8013980: 73bb         	strb	r3, [r7, #0xe]
; 	va_start(ap, fmt);
 8013982: f107 032c    	add.w	r3, r7, #0x2c
 8013986: 617b         	str	r3, [r7, #0x14]
; 	z_log_msg_runtime_vcreate(domain_id, source, level,
 8013988: 7bba         	ldrb	r2, [r7, #0xe]
 801398a: 7bf8         	ldrb	r0, [r7, #0xf]
 801398c: 697b         	ldr	r3, [r7, #0x14]
 801398e: 9303         	str	r3, [sp, #0xc]
 8013990: 6abb         	ldr	r3, [r7, #0x28]
 8013992: 9302         	str	r3, [sp, #0x8]
 8013994: 6a7b         	ldr	r3, [r7, #0x24]
 8013996: 9301         	str	r3, [sp, #0x4]
 8013998: 6a3b         	ldr	r3, [r7, #0x20]
 801399a: 9300         	str	r3, [sp]
 801399c: 687b         	ldr	r3, [r7, #0x4]
 801399e: 68b9         	ldr	r1, [r7, #0x8]
 80139a0: f7ed ff50    	bl	0x8001844 <z_log_msg_runtime_vcreate> @ imm = #-0x12160
; }
 80139a4: bf00         	nop
 80139a6: 3718         	adds	r7, #0x18
 80139a8: 46bd         	mov	sp, r7
 80139aa: bd80         	pop	{r7, pc}

080139ac <z_sched_prio_cmp>:
; {
 80139ac: b480         	push	{r7}
 80139ae: b085         	sub	sp, #0x14
 80139b0: af00         	add	r7, sp, #0x0
 80139b2: 6078         	str	r0, [r7, #0x4]
 80139b4: 6039         	str	r1, [r7]
; 	int32_t b1 = thread_1->base.prio;
 80139b6: 687b         	ldr	r3, [r7, #0x4]
 80139b8: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 80139bc: 60fb         	str	r3, [r7, #0xc]
; 	int32_t b2 = thread_2->base.prio;
 80139be: 683b         	ldr	r3, [r7]
 80139c0: f993 300e    	ldrsb.w	r3, [r3, #0xe]
 80139c4: 60bb         	str	r3, [r7, #0x8]
; 	if (b1 != b2) {
 80139c6: 68fa         	ldr	r2, [r7, #0xc]
 80139c8: 68bb         	ldr	r3, [r7, #0x8]
 80139ca: 429a         	cmp	r2, r3
 80139cc: d003         	beq	0x80139d6 <z_sched_prio_cmp+0x2a> @ imm = #0x6
; 		return b2 - b1;
 80139ce: 68ba         	ldr	r2, [r7, #0x8]
 80139d0: 68fb         	ldr	r3, [r7, #0xc]
 80139d2: 1ad3         	subs	r3, r2, r3
 80139d4: e000         	b	0x80139d8 <z_sched_prio_cmp+0x2c> @ imm = #0x0
; 	return 0;
 80139d6: 2300         	movs	r3, #0x0
; }
 80139d8: 4618         	mov	r0, r3
 80139da: 3714         	adds	r7, #0x14
 80139dc: 46bd         	mov	sp, r7
 80139de: bc80         	pop	{r7}
 80139e0: 4770         	bx	lr

080139e2 <should_queue_thread>:
; {
 80139e2: b480         	push	{r7}
 80139e4: b083         	sub	sp, #0xc
 80139e6: af00         	add	r7, sp, #0x0
 80139e8: 6078         	str	r0, [r7, #0x4]
; 	return !IS_ENABLED(CONFIG_SMP) || (thread != arch_current_thread());
 80139ea: 2301         	movs	r3, #0x1
; }
 80139ec: 4618         	mov	r0, r3
 80139ee: 370c         	adds	r7, #0xc
 80139f0: 46bd         	mov	sp, r7
 80139f2: bc80         	pop	{r7}
 80139f4: 4770         	bx	lr

080139f6 <is_aborting>:
; {
 80139f6: b480         	push	{r7}
 80139f8: b083         	sub	sp, #0xc
 80139fa: af00         	add	r7, sp, #0x0
 80139fc: 6078         	str	r0, [r7, #0x4]
; 	return (thread->base.thread_state & _THREAD_ABORTING) != 0U;
 80139fe: 687b         	ldr	r3, [r7, #0x4]
 8013a00: 7b5b         	ldrb	r3, [r3, #0xd]
 8013a02: f003 0320    	and	r3, r3, #0x20
 8013a06: 2b00         	cmp	r3, #0x0
 8013a08: bf14         	ite	ne
 8013a0a: 2301         	movne	r3, #0x1
 8013a0c: 2300         	moveq	r3, #0x0
 8013a0e: b2db         	uxtb	r3, r3
; }
 8013a10: 4618         	mov	r0, r3
 8013a12: 370c         	adds	r7, #0xc
 8013a14: 46bd         	mov	sp, r7
 8013a16: bc80         	pop	{r7}
 8013a18: 4770         	bx	lr

08013a1a <is_halting>:
; {
 8013a1a: b480         	push	{r7}
 8013a1c: b083         	sub	sp, #0xc
 8013a1e: af00         	add	r7, sp, #0x0
 8013a20: 6078         	str	r0, [r7, #0x4]
; 	return (thread->base.thread_state &
 8013a22: 687b         	ldr	r3, [r7, #0x4]
 8013a24: 7b5b         	ldrb	r3, [r3, #0xd]
 8013a26: f003 0360    	and	r3, r3, #0x60
; 		(_THREAD_ABORTING | _THREAD_SUSPENDING)) != 0U;
 8013a2a: 2b00         	cmp	r3, #0x0
 8013a2c: bf14         	ite	ne
 8013a2e: 2301         	movne	r3, #0x1
 8013a30: 2300         	moveq	r3, #0x0
 8013a32: b2db         	uxtb	r3, r3
; }
 8013a34: 4618         	mov	r0, r3
 8013a36: 370c         	adds	r7, #0xc
 8013a38: 46bd         	mov	sp, r7
 8013a3a: bc80         	pop	{r7}
 8013a3c: 4770         	bx	lr

08013a3e <clear_halting>:
; {
 8013a3e: b480         	push	{r7}
 8013a40: b083         	sub	sp, #0xc
 8013a42: af00         	add	r7, sp, #0x0
 8013a44: 6078         	str	r0, [r7, #0x4]
;   __ASM volatile ("dmb 0xF":::"memory");
 8013a46: f3bf 8f5f    	dmb	sy
; }
 8013a4a: bf00         	nop
; }
 8013a4c: bf00         	nop
; }
 8013a4e: bf00         	nop
; 	thread->base.thread_state &= ~(_THREAD_ABORTING | _THREAD_SUSPENDING);
 8013a50: 687b         	ldr	r3, [r7, #0x4]
 8013a52: 7b5b         	ldrb	r3, [r3, #0xd]
 8013a54: f023 0360    	bic	r3, r3, #0x60
 8013a58: b2da         	uxtb	r2, r3
 8013a5a: 687b         	ldr	r3, [r7, #0x4]
 8013a5c: 735a         	strb	r2, [r3, #0xd]
; }
 8013a5e: bf00         	nop
 8013a60: 370c         	adds	r7, #0xc
 8013a62: 46bd         	mov	sp, r7
 8013a64: bc80         	pop	{r7}
 8013a66: 4770         	bx	lr

08013a68 <update_metairq_preempt>:
; {
 8013a68: b480         	push	{r7}
 8013a6a: b083         	sub	sp, #0xc
 8013a6c: af00         	add	r7, sp, #0x0
 8013a6e: 6078         	str	r0, [r7, #0x4]
; }
 8013a70: bf00         	nop
 8013a72: 370c         	adds	r7, #0xc
 8013a74: 46bd         	mov	sp, r7
 8013a76: bc80         	pop	{r7}
 8013a78: 4770         	bx	lr

08013a7a <thread_active_elsewhere>:
; {
 8013a7a: b480         	push	{r7}
 8013a7c: b083         	sub	sp, #0xc
 8013a7e: af00         	add	r7, sp, #0x0
 8013a80: 6078         	str	r0, [r7, #0x4]
; 	return NULL;
 8013a82: 2300         	movs	r3, #0x0
; }
 8013a84: 4618         	mov	r0, r3
 8013a86: 370c         	adds	r7, #0xc
 8013a88: 46bd         	mov	sp, r7
 8013a8a: bc80         	pop	{r7}
 8013a8c: 4770         	bx	lr

08013a8e <add_to_waitq_locked>:
; {
 8013a8e: b580         	push	{r7, lr}
 8013a90: b086         	sub	sp, #0x18
 8013a92: af00         	add	r7, sp, #0x0
 8013a94: 6078         	str	r0, [r7, #0x4]
 8013a96: 6039         	str	r1, [r7]
; 	unready_thread(thread);
 8013a98: 6878         	ldr	r0, [r7, #0x4]
 8013a9a: f7f7 f995    	bl	0x800adc8 <unready_thread> @ imm = #-0x8cd6
; 	z_mark_thread_as_pending(thread);
 8013a9e: 6878         	ldr	r0, [r7, #0x4]
 8013aa0: f7ff fee7    	bl	0x8013872 <z_mark_thread_as_pending> @ imm = #-0x232
; 	if (wait_q != NULL) {
 8013aa4: 683b         	ldr	r3, [r7]
 8013aa6: 2b00         	cmp	r3, #0x0
 8013aa8: d041         	beq	0x8013b2e <add_to_waitq_locked+0xa0> @ imm = #0x82
; 		thread->base.pended_on = wait_q;
 8013aaa: 687b         	ldr	r3, [r7, #0x4]
 8013aac: 683a         	ldr	r2, [r7]
 8013aae: 609a         	str	r2, [r3, #0x8]
; 		_priq_wait_add(&wait_q->waitq, thread);
 8013ab0: 683b         	ldr	r3, [r7]
 8013ab2: 617b         	str	r3, [r7, #0x14]
 8013ab4: 687b         	ldr	r3, [r7, #0x4]
 8013ab6: 613b         	str	r3, [r7, #0x10]
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 8013ab8: 6978         	ldr	r0, [r7, #0x14]
 8013aba: f7ff fd68    	bl	0x801358e <sys_dlist_peek_head> @ imm = #-0x530
 8013abe: 4603         	mov	r3, r0
 8013ac0: 2b00         	cmp	r3, #0x0
 8013ac2: d004         	beq	0x8013ace <add_to_waitq_locked+0x40> @ imm = #0x8
 8013ac4: 6978         	ldr	r0, [r7, #0x14]
 8013ac6: f7ff fd62    	bl	0x801358e <sys_dlist_peek_head> @ imm = #-0x53c
 8013aca: 4603         	mov	r3, r0
 8013acc: e000         	b	0x8013ad0 <add_to_waitq_locked+0x42> @ imm = #0x0
 8013ace: 2300         	movs	r3, #0x0
 8013ad0: 60fb         	str	r3, [r7, #0xc]
 8013ad2: e024         	b	0x8013b1e <add_to_waitq_locked+0x90> @ imm = #0x48
; 		if (z_sched_prio_cmp(thread, t) > 0) {
 8013ad4: 68f9         	ldr	r1, [r7, #0xc]
 8013ad6: 6938         	ldr	r0, [r7, #0x10]
 8013ad8: f7ff ff68    	bl	0x80139ac <z_sched_prio_cmp> @ imm = #-0x130
 8013adc: 4603         	mov	r3, r0
 8013ade: 2b00         	cmp	r3, #0x0
 8013ae0: dd07         	ble	0x8013af2 <add_to_waitq_locked+0x64> @ imm = #0xe
; 			sys_dlist_insert(&t->base.qnode_dlist,
 8013ae2: 68fb         	ldr	r3, [r7, #0xc]
 8013ae4: 693a         	ldr	r2, [r7, #0x10]
 8013ae6: 4611         	mov	r1, r2
 8013ae8: 4618         	mov	r0, r3
 8013aea: f7ff fda1    	bl	0x8013630 <sys_dlist_insert> @ imm = #-0x4be
; 			return;
 8013aee: bf00         	nop
; }
 8013af0: e01d         	b	0x8013b2e <add_to_waitq_locked+0xa0> @ imm = #0x3a
; 	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 8013af2: 68fb         	ldr	r3, [r7, #0xc]
 8013af4: 2b00         	cmp	r3, #0x0
 8013af6: d010         	beq	0x8013b1a <add_to_waitq_locked+0x8c> @ imm = #0x20
 8013af8: 68fb         	ldr	r3, [r7, #0xc]
 8013afa: 4619         	mov	r1, r3
 8013afc: 6978         	ldr	r0, [r7, #0x14]
 8013afe: f7ff fd6b    	bl	0x80135d8 <sys_dlist_peek_next> @ imm = #-0x52a
 8013b02: 4603         	mov	r3, r0
 8013b04: 2b00         	cmp	r3, #0x0
 8013b06: d006         	beq	0x8013b16 <add_to_waitq_locked+0x88> @ imm = #0xc
 8013b08: 68fb         	ldr	r3, [r7, #0xc]
 8013b0a: 4619         	mov	r1, r3
 8013b0c: 6978         	ldr	r0, [r7, #0x14]
 8013b0e: f7ff fd63    	bl	0x80135d8 <sys_dlist_peek_next> @ imm = #-0x53a
 8013b12: 4603         	mov	r3, r0
 8013b14: e002         	b	0x8013b1c <add_to_waitq_locked+0x8e> @ imm = #0x4
 8013b16: 2300         	movs	r3, #0x0
 8013b18: e000         	b	0x8013b1c <add_to_waitq_locked+0x8e> @ imm = #0x0
 8013b1a: 2300         	movs	r3, #0x0
 8013b1c: 60fb         	str	r3, [r7, #0xc]
 8013b1e: 68fb         	ldr	r3, [r7, #0xc]
 8013b20: 2b00         	cmp	r3, #0x0
 8013b22: d1d7         	bne	0x8013ad4 <add_to_waitq_locked+0x46> @ imm = #-0x52
; 	sys_dlist_append(pq, &thread->base.qnode_dlist);
 8013b24: 693b         	ldr	r3, [r7, #0x10]
 8013b26: 4619         	mov	r1, r3
 8013b28: 6978         	ldr	r0, [r7, #0x14]
 8013b2a: f7ff fd68    	bl	0x80135fe <sys_dlist_append> @ imm = #-0x530
; }
 8013b2e: bf00         	nop
 8013b30: 3718         	adds	r7, #0x18
 8013b32: 46bd         	mov	sp, r7
 8013b34: bd80         	pop	{r7, pc}

08013b36 <add_thread_timeout>:
; {
 8013b36: b580         	push	{r7, lr}
 8013b38: b084         	sub	sp, #0x10
 8013b3a: af00         	add	r7, sp, #0x0
 8013b3c: 60f8         	str	r0, [r7, #0xc]
 8013b3e: e9c7 2300    	strd	r2, r3, [r7]
; 	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 8013b42: e9d7 2300    	ldrd	r2, r3, [r7]
 8013b46: f04f 30ff    	mov.w	r0, #0xffffffff
 8013b4a: f04f 31ff    	mov.w	r1, #0xffffffff
 8013b4e: 428b         	cmp	r3, r1
 8013b50: bf08         	it	eq
 8013b52: 4282         	cmpeq	r2, r0
 8013b54: d004         	beq	0x8013b60 <add_thread_timeout+0x2a> @ imm = #0x8
; 		z_add_thread_timeout(thread, timeout);
 8013b56: e9d7 2300    	ldrd	r2, r3, [r7]
 8013b5a: 68f8         	ldr	r0, [r7, #0xc]
 8013b5c: f7f6 fc84    	bl	0x800a468 <z_add_thread_timeout> @ imm = #-0x96f8
; }
 8013b60: bf00         	nop
 8013b62: 3710         	adds	r7, #0x10
 8013b64: 46bd         	mov	sp, r7
 8013b66: bd80         	pop	{r7, pc}

08013b68 <pend_locked>:
; {
 8013b68: b580         	push	{r7, lr}
 8013b6a: b084         	sub	sp, #0x10
 8013b6c: af00         	add	r7, sp, #0x0
 8013b6e: 60f8         	str	r0, [r7, #0xc]
 8013b70: 60b9         	str	r1, [r7, #0x8]
 8013b72: e9c7 2300    	strd	r2, r3, [r7]
; 	add_to_waitq_locked(thread, wait_q);
 8013b76: 68b9         	ldr	r1, [r7, #0x8]
 8013b78: 68f8         	ldr	r0, [r7, #0xc]
 8013b7a: f7ff ff88    	bl	0x8013a8e <add_to_waitq_locked> @ imm = #-0xf0
; 	add_thread_timeout(thread, timeout);
 8013b7e: e9d7 2300    	ldrd	r2, r3, [r7]
 8013b82: 68f8         	ldr	r0, [r7, #0xc]
 8013b84: f7ff ffd7    	bl	0x8013b36 <add_thread_timeout> @ imm = #-0x52
; }
 8013b88: bf00         	nop
 8013b8a: 3710         	adds	r7, #0x10
 8013b8c: 46bd         	mov	sp, r7
 8013b8e: bd80         	pop	{r7, pc}

08013b90 <z_thread_timeout>:
; {
 8013b90: b580         	push	{r7, lr}
 8013b92: b084         	sub	sp, #0x10
 8013b94: af00         	add	r7, sp, #0x0
 8013b96: 6078         	str	r0, [r7, #0x4]
; 	struct k_thread *thread = CONTAINER_OF(timeout,
 8013b98: 687b         	ldr	r3, [r7, #0x4]
 8013b9a: 3b18         	subs	r3, #0x18
 8013b9c: 60fb         	str	r3, [r7, #0xc]
; 	z_sched_wake_thread(thread, true);
 8013b9e: 2101         	movs	r1, #0x1
 8013ba0: 68f8         	ldr	r0, [r7, #0xc]
 8013ba2: f7f7 f9af    	bl	0x800af04 <z_sched_wake_thread> @ imm = #-0x8ca2
; }
 8013ba6: bf00         	nop
 8013ba8: 3710         	adds	r7, #0x10
 8013baa: 46bd         	mov	sp, r7
 8013bac: bd80         	pop	{r7, pc}

08013bae <resched>:
; {
 8013bae: b480         	push	{r7}
 8013bb0: b085         	sub	sp, #0x14
 8013bb2: af00         	add	r7, sp, #0x0
 8013bb4: 6078         	str	r0, [r7, #0x4]
 8013bb6: 687b         	ldr	r3, [r7, #0x4]
 8013bb8: 60fb         	str	r3, [r7, #0xc]
; 	return key == 0U;
 8013bba: 68fb         	ldr	r3, [r7, #0xc]
 8013bbc: 2b00         	cmp	r3, #0x0
 8013bbe: bf0c         	ite	eq
 8013bc0: 2301         	moveq	r3, #0x1
 8013bc2: 2300         	movne	r3, #0x0
 8013bc4: b2db         	uxtb	r3, r3
; 	return arch_irq_unlocked(key) && !arch_is_in_isr();
 8013bc6: 2b00         	cmp	r3, #0x0
 8013bc8: d00f         	beq	0x8013bea <resched+0x3c> @ imm = #0x1e
;   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8013bca: f3ef 8305    	mrs	r3, ipsr
 8013bce: 60bb         	str	r3, [r7, #0x8]
;   return(result);
 8013bd0: 68bb         	ldr	r3, [r7, #0x8]
; 	return (__get_IPSR()) ? (true) : (false);
 8013bd2: 2b00         	cmp	r3, #0x0
 8013bd4: bf14         	ite	ne
 8013bd6: 2301         	movne	r3, #0x1
 8013bd8: 2300         	moveq	r3, #0x0
 8013bda: b2db         	uxtb	r3, r3
; 	return arch_irq_unlocked(key) && !arch_is_in_isr();
 8013bdc: f083 0301    	eor	r3, r3, #0x1
 8013be0: b2db         	uxtb	r3, r3
 8013be2: 2b00         	cmp	r3, #0x0
 8013be4: d001         	beq	0x8013bea <resched+0x3c> @ imm = #0x2
 8013be6: 2301         	movs	r3, #0x1
 8013be8: e000         	b	0x8013bec <resched+0x3e> @ imm = #0x0
 8013bea: 2300         	movs	r3, #0x0
 8013bec: f003 0301    	and	r3, r3, #0x1
 8013bf0: b2db         	uxtb	r3, r3
; }
 8013bf2: 4618         	mov	r0, r3
 8013bf4: 3714         	adds	r7, #0x14
 8013bf6: 46bd         	mov	sp, r7
 8013bf8: bc80         	pop	{r7}
 8013bfa: 4770         	bx	lr

08013bfc <z_reschedule>:
; {
 8013bfc: b580         	push	{r7, lr}
 8013bfe: b08a         	sub	sp, #0x28
 8013c00: af00         	add	r7, sp, #0x0
 8013c02: 6078         	str	r0, [r7, #0x4]
 8013c04: 6039         	str	r1, [r7]
; 	if (resched(key.key) && need_swap()) {
 8013c06: 683b         	ldr	r3, [r7]
 8013c08: 4618         	mov	r0, r3
 8013c0a: f7ff ffd0    	bl	0x8013bae <resched>     @ imm = #-0x60
 8013c0e: 4603         	mov	r3, r0
 8013c10: 2b00         	cmp	r3, #0x0
 8013c12: d010         	beq	0x8013c36 <z_reschedule+0x3a> @ imm = #0x20
 8013c14: f7f7 fb78    	bl	0x800b308 <need_swap>   @ imm = #-0x8910
 8013c18: 4603         	mov	r3, r0
 8013c1a: 2b00         	cmp	r3, #0x0
 8013c1c: d00b         	beq	0x8013c36 <z_reschedule+0x3a> @ imm = #0x16
 8013c1e: 687b         	ldr	r3, [r7, #0x4]
 8013c20: 627b         	str	r3, [r7, #0x24]
 8013c22: 683b         	ldr	r3, [r7]
 8013c24: 60fb         	str	r3, [r7, #0xc]
 8013c26: 6a7b         	ldr	r3, [r7, #0x24]
 8013c28: 623b         	str	r3, [r7, #0x20]
; }
 8013c2a: bf00         	nop
; 	return z_swap_irqlock(key.key);
 8013c2c: 68fb         	ldr	r3, [r7, #0xc]
 8013c2e: 4618         	mov	r0, r3
 8013c30: f7ff fe91    	bl	0x8013956 <z_swap_irqlock> @ imm = #-0x2de
; 		z_swap(lock, key);
 8013c34: e010         	b	0x8013c58 <z_reschedule+0x5c> @ imm = #0x20
 8013c36: 687b         	ldr	r3, [r7, #0x4]
 8013c38: 61fb         	str	r3, [r7, #0x1c]
 8013c3a: 683b         	ldr	r3, [r7]
 8013c3c: 613b         	str	r3, [r7, #0x10]
; 	arch_irq_unlock(key.key);
 8013c3e: 693b         	ldr	r3, [r7, #0x10]
 8013c40: 61bb         	str	r3, [r7, #0x18]
 8013c42: 69bb         	ldr	r3, [r7, #0x18]
 8013c44: 617b         	str	r3, [r7, #0x14]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8013c46: 697b         	ldr	r3, [r7, #0x14]
 8013c48: f383 8811    	msr	basepri, r3
; }
 8013c4c: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8013c4e: f3bf 8f6f    	isb	sy
; }
 8013c52: bf00         	nop
; }
 8013c54: bf00         	nop
; }
 8013c56: bf00         	nop
; }
 8013c58: bf00         	nop
 8013c5a: 3728         	adds	r7, #0x28
 8013c5c: 46bd         	mov	sp, r7
 8013c5e: bd80         	pop	{r7, pc}

08013c60 <z_reschedule_irqlock>:
; {
 8013c60: b580         	push	{r7, lr}
 8013c62: b084         	sub	sp, #0x10
 8013c64: af00         	add	r7, sp, #0x0
 8013c66: 6078         	str	r0, [r7, #0x4]
; 	if (resched(key) && need_swap()) {
 8013c68: 6878         	ldr	r0, [r7, #0x4]
 8013c6a: f7ff ffa0    	bl	0x8013bae <resched>     @ imm = #-0xc0
 8013c6e: 4603         	mov	r3, r0
 8013c70: 2b00         	cmp	r3, #0x0
 8013c72: d008         	beq	0x8013c86 <z_reschedule_irqlock+0x26> @ imm = #0x10
 8013c74: f7f7 fb48    	bl	0x800b308 <need_swap>   @ imm = #-0x8970
 8013c78: 4603         	mov	r3, r0
 8013c7a: 2b00         	cmp	r3, #0x0
 8013c7c: d003         	beq	0x8013c86 <z_reschedule_irqlock+0x26> @ imm = #0x6
; 		z_swap_irqlock(key);
 8013c7e: 6878         	ldr	r0, [r7, #0x4]
 8013c80: f7ff fe69    	bl	0x8013956 <z_swap_irqlock> @ imm = #-0x32e
 8013c84: e00b         	b	0x8013c9e <z_reschedule_irqlock+0x3e> @ imm = #0x16
 8013c86: 687b         	ldr	r3, [r7, #0x4]
 8013c88: 60fb         	str	r3, [r7, #0xc]
 8013c8a: 68fb         	ldr	r3, [r7, #0xc]
 8013c8c: 60bb         	str	r3, [r7, #0x8]
;   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8013c8e: 68bb         	ldr	r3, [r7, #0x8]
 8013c90: f383 8811    	msr	basepri, r3
; }
 8013c94: bf00         	nop
;   __ASM volatile ("isb 0xF":::"memory");
 8013c96: f3bf 8f6f    	isb	sy
; }
 8013c9a: bf00         	nop
; }
 8013c9c: bf00         	nop
; }
 8013c9e: bf00         	nop
 8013ca0: 3710         	adds	r7, #0x10
 8013ca2: 46bd         	mov	sp, r7
 8013ca4: bd80         	pop	{r7, pc}

08013ca6 <init_ready_q>:
; {
 8013ca6: b580         	push	{r7, lr}
 8013ca8: b084         	sub	sp, #0x10
 8013caa: af00         	add	r7, sp, #0x0
 8013cac: 6078         	str	r0, [r7, #0x4]
; 	_priq_run_init(&ready_q->runq);
 8013cae: 687b         	ldr	r3, [r7, #0x4]
 8013cb0: 3304         	adds	r3, #0x4
 8013cb2: 60fb         	str	r3, [r7, #0xc]
; 	sys_dlist_init(pq);
 8013cb4: 68f8         	ldr	r0, [r7, #0xc]
 8013cb6: f7ff fc2b    	bl	0x8013510 <sys_dlist_init> @ imm = #-0x7aa
; }
 8013cba: bf00         	nop
; }
 8013cbc: bf00         	nop
 8013cbe: 3710         	adds	r7, #0x10
 8013cc0: 46bd         	mov	sp, r7
 8013cc2: bd80         	pop	{r7, pc}

08013cc4 <unpend_all>:
; {
 8013cc4: b580         	push	{r7, lr}
 8013cc6: b086         	sub	sp, #0x18
 8013cc8: af00         	add	r7, sp, #0x0
 8013cca: 6078         	str	r0, [r7, #0x4]
; 	for (thread = z_waitq_head(wait_q); thread != NULL; thread = z_waitq_head(wait_q)) {
 8013ccc: 6878         	ldr	r0, [r7, #0x4]
 8013cce: f7ff fe35    	bl	0x801393c <z_waitq_head> @ imm = #-0x396
 8013cd2: 6178         	str	r0, [r7, #0x14]
 8013cd4: e015         	b	0x8013d02 <unpend_all+0x3e> @ imm = #0x2a
; 		unpend_thread_no_timeout(thread);
 8013cd6: 6978         	ldr	r0, [r7, #0x14]
 8013cd8: f7ff fe16    	bl	0x8013908 <unpend_thread_no_timeout> @ imm = #-0x3d4
; 		(void)z_abort_thread_timeout(thread);
 8013cdc: 6978         	ldr	r0, [r7, #0x14]
 8013cde: f7ff fd00    	bl	0x80136e2 <z_abort_thread_timeout> @ imm = #-0x600
 8013ce2: 697b         	ldr	r3, [r7, #0x14]
 8013ce4: 613b         	str	r3, [r7, #0x10]
 8013ce6: 2300         	movs	r3, #0x0
 8013ce8: 60fb         	str	r3, [r7, #0xc]
; 	thread->arch.swap_return_value = value;
 8013cea: 693b         	ldr	r3, [r7, #0x10]
 8013cec: 68fa         	ldr	r2, [r7, #0xc]
 8013cee: f8c3 20cc    	str.w	r2, [r3, #0xcc]
; }
 8013cf2: bf00         	nop
; 		ready_thread(thread);
 8013cf4: 6978         	ldr	r0, [r7, #0x14]
 8013cf6: f7f6 fcf1    	bl	0x800a6dc <ready_thread> @ imm = #-0x961e
; 	for (thread = z_waitq_head(wait_q); thread != NULL; thread = z_waitq_head(wait_q)) {
 8013cfa: 6878         	ldr	r0, [r7, #0x4]
 8013cfc: f7ff fe1e    	bl	0x801393c <z_waitq_head> @ imm = #-0x3c4
 8013d00: 6178         	str	r0, [r7, #0x14]
 8013d02: 697b         	ldr	r3, [r7, #0x14]
 8013d04: 2b00         	cmp	r3, #0x0
 8013d06: d1e6         	bne	0x8013cd6 <unpend_all+0x12> @ imm = #-0x34
; }
 8013d08: bf00         	nop
 8013d0a: bf00         	nop
 8013d0c: 3718         	adds	r7, #0x18
 8013d0e: 46bd         	mov	sp, r7
 8013d10: bd80         	pop	{r7, pc}

08013d12 <thread_is_preemptible>:
; {
 8013d12: b480         	push	{r7}
 8013d14: b083         	sub	sp, #0xc
 8013d16: af00         	add	r7, sp, #0x0
 8013d18: 6078         	str	r0, [r7, #0x4]
; 	return thread->base.preempt <= _PREEMPT_THRESHOLD;
 8013d1a: 687b         	ldr	r3, [r7, #0x4]
 8013d1c: 89db         	ldrh	r3, [r3, #0xe]
 8013d1e: 2b7f         	cmp	r3, #0x7f
 8013d20: bf94         	ite	ls
 8013d22: 2301         	movls	r3, #0x1
 8013d24: 2300         	movhi	r3, #0x0
 8013d26: b2db         	uxtb	r3, r3
; }
 8013d28: 4618         	mov	r0, r3
 8013d2a: 370c         	adds	r7, #0xc
 8013d2c: 46bd         	mov	sp, r7
 8013d2e: bc80         	pop	{r7}
 8013d30: 4770         	bx	lr

08013d32 <z_is_thread_prevented_from_running>:
; {
 8013d32: b480         	push	{r7}
 8013d34: b085         	sub	sp, #0x14
 8013d36: af00         	add	r7, sp, #0x0
 8013d38: 6078         	str	r0, [r7, #0x4]
; 	uint8_t state = thread->base.thread_state;
 8013d3a: 687b         	ldr	r3, [r7, #0x4]
 8013d3c: 7b5b         	ldrb	r3, [r3, #0xd]
 8013d3e: 73fb         	strb	r3, [r7, #0xf]
; 	return (state & (_THREAD_PENDING | _THREAD_DEAD |
 8013d40: 7bfb         	ldrb	r3, [r7, #0xf]
 8013d42: f003 031b    	and	r3, r3, #0x1b
; 			 _THREAD_DUMMY | _THREAD_SUSPENDED)) != 0U;
 8013d46: 2b00         	cmp	r3, #0x0
 8013d48: bf14         	ite	ne
 8013d4a: 2301         	movne	r3, #0x1
 8013d4c: 2300         	moveq	r3, #0x0
 8013d4e: b2db         	uxtb	r3, r3
; }
 8013d50: 4618         	mov	r0, r3
 8013d52: 3714         	adds	r7, #0x14
 8013d54: 46bd         	mov	sp, r7
 8013d56: bc80         	pop	{r7}
 8013d58: 4770         	bx	lr

08013d5a <z_is_prio1_higher_than_prio2>:
; {
 8013d5a: b480         	push	{r7}
 8013d5c: b083         	sub	sp, #0xc
 8013d5e: af00         	add	r7, sp, #0x0
 8013d60: 6078         	str	r0, [r7, #0x4]
 8013d62: 6039         	str	r1, [r7]
; 	return prio1 < prio2;
 8013d64: 687a         	ldr	r2, [r7, #0x4]
 8013d66: 683b         	ldr	r3, [r7]
 8013d68: 429a         	cmp	r2, r3
 8013d6a: bfb4         	ite	lt
 8013d6c: 2301         	movlt	r3, #0x1
 8013d6e: 2300         	movge	r3, #0x0
 8013d70: b2db         	uxtb	r3, r3
; }
 8013d72: 4618         	mov	r0, r3
 8013d74: 370c         	adds	r7, #0xc
 8013d76: 46bd         	mov	sp, r7
 8013d78: bc80         	pop	{r7}
 8013d7a: 4770         	bx	lr

08013d7c <z_is_prio_higher>:
; {
 8013d7c: b580         	push	{r7, lr}
 8013d7e: b082         	sub	sp, #0x8
 8013d80: af00         	add	r7, sp, #0x0
 8013d82: 6078         	str	r0, [r7, #0x4]
 8013d84: 6039         	str	r1, [r7]
; 	return z_is_prio1_higher_than_prio2(prio, test_prio);
 8013d86: 6839         	ldr	r1, [r7]
 8013d88: 6878         	ldr	r0, [r7, #0x4]
 8013d8a: f7ff ffe6    	bl	0x8013d5a <z_is_prio1_higher_than_prio2> @ imm = #-0x34
 8013d8e: 4603         	mov	r3, r0
; }
 8013d90: 4618         	mov	r0, r3
 8013d92: 3708         	adds	r7, #0x8
 8013d94: 46bd         	mov	sp, r7
 8013d96: bd80         	pop	{r7, pc}

08013d98 <sys_dnode_init>:
; {
 8013d98: b480         	push	{r7}
 8013d9a: b083         	sub	sp, #0xc
 8013d9c: af00         	add	r7, sp, #0x0
 8013d9e: 6078         	str	r0, [r7, #0x4]
; 	node->next = NULL;
 8013da0: 687b         	ldr	r3, [r7, #0x4]
 8013da2: 2200         	movs	r2, #0x0
 8013da4: 601a         	str	r2, [r3]
; 	node->prev = NULL;
 8013da6: 687b         	ldr	r3, [r7, #0x4]
 8013da8: 2200         	movs	r2, #0x0
 8013daa: 605a         	str	r2, [r3, #0x4]
; }
 8013dac: bf00         	nop
 8013dae: 370c         	adds	r7, #0xc
 8013db0: 46bd         	mov	sp, r7
 8013db2: bc80         	pop	{r7}
 8013db4: 4770         	bx	lr

08013db6 <sys_dnode_is_linked>:
; {
 8013db6: b480         	push	{r7}
 8013db8: b083         	sub	sp, #0xc
 8013dba: af00         	add	r7, sp, #0x0
 8013dbc: 6078         	str	r0, [r7, #0x4]
; 	return node->next != NULL;
 8013dbe: 687b         	ldr	r3, [r7, #0x4]
 8013dc0: 681b         	ldr	r3, [r3]
 8013dc2: 2b00         	cmp	r3, #0x0
 8013dc4: bf14         	ite	ne
 8013dc6: 2301         	movne	r3, #0x1
 8013dc8: 2300         	moveq	r3, #0x0
 8013dca: b2db         	uxtb	r3, r3
; }
 8013dcc: 4618         	mov	r0, r3
 8013dce: 370c         	adds	r7, #0xc
 8013dd0: 46bd         	mov	sp, r7
 8013dd2: bc80         	pop	{r7}
 8013dd4: 4770         	bx	lr

08013dd6 <sys_dlist_is_empty>:
; {
 8013dd6: b480         	push	{r7}
 8013dd8: b083         	sub	sp, #0xc
 8013dda: af00         	add	r7, sp, #0x0
 8013ddc: 6078         	str	r0, [r7, #0x4]
; 	return list->head == list;
 8013dde: 687b         	ldr	r3, [r7, #0x4]
 8013de0: 681b         	ldr	r3, [r3]
 8013de2: 687a         	ldr	r2, [r7, #0x4]
 8013de4: 429a         	cmp	r2, r3
 8013de6: bf0c         	ite	eq
 8013de8: 2301         	moveq	r3, #0x1
 8013dea: 2300         	movne	r3, #0x0
 8013dec: b2db         	uxtb	r3, r3
; }
 8013dee: 4618         	mov	r0, r3
 8013df0: 370c         	adds	r7, #0xc
 8013df2: 46bd         	mov	sp, r7
 8013df4: bc80         	pop	{r7}
 8013df6: 4770         	bx	lr

08013df8 <sys_dlist_peek_head>:
; {
 8013df8: b580         	push	{r7, lr}
 8013dfa: b082         	sub	sp, #0x8
 8013dfc: af00         	add	r7, sp, #0x0
 8013dfe: 6078         	str	r0, [r7, #0x4]
; 	return sys_dlist_is_empty(list) ? NULL : list->head;
 8013e00: 6878         	ldr	r0, [r7, #0x4]
 8013e02: f7ff ffe8    	bl	0x8013dd6 <sys_dlist_is_empty> @ imm = #-0x30
 8013e06: 4603         	mov	r3, r0
 8013e08: 2b00         	cmp	r3, #0x0
 8013e0a: d102         	bne	0x8013e12 <sys_dlist_peek_head+0x1a> @ imm = #0x4
 8013e0c: 687b         	ldr	r3, [r7, #0x4]
 8013e0e: 681b         	ldr	r3, [r3]
 8013e10: e000         	b	0x8013e14 <sys_dlist_peek_head+0x1c> @ imm = #0x0
 8013e12: 2300         	movs	r3, #0x0
; }
 8013e14: 4618         	mov	r0, r3
 8013e16: 3708         	adds	r7, #0x8
 8013e18: 46bd         	mov	sp, r7
 8013e1a: bd80         	pop	{r7, pc}

08013e1c <sys_dlist_peek_next_no_check>:
; {
 8013e1c: b480         	push	{r7}
 8013e1e: b083         	sub	sp, #0xc
 8013e20: af00         	add	r7, sp, #0x0
 8013e22: 6078         	str	r0, [r7, #0x4]
 8013e24: 6039         	str	r1, [r7]
; 	return (node == list->tail) ? NULL : node->next;
 8013e26: 687b         	ldr	r3, [r7, #0x4]
 8013e28: 685b         	ldr	r3, [r3, #0x4]
 8013e2a: 683a         	ldr	r2, [r7]
 8013e2c: 429a         	cmp	r2, r3
 8013e2e: d002         	beq	0x8013e36 <sys_dlist_peek_next_no_check+0x1a> @ imm = #0x4
 8013e30: 683b         	ldr	r3, [r7]
 8013e32: 681b         	ldr	r3, [r3]
 8013e34: e000         	b	0x8013e38 <sys_dlist_peek_next_no_check+0x1c> @ imm = #0x0
 8013e36: 2300         	movs	r3, #0x0
; }
 8013e38: 4618         	mov	r0, r3
 8013e3a: 370c         	adds	r7, #0xc
 8013e3c: 46bd         	mov	sp, r7
 8013e3e: bc80         	pop	{r7}
 8013e40: 4770         	bx	lr

08013e42 <sys_dlist_peek_next>:
; {
 8013e42: b580         	push	{r7, lr}
 8013e44: b082         	sub	sp, #0x8
 8013e46: af00         	add	r7, sp, #0x0
 8013e48: 6078         	str	r0, [r7, #0x4]
 8013e4a: 6039         	str	r1, [r7]
; 	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
 8013e4c: 683b         	ldr	r3, [r7]
 8013e4e: 2b00         	cmp	r3, #0x0
 8013e50: d005         	beq	0x8013e5e <sys_dlist_peek_next+0x1c> @ imm = #0xa
 8013e52: 6839         	ldr	r1, [r7]
 8013e54: 6878         	ldr	r0, [r7, #0x4]
 8013e56: f7ff ffe1    	bl	0x8013e1c <sys_dlist_peek_next_no_check> @ imm = #-0x3e
 8013e5a: 4603         	mov	r3, r0
 8013e5c: e000         	b	0x8013e60 <sys_dlist_peek_next+0x1e> @ imm = #0x0
 8013e5e: 2300         	movs	r3, #0x0
; }
 8013e60: 4618         	mov	r0, r3
 8013e62: 3708         	adds	r7, #0x8
 8013e64: 46bd         	mov	sp, r7
 8013e66: bd80         	pop	{r7, pc}

08013e68 <sys_dlist_append>:
; {
 8013e68: b480         	push	{r7}
 8013e6a: b085         	sub	sp, #0x14
 8013e6c: af00         	add	r7, sp, #0x0
 8013e6e: 6078         	str	r0, [r7, #0x4]
 8013e70: 6039         	str	r1, [r7]
; 	sys_dnode_t *const tail = list->tail;
 8013e72: 687b         	ldr	r3, [r7, #0x4]
 8013e74: 685b         	ldr	r3, [r3, #0x4]
 8013e76: 60fb         	str	r3, [r7, #0xc]
; 	node->next = list;
 8013e78: 683b         	ldr	r3, [r7]
 8013e7a: 687a         	ldr	r2, [r7, #0x4]
 8013e7c: 601a         	str	r2, [r3]
; 	node->prev = tail;
 8013e7e: 683b         	ldr	r3, [r7]
 8013e80: 68fa         	ldr	r2, [r7, #0xc]
 8013e82: 605a         	str	r2, [r3, #0x4]
; 	tail->next = node;
 8013e84: 68fb         	ldr	r3, [r7, #0xc]
 8013e86: 683a         	ldr	r2, [r7]
 8013e88: 601a         	str	r2, [r3]
; 	list->tail = node;
 8013e8a: 687b         	ldr	r3, [r7, #0x4]
 8013e8c: 683a         	ldr	r2, [r7]
 8013e8e: 605a         	str	r2, [r3, #0x4]
; }
 8013e90: bf00         	nop
 8013e92: 3714         	adds	r7, #0x14
 8013e94: 46bd         	mov	sp, r7
 8013e96: bc80         	pop	{r7}
 8013e98: 4770         	bx	lr

08013e9a <sys_dlist_insert>:
; {
 8013e9a: b480         	push	{r7}
 8013e9c: b085         	sub	sp, #0x14
 8013e9e: af00         	add	r7, sp, #0x0
 8013ea0: 6078         	str	r0, [r7, #0x4]
 8013ea2: 6039         	str	r1, [r7]
; 	sys_dnode_t *const prev = successor->prev;
 8013ea4: 687b         	ldr	r3, [r7, #0x4]
 8013ea6: 685b         	ldr	r3, [r3, #0x4]
 8013ea8: 60fb         	str	r3, [r7, #0xc]
; 	node->prev = prev;
 8013eaa: 683b         	ldr	r3, [r7]
 8013eac: 68fa         	ldr	r2, [r7, #0xc]
 8013eae: 605a         	str	r2, [r3, #0x4]
; 	node->next = successor;
 8013eb0: 683b         	ldr	r3, [r7]
 8013eb2: 687a         	ldr	r2, [r7, #0x4]
 8013eb4: 601a         	str	r2, [r3]
; 	prev->next = node;
 8013eb6: 68fb         	ldr	r3, [r7, #0xc]
 8013eb8: 683a         	ldr	r2, [r7]
 8013eba: 601a         	str	r2, [r3]
; 	successor->prev = node;
 8013ebc: 687b         	ldr	r3, [r7, #0x4]
 8013ebe: 683a         	ldr	r2, [r7]
 8013ec0: 605a         	str	r2, [r3, #0x4]
; }
 8013ec2: bf00         	nop
 8013ec4: 3714         	adds	r7, #0x14
 8013ec6: 46bd         	mov	sp, r7
 8013ec8: bc80         	pop	{r7}
 8013eca: 4770         	bx	lr

08013ecc <sys_dlist_remove>:
; {
 8013ecc: b580         	push	{r7, lr}
 8013ece: b084         	sub	sp, #0x10
 8013ed0: af00         	add	r7, sp, #0x0
 8013ed2: 6078         	str	r0, [r7, #0x4]
; 	sys_dnode_t *const prev = node->prev;
 8013ed4: 687b         	ldr	r3, [r7, #0x4]
 8013ed6: 685b         	ldr	r3, [r3, #0x4]
 8013ed8: 60fb         	str	r3, [r7, #0xc]
; 	sys_dnode_t *const next = node->next;
 8013eda: 687b         	ldr	r3, [r7, #0x4]
 8013edc: 681b         	ldr	r3, [r3]
 8013ede: 60bb         	str	r3, [r7, #0x8]
; 	prev->next = next;
 8013ee0: 68fb         	ldr	r3, [r7, #0xc]
 8013ee2: 68ba         	ldr	r2, [r7, #0x8]
 8013ee4: 601a         	str	r2, [r3]
; 	next->prev = prev;
 8013ee6: 68bb         	ldr	r3, [r7, #0x8]
 8013ee8: 68fa         	ldr	r2, [r7, #0xc]
 8013eea: 605a         	str	r2, [r3, #0x4]
; 	sys_dnode_init(node);
 8013eec: 6878         	ldr	r0, [r7, #0x4]
 8013eee: f7ff ff53    	bl	0x8013d98 <sys_dnode_init> @ imm = #-0x15a
; }
 8013ef2: bf00         	nop
 8013ef4: 3710         	adds	r7, #0x10
 8013ef6: 46bd         	mov	sp, r7
 8013ef8: bd80         	pop	{r7, pc}

08013efa <remove_timeout>:
; {
 8013efa: b5f0         	push	{r4, r5, r6, r7, lr}
 8013efc: b083         	sub	sp, #0xc
 8013efe: af00         	add	r7, sp, #0x0
 8013f00: 6078         	str	r0, [r7, #0x4]
; 	if (next(t) != NULL) {
 8013f02: 6878         	ldr	r0, [r7, #0x4]
 8013f04: f7f8 f874    	bl	0x800bff0 <next>        @ imm = #-0x7f18
 8013f08: 4603         	mov	r3, r0
 8013f0a: 2b00         	cmp	r3, #0x0
 8013f0c: d00d         	beq	0x8013f2a <remove_timeout+0x30> @ imm = #0x1a
; 		next(t)->dticks += t->dticks;
 8013f0e: 6878         	ldr	r0, [r7, #0x4]
 8013f10: f7f8 f86e    	bl	0x800bff0 <next>        @ imm = #-0x7f24
 8013f14: 4606         	mov	r6, r0
 8013f16: e9d6 0104    	ldrd	r0, r1, [r6, #16]
 8013f1a: 687b         	ldr	r3, [r7, #0x4]
 8013f1c: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 8013f20: 1884         	adds	r4, r0, r2
 8013f22: eb41 0503    	adc.w	r5, r1, r3
 8013f26: e9c6 4504    	strd	r4, r5, [r6, #16]
; 	sys_dlist_remove(&t->node);
 8013f2a: 687b         	ldr	r3, [r7, #0x4]
 8013f2c: 4618         	mov	r0, r3
 8013f2e: f7ff ffcd    	bl	0x8013ecc <sys_dlist_remove> @ imm = #-0x66
; }
 8013f32: bf00         	nop
 8013f34: 370c         	adds	r7, #0xc
 8013f36: 46bd         	mov	sp, r7
 8013f38: bdf0         	pop	{r4, r5, r6, r7, pc}

08013f3a <next_timeout>:
; {
 8013f3a: e92d 4fb0    	push.w	{r4, r5, r7, r8, r9, r10, r11, lr}
 8013f3e: b086         	sub	sp, #0x18
 8013f40: af00         	add	r7, sp, #0x0
; 	struct _timeout *to = first();
 8013f42: f7f8 f847    	bl	0x800bfd4 <first>       @ imm = #-0x7f72
 8013f46: 6138         	str	r0, [r7, #0x10]
; 	int32_t ticks_elapsed = elapsed();
 8013f48: f7f8 f864    	bl	0x800c014 <elapsed>     @ imm = #-0x7f38
 8013f4c: 60f8         	str	r0, [r7, #0xc]
; 	if ((to == NULL) ||
 8013f4e: 693b         	ldr	r3, [r7, #0x10]
 8013f50: 2b00         	cmp	r3, #0x0
 8013f52: d00f         	beq	0x8013f74 <next_timeout+0x3a> @ imm = #0x1e
; 	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
 8013f54: 693b         	ldr	r3, [r7, #0x10]
 8013f56: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 8013f5a: 68f9         	ldr	r1, [r7, #0xc]
 8013f5c: 17c8         	asrs	r0, r1, #0x1f
 8013f5e: 468a         	mov	r10, r1
 8013f60: 4683         	mov	r11, r0
 8013f62: ebb2 040a    	subs.w	r4, r2, r10
 8013f66: eb63 050b    	sbc.w	r5, r3, r11
; 	if ((to == NULL) ||
 8013f6a: f1b4 4f00    	cmp.w	r4, #0x80000000
 8013f6e: f175 0300    	sbcs	r3, r5, #0x0
 8013f72: db03         	blt	0x8013f7c <next_timeout+0x42> @ imm = #0x6
; 		ret = MAX_WAIT;
 8013f74: f06f 4300    	mvn	r3, #0x80000000
 8013f78: 617b         	str	r3, [r7, #0x14]
 8013f7a: e016         	b	0x8013faa <next_timeout+0x70> @ imm = #0x2c
; 		ret = MAX(0, to->dticks - ticks_elapsed);
 8013f7c: 693b         	ldr	r3, [r7, #0x10]
 8013f7e: e9d3 2304    	ldrd	r2, r3, [r3, #16]
 8013f82: 68f9         	ldr	r1, [r7, #0xc]
 8013f84: 17c8         	asrs	r0, r1, #0x1f
 8013f86: 4688         	mov	r8, r1
 8013f88: 4681         	mov	r9, r0
 8013f8a: ebb2 0108    	subs.w	r1, r2, r8
 8013f8e: 6039         	str	r1, [r7]
 8013f90: eb63 0309    	sbc.w	r3, r3, r9
 8013f94: 607b         	str	r3, [r7, #0x4]
 8013f96: e9d7 2300    	ldrd	r2, r3, [r7]
 8013f9a: 2b00         	cmp	r3, #0x0
 8013f9c: da03         	bge	0x8013fa6 <next_timeout+0x6c> @ imm = #0x6
 8013f9e: f04f 0200    	mov.w	r2, #0x0
 8013fa2: f04f 0300    	mov.w	r3, #0x0
 8013fa6: 4613         	mov	r3, r2
 8013fa8: 617b         	str	r3, [r7, #0x14]
; 	return ret;
 8013faa: 697b         	ldr	r3, [r7, #0x14]
; }
 8013fac: 4618         	mov	r0, r3
 8013fae: 3718         	adds	r7, #0x18
 8013fb0: 46bd         	mov	sp, r7
 8013fb2: e8bd 8fb0    	pop.w	{r4, r5, r7, r8, r9, r10, r11, pc}

08013fb6 <sys_clock_tick_get_32>:
; {
 8013fb6: b580         	push	{r7, lr}
 8013fb8: af00         	add	r7, sp, #0x0
; 	return (uint32_t)sys_clock_tick_get();
 8013fba: f7f8 fa75    	bl	0x800c4a8 <sys_clock_tick_get> @ imm = #-0x7b16
 8013fbe: 4602         	mov	r2, r0
 8013fc0: 460b         	mov	r3, r1
 8013fc2: 4613         	mov	r3, r2
; }
 8013fc4: 4618         	mov	r0, r3
 8013fc6: bd80         	pop	{r7, pc}

08013fc8 <z_impl_k_uptime_ticks>:
; {
 8013fc8: b580         	push	{r7, lr}
 8013fca: af00         	add	r7, sp, #0x0
; 	return sys_clock_tick_get();
 8013fcc: f7f8 fa6c    	bl	0x800c4a8 <sys_clock_tick_get> @ imm = #-0x7b28
 8013fd0: 4602         	mov	r2, r0
 8013fd2: 460b         	mov	r3, r1
; }
 8013fd4: 4610         	mov	r0, r2
 8013fd6: 4619         	mov	r1, r3
 8013fd8: bd80         	pop	{r7, pc}

08013fda <arch_k_cycle_get_32>:
; {
 8013fda: b580         	push	{r7, lr}
 8013fdc: af00         	add	r7, sp, #0x0
; 	return sys_clock_cycle_get_32();
 8013fde: f7f3 fd63    	bl	0x8007aa8 <sys_clock_cycle_get_32> @ imm = #-0xc53a
 8013fe2: 4603         	mov	r3, r0
; }
 8013fe4: 4618         	mov	r0, r3
 8013fe6: bd80         	pop	{r7, pc}

08013fe8 <k_cycle_get_32>:
; {
 8013fe8: b580         	push	{r7, lr}
 8013fea: af00         	add	r7, sp, #0x0
; 	return arch_k_cycle_get_32();
 8013fec: f7ff fff5    	bl	0x8013fda <arch_k_cycle_get_32> @ imm = #-0x16
 8013ff0: 4603         	mov	r3, r0
; }
 8013ff2: 4618         	mov	r0, r3
 8013ff4: bd80         	pop	{r7, pc}

08013ff6 <usage_now>:
; {
 8013ff6: b580         	push	{r7, lr}
 8013ff8: b082         	sub	sp, #0x8
 8013ffa: af00         	add	r7, sp, #0x0
; 	now = k_cycle_get_32();
 8013ffc: f7ff fff4    	bl	0x8013fe8 <k_cycle_get_32> @ imm = #-0x18
 8014000: 6078         	str	r0, [r7, #0x4]
; 	return (now == 0) ? 1 : now;
 8014002: 687b         	ldr	r3, [r7, #0x4]
 8014004: 2b00         	cmp	r3, #0x0
 8014006: d001         	beq	0x801400c <usage_now+0x16> @ imm = #0x2
 8014008: 687b         	ldr	r3, [r7, #0x4]
 801400a: e000         	b	0x801400e <usage_now+0x18> @ imm = #0x0
 801400c: 2301         	movs	r3, #0x1
; }
 801400e: 4618         	mov	r0, r3
 8014010: 3708         	adds	r7, #0x8
 8014012: 46bd         	mov	sp, r7
 8014014: bd80         	pop	{r7, pc}

08014016 <sched_cpu_update_usage>:
; {
 8014016: e92d 03b0    	push.w	{r4, r5, r7, r8, r9}
 801401a: b083         	sub	sp, #0xc
 801401c: af00         	add	r7, sp, #0x0
 801401e: 6078         	str	r0, [r7, #0x4]
 8014020: 6039         	str	r1, [r7]
; 	if (!cpu->usage->track_usage) {
 8014022: 687b         	ldr	r3, [r7, #0x4]
 8014024: 699b         	ldr	r3, [r3, #0x18]
 8014026: 7a1b         	ldrb	r3, [r3, #0x8]
 8014028: f083 0301    	eor	r3, r3, #0x1
 801402c: b2db         	uxtb	r3, r3
 801402e: 2b00         	cmp	r3, #0x0
 8014030: d116         	bne	0x8014060 <sched_cpu_update_usage+0x4a> @ imm = #0x2c
; 	if (cpu->current != cpu->idle_thread) {
 8014032: 687b         	ldr	r3, [r7, #0x4]
 8014034: 689a         	ldr	r2, [r3, #0x8]
 8014036: 687b         	ldr	r3, [r7, #0x4]
 8014038: 68db         	ldr	r3, [r3, #0xc]
 801403a: 429a         	cmp	r2, r3
 801403c: d011         	beq	0x8014062 <sched_cpu_update_usage+0x4c> @ imm = #0x22
; 		cpu->usage->total += cycles;
 801403e: 687b         	ldr	r3, [r7, #0x4]
 8014040: 699b         	ldr	r3, [r3, #0x18]
 8014042: e9d3 2300    	ldrd	r2, r3, [r3]
 8014046: 6839         	ldr	r1, [r7]
 8014048: 2000         	movs	r0, #0x0
 801404a: 460c         	mov	r4, r1
 801404c: 4605         	mov	r5, r0
 801404e: 6879         	ldr	r1, [r7, #0x4]
 8014050: 6989         	ldr	r1, [r1, #0x18]
 8014052: eb12 0804    	adds.w	r8, r2, r4
 8014056: eb43 0905    	adc.w	r9, r3, r5
 801405a: e9c1 8900    	strd	r8, r9, [r1]
 801405e: e000         	b	0x8014062 <sched_cpu_update_usage+0x4c> @ imm = #0x0
; 		return;
 8014060: bf00         	nop
; }
 8014062: 370c         	adds	r7, #0xc
 8014064: 46bd         	mov	sp, r7
 8014066: e8bd 03b0    	pop.w	{r4, r5, r7, r8, r9}
 801406a: 4770         	bx	lr

0801406c <sched_thread_update_usage>:
; {
 801406c: e92d 03b0    	push.w	{r4, r5, r7, r8, r9}
 8014070: b083         	sub	sp, #0xc
 8014072: af00         	add	r7, sp, #0x0
 8014074: 6078         	str	r0, [r7, #0x4]
 8014076: 6039         	str	r1, [r7]
; 	thread->base.usage.total += cycles;
 8014078: 687b         	ldr	r3, [r7, #0x4]
 801407a: e9d3 230c    	ldrd	r2, r3, [r3, #48]
 801407e: 6839         	ldr	r1, [r7]
 8014080: 2000         	movs	r0, #0x0
 8014082: 460c         	mov	r4, r1
 8014084: 4605         	mov	r5, r0
 8014086: eb12 0804    	adds.w	r8, r2, r4
 801408a: eb43 0905    	adc.w	r9, r3, r5
 801408e: 687b         	ldr	r3, [r7, #0x4]
 8014090: e9c3 890c    	strd	r8, r9, [r3, #48]
; }
 8014094: bf00         	nop
 8014096: 370c         	adds	r7, #0xc
 8014098: 46bd         	mov	sp, r7
 801409a: e8bd 03b0    	pop.w	{r4, r5, r7, r8, r9}
 801409e: 4770         	bx	lr

080140a0 <sys_dlist_init>:
; {
 80140a0: b480         	push	{r7}
 80140a2: b083         	sub	sp, #0xc
 80140a4: af00         	add	r7, sp, #0x0
 80140a6: 6078         	str	r0, [r7, #0x4]
; 	list->head = (sys_dnode_t *)list;
 80140a8: 687b         	ldr	r3, [r7, #0x4]
 80140aa: 687a         	ldr	r2, [r7, #0x4]
 80140ac: 601a         	str	r2, [r3]
; 	list->tail = (sys_dnode_t *)list;
 80140ae: 687b         	ldr	r3, [r7, #0x4]
 80140b0: 687a         	ldr	r2, [r7, #0x4]
 80140b2: 605a         	str	r2, [r3, #0x4]
; }
 80140b4: bf00         	nop
 80140b6: 370c         	adds	r7, #0xc
 80140b8: 46bd         	mov	sp, r7
 80140ba: bc80         	pop	{r7}
 80140bc: 4770         	bx	lr

080140be <z_waitq_init>:
; {
 80140be: b580         	push	{r7, lr}
 80140c0: b082         	sub	sp, #0x8
 80140c2: af00         	add	r7, sp, #0x0
 80140c4: 6078         	str	r0, [r7, #0x4]
; 	sys_dlist_init(&w->waitq);
 80140c6: 687b         	ldr	r3, [r7, #0x4]
 80140c8: 4618         	mov	r0, r3
 80140ca: f7ff ffe9    	bl	0x80140a0 <sys_dlist_init> @ imm = #-0x2e
; }
 80140ce: bf00         	nop
 80140d0: 3708         	adds	r7, #0x8
 80140d2: 46bd         	mov	sp, r7
 80140d4: bd80         	pop	{r7, pc}

080140d6 <k_heap_init>:
; {
 80140d6: b580         	push	{r7, lr}
 80140d8: b084         	sub	sp, #0x10
 80140da: af00         	add	r7, sp, #0x0
 80140dc: 60f8         	str	r0, [r7, #0xc]
 80140de: 60b9         	str	r1, [r7, #0x8]
 80140e0: 607a         	str	r2, [r7, #0x4]
; 	z_waitq_init(&heap->wait_q);
 80140e2: 68fb         	ldr	r3, [r7, #0xc]
 80140e4: 330c         	adds	r3, #0xc
 80140e6: 4618         	mov	r0, r3
 80140e8: f7ff ffe9    	bl	0x80140be <z_waitq_init> @ imm = #-0x2e
; 	sys_heap_init(&heap->heap, mem, bytes);
 80140ec: 68fb         	ldr	r3, [r7, #0xc]
 80140ee: 687a         	ldr	r2, [r7, #0x4]
 80140f0: 68b9         	ldr	r1, [r7, #0x8]
 80140f2: 4618         	mov	r0, r3
 80140f4: f7f9 fe14    	bl	0x800dd20 <sys_heap_init> @ imm = #-0x63d8
; }
 80140f8: bf00         	nop
 80140fa: 3710         	adds	r7, #0x10
 80140fc: 46bd         	mov	sp, r7
 80140fe: bd80         	pop	{r7, pc}

08014100 <memcpy>:
 8014100: 440a         	add	r2, r1
 8014102: 4291         	cmp	r1, r2
 8014104: f100 33ff    	add.w	r3, r0, #0xffffffff
 8014108: d100         	bne	0x801410c <memcpy+0xc>  @ imm = #0x0
 801410a: 4770         	bx	lr
 801410c: b510         	push	{r4, lr}
 801410e: f811 4b01    	ldrb	r4, [r1], #1
 8014112: f803 4f01    	strb	r4, [r3, #1]!
 8014116: 4291         	cmp	r1, r2
 8014118: d1f9         	bne	0x801410e <memcpy+0xe>  @ imm = #-0xe
 801411a: bd10         	pop	{r4, pc}

0801411c <memset>:
 801411c: 4402         	add	r2, r0
 801411e: 4603         	mov	r3, r0
 8014120: 4293         	cmp	r3, r2
 8014122: d100         	bne	0x8014126 <memset+0xa>  @ imm = #0x0
 8014124: 4770         	bx	lr
 8014126: f803 1b01    	strb	r1, [r3], #1
 801412a: e7f9         	b	0x8014120 <memset+0x4>  @ imm = #-0xe

0801412c <strncpy>:
 801412c: b510         	push	{r4, lr}
 801412e: 3901         	subs	r1, #0x1
 8014130: 4604         	mov	r4, r0
 8014132: b132         	cbz	r2, 0x8014142 <strncpy+0x16> @ imm = #0xc
 8014134: f811 3f01    	ldrb	r3, [r1, #1]!
 8014138: f800 3b01    	strb	r3, [r0], #1
 801413c: 3a01         	subs	r2, #0x1
 801413e: 2b00         	cmp	r3, #0x0
 8014140: d1f7         	bne	0x8014132 <strncpy+0x6> @ imm = #-0x12
 8014142: 2100         	movs	r1, #0x0
 8014144: f7ff ffea    	bl	0x801411c <memset>      @ imm = #-0x2c
 8014148: 4620         	mov	r0, r4
 801414a: bd10         	pop	{r4, pc}

0801414c <strnlen>:
 801414c: b510         	push	{r4, lr}
 801414e: 4602         	mov	r2, r0
 8014150: 4401         	add	r1, r0
 8014152: 428a         	cmp	r2, r1
 8014154: 4613         	mov	r3, r2
 8014156: d003         	beq	0x8014160 <strnlen+0x14> @ imm = #0x6
 8014158: 781c         	ldrb	r4, [r3]
 801415a: 3201         	adds	r2, #0x1
 801415c: 2c00         	cmp	r4, #0x0
 801415e: d1f8         	bne	0x8014152 <strnlen+0x6> @ imm = #-0x10
 8014160: 1a18         	subs	r0, r3, r0
 8014162: bd10         	pop	{r4, pc}

08014164 <__ultoa_invert>:
 8014164: e92d 47f0    	push.w	{r4, r5, r6, r7, r8, r9, r10, lr}
 8014168: f1c3 0937    	rsb.w	r9, r3, #0x37
 801416c: 4607         	mov	r7, r0
 801416e: 4688         	mov	r8, r1
 8014170: fa5f f989    	uxtb.w	r9, r9
 8014174: f003 051f    	and	r5, r3, #0x1f
 8014178: 4616         	mov	r6, r2
 801417a: f04f 0a00    	mov.w	r10, #0x0
 801417e: 4638         	mov	r0, r7
 8014180: 4641         	mov	r1, r8
 8014182: 462a         	mov	r2, r5
 8014184: 4653         	mov	r3, r10
 8014186: f7ec faf9    	bl	0x800077c <__aeabi_uldivmod> @ imm = #-0x13a0e
 801418a: b2d4         	uxtb	r4, r2
 801418c: 2c09         	cmp	r4, #0x9
 801418e: bf88         	it	hi
 8014190: 444c         	addhi	r4, r9
 8014192: 463a         	mov	r2, r7
 8014194: 4643         	mov	r3, r8
 8014196: bf88         	it	hi
 8014198: b2e4         	uxtbhi	r4, r4
 801419a: 42aa         	cmp	r2, r5
 801419c: f104 0430    	add.w	r4, r4, #0x30
 80141a0: eb73 030a    	sbcs.w	r3, r3, r10
 80141a4: f806 4b01    	strb	r4, [r6], #1
 80141a8: 4607         	mov	r7, r0
 80141aa: 4688         	mov	r8, r1
 80141ac: d2e7         	bhs	0x801417e <__ultoa_invert+0x1a> @ imm = #-0x32
 80141ae: 4630         	mov	r0, r6
 80141b0: e8bd 87f0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, pc}

080141b4 <mulShiftAll64>:
 80141b4: e92d 4ff0    	push.w	{r4, r5, r6, r7, r8, r9, r10, r11, lr}
 80141b8: b087         	sub	sp, #0x1c
 80141ba: 1806         	adds	r6, r0, r0
 80141bc: 4699         	mov	r9, r3
 80141be: ab02         	add	r3, sp, #0x8
 80141c0: eb41 0401    	adc.w	r4, r1, r1
 80141c4: 9300         	str	r3, [sp]
 80141c6: 4615         	mov	r5, r2
 80141c8: 4630         	mov	r0, r6
 80141ca: e9d2 2300    	ldrd	r2, r3, [r2]
 80141ce: 4621         	mov	r1, r4
 80141d0: f8dd b044    	ldr.w	r11, [sp, #0x44]
 80141d4: f000 f8a9    	bl	0x801432a <__umul128>   @ imm = #0x152
 80141d8: ab04         	add	r3, sp, #0x10
 80141da: 9300         	str	r3, [sp]
 80141dc: e9d5 2302    	ldrd	r2, r3, [r5, #8]
 80141e0: 4607         	mov	r7, r0
 80141e2: 4688         	mov	r8, r1
 80141e4: 4630         	mov	r0, r6
 80141e6: 4621         	mov	r1, r4
 80141e8: f000 f89f    	bl	0x801432a <__umul128>   @ imm = #0x13e
 80141ec: e9dd 6302    	ldrd	r6, r3, [sp, #8]
 80141f0: 1984         	adds	r4, r0, r6
 80141f2: eb51 0603    	adcs.w	r6, r1, r3
 80141f6: 9b04         	ldr	r3, [sp, #0x10]
 80141f8: e9d5 0100    	ldrd	r0, r1, [r5]
 80141fc: f04f 0200    	mov.w	r2, #0x0
 8014200: bf28         	it	hs
 8014202: 2201         	movhs	r2, #0x1
 8014204: 18d2         	adds	r2, r2, r3
 8014206: 9b05         	ldr	r3, [sp, #0x14]
 8014208: f143 0300    	adc	r3, r3, #0x0
 801420c: 1838         	adds	r0, r7, r0
 801420e: eb48 0101    	adc.w	r1, r8, r1
 8014212: 42b8         	cmp	r0, r7
 8014214: eb71 0108    	sbcs.w	r1, r1, r8
 8014218: e9d5 c102    	ldrd	r12, r1, [r5, #8]
 801421c: bf34         	ite	lo
 801421e: 2001         	movlo	r0, #0x1
 8014220: 2000         	movhs	r0, #0x0
 8014222: eb14 0c0c    	adds.w	r12, r4, r12
 8014226: eb46 0101    	adc.w	r1, r6, r1
 801422a: eb10 000c    	adds.w	r0, r0, r12
 801422e: f141 0100    	adc	r1, r1, #0x0
 8014232: 42a0         	cmp	r0, r4
 8014234: eb71 0c06    	sbcs.w	r12, r1, r6
 8014238: bf34         	ite	lo
 801423a: f04f 0c01    	movlo.w	r12, #0x1
 801423e: f04f 0c00    	movhs.w	r12, #0x0
 8014242: e9cd 2304    	strd	r2, r3, [sp, #16]
 8014246: f1a9 0a41    	sub.w	r10, r9, #0x41
 801424a: eb1c 0202    	adds.w	r2, r12, r2
 801424e: f143 0300    	adc	r3, r3, #0x0
 8014252: f8cd a000    	str.w	r10, [sp]
 8014256: f000 f883    	bl	0x8014360 <__shiftright128> @ imm = #0x106
 801425a: 9b10         	ldr	r3, [sp, #0x40]
 801425c: e9c3 0100    	strd	r0, r1, [r3]
 8014260: 9b12         	ldr	r3, [sp, #0x48]
 8014262: 2b01         	cmp	r3, #0x1
 8014264: e9dd 2304    	ldrd	r2, r3, [sp, #16]
 8014268: d129         	bne	0x80142be <mulShiftAll64+0x10a> @ imm = #0x52
 801426a: e9d5 0102    	ldrd	r0, r1, [r5, #8]
 801426e: e9d5 c500    	ldrd	r12, r5, [r5]
 8014272: 1a20         	subs	r0, r4, r0
 8014274: eb66 0101    	sbc.w	r1, r6, r1
 8014278: 4567         	cmp	r7, r12
 801427a: eb78 0505    	sbcs.w	r5, r8, r5
 801427e: bf34         	ite	lo
 8014280: 2501         	movlo	r5, #0x1
 8014282: 2500         	movhs	r5, #0x0
 8014284: 1b40         	subs	r0, r0, r5
 8014286: f161 0100    	sbc	r1, r1, #0x0
 801428a: 4284         	cmp	r4, r0
 801428c: eb76 0501    	sbcs.w	r5, r6, r1
 8014290: bf34         	ite	lo
 8014292: 2501         	movlo	r5, #0x1
 8014294: 2500         	movhs	r5, #0x0
 8014296: 1b52         	subs	r2, r2, r5
 8014298: f8cd a000    	str.w	r10, [sp]
 801429c: f163 0300    	sbc	r3, r3, #0x0
 80142a0: f000 f85e    	bl	0x8014360 <__shiftright128> @ imm = #0xbc
 80142a4: e9dd 2304    	ldrd	r2, r3, [sp, #16]
 80142a8: e9cb 0100    	strd	r0, r1, [r11]
 80142ac: f8cd a000    	str.w	r10, [sp]
 80142b0: 4620         	mov	r0, r4
 80142b2: 4631         	mov	r1, r6
 80142b4: f000 f854    	bl	0x8014360 <__shiftright128> @ imm = #0xa8
 80142b8: b007         	add	sp, #0x1c
 80142ba: e8bd 8ff0    	pop.w	{r4, r5, r6, r7, r8, r9, r10, r11, pc}
 80142be: eb17 0e07    	adds.w	lr, r7, r7
 80142c2: eb48 0c08    	adc.w	r12, r8, r8
 80142c6: 1920         	adds	r0, r4, r4
 80142c8: eb46 0106    	adc.w	r1, r6, r6
 80142cc: 45be         	cmp	lr, r7
 80142ce: eb7c 0808    	sbcs.w	r8, r12, r8
 80142d2: bf34         	ite	lo
 80142d4: 2701         	movlo	r7, #0x1
 80142d6: 2700         	movhs	r7, #0x0
 80142d8: 19c7         	adds	r7, r0, r7
 80142da: f141 0800    	adc	r8, r1, #0x0
 80142de: e9d5 0100    	ldrd	r0, r1, [r5]
 80142e2: 4586         	cmp	lr, r0
 80142e4: eb7c 0c01    	sbcs.w	r12, r12, r1
 80142e8: e9d5 1502    	ldrd	r1, r5, [r5, #8]
 80142ec: bf34         	ite	lo
 80142ee: 2001         	movlo	r0, #0x1
 80142f0: 2000         	movhs	r0, #0x0
 80142f2: 1a38         	subs	r0, r7, r0
 80142f4: f168 0c00    	sbc	r12, r8, #0x0
 80142f8: 1a40         	subs	r0, r0, r1
 80142fa: eb6c 0105    	sbc.w	r1, r12, r5
 80142fe: 1892         	adds	r2, r2, r2
 8014300: 415b         	adcs	r3, r3
 8014302: 42a7         	cmp	r7, r4
 8014304: eb78 0506    	sbcs.w	r5, r8, r6
 8014308: bf34         	ite	lo
 801430a: 2501         	movlo	r5, #0x1
 801430c: 2500         	movhs	r5, #0x0
 801430e: 1952         	adds	r2, r2, r5
 8014310: f143 0300    	adc	r3, r3, #0x0
 8014314: 4287         	cmp	r7, r0
 8014316: eb78 0801    	sbcs.w	r8, r8, r1
 801431a: bf34         	ite	lo
 801431c: 2501         	movlo	r5, #0x1
 801431e: 2500         	movhs	r5, #0x0
 8014320: 1b52         	subs	r2, r2, r5
 8014322: f1a9 0540    	sub.w	r5, r9, #0x40
 8014326: 9500         	str	r5, [sp]
 8014328: e7b8         	b	0x801429c <mulShiftAll64+0xe8> @ imm = #-0x90

0801432a <__umul128>:
 801432a: b5f0         	push	{r4, r5, r6, r7, lr}
 801432c: 460f         	mov	r7, r1
 801432e: 4604         	mov	r4, r0
 8014330: fba0 0102    	umull	r0, r1, r0, r2
 8014334: fba7 5202    	umull	r5, r2, r7, r2
 8014338: 1949         	adds	r1, r1, r5
 801433a: fba3 4504    	umull	r4, r5, r3, r4
 801433e: f142 0200    	adc	r2, r2, #0x0
 8014342: fba7 7303    	umull	r7, r3, r7, r3
 8014346: 1861         	adds	r1, r4, r1
 8014348: f145 0400    	adc	r4, r5, #0x0
 801434c: 19d2         	adds	r2, r2, r7
 801434e: 9e05         	ldr	r6, [sp, #0x14]
 8014350: f143 0300    	adc	r3, r3, #0x0
 8014354: 1912         	adds	r2, r2, r4
 8014356: f143 0300    	adc	r3, r3, #0x0
 801435a: e9c6 2300    	strd	r2, r3, [r6]
 801435e: bdf0         	pop	{r4, r5, r6, r7, pc}

08014360 <__shiftright128>:
 8014360: b5f0         	push	{r4, r5, r6, r7, lr}
 8014362: 9c05         	ldr	r4, [sp, #0x14]
 8014364: f1c4 0740    	rsb.w	r7, r4, #0x40
 8014368: f1c4 0620    	rsb.w	r6, r4, #0x20
 801436c: fa02 f606    	lsl.w	r6, r2, r6
 8014370: f1a4 0520    	sub.w	r5, r4, #0x20
 8014374: 40bb         	lsls	r3, r7
 8014376: fa22 f505    	lsr.w	r5, r2, r5
 801437a: 4333         	orrs	r3, r6
 801437c: f1c4 0620    	rsb.w	r6, r4, #0x20
 8014380: 432b         	orrs	r3, r5
 8014382: fa01 f606    	lsl.w	r6, r1, r6
 8014386: f1a4 0520    	sub.w	r5, r4, #0x20
 801438a: 40e0         	lsrs	r0, r4
 801438c: fa21 f505    	lsr.w	r5, r1, r5
 8014390: 4330         	orrs	r0, r6
 8014392: 40ba         	lsls	r2, r7
 8014394: 4328         	orrs	r0, r5
 8014396: 40e1         	lsrs	r1, r4
 8014398: 4310         	orrs	r0, r2
 801439a: 4319         	orrs	r1, r3
 801439c: bdf0         	pop	{r4, r5, r6, r7, pc}

0801439e <__dtox_engine>:
 801439e: e92d 41f0    	push.w	{r4, r5, r6, r7, r8, lr}
 80143a2: 4604         	mov	r4, r0
 80143a4: 0fcd         	lsrs	r5, r1, #0x1f
 80143a6: f3c1 500a    	ubfx	r0, r1, #0x14, #0xb
 80143aa: f3c1 0113    	ubfx	r1, r1, #0x0, #0x14
 80143ae: ea54 0701    	orrs.w	r7, r4, r1
 80143b2: 7115         	strb	r5, [r2, #0x4]
 80143b4: f240 76ff    	movw	r6, #0x7ff
 80143b8: d007         	beq	0x80143ca <__dtox_engine+0x2c> @ imm = #0xe
 80143ba: 42b0         	cmp	r0, r6
 80143bc: d10c         	bne	0x80143d8 <__dtox_engine+0x3a> @ imm = #0x18
 80143be: f045 0508    	orr	r5, r5, #0x8
 80143c2: 7115         	strb	r5, [r2, #0x4]
 80143c4: 2000         	movs	r0, #0x0
 80143c6: e8bd 81f0    	pop.w	{r4, r5, r6, r7, r8, pc}
 80143ca: 2800         	cmp	r0, #0x0
 80143cc: d063         	beq	0x8014496 <__dtox_engine+0xf8> @ imm = #0xc6
 80143ce: 42b0         	cmp	r0, r6
 80143d0: d15e         	bne	0x8014490 <__dtox_engine+0xf2> @ imm = #0xbc
 80143d2: f045 0504    	orr	r5, r5, #0x4
 80143d6: e7f4         	b	0x80143c2 <__dtox_engine+0x24> @ imm = #-0x18
 80143d8: 2800         	cmp	r0, #0x0
 80143da: d159         	bne	0x8014490 <__dtox_engine+0xf2> @ imm = #0xb2
 80143dc: 2001         	movs	r0, #0x1
 80143de: f2a0 30ff    	subw	r0, r0, #0x3ff
 80143e2: 2b00         	cmp	r3, #0x0
 80143e4: 6010         	str	r0, [r2]
 80143e6: db59         	blt	0x801449c <__dtox_engine+0xfe> @ imm = #0xb2
 80143e8: 2b0c         	cmp	r3, #0xc
 80143ea: dc59         	bgt	0x80144a0 <__dtox_engine+0x102> @ imm = #0xb2
 80143ec: f1c3 050d    	rsb.w	r5, r3, #0xd
 80143f0: 00ad         	lsls	r5, r5, #0x2
 80143f2: 2001         	movs	r0, #0x1
 80143f4: f105 3cff    	add.w	r12, r5, #0xffffffff
 80143f8: f1a5 0721    	sub.w	r7, r5, #0x21
 80143fc: f1c5 0621    	rsb.w	r6, r5, #0x21
 8014400: fa20 f606    	lsr.w	r6, r0, r6
 8014404: fa00 f707    	lsl.w	r7, r0, r7
 8014408: fa00 f00c    	lsl.w	r0, r0, r12
 801440c: 4337         	orrs	r7, r6
 801440e: 1806         	adds	r6, r0, r0
 8014410: eb47 0807    	adc.w	r8, r7, r7
 8014414: f1d6 0e00    	rsbs.w	lr, r6, #0x0
 8014418: eb68 0c48    	sbc.w	r12, r8, r8, lsl #1
 801441c: 3e01         	subs	r6, #0x1
 801441e: f148 38ff    	adc	r8, r8, #0xffffffff
 8014422: 4026         	ands	r6, r4
 8014424: ea08 0801    	and.w	r8, r8, r1
 8014428: 42b0         	cmp	r0, r6
 801442a: eb77 0808    	sbcs.w	r8, r7, r8
 801442e: db0f         	blt	0x8014450 <__dtox_engine+0xb2> @ imm = #0x1e
 8014430: f1c5 0820    	rsb.w	r8, r5, #0x20
 8014434: f1b5 0620    	subs.w	r6, r5, #0x20
 8014438: fa01 f808    	lsl.w	r8, r1, r8
 801443c: fa24 f505    	lsr.w	r5, r4, r5
 8014440: ea45 0508    	orr.w	r5, r5, r8
 8014444: bf5c         	itt	pl
 8014446: fa41 f606    	asrpl.w	r6, r1, r6
 801444a: 4335         	orrpl	r5, r6
 801444c: 07ed         	lsls	r5, r5, #0x1f
 801444e: d503         	bpl	0x8014458 <__dtox_engine+0xba> @ imm = #0x6
 8014450: 1820         	adds	r0, r4, r0
 8014452: 4604         	mov	r4, r0
 8014454: eb41 0107    	adc.w	r1, r1, r7
 8014458: ea04 040e    	and.w	r4, r4, lr
 801445c: ea01 010c    	and.w	r1, r1, r12
 8014460: f89d 6018    	ldrb.w	r6, [sp, #0x18]
 8014464: 3212         	adds	r2, #0x12
 8014466: 4618         	mov	r0, r3
 8014468: 250d         	movs	r5, #0xd
 801446a: f1c6 0627    	rsb.w	r6, r6, #0x27
 801446e: f04f 0e30    	mov.w	lr, #0x30
 8014472: f004 030f    	and	r3, r4, #0xf
 8014476: 0924         	lsrs	r4, r4, #0x4
 8014478: ea44 7401    	orr.w	r4, r4, r1, lsl #28
 801447c: f105 3cff    	add.w	r12, r5, #0xffffffff
 8014480: 1109         	asrs	r1, r1, #0x4
 8014482: 1e57         	subs	r7, r2, #0x1
 8014484: b9b3         	cbnz	r3, 0x80144b4 <__dtox_engine+0x116> @ imm = #0x2c
 8014486: 42a8         	cmp	r0, r5
 8014488: da0c         	bge	0x80144a4 <__dtox_engine+0x106> @ imm = #0x18
 801448a: 4665         	mov	r5, r12
 801448c: 463a         	mov	r2, r7
 801448e: e7f0         	b	0x8014472 <__dtox_engine+0xd4> @ imm = #-0x20
 8014490: f441 1180    	orr	r1, r1, #0x100000
 8014494: e7a3         	b	0x80143de <__dtox_engine+0x40> @ imm = #-0xba
 8014496: 4604         	mov	r4, r0
 8014498: 4601         	mov	r1, r0
 801449a: e7a2         	b	0x80143e2 <__dtox_engine+0x44> @ imm = #-0xbc
 801449c: 2300         	movs	r3, #0x0
 801449e: e7df         	b	0x8014460 <__dtox_engine+0xc2> @ imm = #-0x42
 80144a0: 230d         	movs	r3, #0xd
 80144a2: e7dd         	b	0x8014460 <__dtox_engine+0xc2> @ imm = #-0x46
 80144a4: f882 e000    	strb.w	lr, [r2]
 80144a8: f11c 0301    	adds.w	r3, r12, #0x1
 80144ac: 4665         	mov	r5, r12
 80144ae: 463a         	mov	r2, r7
 80144b0: d1df         	bne	0x8014472 <__dtox_engine+0xd4> @ imm = #-0x42
 80144b2: e788         	b	0x80143c6 <__dtox_engine+0x28> @ imm = #-0xf0
 80144b4: 2b09         	cmp	r3, #0x9
 80144b6: bfc8         	it	gt
 80144b8: 199b         	addgt	r3, r3, r6
 80144ba: 3330         	adds	r3, #0x30
 80144bc: 42a8         	cmp	r0, r5
 80144be: 7013         	strb	r3, [r2]
 80144c0: bfb8         	it	lt
 80144c2: 4628         	movlt	r0, r5
 80144c4: e7f0         	b	0x80144a8 <__dtox_engine+0x10a> @ imm = #-0x20
 80144c6: 0000         	movs	r0, r0

080144c8 <__aeabi_read_tp>:
; 	ldr r0, =z_arm_tls_ptr
 80144c8: 4801         	ldr	r0, [pc, #0x4]          @ 0x80144d0 <__aeabi_read_tp+0x8>
; 	ldr r0, [r0]
 80144ca: 6800         	ldr	r0, [r0]
; 	bx lr
 80144cc: 4770         	bx	lr

080144ce <$d>:
 80144ce: 00 00        	.short	0x0000

080144d0 <$d>:
 80144d0: f0 05 00 20  	.word	0x200005f0
